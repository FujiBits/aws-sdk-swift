// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating Amazon Fraud Detector does not have the needed permissions. This can occur if you submit a request, such as PutExternalModel, that specifies a role that is not in your account.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes {
    public enum AsyncJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case cancelInProgress
        case complete
        case failed
        case inProgress
        case inProgressInitializing
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncJobStatus] {
            return [
                .canceled,
                .cancelInProgress,
                .complete,
                .failed,
                .inProgress,
                .inProgressInitializing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInitializing: return "IN_PROGRESS_INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AsyncJobStatus(rawValue: rawValue) ?? AsyncJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.BatchCreateVariableError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decode(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.BatchCreateVariableError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateVariableError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch create variable API.
    public struct BatchCreateVariableError: Swift.Equatable {
        /// The error code.
        public let code: Swift.Int
        /// The error message.
        public let message: Swift.String?
        /// The name.
        public let name: Swift.String?

        public init (
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

public struct BatchCreateVariableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateVariableOutputError>
}

extension BatchCreateVariableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateVariableInput(tags: \(Swift.String(describing: tags)), variableEntries: \(Swift.String(describing: variableEntries)))"}
}

extension BatchCreateVariableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case variableEntries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let variableEntries = variableEntries {
            var variableEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableEntries)
            for variableentrylist0 in variableEntries {
                try variableEntriesContainer.encode(variableentrylist0)
            }
        }
    }
}

public struct BatchCreateVariableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateVariableOutputError>
}

public struct BatchCreateVariableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCreateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCreateVariableOutputError>
}

public struct BatchCreateVariableInput: Swift.Equatable {
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?
    /// The list of variables for the batch create variable request.
    /// This member is required.
    public let variableEntries: [FraudDetectorClientTypes.VariableEntry]?

    public init (
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableEntries: [FraudDetectorClientTypes.VariableEntry]? = nil
    )
    {
        self.tags = tags
        self.variableEntries = variableEntries
    }
}

struct BatchCreateVariableInputBody: Swift.Equatable {
    public let variableEntries: [FraudDetectorClientTypes.VariableEntry]?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension BatchCreateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case variableEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableEntriesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.VariableEntry?].self, forKey: .variableEntries)
        var variableEntriesDecoded0:[FraudDetectorClientTypes.VariableEntry]? = nil
        if let variableEntriesContainer = variableEntriesContainer {
            variableEntriesDecoded0 = [FraudDetectorClientTypes.VariableEntry]()
            for structure0 in variableEntriesContainer {
                if let structure0 = structure0 {
                    variableEntriesDecoded0?.append(structure0)
                }
            }
        }
        variableEntries = variableEntriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BatchCreateVariableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateVariableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateVariableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateVariableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCreateVariableOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchCreateVariableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCreateVariableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreateVariableOutputResponse: Swift.Equatable {
    /// Provides the errors for the BatchCreateVariable request.
    public let errors: [FraudDetectorClientTypes.BatchCreateVariableError]?

    public init (
        errors: [FraudDetectorClientTypes.BatchCreateVariableError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreateVariableOutputResponseBody: Swift.Equatable {
    public let errors: [FraudDetectorClientTypes.BatchCreateVariableError]?
}

extension BatchCreateVariableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchCreateVariableError?].self, forKey: .errors)
        var errorsDecoded0:[FraudDetectorClientTypes.BatchCreateVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [FraudDetectorClientTypes.BatchCreateVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension FraudDetectorClientTypes.BatchGetVariableError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decode(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.BatchGetVariableError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetVariableError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch get variable API.
    public struct BatchGetVariableError: Swift.Equatable {
        /// The error code.
        public let code: Swift.Int
        /// The error message.
        public let message: Swift.String?
        /// The error name.
        public let name: Swift.String?

        public init (
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

public struct BatchGetVariableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetVariableOutputError>
}

extension BatchGetVariableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetVariableInput(names: \(Swift.String(describing: names)))"}
}

extension BatchGetVariableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for namelist0 in names {
                try namesContainer.encode(namelist0)
            }
        }
    }
}

public struct BatchGetVariableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetVariableOutputError>
}

public struct BatchGetVariableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetVariableOutputError>
}

public struct BatchGetVariableInput: Swift.Equatable {
    /// The list of variable names to get.
    /// This member is required.
    public let names: [Swift.String]?

    public init (
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

struct BatchGetVariableInputBody: Swift.Equatable {
    public let names: [Swift.String]?
}

extension BatchGetVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetVariableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetVariableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetVariableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetVariableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetVariableOutputResponse(errors: \(Swift.String(describing: errors)), variables: \(Swift.String(describing: variables)))"}
}

extension BatchGetVariableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetVariableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.variables = output.variables
        } else {
            self.errors = nil
            self.variables = nil
        }
    }
}

public struct BatchGetVariableOutputResponse: Swift.Equatable {
    /// The errors from the request.
    public let errors: [FraudDetectorClientTypes.BatchGetVariableError]?
    /// The returned variables.
    public let variables: [FraudDetectorClientTypes.Variable]?

    public init (
        errors: [FraudDetectorClientTypes.BatchGetVariableError]? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.errors = errors
        self.variables = variables
    }
}

struct BatchGetVariableOutputResponseBody: Swift.Equatable {
    public let variables: [FraudDetectorClientTypes.Variable]?
    public let errors: [FraudDetectorClientTypes.BatchGetVariableError]?
}

extension BatchGetVariableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case variables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[FraudDetectorClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [FraudDetectorClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchGetVariableError?].self, forKey: .errors)
        var errorsDecoded0:[FraudDetectorClientTypes.BatchGetVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [FraudDetectorClientTypes.BatchGetVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension FraudDetectorClientTypes.BatchPrediction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case completionTime
        case detectorName
        case detectorVersion
        case eventTypeName
        case failureReason
        case iamRoleArn
        case inputPath
        case jobId
        case lastHeartbeatTime
        case outputPath
        case processedRecordsCount
        case startTime
        case status
        case totalRecordsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime, forKey: .completionTime)
        }
        if let detectorName = detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastHeartbeatTime = lastHeartbeatTime {
            try encodeContainer.encode(lastHeartbeatTime, forKey: .lastHeartbeatTime)
        }
        if let outputPath = outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let processedRecordsCount = processedRecordsCount {
            try encodeContainer.encode(processedRecordsCount, forKey: .processedRecordsCount)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalRecordsCount = totalRecordsCount {
            try encodeContainer.encode(totalRecordsCount, forKey: .totalRecordsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.AsyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let lastHeartbeatTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastHeartbeatTime)
        lastHeartbeatTime = lastHeartbeatTimeDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let totalRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsCount)
        totalRecordsCount = totalRecordsCountDecoded
    }
}

extension FraudDetectorClientTypes.BatchPrediction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPrediction(arn: \(Swift.String(describing: arn)), completionTime: \(Swift.String(describing: completionTime)), detectorName: \(Swift.String(describing: detectorName)), detectorVersion: \(Swift.String(describing: detectorVersion)), eventTypeName: \(Swift.String(describing: eventTypeName)), failureReason: \(Swift.String(describing: failureReason)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), inputPath: \(Swift.String(describing: inputPath)), jobId: \(Swift.String(describing: jobId)), lastHeartbeatTime: \(Swift.String(describing: lastHeartbeatTime)), outputPath: \(Swift.String(describing: outputPath)), processedRecordsCount: \(Swift.String(describing: processedRecordsCount)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), totalRecordsCount: \(Swift.String(describing: totalRecordsCount)))"}
}

extension FraudDetectorClientTypes {
    /// The batch prediction details.
    public struct BatchPrediction: Swift.Equatable {
        /// The ARN of batch prediction job.
        public let arn: Swift.String?
        /// Timestamp of when the batch prediction job comleted.
        public let completionTime: Swift.String?
        /// The name of the detector.
        public let detectorName: Swift.String?
        /// The detector version.
        public let detectorVersion: Swift.String?
        /// The name of the event type.
        public let eventTypeName: Swift.String?
        /// The reason a batch prediction job failed.
        public let failureReason: Swift.String?
        /// The ARN of the IAM role to use for this job request.
        public let iamRoleArn: Swift.String?
        /// The Amazon S3 location of your training file.
        public let inputPath: Swift.String?
        /// The job ID for the batch prediction.
        public let jobId: Swift.String?
        /// Timestamp of most recent heartbeat indicating the batch prediction job was making progress.
        public let lastHeartbeatTime: Swift.String?
        /// The Amazon S3 location of your output file.
        public let outputPath: Swift.String?
        /// The number of records processed by the batch prediction job.
        public let processedRecordsCount: Swift.Int?
        /// Timestamp of when the batch prediction job started.
        public let startTime: Swift.String?
        /// The batch prediction status.
        public let status: FraudDetectorClientTypes.AsyncJobStatus?
        /// The total number of records in the batch prediction job.
        public let totalRecordsCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            completionTime: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorVersion: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            jobId: Swift.String? = nil,
            lastHeartbeatTime: Swift.String? = nil,
            outputPath: Swift.String? = nil,
            processedRecordsCount: Swift.Int? = nil,
            startTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.AsyncJobStatus? = nil,
            totalRecordsCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.completionTime = completionTime
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.lastHeartbeatTime = lastHeartbeatTime
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }
    }

}

public struct CancelBatchPredictionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelBatchPredictionJobOutputError>
}

extension CancelBatchPredictionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelBatchPredictionJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension CancelBatchPredictionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct CancelBatchPredictionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelBatchPredictionJobOutputError>
}

public struct CancelBatchPredictionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelBatchPredictionJobOutputError>
}

public struct CancelBatchPredictionJobInput: Swift.Equatable {
    /// The ID of the batch prediction job to cancel.
    /// This member is required.
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelBatchPredictionJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension CancelBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelBatchPredictionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelBatchPredictionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelBatchPredictionJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelBatchPredictionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelBatchPredictionJobOutputResponse()"}
}

extension CancelBatchPredictionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelBatchPredictionJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelBatchPredictionJobOutputResponseBody: Swift.Equatable {
}

extension CancelBatchPredictionJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating there was a conflict during a delete operation. The following delete operations can cause a conflict exception:
/// 	
///
///                DeleteDetector: A conflict exception will occur if the detector has associated Rules or DetectorVersions. You can only delete a detector if it has no Rules or DetectorVersions.
///
///
///                DeleteDetectorVersion: A conflict exception will occur if the DetectorVersion status is ACTIVE.
///
///
///                DeleteRule: A conflict exception will occur if the RuleVersion is in use by an associated ACTIVE or INACTIVE DetectorVersion.
///
///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateBatchPredictionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchPredictionJobOutputError>
}

extension CreateBatchPredictionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchPredictionJobInput(detectorName: \(Swift.String(describing: detectorName)), detectorVersion: \(Swift.String(describing: detectorVersion)), eventTypeName: \(Swift.String(describing: eventTypeName)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), inputPath: \(Swift.String(describing: inputPath)), jobId: \(Swift.String(describing: jobId)), outputPath: \(Swift.String(describing: outputPath)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateBatchPredictionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorName = detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputPath = outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBatchPredictionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchPredictionJobOutputError>
}

public struct CreateBatchPredictionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchPredictionJobOutputError>
}

public struct CreateBatchPredictionJobInput: Swift.Equatable {
    /// The name of the detector.
    /// This member is required.
    public let detectorName: Swift.String?
    /// The detector version.
    public let detectorVersion: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public let eventTypeName: Swift.String?
    /// The ARN of the IAM role to use for this job request.
    /// This member is required.
    public let iamRoleArn: Swift.String?
    /// The Amazon S3 location of your training file.
    /// This member is required.
    public let inputPath: Swift.String?
    /// The ID of the batch prediction job.
    /// This member is required.
    public let jobId: Swift.String?
    /// The Amazon S3 location of your output file.
    /// This member is required.
    public let outputPath: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        detectorName: Swift.String? = nil,
        detectorVersion: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        inputPath: Swift.String? = nil,
        jobId: Swift.String? = nil,
        outputPath: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.detectorName = detectorName
        self.detectorVersion = detectorVersion
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

struct CreateBatchPredictionJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let inputPath: Swift.String?
    public let outputPath: Swift.String?
    public let eventTypeName: Swift.String?
    public let detectorName: Swift.String?
    public let detectorVersion: Swift.String?
    public let iamRoleArn: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchPredictionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchPredictionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBatchPredictionJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchPredictionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchPredictionJobOutputResponse()"}
}

extension CreateBatchPredictionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateBatchPredictionJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateBatchPredictionJobOutputResponseBody: Swift.Equatable {
}

extension CreateBatchPredictionJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateDetectorVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorVersionOutputError>
}

extension CreateDetectorVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDetectorVersionInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), externalModelEndpoints: \(Swift.String(describing: externalModelEndpoints)), modelVersions: \(Swift.String(describing: modelVersions)), ruleExecutionMode: \(Swift.String(describing: ruleExecutionMode)), rules: \(Swift.String(describing: rules)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDetectorVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for listofstrings0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(listofstrings0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for listofmodelversions0 in modelVersions {
                try modelVersionsContainer.encode(listofmodelversions0)
            }
        }
        if let ruleExecutionMode = ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rulelist0 in rules {
                try rulesContainer.encode(rulelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDetectorVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorVersionOutputError>
}

public struct CreateDetectorVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDetectorVersionOutputError>
}

public struct CreateDetectorVersionInput: Swift.Equatable {
    /// The description of the detector version.
    public let description: Swift.String?
    /// The ID of the detector under which you want to create a new version.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The Amazon Sagemaker model endpoints to include in the detector version.
    public let externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode for the rules included in the detector version.
    /// 	        You can define and edit the rule mode at the detector version level, when it is in draft status.
    /// 	        If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
    /// 	        If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules.
    ///          The default behavior is FIRST_MATCHED.
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public let rules: [FraudDetectorClientTypes.Rule]?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.tags = tags
    }
}

struct CreateDetectorVersionInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let description: Swift.String?
    public let externalModelEndpoints: [Swift.String]?
    public let rules: [FraudDetectorClientTypes.Rule]?
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDetectorVersionOutputResponse(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), status: \(Swift.String(describing: status)))"}
}

extension CreateDetectorVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDetectorVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.status = output.status
        } else {
            self.detectorId = nil
            self.detectorVersionId = nil
            self.status = nil
        }
    }
}

public struct CreateDetectorVersionOutputResponse: Swift.Equatable {
    /// The ID for the created version's parent detector.
    public let detectorId: Swift.String?
    /// The ID for the created detector.
    public let detectorVersionId: Swift.String?
    /// The status of the detector version.
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init (
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct CreateDetectorVersionOutputResponseBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?
}

extension CreateDetectorVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

extension CreateModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelInput(description: \(Swift.String(describing: description)), eventTypeName: \(Swift.String(describing: eventTypeName)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelOutputError>
}

public struct CreateModelInput: Swift.Equatable {
    /// The model description.
    public let description: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public let eventTypeName: Swift.String?
    /// The model ID.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.eventTypeName = eventTypeName
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct CreateModelInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let description: Swift.String?
    public let eventTypeName: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelOutputResponse()"}
}

extension CreateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateModelOutputResponseBody: Swift.Equatable {
}

extension CreateModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateModelVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelVersionOutputError>
}

extension CreateModelVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelVersionInput(externalEventsDetail: \(Swift.String(describing: externalEventsDetail)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), tags: \(Swift.String(describing: tags)), trainingDataSchema: \(Swift.String(describing: trainingDataSchema)), trainingDataSource: \(Swift.String(describing: trainingDataSource)))"}
}

extension CreateModelVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trainingDataSchema = trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
    }
}

public struct CreateModelVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelVersionOutputError>
}

public struct CreateModelVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateModelVersionOutputError>
}

public struct CreateModelVersionInput: Swift.Equatable {
    /// Details for the external events data used for model version training. Required if trainingDataSource is EXTERNAL_EVENTS.
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The model ID.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?
    /// The training data schema.
    /// This member is required.
    public let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source location in Amazon S3.
    /// This member is required.
    public let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init (
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct CreateModelVersionInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
    public let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateModelVersionOutputResponse(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), status: \(Swift.String(describing: status)))"}
}

extension CreateModelVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct CreateModelVersionOutputResponse: Swift.Equatable {
    /// The model ID.
    public let modelId: Swift.String?
    /// The model type.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version created.
    public let modelVersionNumber: Swift.String?
    /// The model version status.
    public let status: Swift.String?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct CreateModelVersionOutputResponseBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
    public let status: Swift.String?
}

extension CreateModelVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

extension CreateRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), expression: \(Swift.String(describing: expression)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

public struct CreateRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

public struct CreateRuleInput: Swift.Equatable {
    /// The rule description.
    public let description: Swift.String?
    /// The detector ID for the rule's parent detector.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The rule expression.
    /// This member is required.
    public let expression: Swift.String?
    /// The language of the rule.
    /// This member is required.
    public let language: FraudDetectorClientTypes.Language?
    /// The outcome or outcomes returned when the rule expression matches.
    /// This member is required.
    public let outcomes: [Swift.String]?
    /// The rule ID.
    /// This member is required.
    public let ruleId: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        ruleId: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.ruleId = ruleId
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    public let ruleId: Swift.String?
    public let detectorId: Swift.String?
    public let description: Swift.String?
    public let expression: Swift.String?
    public let language: FraudDetectorClientTypes.Language?
    public let outcomes: [Swift.String]?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleOutputResponse(rule: \(Swift.String(describing: rule)))"}
}

extension CreateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct CreateRuleOutputResponse: Swift.Equatable {
    /// The created rule.
    public let rule: FraudDetectorClientTypes.Rule?

    public init (
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct CreateRuleOutputResponseBody: Swift.Equatable {
    public let rule: FraudDetectorClientTypes.Rule?
}

extension CreateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct CreateVariableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVariableOutputError>
}

extension CreateVariableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVariableInput(dataSource: \(Swift.String(describing: dataSource)), dataType: \(Swift.String(describing: dataType)), defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), variableType: \(Swift.String(describing: variableType)))"}
}

extension CreateVariableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

public struct CreateVariableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVariableOutputError>
}

public struct CreateVariableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateVariableOutputError>
}

public struct CreateVariableInput: Swift.Equatable {
    /// The source of the data.
    /// This member is required.
    public let dataSource: FraudDetectorClientTypes.DataSource?
    /// The data type.
    /// This member is required.
    public let dataType: FraudDetectorClientTypes.DataType?
    /// The default value for the variable when no value is received.
    /// This member is required.
    public let defaultValue: Swift.String?
    /// The description.
    public let description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public let name: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?
    /// The variable type. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types.
    /// 				
    ///          Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
    ///
    public let variableType: Swift.String?

    public init (
        dataSource: FraudDetectorClientTypes.DataSource? = nil,
        dataType: FraudDetectorClientTypes.DataType? = nil,
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

struct CreateVariableInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let dataType: FraudDetectorClientTypes.DataType?
    public let dataSource: FraudDetectorClientTypes.DataSource?
    public let defaultValue: Swift.String?
    public let description: Swift.String?
    public let variableType: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVariableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVariableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVariableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVariableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVariableOutputResponse()"}
}

extension CreateVariableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateVariableOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateVariableOutputResponseBody: Swift.Equatable {
}

extension CreateVariableOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FraudDetectorClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case externalModelScore
        case modelScore
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .event,
                .externalModelScore,
                .modelScore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .externalModelScore: return "EXTERNAL_MODEL_SCORE"
            case .modelScore: return "MODEL_SCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum DataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case float
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .boolean,
                .float,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataType(rawValue: rawValue) ?? DataType.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.DataValidationMetrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelMessages
        case fileLevelMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldLevelMessages = fieldLevelMessages {
            var fieldLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldLevelMessages)
            for fieldvalidationmessagelist0 in fieldLevelMessages {
                try fieldLevelMessagesContainer.encode(fieldvalidationmessagelist0)
            }
        }
        if let fileLevelMessages = fileLevelMessages {
            var fileLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileLevelMessages)
            for filevalidationmessagelist0 in fileLevelMessages {
                try fileLevelMessagesContainer.encode(filevalidationmessagelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileLevelMessagesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.FileValidationMessage?].self, forKey: .fileLevelMessages)
        var fileLevelMessagesDecoded0:[FraudDetectorClientTypes.FileValidationMessage]? = nil
        if let fileLevelMessagesContainer = fileLevelMessagesContainer {
            fileLevelMessagesDecoded0 = [FraudDetectorClientTypes.FileValidationMessage]()
            for structure0 in fileLevelMessagesContainer {
                if let structure0 = structure0 {
                    fileLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fileLevelMessages = fileLevelMessagesDecoded0
        let fieldLevelMessagesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.FieldValidationMessage?].self, forKey: .fieldLevelMessages)
        var fieldLevelMessagesDecoded0:[FraudDetectorClientTypes.FieldValidationMessage]? = nil
        if let fieldLevelMessagesContainer = fieldLevelMessagesContainer {
            fieldLevelMessagesDecoded0 = [FraudDetectorClientTypes.FieldValidationMessage]()
            for structure0 in fieldLevelMessagesContainer {
                if let structure0 = structure0 {
                    fieldLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fieldLevelMessages = fieldLevelMessagesDecoded0
    }
}

extension FraudDetectorClientTypes.DataValidationMetrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataValidationMetrics(fieldLevelMessages: \(Swift.String(describing: fieldLevelMessages)), fileLevelMessages: \(Swift.String(describing: fileLevelMessages)))"}
}

extension FraudDetectorClientTypes {
    /// The model training validation messages.
    public struct DataValidationMetrics: Swift.Equatable {
        /// The field-specific model training validation messages.
        public let fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]?
        /// The file-specific model training validation messages.
        public let fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]?

        public init (
            fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]? = nil,
            fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]? = nil
        )
        {
            self.fieldLevelMessages = fieldLevelMessages
            self.fileLevelMessages = fileLevelMessages
        }
    }

}

public struct DeleteBatchPredictionJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBatchPredictionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBatchPredictionJobOutputError>
}

extension DeleteBatchPredictionJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBatchPredictionJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DeleteBatchPredictionJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DeleteBatchPredictionJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBatchPredictionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBatchPredictionJobOutputError>
}

public struct DeleteBatchPredictionJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBatchPredictionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBatchPredictionJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBatchPredictionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBatchPredictionJobOutputError>
}

public struct DeleteBatchPredictionJobInput: Swift.Equatable {
    /// The ID of the batch prediction job to delete.
    /// This member is required.
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DeleteBatchPredictionJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DeleteBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeleteBatchPredictionJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBatchPredictionJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBatchPredictionJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBatchPredictionJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBatchPredictionJobOutputResponse()"}
}

extension DeleteBatchPredictionJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBatchPredictionJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBatchPredictionJobOutputResponseBody: Swift.Equatable {
}

extension DeleteBatchPredictionJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDetectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorOutputError>
}

extension DeleteDetectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorInput(detectorId: \(Swift.String(describing: detectorId)))"}
}

extension DeleteDetectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
    }
}

public struct DeleteDetectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInput: Swift.Equatable {
    /// The ID of the detector to delete.
    /// This member is required.
    public let detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
}

extension DeleteDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
    }
}

extension DeleteDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorOutputResponse()"}
}

extension DeleteDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDetectorOutputResponseBody: Swift.Equatable {
}

extension DeleteDetectorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDetectorVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorVersionOutputError>
}

extension DeleteDetectorVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorVersionInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)))"}
}

extension DeleteDetectorVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct DeleteDetectorVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorVersionOutputError>
}

public struct DeleteDetectorVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDetectorVersionOutputError>
}

public struct DeleteDetectorVersionInput: Swift.Equatable {
    /// The ID of the parent detector for the detector version to delete.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The ID of the detector version to delete.
    /// This member is required.
    public let detectorVersionId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct DeleteDetectorVersionInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
}

extension DeleteDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension DeleteDetectorVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDetectorVersionOutputResponse()"}
}

extension DeleteDetectorVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorVersionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDetectorVersionOutputResponseBody: Swift.Equatable {
}

extension DeleteDetectorVersionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEntityTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEntityTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEntityTypeOutputError>
}

extension DeleteEntityTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEntityTypeInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteEntityTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEntityTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEntityTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEntityTypeOutputError>
}

public struct DeleteEntityTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEntityTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEntityTypeOutputError>
}

public struct DeleteEntityTypeInput: Swift.Equatable {
    /// The name of the entity type to delete.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEntityTypeInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteEntityTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEntityTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEntityTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEntityTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEntityTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEntityTypeOutputResponse()"}
}

extension DeleteEntityTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEntityTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEntityTypeOutputResponseBody: Swift.Equatable {
}

extension DeleteEntityTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEventInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventOutputError>
}

extension DeleteEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventInput(eventId: \(Swift.String(describing: eventId)), eventTypeName: \(Swift.String(describing: eventTypeName)))"}
}

extension DeleteEventInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case eventTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

public struct DeleteEventInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventOutputError>
}

public struct DeleteEventInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventOutputError>
}

public struct DeleteEventInput: Swift.Equatable {
    /// The ID of the event to delete.
    /// This member is required.
    public let eventId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public let eventTypeName: Swift.String?

    public init (
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

struct DeleteEventInputBody: Swift.Equatable {
    public let eventId: Swift.String?
    public let eventTypeName: Swift.String?
}

extension DeleteEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case eventTypeName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
    }
}

extension DeleteEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventOutputResponse()"}
}

extension DeleteEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventOutputResponseBody: Swift.Equatable {
}

extension DeleteEventOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEventTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTypeOutputError>
}

extension DeleteEventTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventTypeInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteEventTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEventTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTypeOutputError>
}

public struct DeleteEventTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTypeOutputError>
}

public struct DeleteEventTypeInput: Swift.Equatable {
    /// The name of the event type to delete.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventTypeInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteEventTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventTypeOutputResponse()"}
}

extension DeleteEventTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventTypeOutputResponseBody: Swift.Equatable {
}

extension DeleteEventTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteExternalModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExternalModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExternalModelOutputError>
}

extension DeleteExternalModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExternalModelInput(modelEndpoint: \(Swift.String(describing: modelEndpoint)))"}
}

extension DeleteExternalModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
    }
}

public struct DeleteExternalModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExternalModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExternalModelOutputError>
}

public struct DeleteExternalModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExternalModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExternalModelOutputError>
}

public struct DeleteExternalModelInput: Swift.Equatable {
    /// The endpoint of the Amazon Sagemaker model to delete.
    /// This member is required.
    public let modelEndpoint: Swift.String?

    public init (
        modelEndpoint: Swift.String? = nil
    )
    {
        self.modelEndpoint = modelEndpoint
    }
}

struct DeleteExternalModelInputBody: Swift.Equatable {
    public let modelEndpoint: Swift.String?
}

extension DeleteExternalModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
    }
}

extension DeleteExternalModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExternalModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExternalModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExternalModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExternalModelOutputResponse()"}
}

extension DeleteExternalModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteExternalModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteExternalModelOutputResponseBody: Swift.Equatable {
}

extension DeleteExternalModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteLabelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLabelOutputError>
}

extension DeleteLabelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLabelInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteLabelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteLabelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLabelOutputError>
}

public struct DeleteLabelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLabelOutputError>
}

public struct DeleteLabelInput: Swift.Equatable {
    /// The name of the label to delete.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLabelInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLabelOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLabelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLabelOutputResponse()"}
}

extension DeleteLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLabelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLabelOutputResponseBody: Swift.Equatable {
}

extension DeleteLabelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelOutputError>
}

extension DeleteModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelInput(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)))"}
}

extension DeleteModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

public struct DeleteModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Swift.Equatable {
    /// The model ID of the model to delete.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type of the model to delete.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct DeleteModelInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
}

extension DeleteModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
    }
}

extension DeleteModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelOutputResponse()"}
}

extension DeleteModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteModelOutputResponseBody: Swift.Equatable {
}

extension DeleteModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteModelVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelVersionOutputError>
}

extension DeleteModelVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelVersionInput(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)))"}
}

extension DeleteModelVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

public struct DeleteModelVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelVersionOutputError>
}

public struct DeleteModelVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteModelVersionOutputError>
}

public struct DeleteModelVersionInput: Swift.Equatable {
    /// The model ID of the model version to delete.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type of the model version to delete.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version to delete.
    /// This member is required.
    public let modelVersionNumber: Swift.String?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct DeleteModelVersionInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
}

extension DeleteModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension DeleteModelVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteModelVersionOutputResponse()"}
}

extension DeleteModelVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelVersionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteModelVersionOutputResponseBody: Swift.Equatable {
}

extension DeleteModelVersionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteOutcomeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutcomeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutcomeOutputError>
}

extension DeleteOutcomeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutcomeInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteOutcomeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteOutcomeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutcomeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutcomeOutputError>
}

public struct DeleteOutcomeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutcomeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutcomeOutputError>
}

public struct DeleteOutcomeInput: Swift.Equatable {
    /// The name of the outcome to delete.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteOutcomeInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteOutcomeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteOutcomeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOutcomeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOutcomeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOutcomeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutcomeOutputResponse()"}
}

extension DeleteOutcomeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOutcomeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOutcomeOutputResponseBody: Swift.Equatable {
}

extension DeleteOutcomeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleInput(rule: \(Swift.String(describing: rule)))"}
}

extension DeleteRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct DeleteRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Swift.Equatable {
    /// A rule.
    /// This member is required.
    public let rule: FraudDetectorClientTypes.Rule?

    public init (
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
    public let rule: FraudDetectorClientTypes.Rule?
}

extension DeleteRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteVariableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVariableOutputError>
}

extension DeleteVariableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVariableInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteVariableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteVariableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVariableOutputError>
}

public struct DeleteVariableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteVariableOutputError>
}

public struct DeleteVariableInput: Swift.Equatable {
    /// The name of the variable to delete.
    /// This member is required.
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteVariableInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteVariableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVariableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVariableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVariableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVariableOutputResponse()"}
}

extension DeleteVariableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVariableOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteVariableOutputResponseBody: Swift.Equatable {
}

extension DeleteVariableOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeDetectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorOutputError>
}

extension DescribeDetectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorInput(detectorId: \(Swift.String(describing: detectorId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDetectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDetectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The maximum number of results to return for the request.
    public let maxResults: Swift.Int?
    /// The next token from the previous response.
    public let nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDetectorInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorOutputResponse(arn: \(Swift.String(describing: arn)), detectorId: \(Swift.String(describing: detectorId)), detectorVersionSummaries: \(Swift.String(describing: detectorVersionSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.detectorId = output.detectorId
            self.detectorVersionSummaries = output.detectorVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.arn = nil
            self.detectorId = nil
            self.detectorVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDetectorOutputResponse: Swift.Equatable {
    /// The detector ARN.
    public let arn: Swift.String?
    /// The detector ID.
    public let detectorId: Swift.String?
    /// The status and description for each detector version.
    public let detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]?
    /// The next token to be used for subsequent requests.
    public let nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.detectorId = detectorId
        self.detectorVersionSummaries = detectorVersionSummaries
        self.nextToken = nextToken
    }
}

struct DescribeDetectorOutputResponseBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]?
    public let nextToken: Swift.String?
    public let arn: Swift.String?
}

extension DescribeDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case detectorId
        case detectorVersionSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionSummariesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.DetectorVersionSummary?].self, forKey: .detectorVersionSummaries)
        var detectorVersionSummariesDecoded0:[FraudDetectorClientTypes.DetectorVersionSummary]? = nil
        if let detectorVersionSummariesContainer = detectorVersionSummariesContainer {
            detectorVersionSummariesDecoded0 = [FraudDetectorClientTypes.DetectorVersionSummary]()
            for structure0 in detectorVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorVersionSummaries = detectorVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct DescribeModelVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeModelVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeModelVersionsOutputError>
}

extension DescribeModelVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeModelVersionsInput(maxResults: \(Swift.String(describing: maxResults)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeModelVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeModelVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeModelVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeModelVersionsOutputError>
}

public struct DescribeModelVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeModelVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeModelVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeModelVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeModelVersionsOutputError>
}

public struct DescribeModelVersionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public let maxResults: Swift.Int?
    /// The model ID.
    public let modelId: Swift.String?
    /// The model type.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public let modelVersionNumber: Swift.String?
    /// The next token from the previous results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelVersionNumber: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeModelVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeModelVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeModelVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeModelVersionsOutputResponse(modelVersionDetails: \(Swift.String(describing: modelVersionDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeModelVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeModelVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelVersionDetails = output.modelVersionDetails
            self.nextToken = output.nextToken
        } else {
            self.modelVersionDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeModelVersionsOutputResponse: Swift.Equatable {
    /// The model version details.
    public let modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]?
    /// The next token.
    public let nextToken: Swift.String?

    public init (
        modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelVersionDetails = modelVersionDetails
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsOutputResponseBody: Swift.Equatable {
    public let modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]?
    public let nextToken: Swift.String?
}

extension DescribeModelVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelVersionDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDetailsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersionDetail?].self, forKey: .modelVersionDetails)
        var modelVersionDetailsDecoded0:[FraudDetectorClientTypes.ModelVersionDetail]? = nil
        if let modelVersionDetailsContainer = modelVersionDetailsContainer {
            modelVersionDetailsDecoded0 = [FraudDetectorClientTypes.ModelVersionDetail]()
            for structure0 in modelVersionDetailsContainer {
                if let structure0 = structure0 {
                    modelVersionDetailsDecoded0?.append(structure0)
                }
            }
        }
        modelVersionDetails = modelVersionDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FraudDetectorClientTypes.Detector: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case eventTypeName
        case lastUpdatedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.Detector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Detector(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), eventTypeName: \(Swift.String(describing: eventTypeName)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)))"}
}

extension FraudDetectorClientTypes {
    /// The detector.
    public struct Detector: Swift.Equatable {
        /// The detector ARN.
        public let arn: Swift.String?
        /// Timestamp of when the detector was created.
        public let createdTime: Swift.String?
        /// The detector description.
        public let description: Swift.String?
        /// The detector ID.
        public let detectorId: Swift.String?
        /// The name of the event type.
        public let eventTypeName: Swift.String?
        /// Timestamp of when the detector was last updated.
        public let lastUpdatedTime: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension FraudDetectorClientTypes {
    public enum DetectorVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorVersionStatus] {
            return [
                .active,
                .draft,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorVersionStatus(rawValue: rawValue) ?? DetectorVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.DetectorVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorVersionId
        case lastUpdatedTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension FraudDetectorClientTypes.DetectorVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorVersionSummary(description: \(Swift.String(describing: description)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), status: \(Swift.String(describing: status)))"}
}

extension FraudDetectorClientTypes {
    /// The summary of the detector version.
    public struct DetectorVersionSummary: Swift.Equatable {
        /// The detector version description.
        public let description: Swift.String?
        /// The detector version ID.
        public let detectorVersionId: Swift.String?
        /// Timestamp of when the detector version was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The detector version status.
        public let status: FraudDetectorClientTypes.DetectorVersionStatus?

        public init (
            description: Swift.String? = nil,
            detectorVersionId: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
        )
        {
            self.description = description
            self.detectorVersionId = detectorVersionId
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
        }
    }

}

extension FraudDetectorClientTypes.Entity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case entityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension FraudDetectorClientTypes.Entity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Entity(entityId: \(Swift.String(describing: entityId)), entityType: \(Swift.String(describing: entityType)))"}
}

extension FraudDetectorClientTypes {
    /// The entity details.
    public struct Entity: Swift.Equatable {
        /// The entity ID. If you do not know the entityId, you can pass unknown, which is areserved string literal.
        /// This member is required.
        public let entityId: Swift.String?
        /// The entity type.
        /// This member is required.
        public let entityType: Swift.String?

        public init (
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityType = entityType
        }
    }

}

extension FraudDetectorClientTypes.EntityType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.EntityType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityType(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// The entity type details.
    public struct EntityType: Swift.Equatable {
        /// The entity type ARN.
        public let arn: Swift.String?
        /// Timestamp of when the entity type was created.
        public let createdTime: Swift.String?
        /// The entity type description.
        public let description: Swift.String?
        /// Timestamp of when the entity type was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The entity type name.
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.EventType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case entityTypes
        case eventVariables
        case labels
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for nonemptylistofstrings0 in entityTypes {
                try entityTypesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for listofstrings0 in eventVariables {
                try eventVariablesContainer.encode(listofstrings0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for listofstrings0 in labels {
                try labelsContainer.encode(listofstrings0)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[Swift.String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [Swift.String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.EventType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventType(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), entityTypes: \(Swift.String(describing: entityTypes)), eventVariables: \(Swift.String(describing: eventVariables)), labels: \(Swift.String(describing: labels)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// The event type details.
    public struct EventType: Swift.Equatable {
        /// The entity type ARN.
        public let arn: Swift.String?
        /// Timestamp of when the event type was created.
        public let createdTime: Swift.String?
        /// The event type description.
        public let description: Swift.String?
        /// The event type entity types.
        public let entityTypes: [Swift.String]?
        /// The event type event variables.
        public let eventVariables: [Swift.String]?
        /// The event type labels.
        public let labels: [Swift.String]?
        /// Timestamp of when the event type was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The event type name.
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            entityTypes: [Swift.String]? = nil,
            eventVariables: [Swift.String]? = nil,
            labels: [Swift.String]? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.entityTypes = entityTypes
            self.eventVariables = eventVariables
            self.labels = labels
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.ExternalEventsDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn
        case dataLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let dataLocation = dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension FraudDetectorClientTypes.ExternalEventsDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExternalEventsDetail(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), dataLocation: \(Swift.String(describing: dataLocation)))"}
}

extension FraudDetectorClientTypes {
    /// Details for the external events data used for model version training.
    public struct ExternalEventsDetail: Swift.Equatable {
        /// The ARN of the role that provides Amazon Fraud Detector access to the data location.
        /// This member is required.
        public let dataAccessRoleArn: Swift.String?
        /// The Amazon S3 bucket location for the data.
        /// This member is required.
        public let dataLocation: Swift.String?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            dataLocation: Swift.String? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.dataLocation = dataLocation
        }
    }

}

extension FraudDetectorClientTypes.ExternalModel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case lastUpdatedTime
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.ExternalModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExternalModel(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), inputConfiguration: \(Swift.String(describing: inputConfiguration)), invokeModelEndpointRoleArn: \(Swift.String(describing: invokeModelEndpointRoleArn)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), modelEndpoint: \(Swift.String(describing: modelEndpoint)), modelEndpointStatus: \(Swift.String(describing: modelEndpointStatus)), modelSource: \(Swift.String(describing: modelSource)), outputConfiguration: \(Swift.String(describing: outputConfiguration)))"}
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model.
    public struct ExternalModel: Swift.Equatable {
        /// The model ARN.
        public let arn: Swift.String?
        /// Timestamp of when the model was last created.
        public let createdTime: Swift.String?
        /// The input configuration.
        public let inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
        /// The role used to invoke the model.
        public let invokeModelEndpointRoleArn: Swift.String?
        /// Timestamp of when the model was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The Amazon SageMaker model endpoints.
        public let modelEndpoint: Swift.String?
        /// The Amazon Fraud Detector status for the external model endpoint
        public let modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
        /// The source of the model.
        public let modelSource: FraudDetectorClientTypes.ModelSource?
        /// The output configuration.
        public let outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
            invokeModelEndpointRoleArn: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelEndpoint: Swift.String? = nil,
            modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
            modelSource: FraudDetectorClientTypes.ModelSource? = nil,
            outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.lastUpdatedTime = lastUpdatedTime
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
        }
    }

}

extension FraudDetectorClientTypes.FieldValidationMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case fieldName
        case identifier
        case title
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FraudDetectorClientTypes.FieldValidationMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldValidationMessage(content: \(Swift.String(describing: content)), fieldName: \(Swift.String(describing: fieldName)), identifier: \(Swift.String(describing: identifier)), title: \(Swift.String(describing: title)), type: \(Swift.String(describing: type)))"}
}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FieldValidationMessage: Swift.Equatable {
        /// The message content.
        public let content: Swift.String?
        /// The field name.
        public let fieldName: Swift.String?
        /// The message ID.
        public let identifier: Swift.String?
        /// The message title.
        public let title: Swift.String?
        /// The message type.
        public let type: Swift.String?

        public init (
            content: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.fieldName = fieldName
            self.identifier = identifier
            self.title = title
            self.type = type
        }
    }

}

extension FraudDetectorClientTypes.FileValidationMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case title
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FraudDetectorClientTypes.FileValidationMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileValidationMessage(content: \(Swift.String(describing: content)), title: \(Swift.String(describing: title)), type: \(Swift.String(describing: type)))"}
}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FileValidationMessage: Swift.Equatable {
        /// The message content.
        public let content: Swift.String?
        /// The message title.
        public let title: Swift.String?
        /// The message type.
        public let type: Swift.String?

        public init (
            content: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.title = title
            self.type = type
        }
    }

}

public struct GetBatchPredictionJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBatchPredictionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBatchPredictionJobsOutputError>
}

extension GetBatchPredictionJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBatchPredictionJobsInput(jobId: \(Swift.String(describing: jobId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetBatchPredictionJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetBatchPredictionJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBatchPredictionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBatchPredictionJobsOutputError>
}

public struct GetBatchPredictionJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBatchPredictionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBatchPredictionJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBatchPredictionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBatchPredictionJobsOutputError>
}

public struct GetBatchPredictionJobsInput: Swift.Equatable {
    /// The batch prediction job for which to get the details.
    public let jobId: Swift.String?
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The next token from the previous request.
    public let nextToken: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension GetBatchPredictionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetBatchPredictionJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBatchPredictionJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBatchPredictionJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBatchPredictionJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBatchPredictionJobsOutputResponse(batchPredictions: \(Swift.String(describing: batchPredictions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetBatchPredictionJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBatchPredictionJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchPredictions = output.batchPredictions
            self.nextToken = output.nextToken
        } else {
            self.batchPredictions = nil
            self.nextToken = nil
        }
    }
}

public struct GetBatchPredictionJobsOutputResponse: Swift.Equatable {
    /// An array containing the details of each batch prediction job.
    public let batchPredictions: [FraudDetectorClientTypes.BatchPrediction]?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        batchPredictions: [FraudDetectorClientTypes.BatchPrediction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchPredictions = batchPredictions
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsOutputResponseBody: Swift.Equatable {
    public let batchPredictions: [FraudDetectorClientTypes.BatchPrediction]?
    public let nextToken: Swift.String?
}

extension GetBatchPredictionJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPredictions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPredictionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchPrediction?].self, forKey: .batchPredictions)
        var batchPredictionsDecoded0:[FraudDetectorClientTypes.BatchPrediction]? = nil
        if let batchPredictionsContainer = batchPredictionsContainer {
            batchPredictionsDecoded0 = [FraudDetectorClientTypes.BatchPrediction]()
            for structure0 in batchPredictionsContainer {
                if let structure0 = structure0 {
                    batchPredictionsDecoded0?.append(structure0)
                }
            }
        }
        batchPredictions = batchPredictionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetDetectorVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorVersionOutputError>
}

extension GetDetectorVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorVersionInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)))"}
}

extension GetDetectorVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct GetDetectorVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorVersionOutputError>
}

public struct GetDetectorVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorVersionOutputError>
}

public struct GetDetectorVersionInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public let detectorVersionId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct GetDetectorVersionInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
}

extension GetDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension GetDetectorVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorVersionOutputResponse(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), externalModelEndpoints: \(Swift.String(describing: externalModelEndpoints)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), modelVersions: \(Swift.String(describing: modelVersions)), ruleExecutionMode: \(Swift.String(describing: ruleExecutionMode)), rules: \(Swift.String(describing: rules)), status: \(Swift.String(describing: status)))"}
}

extension GetDetectorVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDetectorVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.externalModelEndpoints = output.externalModelEndpoints
            self.lastUpdatedTime = output.lastUpdatedTime
            self.modelVersions = output.modelVersions
            self.ruleExecutionMode = output.ruleExecutionMode
            self.rules = output.rules
            self.status = output.status
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.detectorId = nil
            self.detectorVersionId = nil
            self.externalModelEndpoints = nil
            self.lastUpdatedTime = nil
            self.modelVersions = nil
            self.ruleExecutionMode = nil
            self.rules = nil
            self.status = nil
        }
    }
}

public struct GetDetectorVersionOutputResponse: Swift.Equatable {
    /// The detector version ARN.
    public let arn: Swift.String?
    /// The timestamp when the detector version was created.
    public let createdTime: Swift.String?
    /// The detector version description.
    public let description: Swift.String?
    /// The detector ID.
    public let detectorId: Swift.String?
    /// The detector version ID.
    public let detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints included in the detector version.
    public let externalModelEndpoints: [Swift.String]?
    /// The timestamp when the detector version was last updated.
    ///
    public let lastUpdatedTime: Swift.String?
    /// The model versions included in the detector version.
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The execution mode of the rule in the dectector
    /// 	
    ///             FIRST_MATCHED indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
    /// 	
    ///             ALL_MATCHED indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules included in the detector version.
    public let rules: [FraudDetectorClientTypes.Rule]?
    /// The status of the detector version.
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init (
        arn: Swift.String? = nil,
        createdTime: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        lastUpdatedTime: Swift.String? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.lastUpdatedTime = lastUpdatedTime
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.status = status
    }
}

struct GetDetectorVersionOutputResponseBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let description: Swift.String?
    public let externalModelEndpoints: [Swift.String]?
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    public let rules: [FraudDetectorClientTypes.Rule]?
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?
    public let lastUpdatedTime: Swift.String?
    public let createdTime: Swift.String?
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    public let arn: Swift.String?
}

extension GetDetectorVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case lastUpdatedTime
        case modelVersions
        case ruleExecutionMode
        case rules
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetDetectorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorsOutputError>
}

extension GetDetectorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorsInput(detectorId: \(Swift.String(describing: detectorId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDetectorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetDetectorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorsOutputError>
}

public struct GetDetectorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDetectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDetectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDetectorsOutputError>
}

public struct GetDetectorsInput: Swift.Equatable {
    /// The detector ID.
    public let detectorId: Swift.String?
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorsInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDetectorsOutputResponse(detectors: \(Swift.String(describing: detectors)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectors = output.detectors
            self.nextToken = output.nextToken
        } else {
            self.detectors = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorsOutputResponse: Swift.Equatable {
    /// The detectors.
    public let detectors: [FraudDetectorClientTypes.Detector]?
    /// The next page token.
    public let nextToken: Swift.String?

    public init (
        detectors: [FraudDetectorClientTypes.Detector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectors = detectors
        self.nextToken = nextToken
    }
}

struct GetDetectorsOutputResponseBody: Swift.Equatable {
    public let detectors: [FraudDetectorClientTypes.Detector]?
    public let nextToken: Swift.String?
}

extension GetDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Detector?].self, forKey: .detectors)
        var detectorsDecoded0:[FraudDetectorClientTypes.Detector]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [FraudDetectorClientTypes.Detector]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetEntityTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEntityTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEntityTypesOutputError>
}

extension GetEntityTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEntityTypesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetEntityTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetEntityTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEntityTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEntityTypesOutputError>
}

public struct GetEntityTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEntityTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEntityTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEntityTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEntityTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEntityTypesOutputError>
}

public struct GetEntityTypesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The name.
    public let name: Swift.String?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEntityTypesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetEntityTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEntityTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntityTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEntityTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntityTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEntityTypesOutputResponse(entityTypes: \(Swift.String(describing: entityTypes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetEntityTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEntityTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entityTypes = output.entityTypes
            self.nextToken = output.nextToken
        } else {
            self.entityTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEntityTypesOutputResponse: Swift.Equatable {
    /// An array of entity types.
    public let entityTypes: [FraudDetectorClientTypes.EntityType]?
    /// The next page token.
    public let nextToken: Swift.String?

    public init (
        entityTypes: [FraudDetectorClientTypes.EntityType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.nextToken = nextToken
    }
}

struct GetEntityTypesOutputResponseBody: Swift.Equatable {
    public let entityTypes: [FraudDetectorClientTypes.EntityType]?
    public let nextToken: Swift.String?
}

extension GetEntityTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[FraudDetectorClientTypes.EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [FraudDetectorClientTypes.EntityType]()
            for structure0 in entityTypesContainer {
                if let structure0 = structure0 {
                    entityTypesDecoded0?.append(structure0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetEventPredictionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventPredictionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventPredictionOutputError>
}

extension GetEventPredictionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventPredictionInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), entities: \(Swift.String(describing: entities)), eventId: \(Swift.String(describing: eventId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventTypeName: \(Swift.String(describing: eventTypeName)), eventVariables: \(Swift.String(describing: eventVariables)), externalModelEndpointDataBlobs: \(Swift.String(describing: externalModelEndpointDataBlobs)))"}
}

extension GetEventPredictionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for listofentities0 in entities {
                try entitiesContainer.encode(listofentities0)
            }
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventVariables)
            for (dictKey0, eventvariablemap0) in eventVariables {
                try eventVariablesContainer.encode(eventvariablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let externalModelEndpointDataBlobs = externalModelEndpointDataBlobs {
            var externalModelEndpointDataBlobsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalModelEndpointDataBlobs)
            for (dictKey0, externalmodelendpointdatablobmap0) in externalModelEndpointDataBlobs {
                try externalModelEndpointDataBlobsContainer.encode(externalmodelendpointdatablobmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetEventPredictionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventPredictionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventPredictionOutputError>
}

public struct GetEventPredictionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventPredictionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventPredictionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventPredictionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventPredictionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventPredictionOutputError>
}

public struct GetEventPredictionInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The detector version ID.
    public let detectorVersionId: Swift.String?
    /// The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."
    /// This member is required.
    public let entities: [FraudDetectorClientTypes.Entity]?
    /// The unique ID used to identify the event.
    /// This member is required.
    public let eventId: Swift.String?
    /// Timestamp that defines when the event under evaluation occurred.
    /// This member is required.
    public let eventTimestamp: Swift.String?
    /// The event type associated with the detector specified for the prediction.
    /// This member is required.
    public let eventTypeName: Swift.String?
    /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and
    ///          their corresponding values for the event you are sending for evaluation.
    ///
    ///
    ///
    ///                   You must provide at least one eventVariable
    ///
    ///
    ///                   If detectorVersion is associated with a modelVersion, you must provide at least one associated eventVariable
    ///
    ///
    ///
    ///
    ///          To ensure highest possible fraud prediction and to simplify your data preparation, Amazon Fraud Detector will replace all missing variables or values as follows:
    ///
    ///
    ///             For Amazon Fraud Detector trained models:
    ///
    ///          If a null value is provided explicitly for a variable or if a variable is missing, model will replace the null value or the missing variable (no variable name in the eventVariables map)
    ///          with calculated default mean/medians for numeric variables and with special values for categorical variables.
    ///
    ///
    ///             For External models ( for example, imported SageMaker):
    ///
    ///          If a null value is provided explicitly for a variable, the model and rules will use “null” as the value. If a variable is not provided (no variable name in the eventVariables map), model and rules
    ///          will use the default value that is provided for the variable.
    /// This member is required.
    public let eventVariables: [Swift.String:Swift.String]?
    /// The Amazon SageMaker model endpoint input data blobs.
    public let externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]?

    public init (
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        entities: [FraudDetectorClientTypes.Entity]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [Swift.String:Swift.String]? = nil,
        externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
    }
}

struct GetEventPredictionInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let eventId: Swift.String?
    public let eventTypeName: Swift.String?
    public let entities: [FraudDetectorClientTypes.Entity]?
    public let eventTimestamp: Swift.String?
    public let eventVariables: [Swift.String:Swift.String]?
    public let externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]?
}

extension GetEventPredictionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[FraudDetectorClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [FraudDetectorClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variablevalue0) in eventVariablesContainer {
                if let variablevalue0 = variablevalue0 {
                    eventVariablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let externalModelEndpointDataBlobsContainer = try containerValues.decodeIfPresent([Swift.String: FraudDetectorClientTypes.ModelEndpointDataBlob?].self, forKey: .externalModelEndpointDataBlobs)
        var externalModelEndpointDataBlobsDecoded0: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]? = nil
        if let externalModelEndpointDataBlobsContainer = externalModelEndpointDataBlobsContainer {
            externalModelEndpointDataBlobsDecoded0 = [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]()
            for (key0, modelendpointdatablob0) in externalModelEndpointDataBlobsContainer {
                if let modelendpointdatablob0 = modelendpointdatablob0 {
                    externalModelEndpointDataBlobsDecoded0?[key0] = modelendpointdatablob0
                }
            }
        }
        externalModelEndpointDataBlobs = externalModelEndpointDataBlobsDecoded0
    }
}

extension GetEventPredictionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventPredictionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventPredictionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventPredictionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventPredictionOutputResponse(modelScores: \(Swift.String(describing: modelScores)), ruleResults: \(Swift.String(describing: ruleResults)))"}
}

extension GetEventPredictionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventPredictionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelScores = output.modelScores
            self.ruleResults = output.ruleResults
        } else {
            self.modelScores = nil
            self.ruleResults = nil
        }
    }
}

public struct GetEventPredictionOutputResponse: Swift.Equatable {
    /// The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.
    public let modelScores: [FraudDetectorClientTypes.ModelScores]?
    /// The results.
    public let ruleResults: [FraudDetectorClientTypes.RuleResult]?

    public init (
        modelScores: [FraudDetectorClientTypes.ModelScores]? = nil,
        ruleResults: [FraudDetectorClientTypes.RuleResult]? = nil
    )
    {
        self.modelScores = modelScores
        self.ruleResults = ruleResults
    }
}

struct GetEventPredictionOutputResponseBody: Swift.Equatable {
    public let modelScores: [FraudDetectorClientTypes.ModelScores]?
    public let ruleResults: [FraudDetectorClientTypes.RuleResult]?
}

extension GetEventPredictionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelScores
        case ruleResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelScoresContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelScores?].self, forKey: .modelScores)
        var modelScoresDecoded0:[FraudDetectorClientTypes.ModelScores]? = nil
        if let modelScoresContainer = modelScoresContainer {
            modelScoresDecoded0 = [FraudDetectorClientTypes.ModelScores]()
            for structure0 in modelScoresContainer {
                if let structure0 = structure0 {
                    modelScoresDecoded0?.append(structure0)
                }
            }
        }
        modelScores = modelScoresDecoded0
        let ruleResultsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.RuleResult?].self, forKey: .ruleResults)
        var ruleResultsDecoded0:[FraudDetectorClientTypes.RuleResult]? = nil
        if let ruleResultsContainer = ruleResultsContainer {
            ruleResultsDecoded0 = [FraudDetectorClientTypes.RuleResult]()
            for structure0 in ruleResultsContainer {
                if let structure0 = structure0 {
                    ruleResultsDecoded0?.append(structure0)
                }
            }
        }
        ruleResults = ruleResultsDecoded0
    }
}

public struct GetEventTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventTypesOutputError>
}

extension GetEventTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventTypesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetEventTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetEventTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventTypesOutputError>
}

public struct GetEventTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEventTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEventTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEventTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEventTypesOutputError>
}

public struct GetEventTypesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The name.
    public let name: Swift.String?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEventTypesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetEventTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEventTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventTypesOutputResponse(eventTypes: \(Swift.String(describing: eventTypes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetEventTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEventTypesOutputResponse: Swift.Equatable {
    /// An array of event types.
    public let eventTypes: [FraudDetectorClientTypes.EventType]?
    /// The next page token.
    public let nextToken: Swift.String?

    public init (
        eventTypes: [FraudDetectorClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct GetEventTypesOutputResponseBody: Swift.Equatable {
    public let eventTypes: [FraudDetectorClientTypes.EventType]?
    public let nextToken: Swift.String?
}

extension GetEventTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[FraudDetectorClientTypes.EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [FraudDetectorClientTypes.EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetExternalModelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExternalModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExternalModelsOutputError>
}

extension GetExternalModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExternalModelsInput(maxResults: \(Swift.String(describing: maxResults)), modelEndpoint: \(Swift.String(describing: modelEndpoint)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetExternalModelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetExternalModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExternalModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExternalModelsOutputError>
}

public struct GetExternalModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExternalModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExternalModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExternalModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExternalModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExternalModelsOutputError>
}

public struct GetExternalModelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The Amazon SageMaker model endpoint.
    public let modelEndpoint: Swift.String?
    /// The next page token for the request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        modelEndpoint: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelEndpoint = modelEndpoint
        self.nextToken = nextToken
    }
}

struct GetExternalModelsInputBody: Swift.Equatable {
    public let modelEndpoint: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetExternalModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetExternalModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExternalModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExternalModelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExternalModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExternalModelsOutputResponse(externalModels: \(Swift.String(describing: externalModels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetExternalModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExternalModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalModels = output.externalModels
            self.nextToken = output.nextToken
        } else {
            self.externalModels = nil
            self.nextToken = nil
        }
    }
}

public struct GetExternalModelsOutputResponse: Swift.Equatable {
    /// Gets the Amazon SageMaker models.
    public let externalModels: [FraudDetectorClientTypes.ExternalModel]?
    /// The next page token to be used in subsequent requests.
    public let nextToken: Swift.String?

    public init (
        externalModels: [FraudDetectorClientTypes.ExternalModel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.externalModels = externalModels
        self.nextToken = nextToken
    }
}

struct GetExternalModelsOutputResponseBody: Swift.Equatable {
    public let externalModels: [FraudDetectorClientTypes.ExternalModel]?
    public let nextToken: Swift.String?
}

extension GetExternalModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalModels
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalModelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ExternalModel?].self, forKey: .externalModels)
        var externalModelsDecoded0:[FraudDetectorClientTypes.ExternalModel]? = nil
        if let externalModelsContainer = externalModelsContainer {
            externalModelsDecoded0 = [FraudDetectorClientTypes.ExternalModel]()
            for structure0 in externalModelsContainer {
                if let structure0 = structure0 {
                    externalModelsDecoded0?.append(structure0)
                }
            }
        }
        externalModels = externalModelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetKMSEncryptionKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKMSEncryptionKeyInput()"}
}

extension GetKMSEncryptionKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKMSEncryptionKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKMSEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKMSEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKMSEncryptionKeyOutputError>
}

public struct GetKMSEncryptionKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKMSEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKMSEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKMSEncryptionKeyOutputError>
}

public struct GetKMSEncryptionKeyInput: Swift.Equatable {

    public init() {}
}

struct GetKMSEncryptionKeyInputBody: Swift.Equatable {
}

extension GetKMSEncryptionKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKMSEncryptionKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKMSEncryptionKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKMSEncryptionKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKMSEncryptionKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKMSEncryptionKeyOutputResponse(kmsKey: \(Swift.String(describing: kmsKey)))"}
}

extension GetKMSEncryptionKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetKMSEncryptionKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.kmsKey = output.kmsKey
        } else {
            self.kmsKey = nil
        }
    }
}

public struct GetKMSEncryptionKeyOutputResponse: Swift.Equatable {
    /// The KMS encryption key.
    public let kmsKey: FraudDetectorClientTypes.KMSKey?

    public init (
        kmsKey: FraudDetectorClientTypes.KMSKey? = nil
    )
    {
        self.kmsKey = kmsKey
    }
}

struct GetKMSEncryptionKeyOutputResponseBody: Swift.Equatable {
    public let kmsKey: FraudDetectorClientTypes.KMSKey?
}

extension GetKMSEncryptionKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.KMSKey.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

public struct GetLabelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLabelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLabelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLabelsOutputError>
}

extension GetLabelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLabelsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLabelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetLabelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLabelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLabelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLabelsOutputError>
}

public struct GetLabelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLabelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLabelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLabelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLabelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLabelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLabelsOutputError>
}

public struct GetLabelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The name of the label or labels to get.
    public let name: Swift.String?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetLabelsInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetLabelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetLabelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLabelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLabelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLabelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLabelsOutputResponse(labels: \(Swift.String(describing: labels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetLabelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLabelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.labels = output.labels
            self.nextToken = output.nextToken
        } else {
            self.labels = nil
            self.nextToken = nil
        }
    }
}

public struct GetLabelsOutputResponse: Swift.Equatable {
    /// An array of labels.
    public let labels: [FraudDetectorClientTypes.Label]?
    /// The next page token.
    public let nextToken: Swift.String?

    public init (
        labels: [FraudDetectorClientTypes.Label]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.labels = labels
        self.nextToken = nextToken
    }
}

struct GetLabelsOutputResponseBody: Swift.Equatable {
    public let labels: [FraudDetectorClientTypes.Label]?
    public let nextToken: Swift.String?
}

extension GetLabelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Label?].self, forKey: .labels)
        var labelsDecoded0:[FraudDetectorClientTypes.Label]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [FraudDetectorClientTypes.Label]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetModelVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelVersionOutputError>
}

extension GetModelVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelVersionInput(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)))"}
}

extension GetModelVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

public struct GetModelVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelVersionOutputError>
}

public struct GetModelVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelVersionOutputError>
}

public struct GetModelVersionInput: Swift.Equatable {
    /// The model ID.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public let modelVersionNumber: Swift.String?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct GetModelVersionInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
}

extension GetModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension GetModelVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelVersionOutputResponse(arn: \(Swift.String(describing: arn)), externalEventsDetail: \(Swift.String(describing: externalEventsDetail)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), status: \(Swift.String(describing: status)), trainingDataSchema: \(Swift.String(describing: trainingDataSchema)), trainingDataSource: \(Swift.String(describing: trainingDataSource)))"}
}

extension GetModelVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.externalEventsDetail = output.externalEventsDetail
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
            self.trainingDataSchema = output.trainingDataSchema
            self.trainingDataSource = output.trainingDataSource
        } else {
            self.arn = nil
            self.externalEventsDetail = nil
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
            self.trainingDataSchema = nil
            self.trainingDataSource = nil
        }
    }
}

public struct GetModelVersionOutputResponse: Swift.Equatable {
    /// The model version ARN.
    public let arn: Swift.String?
    /// The event details.
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The model ID.
    public let modelId: Swift.String?
    /// The model type.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public let modelVersionNumber: Swift.String?
    /// The model version status.
    /// 	        Possible values are:
    /// 	
    ///
    ///
    ///                   TRAINING_IN_PROGRESS
    ///
    ///
    ///
    ///
    ///                   TRAINING_COMPLETE
    ///
    ///
    ///
    ///
    ///                   ACTIVATE_REQUESTED
    ///
    ///
    ///
    ///
    ///                   ACTIVATE_IN_PROGRESS
    ///
    ///
    ///
    ///
    ///                   ACTIVE
    ///
    ///
    ///
    ///
    ///                   INACTIVATE_REQUESTED
    ///
    ///
    ///
    ///
    ///                   INACTIVATE_IN_PROGRESS
    ///
    ///
    ///
    ///
    ///                   INACTIVE
    ///
    ///
    ///
    ///
    ///                   ERROR
    ///
    ///
    ///
    public let status: Swift.String?
    /// The training data schema.
    public let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source.
    public let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init (
        arn: Swift.String? = nil,
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.arn = arn
        self.externalEventsDetail = externalEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct GetModelVersionOutputResponseBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
    public let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
    public let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    public let status: Swift.String?
    public let arn: Swift.String?
}

extension GetModelVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case externalEventsDetail
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetModelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelsOutputError>
}

extension GetModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelsInput(maxResults: \(Swift.String(describing: maxResults)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetModelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelsOutputError>
}

public struct GetModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetModelsOutputError>
}

public struct GetModelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The model ID.
    public let modelId: Swift.String?
    /// The model type.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The next token for the subsequent request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelsOutputResponse(models: \(Swift.String(describing: models)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutputResponse: Swift.Equatable {
    /// The array of models.
    public let models: [FraudDetectorClientTypes.Model]?
    /// The next page token to be used in subsequent requests.
    public let nextToken: Swift.String?

    public init (
        models: [FraudDetectorClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct GetModelsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let models: [FraudDetectorClientTypes.Model]?
}

extension GetModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Model?].self, forKey: .models)
        var modelsDecoded0:[FraudDetectorClientTypes.Model]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [FraudDetectorClientTypes.Model]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
    }
}

public struct GetOutcomesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutcomesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutcomesOutputError>
}

extension GetOutcomesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutcomesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetOutcomesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetOutcomesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutcomesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutcomesOutputError>
}

public struct GetOutcomesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutcomesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutcomesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutcomesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutcomesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutcomesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutcomesOutputError>
}

public struct GetOutcomesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The name of the outcome or outcomes to get.
    public let name: Swift.String?
    /// The next page token for the request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetOutcomesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetOutcomesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOutcomesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutcomesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutcomesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutcomesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutcomesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outcomes: \(Swift.String(describing: outcomes)))"}
}

extension GetOutcomesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOutcomesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outcomes = output.outcomes
        } else {
            self.nextToken = nil
            self.outcomes = nil
        }
    }
}

public struct GetOutcomesOutputResponse: Swift.Equatable {
    /// The next page token for subsequent requests.
    public let nextToken: Swift.String?
    /// The outcomes.
    public let outcomes: [FraudDetectorClientTypes.Outcome]?

    public init (
        nextToken: Swift.String? = nil,
        outcomes: [FraudDetectorClientTypes.Outcome]? = nil
    )
    {
        self.nextToken = nextToken
        self.outcomes = outcomes
    }
}

struct GetOutcomesOutputResponseBody: Swift.Equatable {
    public let outcomes: [FraudDetectorClientTypes.Outcome]?
    public let nextToken: Swift.String?
}

extension GetOutcomesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outcomes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outcomesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Outcome?].self, forKey: .outcomes)
        var outcomesDecoded0:[FraudDetectorClientTypes.Outcome]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [FraudDetectorClientTypes.Outcome]()
            for structure0 in outcomesContainer {
                if let structure0 = structure0 {
                    outcomesDecoded0?.append(structure0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetRulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRulesOutputError>
}

extension GetRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRulesInput(detectorId: \(Swift.String(describing: detectorId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)))"}
}

extension GetRulesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }
}

public struct GetRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRulesOutputError>
}

public struct GetRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRulesOutputError>
}

public struct GetRulesInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The maximum number of rules to return for the request.
    public let maxResults: Swift.Int?
    /// The next page token.
    public let nextToken: Swift.String?
    /// The rule ID.
    public let ruleId: Swift.String?
    /// The rule version.
    public let ruleVersion: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleId: Swift.String? = nil,
        ruleVersion: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

struct GetRulesInputBody: Swift.Equatable {
    public let ruleId: Swift.String?
    public let detectorId: Swift.String?
    public let ruleVersion: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRulesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), ruleDetails: \(Swift.String(describing: ruleDetails)))"}
}

extension GetRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleDetails = output.ruleDetails
        } else {
            self.nextToken = nil
            self.ruleDetails = nil
        }
    }
}

public struct GetRulesOutputResponse: Swift.Equatable {
    /// The next page token to be used in subsequent requests.
    public let nextToken: Swift.String?
    /// The details of the requested rule.
    public let ruleDetails: [FraudDetectorClientTypes.RuleDetail]?

    public init (
        nextToken: Swift.String? = nil,
        ruleDetails: [FraudDetectorClientTypes.RuleDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleDetails = ruleDetails
    }
}

struct GetRulesOutputResponseBody: Swift.Equatable {
    public let ruleDetails: [FraudDetectorClientTypes.RuleDetail]?
    public let nextToken: Swift.String?
}

extension GetRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case ruleDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDetailsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.RuleDetail?].self, forKey: .ruleDetails)
        var ruleDetailsDecoded0:[FraudDetectorClientTypes.RuleDetail]? = nil
        if let ruleDetailsContainer = ruleDetailsContainer {
            ruleDetailsDecoded0 = [FraudDetectorClientTypes.RuleDetail]()
            for structure0 in ruleDetailsContainer {
                if let structure0 = structure0 {
                    ruleDetailsDecoded0?.append(structure0)
                }
            }
        }
        ruleDetails = ruleDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetVariablesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVariablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVariablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVariablesOutputError>
}

extension GetVariablesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVariablesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetVariablesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetVariablesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVariablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVariablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVariablesOutputError>
}

public struct GetVariablesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetVariablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetVariablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetVariablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetVariablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetVariablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetVariablesOutputError>
}

public struct GetVariablesInput: Swift.Equatable {
    /// The max size per page determined for the get variable request.
    public let maxResults: Swift.Int?
    /// The name of the variable.
    public let name: Swift.String?
    /// The next page token of the get variable request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetVariablesInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetVariablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetVariablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVariablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVariablesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVariablesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetVariablesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), variables: \(Swift.String(describing: variables)))"}
}

extension GetVariablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVariablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variables = output.variables
        } else {
            self.nextToken = nil
            self.variables = nil
        }
    }
}

public struct GetVariablesOutputResponse: Swift.Equatable {
    /// The next page token to be used in subsequent requests.
    public let nextToken: Swift.String?
    /// The names of the variables returned.
    public let variables: [FraudDetectorClientTypes.Variable]?

    public init (
        nextToken: Swift.String? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.nextToken = nextToken
        self.variables = variables
    }
}

struct GetVariablesOutputResponseBody: Swift.Equatable {
    public let variables: [FraudDetectorClientTypes.Variable]?
    public let nextToken: Swift.String?
}

extension GetVariablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[FraudDetectorClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [FraudDetectorClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.KMSKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension FraudDetectorClientTypes.KMSKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSKey(kmsEncryptionKeyArn: \(Swift.String(describing: kmsEncryptionKeyArn)))"}
}

extension FraudDetectorClientTypes {
    /// The KMS key details.
    public struct KMSKey: Swift.Equatable {
        /// The encryption key ARN.
        public let kmsEncryptionKeyArn: Swift.String?

        public init (
            kmsEncryptionKeyArn: Swift.String? = nil
        )
        {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }
    }

}

extension FraudDetectorClientTypes.Label: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.Label: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Label(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// The label details.
    public struct Label: Swift.Equatable {
        /// The label ARN.
        public let arn: Swift.String?
        /// Timestamp of when the event type was created.
        public let createdTime: Swift.String?
        /// The label description.
        public let description: Swift.String?
        /// Timestamp of when the label was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The label name.
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.LabelSchema: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelMapper
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelMapper = labelMapper {
            var labelMapperContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .labelMapper)
            for (dictKey0, labelmapper0) in labelMapper {
                try labelMapperContainer.encode(labelmapper0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelMapperContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .labelMapper)
        var labelMapperDecoded0: [Swift.String:[Swift.String]]? = nil
        if let labelMapperContainer = labelMapperContainer {
            labelMapperDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstrings0) in labelMapperContainer {
                var listofstrings0Decoded0: [Swift.String]? = nil
                if let listofstrings0 = listofstrings0 {
                    listofstrings0Decoded0 = [Swift.String]()
                    for string1 in listofstrings0 {
                        if let string1 = string1 {
                            listofstrings0Decoded0?.append(string1)
                        }
                    }
                }
                labelMapperDecoded0?[key0] = listofstrings0Decoded0
            }
        }
        labelMapper = labelMapperDecoded0
    }
}

extension FraudDetectorClientTypes.LabelSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LabelSchema(labelMapper: \(Swift.String(describing: labelMapper)))"}
}

extension FraudDetectorClientTypes {
    /// The label schema.
    public struct LabelSchema: Swift.Equatable {
        /// The label mapper maps the Amazon Fraud Detector supported model classification labels (FRAUD, LEGIT) to the appropriate event type labels. For example, if "FRAUD" and "LEGIT" are Amazon Fraud Detector supported labels, this mapper could be: {"FRAUD" => ["0"], "LEGIT" => ["1"]} or {"FRAUD" => ["false"], "LEGIT" => ["true"]} or {"FRAUD" => ["fraud", "abuse"], "LEGIT" => ["legit", "safe"]}. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
        ///
        /// This member is required.
        public let labelMapper: [Swift.String:[Swift.String]]?

        public init (
            labelMapper: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.labelMapper = labelMapper
        }
    }

}

extension FraudDetectorClientTypes {
    public enum Language: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detectorpl
        case sdkUnknown(Swift.String)

        public static var allCases: [Language] {
            return [
                .detectorpl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detectorpl: return "DETECTORPL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Language(rawValue: rawValue) ?? Language.sdkUnknown(rawValue)
        }
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public let maxResults: Swift.Int?
    /// The next token from the previous results.
    public let nextToken: Swift.String?
    /// The ARN that specifies the resource whose tags you want to list.
    /// This member is required.
    public let resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The next token for subsequent requests.
    public let nextToken: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [FraudDetectorClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FraudDetectorClientTypes.LogitMetric: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case variableImportance
        case variableName
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variableImportance = variableImportance {
            try encodeContainer.encode(variableImportance, forKey: .variableImportance)
        }
        if let variableName = variableName {
            try encodeContainer.encode(variableName, forKey: .variableName)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableName)
        variableName = variableNameDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let variableImportanceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .variableImportance)
        variableImportance = variableImportanceDecoded
    }
}

extension FraudDetectorClientTypes.LogitMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogitMetric(variableImportance: \(Swift.String(describing: variableImportance)), variableName: \(Swift.String(describing: variableName)), variableType: \(Swift.String(describing: variableType)))"}
}

extension FraudDetectorClientTypes {
    /// The logit metric details.
    public struct LogitMetric: Swift.Equatable {
        /// The relative importance of the variable.
        /// This member is required.
        public let variableImportance: Swift.Float?
        /// The name of the variable.
        /// This member is required.
        public let variableName: Swift.String?
        /// The type of variable.
        /// This member is required.
        public let variableType: Swift.String?

        public init (
            variableImportance: Swift.Float? = nil,
            variableName: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.variableImportance = variableImportance
            self.variableName = variableName
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.MetricDataPoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fpr
        case precision
        case threshold
        case tpr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fpr = fpr {
            try encodeContainer.encode(fpr, forKey: .fpr)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let tpr = tpr {
            try encodeContainer.encode(tpr, forKey: .tpr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .fpr)
        fpr = fprDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
        let tprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .tpr)
        tpr = tprDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension FraudDetectorClientTypes.MetricDataPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricDataPoint(fpr: \(Swift.String(describing: fpr)), precision: \(Swift.String(describing: precision)), threshold: \(Swift.String(describing: threshold)), tpr: \(Swift.String(describing: tpr)))"}
}

extension FraudDetectorClientTypes {
    /// Model performance metrics data points.
    public struct MetricDataPoint: Swift.Equatable {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public let fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public let precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public let threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public let tpr: Swift.Float?

        public init (
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes.Model: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case eventTypeName
        case lastUpdatedTime
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.Model: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Model(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), eventTypeName: \(Swift.String(describing: eventTypeName)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)))"}
}

extension FraudDetectorClientTypes {
    /// The model.
    public struct Model: Swift.Equatable {
        /// The ARN of the model.
        public let arn: Swift.String?
        /// Timestamp of when the model was created.
        public let createdTime: Swift.String?
        /// The model description.
        public let description: Swift.String?
        /// The name of the event type.
        public let eventTypeName: Swift.String?
        /// Timestamp of last time the model was updated.
        public let lastUpdatedTime: Swift.String?
        /// The model ID.
        public let modelId: Swift.String?
        /// The model type.
        public let modelType: FraudDetectorClientTypes.ModelTypeEnum?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
        }
    }

}

extension FraudDetectorClientTypes.ModelEndpointDataBlob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byteBuffer
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteBuffer = byteBuffer {
            try encodeContainer.encode(byteBuffer.base64EncodedString(), forKey: .byteBuffer)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteBufferDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .byteBuffer)
        byteBuffer = byteBufferDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension FraudDetectorClientTypes.ModelEndpointDataBlob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelEndpointDataBlob(byteBuffer: \(Swift.String(describing: byteBuffer)), contentType: \(Swift.String(describing: contentType)))"}
}

extension FraudDetectorClientTypes {
    /// A pre-formed Amazon SageMaker model input you can include if your detector version includes an imported Amazon SageMaker model endpoint with pass-through input configuration.
    public struct ModelEndpointDataBlob: Swift.Equatable {
        /// The byte buffer of the Amazon SageMaker model endpoint input data blob.
        public let byteBuffer: ClientRuntime.Data?
        /// The content type of the Amazon SageMaker model endpoint input data blob.
        public let contentType: Swift.String?

        public init (
            byteBuffer: ClientRuntime.Data? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.byteBuffer = byteBuffer
            self.contentType = contentType
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case dissociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelEndpointStatus] {
            return [
                .associated,
                .dissociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .dissociated: return "DISSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelEndpointStatus(rawValue: rawValue) ?? ModelEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelInputConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvInputTemplate
        case eventTypeName
        case format
        case jsonInputTemplate
        case useEventVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvInputTemplate = csvInputTemplate {
            try encodeContainer.encode(csvInputTemplate, forKey: .csvInputTemplate)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonInputTemplate = jsonInputTemplate {
            try encodeContainer.encode(jsonInputTemplate, forKey: .jsonInputTemplate)
        }
        if let useEventVariables = useEventVariables {
            try encodeContainer.encode(useEventVariables, forKey: .useEventVariables)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputDataFormat.self, forKey: .format)
        format = formatDecoded
        let useEventVariablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEventVariables)
        useEventVariables = useEventVariablesDecoded
        let jsonInputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonInputTemplate)
        jsonInputTemplate = jsonInputTemplateDecoded
        let csvInputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvInputTemplate)
        csvInputTemplate = csvInputTemplateDecoded
    }
}

extension FraudDetectorClientTypes.ModelInputConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelInputConfiguration(csvInputTemplate: \(Swift.String(describing: csvInputTemplate)), eventTypeName: \(Swift.String(describing: eventTypeName)), format: \(Swift.String(describing: format)), jsonInputTemplate: \(Swift.String(describing: jsonInputTemplate)), useEventVariables: \(Swift.String(describing: useEventVariables)))"}
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model input configuration.
    public struct ModelInputConfiguration: Swift.Equatable {
        ///  Template for constructing the CSV input-data sent to SageMaker. At event-evaluation,
        ///             the placeholders for variable-names in the template will be replaced with the variable
        ///             values before being sent to SageMaker.
        public let csvInputTemplate: Swift.String?
        /// The event type name.
        public let eventTypeName: Swift.String?
        ///  The format of the model input configuration. The format differs depending on if it is
        ///             passed through to SageMaker or constructed by Amazon Fraud Detector.
        public let format: FraudDetectorClientTypes.ModelInputDataFormat?
        ///  Template for constructing the JSON input-data sent to SageMaker. At event-evaluation,
        ///             the placeholders for variable names in the template will be replaced with the variable
        ///             values before being sent to SageMaker.
        public let jsonInputTemplate: Swift.String?
        /// The event variables.
        /// This member is required.
        public let useEventVariables: Swift.Bool?

        public init (
            csvInputTemplate: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            format: FraudDetectorClientTypes.ModelInputDataFormat? = nil,
            jsonInputTemplate: Swift.String? = nil,
            useEventVariables: Swift.Bool? = nil
        )
        {
            self.csvInputTemplate = csvInputTemplate
            self.eventTypeName = eventTypeName
            self.format = format
            self.jsonInputTemplate = jsonInputTemplate
            self.useEventVariables = useEventVariables
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelInputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInputDataFormat] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .json: return "APPLICATION_JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelInputDataFormat(rawValue: rawValue) ?? ModelInputDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelOutputConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvIndexToVariableMap
        case format
        case jsonKeyToVariableMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvIndexToVariableMap = csvIndexToVariableMap {
            var csvIndexToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .csvIndexToVariableMap)
            for (dictKey0, csvindextovariablemap0) in csvIndexToVariableMap {
                try csvIndexToVariableMapContainer.encode(csvindextovariablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonKeyToVariableMap = jsonKeyToVariableMap {
            var jsonKeyToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jsonKeyToVariableMap)
            for (dictKey0, jsonkeytovariablemap0) in jsonKeyToVariableMap {
                try jsonKeyToVariableMapContainer.encode(jsonkeytovariablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputDataFormat.self, forKey: .format)
        format = formatDecoded
        let jsonKeyToVariableMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .jsonKeyToVariableMap)
        var jsonKeyToVariableMapDecoded0: [Swift.String:Swift.String]? = nil
        if let jsonKeyToVariableMapContainer = jsonKeyToVariableMapContainer {
            jsonKeyToVariableMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in jsonKeyToVariableMapContainer {
                if let string0 = string0 {
                    jsonKeyToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        jsonKeyToVariableMap = jsonKeyToVariableMapDecoded0
        let csvIndexToVariableMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .csvIndexToVariableMap)
        var csvIndexToVariableMapDecoded0: [Swift.String:Swift.String]? = nil
        if let csvIndexToVariableMapContainer = csvIndexToVariableMapContainer {
            csvIndexToVariableMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in csvIndexToVariableMapContainer {
                if let string0 = string0 {
                    csvIndexToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        csvIndexToVariableMap = csvIndexToVariableMapDecoded0
    }
}

extension FraudDetectorClientTypes.ModelOutputConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelOutputConfiguration(csvIndexToVariableMap: \(Swift.String(describing: csvIndexToVariableMap)), format: \(Swift.String(describing: format)), jsonKeyToVariableMap: \(Swift.String(describing: jsonKeyToVariableMap)))"}
}

extension FraudDetectorClientTypes {
    /// Provides the Amazon Sagemaker model output configuration.
    public struct ModelOutputConfiguration: Swift.Equatable {
        /// A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables.
        public let csvIndexToVariableMap: [Swift.String:Swift.String]?
        /// The format of the model output configuration.
        /// This member is required.
        public let format: FraudDetectorClientTypes.ModelOutputDataFormat?
        /// A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables.
        public let jsonKeyToVariableMap: [Swift.String:Swift.String]?

        public init (
            csvIndexToVariableMap: [Swift.String:Swift.String]? = nil,
            format: FraudDetectorClientTypes.ModelOutputDataFormat? = nil,
            jsonKeyToVariableMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.csvIndexToVariableMap = csvIndexToVariableMap
            self.format = format
            self.jsonKeyToVariableMap = jsonKeyToVariableMap
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelOutputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case jsonlines
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelOutputDataFormat] {
            return [
                .csv,
                .jsonlines,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .jsonlines: return "APPLICATION_JSONLINES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelOutputDataFormat(rawValue: rawValue) ?? ModelOutputDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelScores: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelVersion
        case scores
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let scores = scores {
            var scoresContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .scores)
            for (dictKey0, modelpredictionmap0) in scores {
                try scoresContainer.encode(modelpredictionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelVersion.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let scoresContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Float?].self, forKey: .scores)
        var scoresDecoded0: [Swift.String:Swift.Float]? = nil
        if let scoresContainer = scoresContainer {
            scoresDecoded0 = [Swift.String:Swift.Float]()
            for (key0, float0) in scoresContainer {
                if let float0 = float0 {
                    scoresDecoded0?[key0] = float0
                }
            }
        }
        scores = scoresDecoded0
    }
}

extension FraudDetectorClientTypes.ModelScores: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelScores(modelVersion: \(Swift.String(describing: modelVersion)), scores: \(Swift.String(describing: scores)))"}
}

extension FraudDetectorClientTypes {
    /// The fraud prediction scores.
    public struct ModelScores: Swift.Equatable {
        /// The model version.
        public let modelVersion: FraudDetectorClientTypes.ModelVersion?
        /// The model's fraud prediction scores.
        public let scores: [Swift.String:Swift.Float]?

        public init (
            modelVersion: FraudDetectorClientTypes.ModelVersion? = nil,
            scores: [Swift.String:Swift.Float]? = nil
        )
        {
            self.modelVersion = modelVersion
            self.scores = scores
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelSource] {
            return [
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelSource(rawValue: rawValue) ?? ModelSource.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum ModelTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onlineFraudInsights
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelTypeEnum] {
            return [
                .onlineFraudInsights,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onlineFraudInsights: return "ONLINE_FRAUD_INSIGHTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelTypeEnum(rawValue: rawValue) ?? ModelTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.ModelVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelVersion(arn: \(Swift.String(describing: arn)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)))"}
}

extension FraudDetectorClientTypes {
    /// The model version.
    public struct ModelVersion: Swift.Equatable {
        /// The model version ARN.
        public let arn: Swift.String?
        /// The model ID.
        /// This member is required.
        public let modelId: Swift.String?
        /// The model type.
        /// This member is required.
        public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        /// This member is required.
        public let modelVersionNumber: Swift.String?

        public init (
            arn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil
        )
        {
            self.arn = arn
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }
    }

}

extension FraudDetectorClientTypes.ModelVersionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case externalEventsDetail
        case lastUpdatedTime
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
        case trainingResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingDataSchema = trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
        if let trainingResult = trainingResult {
            try encodeContainer.encode(trainingResult, forKey: .trainingResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let trainingResultDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingResult.self, forKey: .trainingResult)
        trainingResult = trainingResultDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.ModelVersionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelVersionDetail(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), externalEventsDetail: \(Swift.String(describing: externalEventsDetail)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), status: \(Swift.String(describing: status)), trainingDataSchema: \(Swift.String(describing: trainingDataSchema)), trainingDataSource: \(Swift.String(describing: trainingDataSource)), trainingResult: \(Swift.String(describing: trainingResult)))"}
}

extension FraudDetectorClientTypes {
    /// The details of the model version.
    public struct ModelVersionDetail: Swift.Equatable {
        /// The model version ARN.
        public let arn: Swift.String?
        /// The timestamp when the model was created.
        public let createdTime: Swift.String?
        /// The event details.
        public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
        /// The timestamp when the model was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The model ID.
        public let modelId: Swift.String?
        /// The model type.
        public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        public let modelVersionNumber: Swift.String?
        /// The status of the model version.
        public let status: Swift.String?
        /// The training data schema.
        public let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
        /// The model version training data source.
        public let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
        /// The training results.
        public let trainingResult: FraudDetectorClientTypes.TrainingResult?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
            trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil,
            trainingResult: FraudDetectorClientTypes.TrainingResult? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.externalEventsDetail = externalEventsDetail
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
            self.trainingResult = trainingResult
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case trainingCancelled
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelVersionStatus] {
            return [
                .active,
                .inactive,
                .trainingCancelled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .trainingCancelled: return "TRAINING_CANCELLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelVersionStatus(rawValue: rawValue) ?? ModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.Outcome: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.Outcome: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Outcome(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)))"}
}

extension FraudDetectorClientTypes {
    /// The outcome.
    public struct Outcome: Swift.Equatable {
        /// The outcome ARN.
        public let arn: Swift.String?
        /// The timestamp when the outcome was created.
        public let createdTime: Swift.String?
        /// The outcome description.
        public let description: Swift.String?
        /// The timestamp when the outcome was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The outcome name.
        public let name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

public struct PutDetectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDetectorOutputError>
}

extension PutDetectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDetectorInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), eventTypeName: \(Swift.String(describing: eventTypeName)), tags: \(Swift.String(describing: tags)))"}
}

extension PutDetectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutDetectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDetectorOutputError>
}

public struct PutDetectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDetectorOutputError>
}

public struct PutDetectorInput: Swift.Equatable {
    /// The description of the detector.
    public let description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public let eventTypeName: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.eventTypeName = eventTypeName
        self.tags = tags
    }
}

struct PutDetectorInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let description: Swift.String?
    public let eventTypeName: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDetectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDetectorOutputResponse()"}
}

extension PutDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutDetectorOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutDetectorOutputResponseBody: Swift.Equatable {
}

extension PutDetectorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutEntityTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEntityTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEntityTypeOutputError>
}

extension PutEntityTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEntityTypeInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension PutEntityTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutEntityTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEntityTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEntityTypeOutputError>
}

public struct PutEntityTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEntityTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEntityTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEntityTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEntityTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEntityTypeOutputError>
}

public struct PutEntityTypeInput: Swift.Equatable {
    /// The description.
    public let description: Swift.String?
    /// The name of the entity type.
    /// This member is required.
    public let name: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutEntityTypeInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutEntityTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutEntityTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEntityTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEntityTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEntityTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEntityTypeOutputResponse()"}
}

extension PutEntityTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutEntityTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutEntityTypeOutputResponseBody: Swift.Equatable {
}

extension PutEntityTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutEventTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventTypeOutputError>
}

extension PutEventTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventTypeInput(description: \(Swift.String(describing: description)), entityTypes: \(Swift.String(describing: entityTypes)), eventVariables: \(Swift.String(describing: eventVariables)), labels: \(Swift.String(describing: labels)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension PutEventTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case entityTypes
        case eventVariables
        case labels
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for nonemptylistofstrings0 in entityTypes {
                try entityTypesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for nonemptylistofstrings0 in eventVariables {
                try eventVariablesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for listofstrings0 in labels {
                try labelsContainer.encode(listofstrings0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutEventTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventTypeOutputError>
}

public struct PutEventTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutEventTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutEventTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutEventTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutEventTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutEventTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutEventTypeOutputError>
}

public struct PutEventTypeInput: Swift.Equatable {
    /// The description of the event type.
    public let description: Swift.String?
    /// The entity type for the event type. Example entity types: customer, merchant, account.
    /// This member is required.
    public let entityTypes: [Swift.String]?
    /// The event type variables.
    /// This member is required.
    public let eventVariables: [Swift.String]?
    /// The event type labels.
    public let labels: [Swift.String]?
    /// The name.
    /// This member is required.
    public let name: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        entityTypes: [Swift.String]? = nil,
        eventVariables: [Swift.String]? = nil,
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.entityTypes = entityTypes
        self.eventVariables = eventVariables
        self.labels = labels
        self.name = name
        self.tags = tags
    }
}

struct PutEventTypeInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let eventVariables: [Swift.String]?
    public let labels: [Swift.String]?
    public let entityTypes: [Swift.String]?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutEventTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case entityTypes
        case eventVariables
        case labels
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[Swift.String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [Swift.String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutEventTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventTypeOutputResponse()"}
}

extension PutEventTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutEventTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutEventTypeOutputResponseBody: Swift.Equatable {
}

extension PutEventTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutExternalModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutExternalModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutExternalModelOutputError>
}

extension PutExternalModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutExternalModelInput(inputConfiguration: \(Swift.String(describing: inputConfiguration)), invokeModelEndpointRoleArn: \(Swift.String(describing: invokeModelEndpointRoleArn)), modelEndpoint: \(Swift.String(describing: modelEndpoint)), modelEndpointStatus: \(Swift.String(describing: modelEndpointStatus)), modelSource: \(Swift.String(describing: modelSource)), outputConfiguration: \(Swift.String(describing: outputConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension PutExternalModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let modelEndpoint = modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutExternalModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutExternalModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutExternalModelOutputError>
}

public struct PutExternalModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutExternalModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutExternalModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutExternalModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutExternalModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutExternalModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutExternalModelOutputError>
}

public struct PutExternalModelInput: Swift.Equatable {
    /// The model endpoint input configuration.
    /// This member is required.
    public let inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
    /// The IAM role used to invoke the model endpoint.
    /// This member is required.
    public let invokeModelEndpointRoleArn: Swift.String?
    /// The model endpoints name.
    /// This member is required.
    public let modelEndpoint: Swift.String?
    /// The model endpoint’s status in Amazon Fraud Detector.
    /// This member is required.
    public let modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
    /// The source of the model.
    /// This member is required.
    public let modelSource: FraudDetectorClientTypes.ModelSource?
    /// The model endpoint output configuration.
    /// This member is required.
    public let outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
        invokeModelEndpointRoleArn: Swift.String? = nil,
        modelEndpoint: Swift.String? = nil,
        modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
        modelSource: FraudDetectorClientTypes.ModelSource? = nil,
        outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
        self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
        self.modelEndpoint = modelEndpoint
        self.modelEndpointStatus = modelEndpointStatus
        self.modelSource = modelSource
        self.outputConfiguration = outputConfiguration
        self.tags = tags
    }
}

struct PutExternalModelInputBody: Swift.Equatable {
    public let modelEndpoint: Swift.String?
    public let modelSource: FraudDetectorClientTypes.ModelSource?
    public let invokeModelEndpointRoleArn: Swift.String?
    public let inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
    public let outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?
    public let modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutExternalModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutExternalModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutExternalModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutExternalModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutExternalModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutExternalModelOutputResponse()"}
}

extension PutExternalModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutExternalModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutExternalModelOutputResponseBody: Swift.Equatable {
}

extension PutExternalModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutKMSEncryptionKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutKMSEncryptionKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutKMSEncryptionKeyOutputError>
}

extension PutKMSEncryptionKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKMSEncryptionKeyInput(kmsEncryptionKeyArn: \(Swift.String(describing: kmsEncryptionKeyArn)))"}
}

extension PutKMSEncryptionKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }
}

public struct PutKMSEncryptionKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutKMSEncryptionKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutKMSEncryptionKeyOutputError>
}

public struct PutKMSEncryptionKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutKMSEncryptionKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutKMSEncryptionKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutKMSEncryptionKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutKMSEncryptionKeyOutputError>
}

public struct PutKMSEncryptionKeyInput: Swift.Equatable {
    /// The KMS encryption key ARN.
    /// This member is required.
    public let kmsEncryptionKeyArn: Swift.String?

    public init (
        kmsEncryptionKeyArn: Swift.String? = nil
    )
    {
        self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
    }
}

struct PutKMSEncryptionKeyInputBody: Swift.Equatable {
    public let kmsEncryptionKeyArn: Swift.String?
}

extension PutKMSEncryptionKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension PutKMSEncryptionKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutKMSEncryptionKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutKMSEncryptionKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutKMSEncryptionKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKMSEncryptionKeyOutputResponse()"}
}

extension PutKMSEncryptionKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutKMSEncryptionKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutKMSEncryptionKeyOutputResponseBody: Swift.Equatable {
}

extension PutKMSEncryptionKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutLabelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLabelOutputError>
}

extension PutLabelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLabelInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension PutLabelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutLabelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLabelOutputError>
}

public struct PutLabelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLabelOutputError>
}

public struct PutLabelInput: Swift.Equatable {
    /// The label description.
    public let description: Swift.String?
    /// The label name.
    /// This member is required.
    public let name: Swift.String?
    ///
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutLabelInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLabelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLabelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLabelOutputResponse()"}
}

extension PutLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLabelOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutLabelOutputResponseBody: Swift.Equatable {
}

extension PutLabelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutOutcomeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutOutcomeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutOutcomeOutputError>
}

extension PutOutcomeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutOutcomeInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension PutOutcomeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutOutcomeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutOutcomeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutOutcomeOutputError>
}

public struct PutOutcomeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutOutcomeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutOutcomeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutOutcomeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutOutcomeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutOutcomeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutOutcomeOutputError>
}

public struct PutOutcomeInput: Swift.Equatable {
    /// The outcome description.
    public let description: Swift.String?
    /// The name of the outcome.
    /// This member is required.
    public let name: Swift.String?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutOutcomeInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutOutcomeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutOutcomeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOutcomeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutOutcomeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOutcomeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutOutcomeOutputResponse()"}
}

extension PutOutcomeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutOutcomeOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutOutcomeOutputResponseBody: Swift.Equatable {
}

extension PutOutcomeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating the specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.Rule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
    }
}

extension FraudDetectorClientTypes.Rule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Rule(detectorId: \(Swift.String(describing: detectorId)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)))"}
}

extension FraudDetectorClientTypes {
    /// A rule.
    public struct Rule: Swift.Equatable {
        /// The detector for which the rule is associated.
        /// This member is required.
        public let detectorId: Swift.String?
        /// The rule ID.
        /// This member is required.
        public let ruleId: Swift.String?
        /// The rule version.
        /// This member is required.
        public let ruleVersion: Swift.String?

        public init (
            detectorId: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.detectorId = detectorId
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes.RuleDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case expression
        case language
        case lastUpdatedTime
        case outcomes
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.RuleDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleDetail(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), expression: \(Swift.String(describing: expression)), language: \(Swift.String(describing: language)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)))"}
}

extension FraudDetectorClientTypes {
    /// The details of the rule.
    public struct RuleDetail: Swift.Equatable {
        /// The rule ARN.
        public let arn: Swift.String?
        /// The timestamp of when the rule was created.
        public let createdTime: Swift.String?
        /// The rule description.
        public let description: Swift.String?
        /// The detector for which the rule is associated.
        public let detectorId: Swift.String?
        /// The rule expression.
        public let expression: Swift.String?
        /// The rule language.
        public let language: FraudDetectorClientTypes.Language?
        /// Timestamp of the last time the rule was updated.
        public let lastUpdatedTime: Swift.String?
        /// The rule outcomes.
        public let outcomes: [Swift.String]?
        /// The rule ID.
        public let ruleId: Swift.String?
        /// The rule version.
        public let ruleVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            expression: Swift.String? = nil,
            language: FraudDetectorClientTypes.Language? = nil,
            lastUpdatedTime: Swift.String? = nil,
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.lastUpdatedTime = lastUpdatedTime
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes {
    public enum RuleExecutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allMatched
        case firstMatched
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleExecutionMode] {
            return [
                .allMatched,
                .firstMatched,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allMatched: return "ALL_MATCHED"
            case .firstMatched: return "FIRST_MATCHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleExecutionMode(rawValue: rawValue) ?? RuleExecutionMode.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.RuleResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outcomes
        case ruleId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for listofstrings0 in outcomes {
                try outcomesContainer.encode(listofstrings0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
    }
}

extension FraudDetectorClientTypes.RuleResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleResult(outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)))"}
}

extension FraudDetectorClientTypes {
    /// The rule results.
    public struct RuleResult: Swift.Equatable {
        /// The outcomes of the matched rule, based on the rule execution mode.
        public let outcomes: [Swift.String]?
        /// The rule ID that was matched, based on the rule execution mode.
        public let ruleId: Swift.String?

        public init (
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.outcomes = outcomes
            self.ruleId = ruleId
        }
    }

}

extension FraudDetectorClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FraudDetectorClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension FraudDetectorClientTypes {
    /// A key and value pair.
    public struct Tag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public let key: Swift.String?
        /// A value assigned to a tag key.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The tags to assign to the resource.
    /// This member is required.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating a throttling error.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.TrainingDataSchema: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelSchema
        case modelVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelSchema = labelSchema {
            try encodeContainer.encode(labelSchema, forKey: .labelSchema)
        }
        if let modelVariables = modelVariables {
            var modelVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVariables)
            for listofstrings0 in modelVariables {
                try modelVariablesContainer.encode(listofstrings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .modelVariables)
        var modelVariablesDecoded0:[Swift.String]? = nil
        if let modelVariablesContainer = modelVariablesContainer {
            modelVariablesDecoded0 = [Swift.String]()
            for string0 in modelVariablesContainer {
                if let string0 = string0 {
                    modelVariablesDecoded0?.append(string0)
                }
            }
        }
        modelVariables = modelVariablesDecoded0
        let labelSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.LabelSchema.self, forKey: .labelSchema)
        labelSchema = labelSchemaDecoded
    }
}

extension FraudDetectorClientTypes.TrainingDataSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrainingDataSchema(labelSchema: \(Swift.String(describing: labelSchema)), modelVariables: \(Swift.String(describing: modelVariables)))"}
}

extension FraudDetectorClientTypes {
    /// The training data schema.
    public struct TrainingDataSchema: Swift.Equatable {
        /// The label schema.
        /// This member is required.
        public let labelSchema: FraudDetectorClientTypes.LabelSchema?
        /// The training data schema variables.
        /// This member is required.
        public let modelVariables: [Swift.String]?

        public init (
            labelSchema: FraudDetectorClientTypes.LabelSchema? = nil,
            modelVariables: [Swift.String]? = nil
        )
        {
            self.labelSchema = labelSchema
            self.modelVariables = modelVariables
        }
    }

}

extension FraudDetectorClientTypes {
    public enum TrainingDataSourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case externalEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingDataSourceEnum] {
            return [
                .externalEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .externalEvents: return "EXTERNAL_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingDataSourceEnum(rawValue: rawValue) ?? TrainingDataSourceEnum.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.TrainingMetrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auc
        case metricDataPoints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auc = auc {
            try encodeContainer.encode(auc, forKey: .auc)
        }
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for metricdatapointslist0 in metricDataPoints {
                try metricDataPointsContainer.encode(metricdatapointslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aucDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .auc)
        auc = aucDecoded
        let metricDataPointsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.MetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[FraudDetectorClientTypes.MetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [FraudDetectorClientTypes.MetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
    }
}

extension FraudDetectorClientTypes.TrainingMetrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrainingMetrics(auc: \(Swift.String(describing: auc)), metricDataPoints: \(Swift.String(describing: metricDataPoints)))"}
}

extension FraudDetectorClientTypes {
    /// The training metric details.
    public struct TrainingMetrics: Swift.Equatable {
        /// The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.
        public let auc: Swift.Float?
        /// The data points details.
        public let metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]?

        public init (
            auc: Swift.Float? = nil,
            metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]? = nil
        )
        {
            self.auc = auc
            self.metricDataPoints = metricDataPoints
        }
    }

}

extension FraudDetectorClientTypes.TrainingResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataValidationMetrics
        case trainingMetrics
        case variableImportanceMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataValidationMetrics = dataValidationMetrics {
            try encodeContainer.encode(dataValidationMetrics, forKey: .dataValidationMetrics)
        }
        if let trainingMetrics = trainingMetrics {
            try encodeContainer.encode(trainingMetrics, forKey: .trainingMetrics)
        }
        if let variableImportanceMetrics = variableImportanceMetrics {
            try encodeContainer.encode(variableImportanceMetrics, forKey: .variableImportanceMetrics)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataValidationMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataValidationMetrics.self, forKey: .dataValidationMetrics)
        dataValidationMetrics = dataValidationMetricsDecoded
        let trainingMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingMetrics.self, forKey: .trainingMetrics)
        trainingMetrics = trainingMetricsDecoded
        let variableImportanceMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.VariableImportanceMetrics.self, forKey: .variableImportanceMetrics)
        variableImportanceMetrics = variableImportanceMetricsDecoded
    }
}

extension FraudDetectorClientTypes.TrainingResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrainingResult(dataValidationMetrics: \(Swift.String(describing: dataValidationMetrics)), trainingMetrics: \(Swift.String(describing: trainingMetrics)), variableImportanceMetrics: \(Swift.String(describing: variableImportanceMetrics)))"}
}

extension FraudDetectorClientTypes {
    /// The training result details.
    public struct TrainingResult: Swift.Equatable {
        /// The validation metrics.
        public let dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics?
        /// The training metric details.
        public let trainingMetrics: FraudDetectorClientTypes.TrainingMetrics?
        /// The variable importance metrics.
        public let variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics?

        public init (
            dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics? = nil,
            trainingMetrics: FraudDetectorClientTypes.TrainingMetrics? = nil,
            variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics? = nil
        )
        {
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetrics = trainingMetrics
            self.variableImportanceMetrics = variableImportanceMetrics
        }
    }

}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource from which to remove the tag.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The resource ARN.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDetectorVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionOutputError>
}

extension UpdateDetectorVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), externalModelEndpoints: \(Swift.String(describing: externalModelEndpoints)), modelVersions: \(Swift.String(describing: modelVersions)), ruleExecutionMode: \(Swift.String(describing: ruleExecutionMode)), rules: \(Swift.String(describing: rules)))"}
}

extension UpdateDetectorVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for listofstrings0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(listofstrings0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for listofmodelversions0 in modelVersions {
                try modelVersionsContainer.encode(listofmodelversions0)
            }
        }
        if let ruleExecutionMode = ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rulelist0 in rules {
                try rulesContainer.encode(rulelist0)
            }
        }
    }
}

public struct UpdateDetectorVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionOutputError>
}

public struct UpdateDetectorVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionOutputError>
}

public struct UpdateDetectorVersionInput: Swift.Equatable {
    /// The detector version description.
    public let description: Swift.String?
    /// The parent detector ID for the detector version you want to update.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public let detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints to include in the detector version.
    /// This member is required.
    public let externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode to add to the detector.
    /// 	        If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule.
    /// 	        If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
    ///          The default behavior is FIRST_MATCHED.
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public let rules: [FraudDetectorClientTypes.Rule]?

    public init (
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

struct UpdateDetectorVersionInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let externalModelEndpoints: [Swift.String]?
    public let rules: [FraudDetectorClientTypes.Rule]?
    public let description: Swift.String?
    public let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    public let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
}

extension UpdateDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
    }
}

public struct UpdateDetectorVersionMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionMetadataOutputError>
}

extension UpdateDetectorVersionMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionMetadataInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)))"}
}

extension UpdateDetectorVersionMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

public struct UpdateDetectorVersionMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionMetadataOutputError>
}

public struct UpdateDetectorVersionMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionMetadataOutputError>
}

public struct UpdateDetectorVersionMetadataInput: Swift.Equatable {
    /// The description.
    /// This member is required.
    public let description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public let detectorVersionId: Swift.String?

    public init (
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct UpdateDetectorVersionMetadataInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let description: Swift.String?
}

extension UpdateDetectorVersionMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDetectorVersionMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionMetadataOutputResponse()"}
}

extension UpdateDetectorVersionMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDetectorVersionMetadataOutputResponseBody: Swift.Equatable {
}

extension UpdateDetectorVersionMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateDetectorVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionOutputResponse()"}
}

extension UpdateDetectorVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDetectorVersionOutputResponseBody: Swift.Equatable {
}

extension UpdateDetectorVersionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDetectorVersionStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionStatusOutputError>
}

extension UpdateDetectorVersionStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionStatusInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), status: \(Swift.String(describing: status)))"}
}

extension UpdateDetectorVersionStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateDetectorVersionStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionStatusOutputError>
}

public struct UpdateDetectorVersionStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDetectorVersionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDetectorVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDetectorVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDetectorVersionStatusOutputError>
}

public struct UpdateDetectorVersionStatusInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public let detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public let detectorVersionId: Swift.String?
    /// The new status.
    /// This member is required.
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init (
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct UpdateDetectorVersionStatusInputBody: Swift.Equatable {
    public let detectorId: Swift.String?
    public let detectorVersionId: Swift.String?
    public let status: FraudDetectorClientTypes.DetectorVersionStatus?
}

extension UpdateDetectorVersionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDetectorVersionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorVersionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorVersionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorVersionStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorVersionStatusOutputResponse()"}
}

extension UpdateDetectorVersionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorVersionStatusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDetectorVersionStatusOutputResponseBody: Swift.Equatable {
}

extension UpdateDetectorVersionStatusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelOutputError>
}

extension UpdateModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelInput(description: \(Swift.String(describing: description)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)))"}
}

extension UpdateModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

public struct UpdateModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelOutputError>
}

public struct UpdateModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelOutputError>
}

public struct UpdateModelInput: Swift.Equatable {
    /// The new model description.
    public let description: Swift.String?
    /// The model ID.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init (
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.description = description
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let description: Swift.String?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelId
        case modelType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelOutputResponse()"}
}

extension UpdateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateModelOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateModelOutputResponseBody: Swift.Equatable {
}

extension UpdateModelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateModelVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionOutputError>
}

extension UpdateModelVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelVersionInput(externalEventsDetail: \(Swift.String(describing: externalEventsDetail)), majorVersionNumber: \(Swift.String(describing: majorVersionNumber)), modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateModelVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let majorVersionNumber = majorVersionNumber {
            try encodeContainer.encode(majorVersionNumber, forKey: .majorVersionNumber)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateModelVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionOutputError>
}

public struct UpdateModelVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionOutputError>
}

public struct UpdateModelVersionInput: Swift.Equatable {
    /// The event details.
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The major version number.
    /// This member is required.
    public let majorVersionNumber: Swift.String?
    /// The model ID.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        majorVersionNumber: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.majorVersionNumber = majorVersionNumber
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct UpdateModelVersionInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let majorVersionNumber: Swift.String?
    public let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension UpdateModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let majorVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersionNumber)
        majorVersionNumber = majorVersionNumberDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateModelVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelVersionOutputResponse(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), status: \(Swift.String(describing: status)))"}
}

extension UpdateModelVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateModelVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct UpdateModelVersionOutputResponse: Swift.Equatable {
    /// The model ID.
    public let modelId: Swift.String?
    /// The model type.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version updated.
    public let modelVersionNumber: Swift.String?
    /// The status of the updated model version.
    public let status: Swift.String?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionOutputResponseBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
    public let status: Swift.String?
}

extension UpdateModelVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateModelVersionStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionStatusOutputError>
}

extension UpdateModelVersionStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelVersionStatusInput(modelId: \(Swift.String(describing: modelId)), modelType: \(Swift.String(describing: modelType)), modelVersionNumber: \(Swift.String(describing: modelVersionNumber)), status: \(Swift.String(describing: status)))"}
}

extension UpdateModelVersionStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateModelVersionStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionStatusOutputError>
}

public struct UpdateModelVersionStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateModelVersionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateModelVersionStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateModelVersionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateModelVersionStatusOutputError>
}

public struct UpdateModelVersionStatusInput: Swift.Equatable {
    /// The model ID of the model version to update.
    /// This member is required.
    public let modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public let modelVersionNumber: Swift.String?
    /// The model version status.
    /// This member is required.
    public let status: FraudDetectorClientTypes.ModelVersionStatus?

    public init (
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: FraudDetectorClientTypes.ModelVersionStatus? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionStatusInputBody: Swift.Equatable {
    public let modelId: Swift.String?
    public let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    public let modelVersionNumber: Swift.String?
    public let status: FraudDetectorClientTypes.ModelVersionStatus?
}

extension UpdateModelVersionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateModelVersionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelVersionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelVersionStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelVersionStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateModelVersionStatusOutputResponse()"}
}

extension UpdateModelVersionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateModelVersionStatusOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateModelVersionStatusOutputResponseBody: Swift.Equatable {
}

extension UpdateModelVersionStatusOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRuleMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleMetadataOutputError>
}

extension UpdateRuleMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleMetadataInput(description: \(Swift.String(describing: description)), rule: \(Swift.String(describing: rule)))"}
}

extension UpdateRuleMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case rule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct UpdateRuleMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleMetadataOutputError>
}

public struct UpdateRuleMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleMetadataOutputError>
}

public struct UpdateRuleMetadataInput: Swift.Equatable {
    /// The rule description.
    /// This member is required.
    public let description: Swift.String?
    /// The rule to update.
    /// This member is required.
    public let rule: FraudDetectorClientTypes.Rule?

    public init (
        description: Swift.String? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.description = description
        self.rule = rule
    }
}

struct UpdateRuleMetadataInputBody: Swift.Equatable {
    public let rule: FraudDetectorClientTypes.Rule?
    public let description: Swift.String?
}

extension UpdateRuleMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case rule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRuleMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleMetadataOutputResponse()"}
}

extension UpdateRuleMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRuleMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateRuleMetadataOutputResponseBody: Swift.Equatable {
}

extension UpdateRuleMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRuleVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleVersionOutputError>
}

extension UpdateRuleVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleVersionInput(description: \(Swift.String(describing: description)), expression: \(Swift.String(describing: expression)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), rule: \(Swift.String(describing: rule)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateRuleVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for nonemptylistofstrings0 in outcomes {
                try outcomesContainer.encode(nonemptylistofstrings0)
            }
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UpdateRuleVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleVersionOutputError>
}

public struct UpdateRuleVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRuleVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRuleVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRuleVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRuleVersionOutputError>
}

public struct UpdateRuleVersionInput: Swift.Equatable {
    /// The description.
    public let description: Swift.String?
    /// The rule expression.
    /// This member is required.
    public let expression: Swift.String?
    /// The language.
    /// This member is required.
    public let language: FraudDetectorClientTypes.Language?
    /// The outcomes.
    /// This member is required.
    public let outcomes: [Swift.String]?
    /// The rule to update.
    /// This member is required.
    public let rule: FraudDetectorClientTypes.Rule?
    /// The tags to assign to the rule version.
    public let tags: [FraudDetectorClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.rule = rule
        self.tags = tags
    }
}

struct UpdateRuleVersionInputBody: Swift.Equatable {
    public let rule: FraudDetectorClientTypes.Rule?
    public let description: Swift.String?
    public let expression: Swift.String?
    public let language: FraudDetectorClientTypes.Language?
    public let outcomes: [Swift.String]?
    public let tags: [FraudDetectorClientTypes.Tag]?
}

extension UpdateRuleVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRuleVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleVersionOutputResponse(rule: \(Swift.String(describing: rule)))"}
}

extension UpdateRuleVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRuleVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct UpdateRuleVersionOutputResponse: Swift.Equatable {
    /// The new rule version that was created.
    public let rule: FraudDetectorClientTypes.Rule?

    public init (
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct UpdateRuleVersionOutputResponseBody: Swift.Equatable {
    public let rule: FraudDetectorClientTypes.Rule?
}

extension UpdateRuleVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct UpdateVariableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVariableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVariableOutputError>
}

extension UpdateVariableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVariableInput(defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), variableType: \(Swift.String(describing: variableType)))"}
}

extension UpdateVariableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

public struct UpdateVariableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVariableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVariableOutputError>
}

public struct UpdateVariableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateVariableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateVariableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVariableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateVariableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateVariableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateVariableOutputError>
}

public struct UpdateVariableInput: Swift.Equatable {
    /// The new default value of the variable.
    public let defaultValue: Swift.String?
    /// The new description.
    public let description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public let name: Swift.String?
    /// The variable type. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types.
    public let variableType: Swift.String?

    public init (
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.variableType = variableType
    }
}

struct UpdateVariableInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let defaultValue: Swift.String?
    public let description: Swift.String?
    public let variableType: Swift.String?
}

extension UpdateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension UpdateVariableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVariableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVariableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVariableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateVariableOutputResponse()"}
}

extension UpdateVariableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateVariableOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateVariableOutputResponseBody: Swift.Equatable {
}

extension UpdateVariableOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception indicating a specified value is not allowed.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.Variable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case dataSource
        case dataType
        case defaultValue
        case description
        case lastUpdatedTime
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.Variable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Variable(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), dataSource: \(Swift.String(describing: dataSource)), dataType: \(Swift.String(describing: dataType)), defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), variableType: \(Swift.String(describing: variableType)))"}
}

extension FraudDetectorClientTypes {
    /// The variable.
    public struct Variable: Swift.Equatable {
        /// The ARN of the variable.
        public let arn: Swift.String?
        /// The time when the variable was created.
        public let createdTime: Swift.String?
        /// The data source of the variable.
        public let dataSource: FraudDetectorClientTypes.DataSource?
        /// The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types.
        public let dataType: FraudDetectorClientTypes.DataType?
        /// The default value of the variable.
        public let defaultValue: Swift.String?
        /// The description of the variable.
        public let description: Swift.String?
        /// The time when variable was last updated.
        public let lastUpdatedTime: Swift.String?
        /// The name of the variable.
        public let name: Swift.String?
        /// The variable type of the variable.
        ///          Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        ///
        public let variableType: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dataSource: FraudDetectorClientTypes.DataSource? = nil,
            dataType: FraudDetectorClientTypes.DataType? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.VariableEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension FraudDetectorClientTypes.VariableEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VariableEntry(dataSource: \(Swift.String(describing: dataSource)), dataType: \(Swift.String(describing: dataType)), defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), variableType: \(Swift.String(describing: variableType)))"}
}

extension FraudDetectorClientTypes {
    /// A variable in the list of variables for the batch create variable request.
    public struct VariableEntry: Swift.Equatable {
        /// The data source of the variable.
        public let dataSource: Swift.String?
        /// The data type of the variable.
        public let dataType: Swift.String?
        /// The default value of the variable.
        public let defaultValue: Swift.String?
        /// The description of the variable.
        public let description: Swift.String?
        /// The name of the variable.
        public let name: Swift.String?
        /// The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types.
        ///          Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        ///
        public let variableType: Swift.String?

        public init (
            dataSource: Swift.String? = nil,
            dataType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.VariableImportanceMetrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logitMetrics = "LogitMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logitMetrics = logitMetrics {
            var logitMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logitMetrics)
            for listoflogitmetrics0 in logitMetrics {
                try logitMetricsContainer.encode(listoflogitmetrics0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logitMetricsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.LogitMetric?].self, forKey: .logitMetrics)
        var logitMetricsDecoded0:[FraudDetectorClientTypes.LogitMetric]? = nil
        if let logitMetricsContainer = logitMetricsContainer {
            logitMetricsDecoded0 = [FraudDetectorClientTypes.LogitMetric]()
            for structure0 in logitMetricsContainer {
                if let structure0 = structure0 {
                    logitMetricsDecoded0?.append(structure0)
                }
            }
        }
        logitMetrics = logitMetricsDecoded0
    }
}

extension FraudDetectorClientTypes.VariableImportanceMetrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VariableImportanceMetrics(logitMetrics: \(Swift.String(describing: logitMetrics)))"}
}

extension FraudDetectorClientTypes {
    /// The variable importance metrics details.
    public struct VariableImportanceMetrics: Swift.Equatable {
        /// List of variable metrics.
        public let logitMetrics: [FraudDetectorClientTypes.LogitMetric]?

        public init (
            logitMetrics: [FraudDetectorClientTypes.LogitMetric]? = nil
        )
        {
            self.logitMetrics = logitMetrics
        }
    }

}
