// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension PersonalizeClient {
    /// <p>Creates a batch inference job. The operation can handle up to 50 million records and the
    ///       input file must be in JSON format. For more information, see <a>recommendations-batch</a>.</p>
    func createBatchInferenceJob(input: CreateBatchInferenceJobInput) async throws -> CreateBatchInferenceJobOutputResponse
    {
        typealias createBatchInferenceJobContinuation = CheckedContinuation<CreateBatchInferenceJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBatchInferenceJobContinuation) in
            createBatchInferenceJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a campaign by deploying a solution version. When a client calls the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a>
    ///       and
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetPersonalizedRanking.html">GetPersonalizedRanking</a>
    ///       APIs, a campaign is specified in the request.</p>
    ///
    ///          <p>
    ///             <b>Minimum Provisioned TPS and Auto-Scaling</b>
    ///          </p>
    ///
    ///          <p>A transaction is a single <code>GetRecommendations</code> or
    ///        <code>GetPersonalizedRanking</code> call. Transactions per second (TPS) is the throughput
    ///        and unit of billing for Amazon Personalize. The minimum provisioned TPS
    ///        (<code>minProvisionedTPS</code>) specifies the baseline throughput provisioned by
    ///        Amazon Personalize, and thus, the minimum billing charge.
    ///     </p>
    ///          <p>
    ///        If your TPS increases beyond
    ///        <code>minProvisionedTPS</code>, Amazon Personalize auto-scales the provisioned capacity up and down,
    ///        but never below <code>minProvisionedTPS</code>.
    ///        There's a short time delay while the capacity is increased that might cause loss of
    ///        transactions.</p>
    ///          <p>The actual TPS used is calculated as the average requests/second within a 5-minute window.
    ///       You pay for maximum of either the minimum provisioned TPS or the actual TPS.
    ///       We recommend starting with a low <code>minProvisionedTPS</code>, track
    ///        your usage using Amazon CloudWatch metrics, and then increase the <code>minProvisionedTPS</code>
    ///        as necessary.</p>
    ///
    ///          <p>
    ///             <b>Status</b>
    ///          </p>
    ///          <p>A campaign can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the campaign status, call <a>DescribeCampaign</a>.</p>
    ///          <note>
    ///             <p>Wait until the <code>status</code> of the campaign
    ///         is <code>ACTIVE</code> before asking the campaign for recommendations.</p>
    ///          </note>
    ///
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListCampaigns</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeCampaign</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>UpdateCampaign</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteCampaign</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createCampaign(input: CreateCampaignInput) async throws -> CreateCampaignOutputResponse
    {
        typealias createCampaignContinuation = CheckedContinuation<CreateCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCampaignContinuation) in
            createCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an empty dataset and adds it to the specified dataset group. Use <a>CreateDatasetImportJob</a> to import your training data to a dataset.</p>
    ///          <p>There are three types of datasets:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Interactions</p>
    ///             </li>
    ///             <li>
    ///                <p>Items</p>
    ///             </li>
    ///             <li>
    ///                <p>Users</p>
    ///             </li>
    ///          </ul>
    ///          <p>Each dataset type has an associated schema with required field types. Only the
    ///         <code>Interactions</code> dataset is required in order to train a model (also referred to as
    ///       creating a solution).</p>
    ///          <p>A dataset can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the dataset, call <a>DescribeDataset</a>.</p>
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>CreateDatasetGroup</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>ListDatasets</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeDataset</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteDataset</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createDataset(input: CreateDatasetInput) async throws -> CreateDatasetOutputResponse
    {
        typealias createDatasetContinuation = CheckedContinuation<CreateDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetContinuation) in
            createDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>
    ///       Creates a job that exports data from your dataset to an Amazon S3 bucket.
    ///       To allow Amazon Personalize to export the training data, you must specify an
    ///       service-linked AWS Identity and Access Management (IAM) role that gives Amazon Personalize <code>PutObject</code> permissions for your Amazon S3 bucket.
    ///       For information, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/export-data.html">Exporting a dataset</a>
    ///       in the Amazon Personalize developer guide.
    ///     </p>
    ///          <p>
    ///             <b>Status</b>
    ///          </p>
    ///          <p>A dataset export job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///       To get the status of the export job, call <a>DescribeDatasetExportJob</a>,
    ///       and specify the Amazon Resource Name (ARN) of the dataset export job. The dataset export is
    ///       complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
    ///       includes a <code>failureReason</code> key, which describes why the job failed.
    ///     </p>
    func createDatasetExportJob(input: CreateDatasetExportJobInput) async throws -> CreateDatasetExportJobOutputResponse
    {
        typealias createDatasetExportJobContinuation = CheckedContinuation<CreateDatasetExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetExportJobContinuation) in
            createDatasetExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an empty dataset group. A dataset group contains related datasets that supply data
    ///       for training a model. A dataset group can contain at most three datasets, one for each type of
    ///       dataset:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Interactions</p>
    ///             </li>
    ///             <li>
    ///                <p>Items</p>
    ///             </li>
    ///             <li>
    ///                <p>Users</p>
    ///             </li>
    ///          </ul>
    ///          <p>To train a model (create a solution), a dataset group that contains an
    ///         <code>Interactions</code> dataset is required. Call <a>CreateDataset</a> to add a
    ///       dataset to the group.</p>
    ///          <p>A dataset group can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the dataset group, call <a>DescribeDatasetGroup</a>. If
    ///       the status shows as CREATE FAILED, the response includes a <code>failureReason</code> key,
    ///       which describes why the creation failed.</p>
    ///          <note>
    ///             <p>You must wait until the <code>status</code> of the dataset group is <code>ACTIVE</code>
    ///         before adding a dataset to the group.</p>
    ///          </note>
    ///          <p>You can specify an AWS Key Management Service (KMS) key to encrypt the datasets in the group. If you
    ///       specify a KMS key, you must also include an AWS Identity and Access Management (IAM) role that has permission to
    ///       access the key.</p>
    ///          <p class="title">
    ///             <b>APIs that require a dataset group ARN in the request</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>CreateDataset</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>CreateEventTracker</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>CreateSolution</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListDatasetGroups</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeDatasetGroup</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteDatasetGroup</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createDatasetGroup(input: CreateDatasetGroupInput) async throws -> CreateDatasetGroupOutputResponse
    {
        typealias createDatasetGroupContinuation = CheckedContinuation<CreateDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetGroupContinuation) in
            createDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a job that imports training data from your data source (an Amazon S3 bucket) to an
    ///       Amazon Personalize dataset. To allow Amazon Personalize to import the training data, you must specify an
    ///       AWS Identity and Access Management (IAM) service role that has permission to read from the data source, as Amazon Personalize makes a
    ///       copy of your data and processes it in an internal AWS system. For information on granting access
    ///       to your Amazon S3 bucket, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/granting-personalize-s3-access.html">Giving Amazon Personalize
    ///       Access to Amazon S3 Resources</a>. </p>
    ///          <important>
    ///             <p>The dataset import job replaces any existing data in the dataset that you imported in bulk.</p>
    ///          </important>
    ///          <p>
    ///             <b>Status</b>
    ///          </p>
    ///          <p>A dataset import job can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the import job, call <a>DescribeDatasetImportJob</a>,
    ///       providing the Amazon Resource Name (ARN) of the dataset import job. The dataset import is
    ///       complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
    ///       includes a <code>failureReason</code> key, which describes why the job failed.</p>
    ///          <note>
    ///             <p>Importing takes time. You must wait until the status shows as ACTIVE before training a
    ///         model using the dataset.</p>
    ///          </note>
    ///
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListDatasetImportJobs</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeDatasetImportJob</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createDatasetImportJob(input: CreateDatasetImportJobInput) async throws -> CreateDatasetImportJobOutputResponse
    {
        typealias createDatasetImportJobContinuation = CheckedContinuation<CreateDatasetImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetImportJobContinuation) in
            createDatasetImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an event tracker that you use when adding event data to a specified dataset
    ///       group using the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> API.</p>
    ///          <note>
    ///             <p>Only one event tracker can be associated with a dataset group. You will get
    ///         an error if you call <code>CreateEventTracker</code> using the same dataset group as an
    ///         existing event tracker.</p>
    ///          </note>
    ///          <p>When you create an event tracker, the response includes a tracking ID, which you pass as a parameter when you use the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents</a> operation.
    ///       Amazon Personalize then appends the event data to the Interactions dataset of the dataset group you specify
    ///       in your event tracker.
    ///     </p>
    ///          <p>The event tracker can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the event tracker, call <a>DescribeEventTracker</a>.</p>
    ///          <note>
    ///             <p>The event tracker must be in the ACTIVE state before using the tracking ID.</p>
    ///          </note>
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListEventTrackers</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeEventTracker</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteEventTracker</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createEventTracker(input: CreateEventTrackerInput) async throws -> CreateEventTrackerOutputResponse
    {
        typealias createEventTrackerContinuation = CheckedContinuation<CreateEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEventTrackerContinuation) in
            createEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a recommendation filter. For more information, see <a>filter</a>.</p>
    func createFilter(input: CreateFilterInput) async throws -> CreateFilterOutputResponse
    {
        typealias createFilterContinuation = CheckedContinuation<CreateFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFilterContinuation) in
            createFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an Amazon Personalize schema from the specified schema string. The schema you create
    ///       must be in Avro JSON format.</p>
    ///          <p>Amazon Personalize recognizes three schema variants. Each schema is associated with a dataset
    ///       type and has a set of required field and keywords.
    ///       You specify a schema when you call <a>CreateDataset</a>.</p>
    ///
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListSchemas</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeSchema</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteSchema</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createSchema(input: CreateSchemaInput) async throws -> CreateSchemaOutputResponse
    {
        typealias createSchemaContinuation = CheckedContinuation<CreateSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSchemaContinuation) in
            createSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates the configuration for training a model. A trained model is known as
    ///       a solution. After the configuration is created, you train the model (create a solution)
    ///       by calling the <a>CreateSolutionVersion</a> operation. Every time you call
    ///       <code>CreateSolutionVersion</code>, a new version of the solution is created.</p>
    ///          <p>After creating a solution version, you check its accuracy by calling
    ///       <a>GetSolutionMetrics</a>. When you are satisfied with the version, you
    ///       deploy it using <a>CreateCampaign</a>. The campaign provides recommendations
    ///       to a client through the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a> API.</p>
    ///          <p>To train a model, Amazon Personalize requires training data and a recipe. The training data
    ///       comes from the dataset group that you provide in the request. A recipe specifies
    ///       the training algorithm and a feature transformation. You can specify one of the predefined
    ///       recipes provided by Amazon Personalize. Alternatively, you can specify
    ///       <code>performAutoML</code> and Amazon Personalize will analyze your data and select the
    ///       optimum USER_PERSONALIZATION recipe for you.</p>
    ///          <note>
    ///             <p>Amazon Personalize doesn't support configuring the <code>hpoObjective</code>
    ///         for solution hyperparameter optimization at this time.</p>
    ///          </note>
    ///          <p>
    ///             <b>Status</b>
    ///          </p>
    ///          <p>A solution can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the solution, call <a>DescribeSolution</a>. Wait
    ///       until the status shows as ACTIVE before calling <code>CreateSolutionVersion</code>.</p>
    ///
    ///
    ///
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListSolutions</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>CreateSolutionVersion</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeSolution</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteSolution</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListSolutionVersions</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeSolutionVersion</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createSolution(input: CreateSolutionInput) async throws -> CreateSolutionOutputResponse
    {
        typealias createSolutionContinuation = CheckedContinuation<CreateSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSolutionContinuation) in
            createSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Trains or retrains an active solution. A solution is created using the <a>CreateSolution</a> operation and must be in the ACTIVE state before calling
    ///         <code>CreateSolutionVersion</code>. A new version of the solution is created every time you
    ///       call this operation.</p>
    ///          <p>
    ///             <b>Status</b>
    ///          </p>
    ///          <p>A solution version can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE IN_PROGRESS</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE STOPPING</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE STOPPED</p>
    ///             </li>
    ///          </ul>
    ///          <p>To get the status of the version, call <a>DescribeSolutionVersion</a>. Wait
    ///       until the status shows as ACTIVE before calling <code>CreateCampaign</code>.</p>
    ///          <p>If the status shows as CREATE FAILED, the response includes a <code>failureReason</code>
    ///       key, which describes why the job failed.</p>
    ///          <p class="title">
    ///             <b>Related APIs</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListSolutionVersions</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeSolutionVersion</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ListSolutions</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>CreateSolution</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DescribeSolution</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>DeleteSolution</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    func createSolutionVersion(input: CreateSolutionVersionInput) async throws -> CreateSolutionVersionOutputResponse
    {
        typealias createSolutionVersionContinuation = CheckedContinuation<CreateSolutionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSolutionVersionContinuation) in
            createSolutionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes a campaign by deleting the solution deployment. The solution that
    ///       the campaign is based on is not deleted and can be redeployed when needed. A deleted campaign can no
    ///       longer be specified in a
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a>
    ///       request.
    ///       For more information on campaigns, see <a>CreateCampaign</a>.</p>
    func deleteCampaign(input: DeleteCampaignInput) async throws -> DeleteCampaignOutputResponse
    {
        typealias deleteCampaignContinuation = CheckedContinuation<DeleteCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCampaignContinuation) in
            deleteCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a dataset. You can't delete a dataset if an associated
    ///         <code>DatasetImportJob</code> or <code>SolutionVersion</code> is in the CREATE PENDING or IN
    ///       PROGRESS state. For more information on datasets, see <a>CreateDataset</a>.</p>
    func deleteDataset(input: DeleteDatasetInput) async throws -> DeleteDatasetOutputResponse
    {
        typealias deleteDatasetContinuation = CheckedContinuation<DeleteDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDatasetContinuation) in
            deleteDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a dataset group. Before you delete a dataset group, you must delete the
    ///       following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>All associated event trackers.</p>
    ///             </li>
    ///             <li>
    ///                <p>All associated solutions.</p>
    ///             </li>
    ///             <li>
    ///                <p>All datasets in the dataset group.</p>
    ///             </li>
    ///          </ul>
    func deleteDatasetGroup(input: DeleteDatasetGroupInput) async throws -> DeleteDatasetGroupOutputResponse
    {
        typealias deleteDatasetGroupContinuation = CheckedContinuation<DeleteDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDatasetGroupContinuation) in
            deleteDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the event tracker. Does not delete the event-interactions dataset from
    ///         the associated dataset group. For more
    ///         information on event trackers, see <a>CreateEventTracker</a>.</p>
    func deleteEventTracker(input: DeleteEventTrackerInput) async throws -> DeleteEventTrackerOutputResponse
    {
        typealias deleteEventTrackerContinuation = CheckedContinuation<DeleteEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEventTrackerContinuation) in
            deleteEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a filter.</p>
    func deleteFilter(input: DeleteFilterInput) async throws -> DeleteFilterOutputResponse
    {
        typealias deleteFilterContinuation = CheckedContinuation<DeleteFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFilterContinuation) in
            deleteFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a schema. Before deleting a schema, you must delete all
    ///       datasets referencing the schema. For more information on schemas, see
    ///       <a>CreateSchema</a>.</p>
    func deleteSchema(input: DeleteSchemaInput) async throws -> DeleteSchemaOutputResponse
    {
        typealias deleteSchemaContinuation = CheckedContinuation<DeleteSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSchemaContinuation) in
            deleteSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes all versions of a solution and the <code>Solution</code> object itself.
    ///       Before deleting a solution, you must delete all campaigns based on
    ///       the solution. To determine what campaigns are using the solution, call
    ///       <a>ListCampaigns</a> and supply the Amazon Resource Name (ARN) of the solution.
    ///       You can't delete a solution if an associated <code>SolutionVersion</code> is in the
    ///       CREATE PENDING or IN PROGRESS state.
    ///       For more information on solutions, see <a>CreateSolution</a>.</p>
    func deleteSolution(input: DeleteSolutionInput) async throws -> DeleteSolutionOutputResponse
    {
        typealias deleteSolutionContinuation = CheckedContinuation<DeleteSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSolutionContinuation) in
            deleteSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the given algorithm.</p>
    func describeAlgorithm(input: DescribeAlgorithmInput) async throws -> DescribeAlgorithmOutputResponse
    {
        typealias describeAlgorithmContinuation = CheckedContinuation<DescribeAlgorithmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAlgorithmContinuation) in
            describeAlgorithm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the properties of a batch inference job including name, Amazon Resource Name (ARN),
    ///       status, input and output configurations, and the ARN of the solution version used to generate
    ///       the recommendations.</p>
    func describeBatchInferenceJob(input: DescribeBatchInferenceJobInput) async throws -> DescribeBatchInferenceJobOutputResponse
    {
        typealias describeBatchInferenceJobContinuation = CheckedContinuation<DescribeBatchInferenceJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBatchInferenceJobContinuation) in
            describeBatchInferenceJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the given campaign, including its status.</p>
    ///          <p>A campaign can be in one of the following states:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE PENDING > DELETE IN_PROGRESS</p>
    ///             </li>
    ///          </ul>
    ///          <p>When the <code>status</code> is <code>CREATE FAILED</code>, the response includes the
    ///       <code>failureReason</code> key, which describes why.</p>
    ///          <p>For more information on campaigns, see <a>CreateCampaign</a>.</p>
    func describeCampaign(input: DescribeCampaignInput) async throws -> DescribeCampaignOutputResponse
    {
        typealias describeCampaignContinuation = CheckedContinuation<DescribeCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCampaignContinuation) in
            describeCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the given dataset. For more information on datasets, see <a>CreateDataset</a>.</p>
    func describeDataset(input: DescribeDatasetInput) async throws -> DescribeDatasetOutputResponse
    {
        typealias describeDatasetContinuation = CheckedContinuation<DescribeDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetContinuation) in
            describeDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the dataset export job created by <a>CreateDatasetExportJob</a>,
    ///       including the export job status.</p>
    func describeDatasetExportJob(input: DescribeDatasetExportJobInput) async throws -> DescribeDatasetExportJobOutputResponse
    {
        typealias describeDatasetExportJobContinuation = CheckedContinuation<DescribeDatasetExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetExportJobContinuation) in
            describeDatasetExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the given dataset group. For more information on dataset groups, see <a>CreateDatasetGroup</a>.</p>
    func describeDatasetGroup(input: DescribeDatasetGroupInput) async throws -> DescribeDatasetGroupOutputResponse
    {
        typealias describeDatasetGroupContinuation = CheckedContinuation<DescribeDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetGroupContinuation) in
            describeDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the dataset import job created by <a>CreateDatasetImportJob</a>,
    ///       including the import job status.</p>
    func describeDatasetImportJob(input: DescribeDatasetImportJobInput) async throws -> DescribeDatasetImportJobOutputResponse
    {
        typealias describeDatasetImportJobContinuation = CheckedContinuation<DescribeDatasetImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetImportJobContinuation) in
            describeDatasetImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes an event tracker. The response includes the <code>trackingId</code> and
    ///       <code>status</code> of the event tracker.
    ///       For more information on event trackers, see <a>CreateEventTracker</a>.</p>
    func describeEventTracker(input: DescribeEventTrackerInput) async throws -> DescribeEventTrackerOutputResponse
    {
        typealias describeEventTrackerContinuation = CheckedContinuation<DescribeEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeEventTrackerContinuation) in
            describeEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes the given feature transformation.</p>
    func describeFeatureTransformation(input: DescribeFeatureTransformationInput) async throws -> DescribeFeatureTransformationOutputResponse
    {
        typealias describeFeatureTransformationContinuation = CheckedContinuation<DescribeFeatureTransformationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFeatureTransformationContinuation) in
            describeFeatureTransformation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a filter's properties.</p>
    func describeFilter(input: DescribeFilterInput) async throws -> DescribeFilterOutputResponse
    {
        typealias describeFilterContinuation = CheckedContinuation<DescribeFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFilterContinuation) in
            describeFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a recipe.</p>
    ///          <p>A recipe contains three items:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An algorithm that trains a model.</p>
    ///             </li>
    ///             <li>
    ///                <p>Hyperparameters that govern the training.</p>
    ///             </li>
    ///             <li>
    ///                <p>Feature transformation information for modifying the input data before training.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Amazon Personalize provides a set of predefined recipes. You specify a recipe when you create a
    ///       solution with the <a>CreateSolution</a> API.
    ///       <code>CreateSolution</code> trains a model by using the algorithm
    ///       in the specified recipe and a training dataset. The solution, when deployed as a campaign,
    ///       can provide recommendations using the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations</a> API.</p>
    func describeRecipe(input: DescribeRecipeInput) async throws -> DescribeRecipeOutputResponse
    {
        typealias describeRecipeContinuation = CheckedContinuation<DescribeRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRecipeContinuation) in
            describeRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a schema. For more information on schemas, see
    ///       <a>CreateSchema</a>.</p>
    func describeSchema(input: DescribeSchemaInput) async throws -> DescribeSchemaOutputResponse
    {
        typealias describeSchemaContinuation = CheckedContinuation<DescribeSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSchemaContinuation) in
            describeSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a solution.
    ///       For more information on solutions, see <a>CreateSolution</a>.</p>
    func describeSolution(input: DescribeSolutionInput) async throws -> DescribeSolutionOutputResponse
    {
        typealias describeSolutionContinuation = CheckedContinuation<DescribeSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSolutionContinuation) in
            describeSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Describes a specific version of a solution. For more information on solutions, see <a>CreateSolution</a>.</p>
    func describeSolutionVersion(input: DescribeSolutionVersionInput) async throws -> DescribeSolutionVersionOutputResponse
    {
        typealias describeSolutionVersionContinuation = CheckedContinuation<DescribeSolutionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSolutionVersionContinuation) in
            describeSolutionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the metrics for the specified solution version.</p>
    func getSolutionMetrics(input: GetSolutionMetricsInput) async throws -> GetSolutionMetricsOutputResponse
    {
        typealias getSolutionMetricsContinuation = CheckedContinuation<GetSolutionMetricsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSolutionMetricsContinuation) in
            getSolutionMetrics(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of the batch inference jobs that have been performed off of a solution
    ///       version.</p>
    func listBatchInferenceJobs(input: ListBatchInferenceJobsInput) async throws -> ListBatchInferenceJobsOutputResponse
    {
        typealias listBatchInferenceJobsContinuation = CheckedContinuation<ListBatchInferenceJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBatchInferenceJobsContinuation) in
            listBatchInferenceJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of campaigns that use the given solution.
    ///       When a solution is not specified, all the campaigns associated with the account are listed.
    ///       The response provides the properties for each campaign, including the Amazon Resource Name (ARN).
    ///       For more information on campaigns, see <a>CreateCampaign</a>.</p>
    func listCampaigns(input: ListCampaignsInput) async throws -> ListCampaignsOutputResponse
    {
        typealias listCampaignsContinuation = CheckedContinuation<ListCampaignsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCampaignsContinuation) in
            listCampaigns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of dataset export jobs that use the given dataset. When a dataset is not
    ///       specified, all the dataset export jobs associated with the account are listed. The response
    ///       provides the properties for each dataset export job, including the Amazon Resource Name (ARN).
    ///       For more information on dataset export jobs, see <a>CreateDatasetExportJob</a>. For
    ///       more information on datasets, see <a>CreateDataset</a>.</p>
    func listDatasetExportJobs(input: ListDatasetExportJobsInput) async throws -> ListDatasetExportJobsOutputResponse
    {
        typealias listDatasetExportJobsContinuation = CheckedContinuation<ListDatasetExportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetExportJobsContinuation) in
            listDatasetExportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of dataset groups. The response provides the properties for each dataset
    ///       group, including the Amazon Resource Name (ARN). For more information on dataset groups, see
    ///         <a>CreateDatasetGroup</a>.</p>
    func listDatasetGroups(input: ListDatasetGroupsInput) async throws -> ListDatasetGroupsOutputResponse
    {
        typealias listDatasetGroupsContinuation = CheckedContinuation<ListDatasetGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetGroupsContinuation) in
            listDatasetGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of dataset import jobs that use the given dataset. When a dataset is not
    ///       specified, all the dataset import jobs associated with the account are listed. The response
    ///       provides the properties for each dataset import job, including the Amazon Resource Name (ARN).
    ///       For more information on dataset import jobs, see <a>CreateDatasetImportJob</a>. For
    ///       more information on datasets, see <a>CreateDataset</a>.</p>
    func listDatasetImportJobs(input: ListDatasetImportJobsInput) async throws -> ListDatasetImportJobsOutputResponse
    {
        typealias listDatasetImportJobsContinuation = CheckedContinuation<ListDatasetImportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetImportJobsContinuation) in
            listDatasetImportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the list of datasets contained in the given dataset group. The response provides
    ///       the properties for each dataset, including the Amazon Resource Name (ARN). For more
    ///       information on datasets, see <a>CreateDataset</a>.</p>
    func listDatasets(input: ListDatasetsInput) async throws -> ListDatasetsOutputResponse
    {
        typealias listDatasetsContinuation = CheckedContinuation<ListDatasetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetsContinuation) in
            listDatasets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the list of event trackers associated with the account.
    ///       The response provides the properties for each event tracker, including the Amazon Resource
    ///       Name (ARN) and tracking ID. For more
    ///       information on event trackers, see <a>CreateEventTracker</a>.</p>
    func listEventTrackers(input: ListEventTrackersInput) async throws -> ListEventTrackersOutputResponse
    {
        typealias listEventTrackersContinuation = CheckedContinuation<ListEventTrackersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEventTrackersContinuation) in
            listEventTrackers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists all filters that belong to a given dataset group.</p>
    func listFilters(input: ListFiltersInput) async throws -> ListFiltersOutputResponse
    {
        typealias listFiltersContinuation = CheckedContinuation<ListFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFiltersContinuation) in
            listFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of available recipes. The response provides the properties
    ///        for each recipe, including the recipe's Amazon Resource Name (ARN).</p>
    func listRecipes(input: ListRecipesInput) async throws -> ListRecipesOutputResponse
    {
        typealias listRecipesContinuation = CheckedContinuation<ListRecipesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRecipesContinuation) in
            listRecipes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the list of schemas associated with the account. The response provides the
    ///       properties for each schema, including the Amazon Resource Name (ARN).
    ///       For more information on schemas, see <a>CreateSchema</a>.</p>
    func listSchemas(input: ListSchemasInput) async throws -> ListSchemasOutputResponse
    {
        typealias listSchemasContinuation = CheckedContinuation<ListSchemasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSchemasContinuation) in
            listSchemas(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of solution versions for the given solution. When a solution is not
    ///       specified, all the solution versions associated with the account are listed. The response
    ///       provides the properties for each solution version, including the Amazon Resource Name (ARN).
    ///       For more information on solutions, see <a>CreateSolution</a>.</p>
    func listSolutionVersions(input: ListSolutionVersionsInput) async throws -> ListSolutionVersionsOutputResponse
    {
        typealias listSolutionVersionsContinuation = CheckedContinuation<ListSolutionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSolutionVersionsContinuation) in
            listSolutionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of solutions that use the given dataset group.
    ///       When a dataset group is not specified, all the solutions associated with the account are listed.
    ///       The response provides the properties for each solution, including the Amazon Resource Name (ARN).
    ///       For more information on solutions, see <a>CreateSolution</a>.</p>
    func listSolutions(input: ListSolutionsInput) async throws -> ListSolutionsOutputResponse
    {
        typealias listSolutionsContinuation = CheckedContinuation<ListSolutionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSolutionsContinuation) in
            listSolutions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Stops creating a solution version that is in a state of CREATE_PENDING or CREATE IN_PROGRESS.
    ///       </p>
    ///          <p>Depending on the current state of the solution version, the solution version state changes as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>CREATE_PENDING > CREATE_STOPPED</p>
    ///                <p>or</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE_IN_PROGRESS > CREATE_STOPPING > CREATE_STOPPED</p>
    ///             </li>
    ///          </ul>
    ///          <p>You are billed for all of the training completed up
    ///       until you stop the solution version creation. You cannot resume creating a solution version once it has been stopped.</p>
    func stopSolutionVersionCreation(input: StopSolutionVersionCreationInput) async throws -> StopSolutionVersionCreationOutputResponse
    {
        typealias stopSolutionVersionCreationContinuation = CheckedContinuation<StopSolutionVersionCreationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopSolutionVersionCreationContinuation) in
            stopSolutionVersionCreation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a campaign by either deploying a new solution or changing the value of the
    ///       campaign's <code>minProvisionedTPS</code> parameter.</p>
    ///          <p>To update a campaign, the campaign status must be ACTIVE or CREATE FAILED.
    ///       Check the campaign status using the <a>DescribeCampaign</a> API.</p>
    ///          <note>
    ///             <p>You must wait until the <code>status</code> of the
    ///         updated campaign is <code>ACTIVE</code> before asking the campaign for recommendations.</p>
    ///          </note>
    ///          <p>For more information on campaigns, see <a>CreateCampaign</a>.</p>
    func updateCampaign(input: UpdateCampaignInput) async throws -> UpdateCampaignOutputResponse
    {
        typealias updateCampaignContinuation = CheckedContinuation<UpdateCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCampaignContinuation) in
            updateCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
