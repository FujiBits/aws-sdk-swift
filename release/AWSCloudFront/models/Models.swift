// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDenied: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDenied(message: \(Swift.String(describing: message)))"}
}

extension AccessDenied {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AccessDeniedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access denied.
public struct AccessDenied: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for kgkeypairids0 in items {
                try itemsContainer.encode(kgkeypairids0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KGKeyPairIds].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KGKeyPairIds]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KGKeyPairIds]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveTrustedKeyGroups(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups, and the public keys in each key group, that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups, including the identifiers of the public keys in each key group that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for signer0 in items {
                try itemsContainer.encode(signer0, forKey: ClientRuntime.Key("Signer"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Signer{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Signer>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Signer].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Signer]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Signer]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveTrustedSigners(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ActiveTrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct ActiveTrustedSigners: Swift.Equatable {
        /// This field is true if any of the accounts in the list have active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of accounts and the identifiers of active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        public var items: [CloudFrontClientTypes.Signer]?
        /// The number of accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cNAME = "CNAME"
        case iCPRecordalStatus = "ICPRecordalStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cNAME = cNAME {
            try container.encode(cNAME, forKey: ClientRuntime.Key("CNAME"))
        }
        if let iCPRecordalStatus = iCPRecordalStatus {
            try container.encode(iCPRecordalStatus, forKey: ClientRuntime.Key("ICPRecordalStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cNAMEDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let iCPRecordalStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ICPRecordalStatus.self, forKey: .iCPRecordalStatus)
        iCPRecordalStatus = iCPRecordalStatusDecoded
    }
}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AliasICPRecordal(cNAME: \(Swift.String(describing: cNAME)), iCPRecordalStatus: \(Swift.String(describing: iCPRecordalStatus)))"}
}

extension CloudFrontClientTypes.AliasICPRecordal: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure it yourself. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
    public struct AliasICPRecordal: Swift.Equatable {
        /// A domain name associated with a distribution.
        public var cNAME: Swift.String?
        /// The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to APPROVED for all CNAMEs (aliases) in regions outside of China. The status values returned are the following:
        ///
        /// * APPROVED indicates that the associated CNAME has a valid ICP recordal number. Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.
        ///
        /// * SUSPENDED indicates that the associated CNAME does not have a valid ICP recordal number.
        ///
        /// * PENDING indicates that CloudFront can't determine the ICP recordal status of the CNAME associated with the distribution because there was an error in trying to determine the status. You can try again to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.
        public var iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init (
            cNAME: Swift.String? = nil,
            iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cNAME = cNAME
            self.iCPRecordalStatus = iCPRecordalStatus
        }
    }

}

extension CloudFrontClientTypes.Aliases: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("CNAME"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CNAME{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CNAME>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Aliases: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Aliases(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Aliases: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
    public struct Aliases: Swift.Equatable {
        /// A complex type that contains the CNAME aliases, if any, that you want to associate with this distribution.
        public var items: [Swift.String]?
        /// The number of CNAME aliases, if any, that you want to associate with this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AllowedMethods: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachedMethods = "CachedMethods"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachedMethods = cachedMethods {
            try container.encode(cachedMethods, forKey: ClientRuntime.Key("CachedMethods"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let cachedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachedMethods.self, forKey: .cachedMethods)
        cachedMethods = cachedMethodsDecoded
    }
}

extension CloudFrontClientTypes.AllowedMethods: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllowedMethods(cachedMethods: \(Swift.String(describing: cachedMethods)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.AllowedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
    ///
    /// * CloudFront forwards only GET and HEAD requests.
    ///
    /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
    ///
    /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
    ///
    ///
    /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
    public struct AllowedMethods: Swift.Equatable {
        /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
        ///
        /// * CloudFront caches responses to GET and HEAD requests.
        ///
        /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
        ///
        ///
        /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        public var cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// A complex type that contains the HTTP methods that you want CloudFront to process and forward to your origin.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods that you want CloudFront to forward to your origin. Valid values are 2 (for GET and HEAD requests), 3 (for GET, HEAD, and OPTIONS requests) and 7 (for GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }

}

extension AssociateAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAliasInput(alias: \(Swift.String(describing: alias)), targetDistributionId: \(Swift.String(describing: targetDistributionId)))"}
}

extension AssociateAliasInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAliasOutputError>
}

public struct AssociateAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let alias = input.operationInput.alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            input.builder.withQueryItem(aliasQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAliasOutputError>
}

public struct AssociateAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAliasOutputError>
}

public struct AssociateAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let targetDistributionId = input.targetDistributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("targetDistributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(targetDistributionId.urlPercentEncoding())/associate-alias"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAliasOutputError>
}

public struct AssociateAliasInput: Swift.Equatable {
    /// The alias (also known as a CNAME) to add to the target distribution.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the distribution that you’re associating the alias with.
    /// This member is required.
    public var targetDistributionId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        targetDistributionId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.targetDistributionId = targetDistributionId
    }
}

struct AssociateAliasInputBody: Swift.Equatable {
}

extension AssociateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssociateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAliasOutputResponse()"}
}

extension AssociateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAliasOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateAliasOutputResponseBody: Swift.Equatable {
}

extension AssociateAliasOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension BatchTooLarge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchTooLarge(message: \(Swift.String(describing: message)))"}
}

extension BatchTooLarge {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BatchTooLargeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalidation batch specified is too large.
public struct BatchTooLarge: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchTooLargeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BatchTooLargeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CNAMEAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CNAMEAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CNAMEAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CNAMEAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CNAME specified is already defined for CloudFront.
public struct CNAMEAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CNAMEAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CNAMEAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: ClientRuntime.Key("PathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CacheBehavior(allowedMethods: \(Swift.String(describing: allowedMethods)), cachePolicyId: \(Swift.String(describing: cachePolicyId)), compress: \(Swift.String(describing: compress)), defaultTTL: \(Swift.String(describing: defaultTTL)), fieldLevelEncryptionId: \(Swift.String(describing: fieldLevelEncryptionId)), forwardedValues: \(Swift.String(describing: forwardedValues)), functionAssociations: \(Swift.String(describing: functionAssociations)), lambdaFunctionAssociations: \(Swift.String(describing: lambdaFunctionAssociations)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)), pathPattern: \(Swift.String(describing: pathPattern)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), smoothStreaming: \(Swift.String(describing: smoothStreaming)), targetOriginId: \(Swift.String(describing: targetOriginId)), trustedKeyGroups: \(Swift.String(describing: trustedKeyGroups)), trustedSigners: \(Swift.String(describing: trustedSigners)), viewerProtocolPolicy: \(Swift.String(describing: viewerProtocolPolicy)))"}
}

extension CloudFrontClientTypes.CacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes how CloudFront processes requests. You must create at least as many cache behaviors (including the default cache behavior) as you have origins if you want CloudFront to serve objects from all of the origins. Each cache behavior specifies the one origin from which you want CloudFront to get objects. If you have two origins and only the default cache behavior, the default cache behavior will cause CloudFront to get objects from one of the origins, but the other origin is never used. For the current quota (formerly known as limit) on the number of cache behaviors that you can add to a distribution, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) in the Amazon CloudFront Developer Guide. If you don’t want to specify any cache behaviors, include only an empty CacheBehaviors element. Don’t include an empty CacheBehavior element because this is invalid. To delete all cache behaviors in an existing distribution, update the distribution configuration and include only an empty CacheBehaviors element. To add, change, or remove one or more cache behaviors, update the distribution configuration and specify all of the cache behaviors that you want to include in the updated distribution. For more information about cache behaviors, see [Cache Behavior Settings](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior) in the Amazon CloudFront Developer Guide.
    public struct CacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A CacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [ Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The pattern (for example, images/*.jpg) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution. You can optionally include a slash (/) at the beginning of the path pattern. For example, /images/*.jpg. CloudFront behavior is the same with or without the leading /. The path pattern for the default cache behavior is * and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var pathPattern: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they match this cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer’s account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension CloudFrontClientTypes.CacheBehaviors: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachebehavior0 in items {
                try itemsContainer.encode(cachebehavior0, forKey: ClientRuntime.Key("CacheBehavior"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CacheBehavior{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheBehavior>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CacheBehavior].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CacheBehavior]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CacheBehavior]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CacheBehaviors: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CacheBehaviors(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CacheBehaviors: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more CacheBehavior elements.
    public struct CacheBehaviors: Swift.Equatable {
        /// Optional: A complex type that contains cache behaviors for this distribution. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.CacheBehavior]?
        /// The number of cache behaviors for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CachePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.CachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicy(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.CachePolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy. When it’s attached to a cache behavior, the cache policy determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find a valid object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicy: Swift.Equatable {
        /// The cache policy configuration.
        /// This member is required.
        public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// The unique identifier for the cache policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the cache policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CachePolicyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CachePolicyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A cache policy with this name already exists. You must provide a unique name. To modify an existing cache policy, use UpdateCachePolicy.
public struct CachePolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CachePolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case defaultTTL = "DefaultTTL"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case name = "Name"
        case parametersInCacheKeyAndForwardedToOrigin = "ParametersInCacheKeyAndForwardedToOrigin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin {
            try container.encode(parametersInCacheKeyAndForwardedToOrigin, forKey: ClientRuntime.Key("ParametersInCacheKeyAndForwardedToOrigin"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let parametersInCacheKeyAndForwardedToOriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.self, forKey: .parametersInCacheKeyAndForwardedToOrigin)
        parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOriginDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyConfig(comment: \(Swift.String(describing: comment)), defaultTTL: \(Swift.String(describing: defaultTTL)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), name: \(Swift.String(describing: name)), parametersInCacheKeyAndForwardedToOrigin: \(Swift.String(describing: parametersInCacheKeyAndForwardedToOrigin)))"}
}

extension CloudFrontClientTypes.CachePolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A cache policy configuration. This configuration determines the following:
    ///
    /// * The values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer.
    ///
    /// * The default, minimum, and maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.
    ///
    ///
    /// The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find a valid object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct CachePolicyConfig: Swift.Equatable {
        /// A comment to describe the cache policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The default amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value as the object’s time to live (TTL) only when the origin does not send Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 86400 seconds (one day). If the value of MinTTL is more than 86400 seconds, then the default value for this field is the same as the value of MinTTL.
        public var defaultTTL: Swift.Int?
        /// The maximum amount of time, in seconds, that objects stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. CloudFront uses this value only when the origin sends Cache-Control or Expires headers with the object. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. The default value for this field is 31536000 seconds (one year). If the value of MinTTL or DefaultTTL is more than 31536000 seconds, then the default value for this field is the same as the value of DefaultTTL.
        public var maxTTL: Swift.Int?
        /// The minimum amount of time, in seconds, that you want objects to stay in the CloudFront cache before CloudFront sends another request to the origin to see if the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var minTTL: Swift.Int?
        /// A unique name to identify the cache policy.
        /// This member is required.
        public var name: Swift.String?
        /// The HTTP headers, cookies, and URL query strings to include in the cache key. The values included in the cache key are automatically included in requests that CloudFront sends to the origin.
        public var parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init (
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyCookiesConfig(cookieBehavior: \(Swift.String(describing: cookieBehavior)), cookies: \(Swift.String(describing: cookies)))"}
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyCookiesConfig: Swift.Equatable {
        /// Determines whether any cookies in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Cookies in viewer requests are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The cookies in viewer requests that are listed in the CookieNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All cookies in viewer requests that are not listed in the CookieNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyHeadersConfig(headerBehavior: \(Swift.String(describing: headerBehavior)), headers: \(Swift.String(describing: headers)))"}
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – HTTP headers are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The HTTP headers that are listed in the Headers type are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension CachePolicyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyInUse(message: \(Swift.String(describing: message)))"}
}

extension CachePolicyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CachePolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the cache policy because it is attached to one or more cache behaviors.
public struct CachePolicyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CachePolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachepolicysummary0 in items {
                try itemsContainer.encode(cachepolicysummary0, forKey: ClientRuntime.Key("CachePolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CachePolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CachePolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CachePolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CachePolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CachePolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CachePolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of cache policies.
    public struct CachePolicyList: Swift.Equatable {
        /// Contains the cache policies in the list.
        public var items: [CloudFrontClientTypes.CachePolicySummary]?
        /// The maximum number of cache policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing cache policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of cache policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyQueryStringsConfig(queryStringBehavior: \(Swift.String(describing: queryStringBehavior)), queryStrings: \(Swift.String(describing: queryStrings)))"}
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
    public struct CachePolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in the cache key and automatically included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Query strings in viewer requests are not included in the cache key and are not automatically included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in an OriginRequestPolicy are included in origin requests.
        ///
        /// * whitelist – The query strings in viewer requests that are listed in the QueryStringNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * allExcept – All query strings in viewer requests that are not listed in the QueryStringNames type are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in the cache key and are automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// Contains the specific query strings in viewer requests that either are or are not included in the cache key and automatically included in requests that CloudFront sends to the origin. The behavior depends on whether the QueryStringBehavior field in the CachePolicyQueryStringsConfig type is set to whitelist (the listed query strings are included) or allExcept (the listed query strings are not included, but all other query strings are).
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.CachePolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicy = cachePolicy {
            try container.encode(cachePolicy, forKey: ClientRuntime.Key("CachePolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyType.self, forKey: .type)
        type = typeDecoded
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension CloudFrontClientTypes.CachePolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicySummary(cachePolicy: \(Swift.String(describing: cachePolicy)), type: \(Swift.String(describing: type)))"}
}

extension CloudFrontClientTypes.CachePolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a cache policy.
    public struct CachePolicySummary: Swift.Equatable {
        /// The cache policy.
        /// This member is required.
        public var cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// The type of cache policy, either managed (created by Amazon Web Services) or custom (created in this account).
        /// This member is required.
        public var type: CloudFrontClientTypes.CachePolicyType?

        public init (
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachedMethods(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CachedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:
    ///
    /// * CloudFront caches responses to GET and HEAD requests.
    ///
    /// * CloudFront caches responses to GET, HEAD, and OPTIONS requests.
    ///
    ///
    /// If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
    public struct CachedMethods: Swift.Equatable {
        /// A complex type that contains the HTTP methods that you want CloudFront to cache responses to.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Method]?
        /// The number of HTTP methods for which you want CloudFront to cache responses. Valid values are 2 (for caching responses to GET and HEAD requests) and 3 (for caching responses to GET, HEAD, and OPTIONS requests).
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CannotChangeImmutablePublicKeyFields: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CannotChangeImmutablePublicKeyFields(message: \(Swift.String(describing: message)))"}
}

extension CannotChangeImmutablePublicKeyFields {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CannotChangeImmutablePublicKeyFieldsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't change the value of a public key.
public struct CannotChangeImmutablePublicKeyFields: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotChangeImmutablePublicKeyFieldsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CannotChangeImmutablePublicKeyFieldsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum CertificateSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentity(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(Swift.String(describing: id)), s3CanonicalUserId: \(Swift.String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentity: Swift.Equatable {
        /// The current configuration information for the identity.
        public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// The ID for the origin access identity, for example, E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, used when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init (
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontOriginAccessIdentityAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// If the CallerReference is a value you already sent in a previous request to create an identity but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
public struct CloudFrontOriginAccessIdentityAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Origin access identity configuration. Send a GET request to the /CloudFront API version/CloudFront/identity ID/config resource.
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Equatable {
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the CloudFrontOriginAccessIdentityConfig object), a new origin access identity is created. If the CallerReference is a value already sent in a previous identity request, and the content of the CloudFrontOriginAccessIdentityConfig is identical to the original request (ignoring white space), the response includes the same information returned to the original request. If the CallerReference is a value you already sent in a previous request to create an identity, but the content of the CloudFrontOriginAccessIdentityConfig is different from the original request, CloudFront returns a CloudFrontOriginAccessIdentityAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the origin access identity. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }

}

extension CloudFrontOriginAccessIdentityInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityInUse(message: \(Swift.String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CloudFrontOriginAccessIdentityInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Origin Access Identity specified is already in use.
public struct CloudFrontOriginAccessIdentityInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cloudfrontoriginaccessidentitysummary0 in items {
                try itemsContainer.encode(cloudfrontoriginaccessidentitysummary0, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentitySummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CloudFrontOriginAccessIdentitySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CloudFrontOriginAccessIdentitySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Lists the origin access identities for CloudFront.Send a GET request to the /CloudFront API version/origin-access-identity/cloudfront resource. The response includes a CloudFrontOriginAccessIdentityList element with zero or more CloudFrontOriginAccessIdentitySummary child elements. By default, your entire list of origin access identities is returned in one single page. If the list is long, you can paginate it using the MaxItems and Marker parameters.
    public struct CloudFrontOriginAccessIdentityList: Swift.Equatable {
        /// A flag that indicates whether more origin access identities remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more items in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one CloudFrontOriginAccessIdentitySummary element for each origin access identity that was created by the current account.
        public var items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of origin access identities you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your origin access identities where they left off.
        public var nextMarker: Swift.String?
        /// The number of CloudFront origin access identities that were created by the current account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentitySummary(comment: \(Swift.String(describing: comment)), id: \(Swift.String(describing: id)), s3CanonicalUserId: \(Swift.String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Summary of the information about a CloudFront origin access identity.
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Equatable {
        /// The comment for this origin access identity, as originally specified when created.
        /// This member is required.
        public var comment: Swift.String?
        /// The ID for the origin access identity. For example: E74FTE3AJFJ256A.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon S3 canonical user ID for the origin access identity, which you use when giving the origin access identity read permission to an object in Amazon S3.
        /// This member is required.
        public var s3CanonicalUserId: Swift.String?

        public init (
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAlias: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alias = "Alias"
        case distributionId = "DistributionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accountId = accountId {
            try container.encode(accountId, forKey: ClientRuntime.Key("AccountId"))
        }
        if let alias = alias {
            try container.encode(alias, forKey: ClientRuntime.Key("Alias"))
        }
        if let distributionId = distributionId {
            try container.encode(distributionId, forKey: ClientRuntime.Key("DistributionId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let distributionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionId)
        distributionId = distributionIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CloudFrontClientTypes.ConflictingAlias: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictingAlias(accountId: \(Swift.String(describing: accountId)), alias: \(Swift.String(describing: alias)), distributionId: \(Swift.String(describing: distributionId)))"}
}

extension CloudFrontClientTypes.ConflictingAlias: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An alias (also called a CNAME) and the CloudFront distribution and Amazon Web Services account ID that it’s associated with. The distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don’t own.
    public struct ConflictingAlias: Swift.Equatable {
        /// The (partially hidden) ID of the Amazon Web Services account that owns the distribution that’s associated with the alias.
        public var accountId: Swift.String?
        /// An alias (also called a CNAME).
        public var alias: Swift.String?
        /// The (partially hidden) ID of the CloudFront distribution associated with the alias.
        public var distributionId: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            alias: Swift.String? = nil,
            distributionId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.alias = alias
            self.distributionId = distributionId
        }
    }

}

extension CloudFrontClientTypes.ConflictingAliasesList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for conflictingalias0 in items {
                try itemsContainer.encode(conflictingalias0, forKey: ClientRuntime.Key("ConflictingAlias"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ConflictingAlias{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ConflictingAlias>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ConflictingAlias].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ConflictingAlias]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ConflictingAlias]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ConflictingAliasesList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictingAliasesList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ConflictingAliasesList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of aliases (also called CNAMEs) and the CloudFront distributions and Amazon Web Services accounts that they are associated with. In the list, the distribution and account IDs are partially hidden, which allows you to identify the distributions and accounts that you own, but helps to protect the information of ones that you don’t own.
    public struct ConflictingAliasesList: Swift.Equatable {
        /// Contains the conflicting aliases in the list.
        public var items: [CloudFrontClientTypes.ConflictingAlias]?
        /// The maximum number of conflicting aliases requested.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing conflicting aliases where you left off.
        public var nextMarker: Swift.String?
        /// The number of conflicting aliases returned in the response.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ConflictingAlias]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case format = "Format"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfile(contentType: \(Swift.String(describing: contentType)), format: \(Swift.String(describing: format)), profileId: \(Swift.String(describing: profileId)))"}
}

extension CloudFrontClientTypes.ContentTypeProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A field-level encryption content type profile.
    public struct ContentTypeProfile: Swift.Equatable {
        /// The content type for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var contentType: Swift.String?
        /// The format for a field-level encryption content type-profile mapping.
        /// This member is required.
        public var format: CloudFrontClientTypes.Format?
        /// The profile ID for a field-level encryption content type-profile mapping.
        public var profileId: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentTypeProfiles = "ContentTypeProfiles"
        case forwardWhenContentTypeIsUnknown = "ForwardWhenContentTypeIsUnknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentTypeProfiles = contentTypeProfiles {
            try container.encode(contentTypeProfiles, forKey: ClientRuntime.Key("ContentTypeProfiles"))
        }
        if let forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown {
            try container.encode(forwardWhenContentTypeIsUnknown, forKey: ClientRuntime.Key("ForwardWhenContentTypeIsUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenContentTypeIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenContentTypeIsUnknown)
        forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknownDecoded
        let contentTypeProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfiles.self, forKey: .contentTypeProfiles)
        contentTypeProfiles = contentTypeProfilesDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfileConfig(contentTypeProfiles: \(Swift.String(describing: contentTypeProfiles)), forwardWhenContentTypeIsUnknown: \(Swift.String(describing: forwardWhenContentTypeIsUnknown)))"}
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The configuration for a field-level encryption content type-profile mapping.
    public struct ContentTypeProfileConfig: Swift.Equatable {
        /// The configuration for a field-level encryption content type-profile.
        public var contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// The setting in a field-level encryption content type-profile mapping that specifies what to do when an unknown content type is provided for the profile. If true, content is forwarded without being encrypted when the content type is unknown. If false (the default), an error is returned when the content type is unknown.
        /// This member is required.
        public var forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init (
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for contenttypeprofile0 in items {
                try itemsContainer.encode(contenttypeprofile0, forKey: ClientRuntime.Key("ContentTypeProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContentTypeProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContentTypeProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ContentTypeProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ContentTypeProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ContentTypeProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfiles(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ContentTypeProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Field-level encryption content type-profile.
    public struct ContentTypeProfiles: Swift.Equatable {
        /// Items in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// The number of field-level encryption content type-profile mappings.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookieNames: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CookieNames: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CookieNames(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CookieNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of cookie names.
    public struct CookieNames: Swift.Equatable {
        /// A list of cookie names.
        public var items: [Swift.String]?
        /// The number of cookie names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookiePreference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forward = "Forward"
        case whitelistedNames = "WhitelistedNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forward = forward {
            try container.encode(forward, forKey: ClientRuntime.Key("Forward"))
        }
        if let whitelistedNames = whitelistedNames {
            try container.encode(whitelistedNames, forKey: ClientRuntime.Key("WhitelistedNames"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ItemSelection.self, forKey: .forward)
        forward = forwardDecoded
        let whitelistedNamesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .whitelistedNames)
        whitelistedNames = whitelistedNamesDecoded
    }
}

extension CloudFrontClientTypes.CookiePreference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CookiePreference(forward: \(Swift.String(describing: forward)), whitelistedNames: \(Swift.String(describing: whitelistedNames)))"}
}

extension CloudFrontClientTypes.CookiePreference: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use CookiesConfig in a cache policy. See CachePolicy. If you want to send cookies to the origin but not include them in the cache key, use CookiesConfig in an origin request policy. See OriginRequestPolicy. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [Caching Content Based on Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
    public struct CookiePreference: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the WhitelistedNames complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the Forward element.
        /// This member is required.
        public var forward: CloudFrontClientTypes.ItemSelection?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Required if you specify whitelist for the value of Forward. A complex type that specifies how many different cookies you want CloudFront to forward to the origin for this cache behavior and, if you want to forward selected cookies, the names of those cookies. If you specify all or none for the value of Forward, omit WhitelistedNames. If you change the value of Forward from whitelist to all or none and you don't delete the WhitelistedNames element and its child elements, CloudFront deletes them automatically. For the current limit on the number of cookie names that you can whitelist for each cache behavior, see [ CloudFront Limits](https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront) in the Amazon Web Services General Reference.
        public var whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init (
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }

}

public struct CreateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

extension CreateCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachePolicyInput(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)))"}
}

extension CreateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

public struct CreateCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/cache-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

struct CreateCachePolicyInputBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension CreateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CreateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCachePolicies" : self = .tooManyCachePolicies(try TooManyCachePolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case tooManyCachePolicies(TooManyCachePolicies)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct CreateCachePolicyOutputResponse: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the cache policy just created.
    public var location: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension CreateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)))"}
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

public struct CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

public struct CreateCloudFrontOriginAccessIdentityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

public struct CreateCloudFrontOriginAccessIdentityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

/// The request to create a new origin access identity (OAI). An origin access identity is a special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or just some of your Amazon S3 content. For more information, see [ Restricting Access to Amazon S3 Content by Using an Origin Access Identity](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The current configuration information for the identity.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

struct CreateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension CreateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudFrontOriginAccessIdentityAlreadyExists" : self = .cloudFrontOriginAccessIdentityAlreadyExists(try CloudFrontOriginAccessIdentityAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCloudFrontOriginAccessIdentities" : self = .tooManyCloudFrontOriginAccessIdentities(try TooManyCloudFrontOriginAccessIdentities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case cloudFrontOriginAccessIdentityAlreadyExists(CloudFrontOriginAccessIdentityAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case tooManyCloudFrontOriginAccessIdentities(TooManyCloudFrontOriginAccessIdentities)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new origin access identity just created.
    public var location: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct CreateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

extension CreateDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionInput(distributionConfig: \(Swift.String(describing: distributionConfig)))"}
}

extension CreateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

public struct CreateDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

public struct CreateDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

public struct CreateDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

public struct CreateDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

/// The request to create a new distribution.
public struct CreateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

struct CreateDistributionInputBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension CreateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension CreateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigWithTags = input.operationInput.distributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let distributionConfigWithTagsdata = try encoder.encode(distributionConfigWithTags)
                let distributionConfigWithTagsbody = ClientRuntime.HttpBody.data(distributionConfigWithTagsdata)
                input.builder.withBody(distributionConfigWithTagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

extension CreateDistributionWithTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionWithTagsInput(distributionConfigWithTags: \(Swift.String(describing: distributionConfigWithTags)))"}
}

extension CreateDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionWithTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfigWithTags = distributionConfigWithTags {
            try container.encode(distributionConfigWithTags, forKey: ClientRuntime.Key("DistributionConfigWithTags"))
        }
    }
}

public struct CreateDistributionWithTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

public struct CreateDistributionWithTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

public struct CreateDistributionWithTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionWithTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionWithTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

public struct CreateDistributionWithTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionWithTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionWithTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

/// The request to create a new distribution with tags.
public struct CreateDistributionWithTagsInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init (
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

struct CreateDistributionWithTagsInputBody: Swift.Equatable {
    public let distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?
}

extension CreateDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfigWithTags.self, forKey: .distributionConfigWithTags)
        distributionConfigWithTags = distributionConfigWithTagsDecoded
    }
}

extension CreateDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTagging(InvalidTagging)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionWithTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionWithTagsOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateDistributionWithTagsOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new distribution resource just created.
    public var location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionWithTagsOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

extension CreateFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)))"}
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/field-level-encryption"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The request to create a new field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct CreateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension CreateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CreateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionConfigAlreadyExists" : self = .fieldLevelEncryptionConfigAlreadyExists(try FieldLevelEncryptionConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionConfigs" : self = .tooManyFieldLevelEncryptionConfigs(try TooManyFieldLevelEncryptionConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionConfigAlreadyExists(FieldLevelEncryptionConfigAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionConfigs(TooManyFieldLevelEncryptionConfigs)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)), location: \(Swift.String(describing: location)))"}
}

extension CreateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// The fully qualified URI of the new configuration resource just created.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

struct CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct CreateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

extension CreateFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/field-level-encryption-profile"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// The request to create a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct CreateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension CreateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CreateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionProfiles" : self = .tooManyFieldLevelEncryptionProfiles(try TooManyFieldLevelEncryptionProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchPublicKey(NoSuchPublicKey)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case tooManyFieldLevelEncryptionProfiles(TooManyFieldLevelEncryptionProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)), location: \(Swift.String(describing: location)))"}
}

extension CreateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Returned when you create a new field-level encryption profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// The fully qualified URI of the new profile resource just created.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

struct CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct CreateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(functionCode: \(Swift.String(describing: functionCode)), functionConfig: \(Swift.String(describing: functionConfig)), name: \(Swift.String(describing: name)))"}
}

extension CreateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/function"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function, including an optional comment and the function’s runtime.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// A name to identify the function.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    public let functionCode: ClientRuntime.Data?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionAlreadyExists" : self = .functionAlreadyExists(try FunctionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctions" : self = .tooManyFunctions(try TooManyFunctions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionAlreadyExists(FunctionAlreadyExists)
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case tooManyFunctions(TooManyFunctions)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)), location: \(Swift.String(describing: location)))"}
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// The URL of the CloudFront function. Use the URL to manage the function with the CloudFront API.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct CreateInvalidationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let invalidationBatch = input.operationInput.invalidationBatch {
            do {
                let encoder = context.getEncoder()
                let invalidationBatchdata = try encoder.encode(invalidationBatch)
                let invalidationBatchbody = ClientRuntime.HttpBody.data(invalidationBatchdata)
                input.builder.withBody(invalidationBatchbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

extension CreateInvalidationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInvalidationInput(distributionId: \(Swift.String(describing: distributionId)), invalidationBatch: \(Swift.String(describing: invalidationBatch)))"}
}

extension CreateInvalidationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateInvalidationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
    }
}

public struct CreateInvalidationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

public struct CreateInvalidationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

public struct CreateInvalidationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateInvalidationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInvalidationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

public struct CreateInvalidationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateInvalidationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInvalidationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

/// The request to create an invalidation.
public struct CreateInvalidationInput: Swift.Equatable {
    /// The distribution's id.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The batch information for the invalidation.
    /// This member is required.
    public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init (
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

struct CreateInvalidationInputBody: Swift.Equatable {
    public let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
}

extension CreateInvalidationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CreateInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchTooLarge" : self = .batchTooLarge(try BatchTooLarge(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyInvalidationsInProgress" : self = .tooManyInvalidationsInProgress(try TooManyInvalidationsInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case batchTooLarge(BatchTooLarge)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyInvalidationsInProgress(TooManyInvalidationsInProgress)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInvalidationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInvalidationOutputResponse(invalidation: \(Swift.String(describing: invalidation)), location: \(Swift.String(describing: location)))"}
}

extension CreateInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateInvalidationOutputResponse: Swift.Equatable {
    /// The invalidation's information.
    public var invalidation: CloudFrontClientTypes.Invalidation?
    /// The fully qualified URI of the distribution and invalidation batch request, including the Invalidation ID.
    public var location: Swift.String?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

struct CreateInvalidationOutputResponseBody: Swift.Equatable {
    public let invalidation: CloudFrontClientTypes.Invalidation?
}

extension CreateInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

public struct CreateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

extension CreateKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyGroupInput(keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension CreateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

public struct CreateKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/key-group"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInput: Swift.Equatable {
    /// A key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

struct CreateKeyGroupInputBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension CreateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CreateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroups" : self = .tooManyKeyGroups(try TooManyKeyGroups(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case tooManyKeyGroups(TooManyKeyGroups)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)), location: \(Swift.String(describing: location)))"}
}

extension CreateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct CreateKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just created.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?
    /// The URL of the key group.
    public var location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

struct CreateKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension CreateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct CreateMonitoringSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let monitoringSubscription = input.operationInput.monitoringSubscription {
            do {
                let encoder = context.getEncoder()
                let monitoringSubscriptiondata = try encoder.encode(monitoringSubscription)
                let monitoringSubscriptionbody = ClientRuntime.HttpBody.data(monitoringSubscriptiondata)
                input.builder.withBody(monitoringSubscriptionbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

extension CreateMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)), monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let monitoringSubscription = monitoringSubscription {
            try container.encode(monitoringSubscription, forKey: ClientRuntime.Key("MonitoringSubscription"))
        }
    }
}

public struct CreateMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are enabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// This member is required.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionInputBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension CreateMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMonitoringSubscriptionOutputResponse(monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct CreateMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

public struct CreateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

extension CreateOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginRequestPolicyInput(originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension CreateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct CreateOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/origin-request-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInput: Swift.Equatable {
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct CreateOriginRequestPolicyInputBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension CreateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CreateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginRequestPolicies" : self = .tooManyOriginRequestPolicies(try TooManyOriginRequestPolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyOriginRequestPolicies(TooManyOriginRequestPolicies)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension CreateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct CreateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The fully qualified URI of the origin request policy just created.
    public var location: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

struct CreateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension CreateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct CreatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

extension CreatePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicKeyInput(publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension CreatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreatePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

public struct CreatePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/public-key"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInput: Swift.Equatable {
    /// A CloudFront public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

struct CreatePublicKeyInputBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension CreatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CreatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyAlreadyExists" : self = .publicKeyAlreadyExists(try PublicKeyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeys" : self = .tooManyPublicKeys(try TooManyPublicKeys(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case publicKeyAlreadyExists(PublicKeyAlreadyExists)
    case tooManyPublicKeys(TooManyPublicKeys)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension CreatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct CreatePublicKeyOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The URL of the public key.
    public var location: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

struct CreatePublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension CreatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct CreateRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

extension CreateRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRealtimeLogConfigInput(endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension CreateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

public struct CreateRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/realtime-log-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInput: Swift.Equatable {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    /// This member is required.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var fields: [Swift.String]?
    /// A unique name to identify this real-time log configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    /// This member is required.
    public var samplingRate: Swift.Int?

    public init (
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct CreateRealtimeLogConfigInputBody: Swift.Equatable {
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    public let fields: [Swift.String]?
    public let name: Swift.String?
    public let samplingRate: Swift.Int?
}

extension CreateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CreateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigAlreadyExists" : self = .realtimeLogConfigAlreadyExists(try RealtimeLogConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRealtimeLogConfigs" : self = .tooManyRealtimeLogConfigs(try TooManyRealtimeLogConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case realtimeLogConfigAlreadyExists(RealtimeLogConfigAlreadyExists)
    case tooManyRealtimeLogConfigs(TooManyRealtimeLogConfigs)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension CreateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct CreateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct CreateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension CreateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct CreateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

extension CreateStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionInput(streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension CreateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

public struct CreateStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

public struct CreateStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

public struct CreateStreamingDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

public struct CreateStreamingDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/streaming-distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

/// The request to create a new streaming distribution.
public struct CreateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct CreateStreamingDistributionInputBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension CreateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CreateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the streaming distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

public struct CreateStreamingDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfigWithTags = input.operationInput.streamingDistributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigWithTagsdata = try encoder.encode(streamingDistributionConfigWithTags)
                let streamingDistributionConfigWithTagsbody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsdata)
                input.builder.withBody(streamingDistributionConfigWithTagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

extension CreateStreamingDistributionWithTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionWithTagsInput(streamingDistributionConfigWithTags: \(Swift.String(describing: streamingDistributionConfigWithTags)))"}
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionWithTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfigWithTags = streamingDistributionConfigWithTags {
            try container.encode(streamingDistributionConfigWithTags, forKey: ClientRuntime.Key("StreamingDistributionConfigWithTags"))
        }
    }
}

public struct CreateStreamingDistributionWithTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

public struct CreateStreamingDistributionWithTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

public struct CreateStreamingDistributionWithTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingDistributionWithTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingDistributionWithTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

public struct CreateStreamingDistributionWithTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingDistributionWithTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/streaming-distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingDistributionWithTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

/// The request to create a new streaming distribution with tags.
public struct CreateStreamingDistributionWithTagsInput: Swift.Equatable {
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init (
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

struct CreateStreamingDistributionWithTagsInputBody: Swift.Equatable {
    public let streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?
}

extension CreateStreamingDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfigWithTags.self, forKey: .streamingDistributionConfigWithTags)
        streamingDistributionConfigWithTags = streamingDistributionConfigWithTagsDecoded
    }
}

extension CreateStreamingDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidTagging(InvalidTagging)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionWithTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionWithTagsOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct CreateStreamingDistributionWithTagsOutputResponse: Swift.Equatable {
    /// The current version of the distribution created.
    public var eTag: Swift.String?
    /// The fully qualified URI of the new streaming distribution resource just created.
    public var location: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCachingMinTTL = "ErrorCachingMinTTL"
        case errorCode = "ErrorCode"
        case responseCode = "ResponseCode"
        case responsePagePath = "ResponsePagePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorCachingMinTTL = errorCachingMinTTL {
            try container.encode(errorCachingMinTTL, forKey: ClientRuntime.Key("ErrorCachingMinTTL"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: ClientRuntime.Key("ErrorCode"))
        }
        if let responseCode = responseCode {
            try container.encode(responseCode, forKey: ClientRuntime.Key("ResponseCode"))
        }
        if let responsePagePath = responsePagePath {
            try container.encode(responsePagePath, forKey: ClientRuntime.Key("ResponsePagePath"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let responsePagePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responsePagePath)
        responsePagePath = responsePagePathDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let errorCachingMinTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCachingMinTTL)
        errorCachingMinTTL = errorCachingMinTTLDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomErrorResponse(errorCachingMinTTL: \(Swift.String(describing: errorCachingMinTTL)), errorCode: \(Swift.String(describing: errorCode)), responseCode: \(Swift.String(describing: responseCode)), responsePagePath: \(Swift.String(describing: responsePagePath)))"}
}

extension CloudFrontClientTypes.CustomErrorResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponse: Swift.Equatable {
        /// The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ErrorCode. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var errorCachingMinTTL: Swift.Int?
        /// The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        /// This member is required.
        public var errorCode: Swift.Int?
        /// The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:
        ///
        /// * Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute 200, the response typically won't be intercepted.
        ///
        /// * If you don't care about distinguishing among different client errors or server errors, you can specify 400 or 500 as the ResponseCode for all 4xx or 5xx errors.
        ///
        /// * You might want to return a 200 status code (OK) and static website so your customers don't know that your website is down.
        ///
        ///
        /// If you specify a value for ResponseCode, you must also specify a value for ResponsePagePath.
        public var responseCode: Swift.String?
        /// The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ErrorCode, for example, /4xx-errors/403-forbidden.html. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:
        ///
        /// * The value of PathPattern matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named /4xx-errors. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, /4xx-errors/*.
        ///
        /// * The value of TargetOriginId specifies the value of the ID element for the origin that contains your custom error pages.
        ///
        ///
        /// If you specify a value for ResponsePagePath, you must also specify a value for ResponseCode. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        public var responsePagePath: Swift.String?

        public init (
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }

}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for customerrorresponse0 in items {
                try itemsContainer.encode(customerrorresponse0, forKey: ClientRuntime.Key("CustomErrorResponse"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CustomErrorResponse{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomErrorResponse>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CustomErrorResponse].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CustomErrorResponse]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CustomErrorResponse]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomErrorResponses(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CustomErrorResponses: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls:
    ///
    /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
    ///
    /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
    ///
    ///
    /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
    public struct CustomErrorResponses: Swift.Equatable {
        /// A complex type that contains a CustomErrorResponse element for each HTTP status code for which you want to specify a custom error page and/or a caching duration.
        public var items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// The number of HTTP status codes for which you want to specify a custom error page and/or a caching duration. If Quantity is 0, you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomHeaders: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origincustomheader0 in items {
                try itemsContainer.encode(origincustomheader0, forKey: ClientRuntime.Key("OriginCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomHeaders: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomHeaders(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CustomHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains the list of Custom Headers for each origin.
    public struct CustomHeaders: Swift.Equatable {
        /// Optional: A list that contains one OriginCustomHeader element for each custom header that you want CloudFront to forward to the origin. If Quantity is 0, omit Items.
        public var items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// The number of custom headers, if any, for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hTTPPort = "HTTPPort"
        case hTTPSPort = "HTTPSPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let hTTPPort = hTTPPort {
            try container.encode(hTTPPort, forKey: ClientRuntime.Key("HTTPPort"))
        }
        if let hTTPSPort = hTTPSPort {
            try container.encode(hTTPSPort, forKey: ClientRuntime.Key("HTTPSPort"))
        }
        if let originKeepaliveTimeout = originKeepaliveTimeout {
            try container.encode(originKeepaliveTimeout, forKey: ClientRuntime.Key("OriginKeepaliveTimeout"))
        }
        if let originProtocolPolicy = originProtocolPolicy {
            try container.encode(originProtocolPolicy, forKey: ClientRuntime.Key("OriginProtocolPolicy"))
        }
        if let originReadTimeout = originReadTimeout {
            try container.encode(originReadTimeout, forKey: ClientRuntime.Key("OriginReadTimeout"))
        }
        if let originSslProtocols = originSslProtocols {
            try container.encode(originSslProtocols, forKey: ClientRuntime.Key("OriginSslProtocols"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hTTPPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPPort)
        hTTPPort = hTTPPortDecoded
        let hTTPSPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPSPort)
        hTTPSPort = hTTPSPortDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginProtocolPolicy.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originReadTimeout)
        originReadTimeout = originReadTimeoutDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originKeepaliveTimeout)
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
    }
}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomOriginConfig(hTTPPort: \(Swift.String(describing: hTTPPort)), hTTPSPort: \(Swift.String(describing: hTTPSPort)), originKeepaliveTimeout: \(Swift.String(describing: originKeepaliveTimeout)), originProtocolPolicy: \(Swift.String(describing: originProtocolPolicy)), originReadTimeout: \(Swift.String(describing: originReadTimeout)), originSslProtocols: \(Swift.String(describing: originSslProtocols)))"}
}

extension CloudFrontClientTypes.CustomOriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct CustomOriginConfig: Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        /// This member is required.
        public var hTTPPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        /// This member is required.
        public var hTTPSPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the Amazon CloudFront Developer Guide.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:
        ///
        /// * http-only – CloudFront always uses HTTP to connect to the origin.
        ///
        /// * match-viewer – CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.
        ///
        /// * https-only – CloudFront always uses HTTPS to connect to the origin.
        /// This member is required.
        public var originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the origin response timeout. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the Amazon CloudFront Developer Guide.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include SSLv3, TLSv1, TLSv1.1, and TLSv1.2. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the Amazon CloudFront Developer Guide.
        public var originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init (
            hTTPPort: Swift.Int? = nil,
            hTTPSPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.hTTPPort = hTTPPort
            self.hTTPSPort = hTTPSPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultCacheBehavior(allowedMethods: \(Swift.String(describing: allowedMethods)), cachePolicyId: \(Swift.String(describing: cachePolicyId)), compress: \(Swift.String(describing: compress)), defaultTTL: \(Swift.String(describing: defaultTTL)), fieldLevelEncryptionId: \(Swift.String(describing: fieldLevelEncryptionId)), forwardedValues: \(Swift.String(describing: forwardedValues)), functionAssociations: \(Swift.String(describing: functionAssociations)), lambdaFunctionAssociations: \(Swift.String(describing: lambdaFunctionAssociations)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), smoothStreaming: \(Swift.String(describing: smoothStreaming)), targetOriginId: \(Swift.String(describing: targetOriginId)), trustedKeyGroups: \(Swift.String(describing: trustedKeyGroups)), trustedSigners: \(Swift.String(describing: trustedSigners)), viewerProtocolPolicy: \(Swift.String(describing: viewerProtocolPolicy)))"}
}

extension CloudFrontClientTypes.DefaultCacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that describes the default cache behavior if you don’t specify a CacheBehavior element or if request URLs don’t match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
    public struct DefaultCacheBehavior: Swift.Equatable {
        /// A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:
        ///
        /// * CloudFront forwards only GET and HEAD requests.
        ///
        /// * CloudFront forwards only GET, HEAD, and OPTIONS requests.
        ///
        /// * CloudFront forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests.
        ///
        ///
        /// If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        public var allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId.
        public var cachePolicyId: Swift.String?
        /// Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the Amazon CloudFront Developer Guide.
        public var compress: Swift.Bool?
        /// This field is deprecated. We recommend that you use the DefaultTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var defaultTTL: Swift.Int?
        /// The value of ID for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        public var fieldLevelEncryptionId: Swift.String?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the Amazon CloudFront Developer Guide. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide. A DefaultCacheBehavior must include either a CachePolicyId or ForwardedValues. We recommend that you use a CachePolicyId. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        @available(*, deprecated)
        public var forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        public var lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// This field is deprecated. We recommend that you use the MaxTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as Cache-Control max-age, Cache-Control s-maxage, and Expires to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        @available(*, deprecated)
        public var maxTTL: Swift.Int?
        /// This field is deprecated. We recommend that you use the MinTTL field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the Amazon CloudFront Developer Guide. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide. You must specify 0 for MinTTL if you configure CloudFront to forward all headers to your origin (under Headers, if you specify 1 for Quantity and * for Name).
        @available(*, deprecated)
        public var minTTL: Swift.Int?
        /// The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the Amazon CloudFront Developer Guide.
        public var originRequestPolicyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the Amazon CloudFront Developer Guide.
        public var realtimeLogConfigArn: Swift.String?
        /// Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify true; if not, specify false. If you specify true for SmoothStreaming, you can still distribute other content using this cache behavior if the content matches the value of PathPattern.
        public var smoothStreaming: Swift.Bool?
        /// The value of ID for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        /// This member is required.
        public var targetOriginId: Swift.String?
        /// A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. A list of account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer’s account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// The protocol that viewers can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. You can specify the following options:
        ///
        /// * allow-all: Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.
        ///
        /// * https-only: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).
        ///
        ///
        /// For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the Amazon CloudFront Developer Guide. The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension DeleteCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCachePolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy that you are deleting. To get the identifier, you can use ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are deleting. The version is the cache policy’s ETag value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCachePolicyInputBody: Swift.Equatable {
}

extension DeleteCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyInUse" : self = .cachePolicyInUse(try CachePolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyInUse(CachePolicyInUse)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCachePolicyOutputResponse()"}
}

extension DeleteCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCachePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCachePolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteCachePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCloudFrontOriginAccessIdentityInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

public struct DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

public struct DeleteCloudFrontOriginAccessIdentityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

public struct DeleteCloudFrontOriginAccessIdentityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

/// Deletes a origin access identity.
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The origin access identity's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header you received from a previous GET or PUT request. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudFrontOriginAccessIdentityInUse" : self = .cloudFrontOriginAccessIdentityInUse(try CloudFrontOriginAccessIdentityInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cloudFrontOriginAccessIdentityInUse(CloudFrontOriginAccessIdentityInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCloudFrontOriginAccessIdentityOutputResponse()"}
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

public struct DeleteDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

public struct DeleteDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

public struct DeleteDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

/// This action deletes a web distribution. To delete a web distribution using the CloudFront API, perform the following steps. To delete a web distribution using the CloudFront API:
///
/// * Disable the web distribution
///
/// * Submit a GET Distribution Config request to get the current configuration and the Etag header for the distribution.
///
/// * Update the XML document that was returned in the response to your GET Distribution Config request to change the value of Enabled to false.
///
/// * Submit a PUT Distribution Config request to update the configuration for your distribution. In the request body, include the XML document that you updated in Step 3. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 2.
///
/// * Review the response to the PUT Distribution Config request to confirm that the distribution was successfully disabled.
///
/// * Submit a GET Distribution request to confirm that your changes have propagated. When propagation is complete, the value of Status is Deployed.
///
/// * Submit a DELETE Distribution request. Set the value of the HTTP If-Match header to the value of the ETag header that CloudFront returned when you submitted the GET Distribution Config request in Step 6.
///
/// * Review the response to your DELETE Distribution request to confirm that the distribution was successfully deleted.
///
///
/// For information about deleting a distribution using the CloudFront console, see [Deleting a Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html) in the Amazon CloudFront Developer Guide.
public struct DeleteDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteDistributionInputBody: Swift.Equatable {
}

extension DeleteDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionNotDisabled" : self = .distributionNotDisabled(try DistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case distributionNotDisabled(DistributionNotDisabled)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchDistribution(NoSuchDistribution)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionOutputResponse()"}
}

extension DeleteDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDistributionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDistributionOutputResponseBody: Swift.Equatable {
}

extension DeleteDistributionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionConfigInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// The ID of the configuration you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionConfigInUse" : self = .fieldLevelEncryptionConfigInUse(try FieldLevelEncryptionConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionConfigInUse(FieldLevelEncryptionConfigInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionConfigOutputResponse()"}
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionProfileInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request the ID of the profile you want to delete from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileInUse" : self = .fieldLevelEncryptionProfileInUse(try FieldLevelEncryptionProfileInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileInUse(FieldLevelEncryptionProfileInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionProfileOutputResponse()"}
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension DeleteFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are deleting, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are deleting.
    /// This member is required.
    public var name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionInUse" : self = .functionInUse(try FunctionInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionInUse(FunctionInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKeyGroupInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/key-group/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are deleting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are deleting. The version is the key group’s ETag value. To get the ETag, use GetKeyGroup or GetKeyGroupConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteKeyGroupInputBody: Swift.Equatable {
}

extension DeleteKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKeyGroupOutputResponse()"}
}

extension DeleteKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKeyGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteKeyGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteKeyGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)))"}
}

extension DeleteMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are disabling metrics for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct DeleteMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMonitoringSubscriptionOutputResponse()"}
}

extension DeleteMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitoringSubscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginRequestPolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are deleting. To get the identifier, you can use ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are deleting. The version is the origin request policy’s ETag value, which you can get using ListOriginRequestPolicies, GetOriginRequestPolicy, or GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginRequestPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyInUse" : self = .originRequestPolicyInUse(try OriginRequestPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyInUse(OriginRequestPolicyInUse)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginRequestPolicyOutputResponse()"}
}

extension DeleteOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginRequestPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOriginRequestPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePublicKeyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeletePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/public-key/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInput: Swift.Equatable {
    /// The ID of the public key you want to remove from CloudFront.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key identity to delete. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeletePublicKeyInputBody: Swift.Equatable {
}

extension DeletePublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyInUse" : self = .publicKeyInUse(try PublicKeyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case publicKeyInUse(PublicKeyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePublicKeyOutputResponse()"}
}

extension DeletePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePublicKeyOutputResponseBody: Swift.Equatable {
}

extension DeletePublicKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

extension DeleteRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension DeleteRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct DeleteRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/delete-realtime-log-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to delete.
    public var aRN: Swift.String?
    /// The name of the real-time log configuration to delete.
    public var name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteRealtimeLogConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let aRN: Swift.String?
}

extension DeleteRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension DeleteRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigInUse" : self = .realtimeLogConfigInUse(try RealtimeLogConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigInUse(RealtimeLogConfigInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRealtimeLogConfigOutputResponse()"}
}

extension DeleteRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRealtimeLogConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRealtimeLogConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteRealtimeLogConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

public struct DeleteStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

public struct DeleteStreamingDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

public struct DeleteStreamingDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

/// The request to delete a streaming distribution.
public struct DeleteStreamingDistributionInput: Swift.Equatable {
    /// The distribution ID.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when you disabled the streaming distribution. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteStreamingDistributionInputBody: Swift.Equatable {
}

extension DeleteStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionNotDisabled" : self = .streamingDistributionNotDisabled(try StreamingDistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case streamingDistributionNotDisabled(StreamingDistributionNotDisabled)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingDistributionOutputResponse()"}
}

extension DeleteStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamingDistributionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStreamingDistributionOutputResponseBody: Swift.Equatable {
}

extension DeleteStreamingDistributionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFunctionInput(name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension DescribeFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())/describe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInput: Swift.Equatable {
    /// The name of the function that you are getting information about.
    /// This member is required.
    public var name: Swift.String?
    /// The function’s stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct DescribeFunctionInputBody: Swift.Equatable {
}

extension DescribeFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension DescribeFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct DescribeFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct DescribeFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension DescribeFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.Distribution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedKeyGroups = "ActiveTrustedKeyGroups"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case aliasICPRecordals = "AliasICPRecordals"
        case distributionConfig = "DistributionConfig"
        case domainName = "DomainName"
        case id = "Id"
        case inProgressInvalidationBatches = "InProgressInvalidationBatches"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedKeyGroups = activeTrustedKeyGroups {
            try container.encode(activeTrustedKeyGroups, forKey: ClientRuntime.Key("ActiveTrustedKeyGroups"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let inProgressInvalidationBatches = inProgressInvalidationBatches {
            try container.encode(inProgressInvalidationBatches, forKey: ClientRuntime.Key("InProgressInvalidationBatches"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let inProgressInvalidationBatchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressInvalidationBatches)
        inProgressInvalidationBatches = inProgressInvalidationBatchesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let activeTrustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedKeyGroups.self, forKey: .activeTrustedKeyGroups)
        activeTrustedKeyGroups = activeTrustedKeyGroupsDecoded
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.Distribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Distribution(aRN: \(Swift.String(describing: aRN)), activeTrustedKeyGroups: \(Swift.String(describing: activeTrustedKeyGroups)), activeTrustedSigners: \(Swift.String(describing: activeTrustedSigners)), aliasICPRecordals: \(Swift.String(describing: aliasICPRecordals)), distributionConfig: \(Swift.String(describing: distributionConfig)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), inProgressInvalidationBatches: \(Swift.String(describing: inProgressInvalidationBatches)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.Distribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution tells CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery.
    public struct Distribution: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// CloudFront automatically adds this field to the response if you’ve configured a cache behavior in this distribution to serve private content using key groups. This field contains a list of key groups and the public keys in each key group that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// We recommend using TrustedKeyGroups instead of TrustedSigners. CloudFront automatically adds this field to the response if you’ve configured a cache behavior in this distribution to serve private content using trusted signers. This field contains a list of account IDs and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs or signed cookies.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// The current configuration information for the distribution. Send a GET request to the /CloudFront API version/distribution ID/config resource.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The number of invalidation batches currently in progress.
        /// This member is required.
        public var inProgressInvalidationBatches: Swift.Int?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// This response element indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension DistributionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension DistributionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller reference you attempted to create the distribution with is associated with another distribution.
public struct DistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case isIPV6Enabled = "IsIPV6Enabled"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let defaultRootObject = defaultRootObject {
            try container.encode(defaultRootObject, forKey: ClientRuntime.Key("DefaultRootObject"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfig(aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), defaultRootObject: \(Swift.String(describing: defaultRootObject)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), logging: \(Swift.String(describing: logging)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension CloudFrontClientTypes.DistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution configuration.
    public struct DistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the DistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment to describe the distribution. The comment cannot be longer than 128 characters.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that controls the following:
        ///
        /// * Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.
        ///
        /// * How long CloudFront caches HTTP status codes in the 4xx and 5xx range.
        ///
        ///
        /// For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the Amazon CloudFront Developer Guide.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, index.html. Don't add a / before the object name. If you don't want to specify a default root object when you create a distribution, include an empty DefaultRootObject element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty DefaultRootObject element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the Amazon CloudFront Developer Guide.
        public var defaultRootObject: Swift.String?
        /// From this field, you can enable or disable the selected distribution.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// (Optional) Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 automatically use an earlier HTTP version. For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must support Server Name Identification (SNI). In general, configuring CloudFront to communicate with viewers using HTTP/2 reduces latency. You can improve performance by optimizing for HTTP/2. For more information, do an Internet search for "http/2 optimization."
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify true. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the IpAddress parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the Amazon CloudFront Developer Guide. If you're using an Route 53 Amazon Web Services Integration alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:
        ///
        /// * You enable IPv6 for the distribution
        ///
        /// * You're using alternate domain names in the URLs for your objects
        ///
        ///
        /// For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the Route 53 Amazon Web Services Integration Developer Guide. If you created a CNAME resource record set, either with Route 53 Amazon Web Services Integration or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        public var isIPV6Enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the Amazon CloudFront Developer Guide.
        public var logging: CloudFrontClientTypes.LoggingConfig?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the Amazon CloudFront Developer Guide. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](http://aws.amazon.com/cloudfront/pricing/).
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a. WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        public var webACLId: Swift.String?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfigWithTags(distributionConfig: \(Swift.String(describing: distributionConfig)), tags: \(Swift.String(describing: tags)))"}
}

extension CloudFrontClientTypes.DistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution Configuration and a list of tags to be associated with the distribution.
    public struct DistributionConfigWithTags: Swift.Equatable {
        /// A distribution configuration.
        /// This member is required.
        public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init (
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.DistributionIdList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("DistributionId"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionIdList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionIdList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.DistributionIdList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of distribution IDs.
    public struct DistributionIdList: Swift.Equatable {
        /// A flag that indicates whether more distribution IDs remain to be listed. If your results were truncated, you can make a subsequent request using the Marker request field to retrieve more distribution IDs in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the distribution IDs in the list.
        public var items: [Swift.String]?
        /// The value provided in the Marker request field.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of distribution IDs requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// Contains the value that you should use in the Marker field of a subsequent request to continue listing distribution IDs where you left off.
        public var nextMarker: Swift.String?
        /// The total number of distribution IDs returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.DistributionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for distributionsummary0 in items {
                try itemsContainer.encode(distributionsummary0, forKey: ClientRuntime.Key("DistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.DistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.DistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.DistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.DistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A distribution list.
    public struct DistributionList: Swift.Equatable {
        /// A flag that indicates whether more distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one DistributionSummary element for each distribution that was created by the current account.
        public var items: [CloudFrontClientTypes.DistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of distributions that were created by the current account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension DistributionNotDisabled: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionNotDisabled(message: \(Swift.String(describing: message)))"}
}

extension DistributionNotDisabled {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct DistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionNotDisabledBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliasICPRecordals = "AliasICPRecordals"
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case id = "Id"
        case isIPV6Enabled = "IsIPV6Enabled"
        case lastModifiedTime = "LastModifiedTime"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionSummary(aRN: \(Swift.String(describing: aRN)), aliasICPRecordals: \(Swift.String(describing: aliasICPRecordals)), aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), comment: \(Swift.String(describing: comment)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), domainName: \(Swift.String(describing: domainName)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), id: \(Swift.String(describing: id)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), status: \(Swift.String(describing: status)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension CloudFrontClientTypes.DistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information about a CloudFront distribution.
    public struct DistributionSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// Amazon Web Services services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP recordal status for CNAMEs associated with distributions. For more information about ICP recordals, see [ Signup, Accounts, and Credentials](https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html) in Getting Started with Amazon Web Services services in China.
        public var aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A complex type that contains zero or more CacheBehavior elements.
        /// This member is required.
        public var cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// A complex type that contains zero or more CustomErrorResponses elements.
        /// This member is required.
        public var customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// A complex type that describes the default cache behavior if you don't specify a CacheBehavior element or if files don't match any of the values of PathPattern in CacheBehavior elements. You must create exactly one default cache behavior.
        /// This member is required.
        public var defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// The domain name that corresponds to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. The default value for new web distributions is http2. Viewers that don't support HTTP/2 will automatically use an earlier version.
        /// This member is required.
        public var httpVersion: CloudFrontClientTypes.HttpVersion?
        /// The identifier for the distribution. For example: EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your distribution.
        /// This member is required.
        public var isIPV6Enabled: Swift.Bool?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about origin groups for this distribution.
        public var originGroups: CloudFrontClientTypes.OriginGroups?
        /// A complex type that contains information about origins for this distribution.
        /// This member is required.
        public var origins: CloudFrontClientTypes.Origins?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that identifies ways in which you want to restrict distribution of your content.
        /// This member is required.
        public var restrictions: CloudFrontClientTypes.Restrictions?
        /// The current status of the distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers.
        /// This member is required.
        public var viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// The Web ACL Id (if any) associated with the distribution.
        /// This member is required.
        public var webACLId: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntities: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for encryptionentity0 in items {
                try itemsContainer.encode(encryptionentity0, forKey: ClientRuntime.Key("EncryptionEntity"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct EncryptionEntity{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EncryptionEntity>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EncryptionEntity].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.EncryptionEntity]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.EncryptionEntity]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.EncryptionEntities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionEntities(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.EncryptionEntities: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes all of the encryption entities.
    public struct EncryptionEntities: Swift.Equatable {
        /// An array of field patterns in a field-level encryption content type-profile mapping.
        public var items: [CloudFrontClientTypes.EncryptionEntity]?
        /// Number of field pattern items in a field-level encryption content type-profile mapping.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPatterns = "FieldPatterns"
        case providerId = "ProviderId"
        case publicKeyId = "PublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldPatterns = fieldPatterns {
            try container.encode(fieldPatterns, forKey: ClientRuntime.Key("FieldPatterns"))
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let publicKeyId = publicKeyId {
            try container.encode(publicKeyId, forKey: ClientRuntime.Key("PublicKeyId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyId)
        publicKeyId = publicKeyIdDecoded
        let providerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerId)
        providerId = providerIdDecoded
        let fieldPatternsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldPatterns.self, forKey: .fieldPatterns)
        fieldPatterns = fieldPatternsDecoded
    }
}

extension CloudFrontClientTypes.EncryptionEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionEntity(fieldPatterns: \(Swift.String(describing: fieldPatterns)), providerId: \(Swift.String(describing: providerId)), publicKeyId: \(Swift.String(describing: publicKeyId)))"}
}

extension CloudFrontClientTypes.EncryptionEntity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications.
    public struct EncryptionEntity: Swift.Equatable {
        /// Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have both ABC* and AB*. Note that field patterns are case-sensitive.
        /// This member is required.
        public var fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// The provider associated with the public key being used for encryption. This value must also be provided with the private key for applications to be able to decrypt data.
        /// This member is required.
        public var providerId: Swift.String?
        /// The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match the patterns.
        /// This member is required.
        public var publicKeyId: Swift.String?

        public init (
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }

}

extension CloudFrontClientTypes.EndPoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamConfig = "KinesisStreamConfig"
        case streamType = "StreamType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try container.encode(kinesisStreamConfig, forKey: ClientRuntime.Key("KinesisStreamConfig"))
        }
        if let streamType = streamType {
            try container.encode(streamType, forKey: ClientRuntime.Key("StreamType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamType)
        streamType = streamTypeDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
    }
}

extension CloudFrontClientTypes.EndPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndPoint(kinesisStreamConfig: \(Swift.String(describing: kinesisStreamConfig)), streamType: \(Swift.String(describing: streamType)))"}
}

extension CloudFrontClientTypes.EndPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data in a real-time log configuration.
    public struct EndPoint: Swift.Equatable {
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
        public var kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// The type of data stream where you are sending real-time log data. The only valid value is Kinesis.
        /// This member is required.
        public var streamType: Swift.String?

        public init (
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }

}

extension CloudFrontClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryption(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations and other options specified for field-level encryption.
    public struct FieldLevelEncryption: Swift.Equatable {
        /// A complex data type that includes the profile configurations specified for field-level encryption.
        /// This member is required.
        public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption configuration was changed.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), contentTypeProfileConfig: \(Swift.String(describing: contentTypeProfileConfig)), queryArgProfileConfig: \(Swift.String(describing: queryArgProfileConfig)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the profile configurations specified for field-level encryption.
    public struct FieldLevelEncryptionConfig: Swift.Equatable {
        /// A unique number that ensures the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment about the configuration. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default in a request if a query argument doesn't specify a profile to use.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a query argument in a request.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension FieldLevelEncryptionConfigAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfigAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionConfigAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption already exists.
public struct FieldLevelEncryptionConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionConfigInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfigInUse(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionConfigInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption is in use.
public struct FieldLevelEncryptionConfigInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionsummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionsummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encrpytion configurations.
    public struct FieldLevelEncryptionList: Swift.Equatable {
        /// An array of field-level encryption items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// The maximum number of elements you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your configurations where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption items.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfile(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for field-level encryption profiles.
    public struct FieldLevelEncryptionProfile: Swift.Equatable {
        /// A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.
        /// This member is required.
        public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain selected data fields to be encrypted by specific public keys.
        /// This member is required.
        public var id: Swift.String?
        /// The last time the field-level encryption profile was updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension FieldLevelEncryptionProfileAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption already exists.
public struct FieldLevelEncryptionProfileAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), encryptionEntities: \(Swift.String(describing: encryptionEntities)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type of profiles for the field-level encryption.
    public struct FieldLevelEncryptionProfileConfig: Swift.Equatable {
        /// A unique number that ensures that the request can't be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// An optional comment for the field-level encryption profile. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// Profile name for the field-level encryption profile.
        /// This member is required.
        public var name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }

}

extension FieldLevelEncryptionProfileInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileInUse(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption is in use.
public struct FieldLevelEncryptionProfileInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionprofilesummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionprofilesummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionProfileSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionProfileSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionProfileSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// List of field-level encryption profiles.
    public struct FieldLevelEncryptionProfileList: Swift.Equatable {
        /// The field-level encryption profile items.
        public var items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// The maximum number of field-level encryption profiles you want in the response body.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your profiles where you left off.
        public var nextMarker: Swift.String?
        /// The number of field-level encryption profiles.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension FieldLevelEncryptionProfileSizeExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileSizeExceeded(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileSizeExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FieldLevelEncryptionProfileSizeExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum size of a profile for field-level encryption was exceeded.
public struct FieldLevelEncryptionProfileSizeExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileSizeExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileSummary(comment: \(Swift.String(describing: comment)), encryptionEntities: \(Swift.String(describing: encryptionEntities)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The field-level encryption profile summary.
    public struct FieldLevelEncryptionProfileSummary: Swift.Equatable {
        /// An optional comment for the field-level encryption profile summary. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and field patterns for specifying which fields to encrypt with this key.
        /// This member is required.
        public var encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// ID for the field-level encryption profile summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the the field-level encryption profile summary was last updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Name for the field-level encryption profile summary.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionSummary(comment: \(Swift.String(describing: comment)), contentTypeProfileConfig: \(Swift.String(describing: contentTypeProfileConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), queryArgProfileConfig: \(Swift.String(describing: queryArgProfileConfig)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of a field-level encryption item.
    public struct FieldLevelEncryptionSummary: Swift.Equatable {
        /// An optional comment about the field-level encryption item. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A summary of a content type-profile mapping.
        public var contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// The unique ID of a field-level encryption item.
        /// This member is required.
        public var id: Swift.String?
        /// The last time that the summary of field-level encryption items was modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A summary of a query argument-profile mapping.
        public var queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension CloudFrontClientTypes.FieldPatterns: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("FieldPattern"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldPattern{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldPattern>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldPatterns: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldPatterns(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldPatterns: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes the field patterns to match for field-level encryption.
    public struct FieldPatterns: Swift.Equatable {
        /// An array of the field-level encryption field patterns.
        public var items: [Swift.String]?
        /// The number of field-level encryption field patterns.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookies = "Cookies"
        case headers = "Headers"
        case queryString = "QueryString"
        case queryStringCacheKeys = "QueryStringCacheKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
        if let queryString = queryString {
            try container.encode(queryString, forKey: ClientRuntime.Key("QueryString"))
        }
        if let queryStringCacheKeys = queryStringCacheKeys {
            try container.encode(queryStringCacheKeys, forKey: ClientRuntime.Key("QueryStringCacheKeys"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queryString)
        queryString = queryStringDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookiePreference.self, forKey: .cookies)
        cookies = cookiesDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
        let queryStringCacheKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringCacheKeys.self, forKey: .queryStringCacheKeys)
        queryStringCacheKeys = queryStringCacheKeysDecoded
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForwardedValues(cookies: \(Swift.String(describing: cookies)), headers: \(Swift.String(describing: headers)), queryString: \(Swift.String(describing: queryString)), queryStringCacheKeys: \(Swift.String(describing: queryStringCacheKeys)))"}
}

extension CloudFrontClientTypes.ForwardedValues: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
    public struct ForwardedValues: Swift.Equatable {
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var cookies: CloudFrontClientTypes.CookiePreference?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that specifies the Headers, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [ Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the Amazon CloudFront Developer Guide.
        public var headers: CloudFrontClientTypes.Headers?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of QueryString and on the values that you specify for QueryStringCacheKeys, if any: If you specify true for QueryString and you don't specify any values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for QueryString and you specify one or more values for QueryStringCacheKeys, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for QueryString, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var queryString: Swift.Bool?
        /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the Amazon CloudFront Developer Guide. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the Amazon CloudFront Developer Guide. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        public var queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init (
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }

}

extension FunctionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FunctionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A function with the same name already exists in this account. To create a function, you must provide a unique name. To update an existing function, use UpdateFunction.
public struct FunctionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case functionARN = "FunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAssociation(eventType: \(Swift.String(describing: eventType)), functionARN: \(Swift.String(describing: functionARN)))"}
}

extension CloudFrontClientTypes.FunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A CloudFront function that is associated with a cache behavior in a CloudFront distribution.
    public struct FunctionAssociation: Swift.Equatable {
        /// The event type of the function, either viewer-request or viewer-response. You cannot use origin-facing event types (origin-request and origin-response) with a CloudFront function.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// The Amazon Resource Name (ARN) of the function.
        /// This member is required.
        public var functionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }

}

extension CloudFrontClientTypes.FunctionAssociations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionassociation0 in items {
                try itemsContainer.encode(functionassociation0, forKey: ClientRuntime.Key("FunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAssociations(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
    public struct FunctionAssociations: Swift.Equatable {
        /// The CloudFront functions that are associated with a cache behavior in a CloudFront distribution. CloudFront functions must be published to the LIVE stage to associate them with a cache behavior.
        public var items: [CloudFrontClientTypes.FunctionAssociation]?
        /// The number of CloudFront functions in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case runtime = "Runtime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let runtime = runtime {
            try container.encode(runtime, forKey: ClientRuntime.Key("Runtime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension CloudFrontClientTypes.FunctionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionConfig(comment: \(Swift.String(describing: comment)), runtime: \(Swift.String(describing: runtime)))"}
}

extension CloudFrontClientTypes.FunctionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information about a CloudFront function.
    public struct FunctionConfig: Swift.Equatable {
        /// A comment to describe the function.
        /// This member is required.
        public var comment: Swift.String?
        /// The function’s runtime environment. The only valid value is cloudfront-js-1.0.
        /// This member is required.
        public var runtime: CloudFrontClientTypes.FunctionRuntime?

        public init (
            comment: Swift.String? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.runtime = runtime
        }
    }

}

extension FunctionInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionInUse(message: \(Swift.String(describing: message)))"}
}

extension FunctionInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the function because it’s attached to one or more cache behaviors.
public struct FunctionInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionsummary0 in items {
                try itemsContainer.encode(functionsummary0, forKey: ClientRuntime.Key("FunctionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FunctionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront functions.
    public struct FunctionList: Swift.Equatable {
        /// Contains the functions in the list.
        public var items: [CloudFrontClientTypes.FunctionSummary]?
        /// The maximum number of functions requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing functions where you left off.
        public var nextMarker: Swift.String?
        /// The number of functions returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case functionARN = "FunctionARN"
        case lastModifiedTime = "LastModifiedTime"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
    }
}

extension CloudFrontClientTypes.FunctionMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionMetadata(createdTime: \(Swift.String(describing: createdTime)), functionARN: \(Swift.String(describing: functionARN)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), stage: \(Swift.String(describing: stage)))"}
}

extension CloudFrontClientTypes.FunctionMetadata: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains metadata about a CloudFront function.
    public struct FunctionMetadata: Swift.Equatable {
        /// The date and time when the function was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the function.
        /// This member is required.
        public var functionARN: Swift.String?
        /// The date and time when the function was most recently updated.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The stage that the function is in, either DEVELOPMENT or LIVE. When a function is in the DEVELOPMENT stage, you can test the function with TestFunction, and update it with UpdateFunction. When a function is in the LIVE stage, you can attach the function to a distribution’s cache behavior, using the function’s ARN.
        public var stage: CloudFrontClientTypes.FunctionStage?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }

}

extension CloudFrontClientTypes {
    public enum FunctionRuntime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontJs10
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
        }
    }
}

extension FunctionSizeLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionSizeLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension FunctionSizeLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<FunctionSizeLimitExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function is too large. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct FunctionSizeLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionSizeLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum FunctionStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfig = "FunctionConfig"
        case functionMetadata = "FunctionMetadata"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let functionMetadata = functionMetadata {
            try container.encode(functionMetadata, forKey: ClientRuntime.Key("FunctionMetadata"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        let functionMetadataDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionMetadata.self, forKey: .functionMetadata)
        functionMetadata = functionMetadataDecoded
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionSummary(functionConfig: \(Swift.String(describing: functionConfig)), functionMetadata: \(Swift.String(describing: functionMetadata)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.FunctionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains configuration information and metadata about a CloudFront function.
    public struct FunctionSummary: Swift.Equatable {
        /// Contains configuration information about a CloudFront function.
        /// This member is required.
        public var functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// Contains metadata about a CloudFront function.
        /// This member is required.
        public var functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// The name of the CloudFront function.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the CloudFront function.
        public var status: Swift.String?

        public init (
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.GeoRestriction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
        case restrictionType = "RestrictionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Location"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
        if let restrictionType = restrictionType {
            try container.encode(restrictionType, forKey: ClientRuntime.Key("RestrictionType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestrictionType.self, forKey: .restrictionType)
        restrictionType = restrictionTypeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Location{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Location>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.GeoRestriction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeoRestriction(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)), restrictionType: \(Swift.String(describing: restrictionType)))"}
}

extension CloudFrontClientTypes.GeoRestriction: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
    public struct GeoRestriction: Swift.Equatable {
        /// A complex type that contains a Location element for each country in which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). The Location element is a two-letter, uppercase country code for a country that you want to include in your blacklist or whitelist. Include one Location element for each country. CloudFront and MaxMind both use ISO 3166 country codes. For the current list of countries and the corresponding codes, see ISO 3166-1-alpha-2 code on the International Organization for Standardization website. You can also refer to the country list on the CloudFront console, which includes both country names and codes.
        public var items: [Swift.String]?
        /// When geo restriction is enabled, this is the number of countries in your whitelist or blacklist. Otherwise, when it is not enabled, Quantity is 0, and you can omit Items.
        /// This member is required.
        public var quantity: Swift.Int?
        /// The method that you want to use to restrict distribution of your content by country:
        ///
        /// * none: No geo restriction is enabled, meaning access to content is not restricted by client geo location.
        ///
        /// * blacklist: The Location elements specify the countries in which you don't want CloudFront to distribute your content.
        ///
        /// * whitelist: The Location elements specify the countries in which you want CloudFront to distribute your content.
        /// This member is required.
        public var restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }

}

extension CloudFrontClientTypes {
    public enum GeoRestrictionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
        }
    }
}

extension GetCachePolicyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetCachePolicyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCachePolicyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCachePolicyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCachePolicyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCachePolicyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/cache-policy/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCachePolicyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyConfigInputBody: Swift.Equatable {
}

extension GetCachePolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyConfigOutputResponse(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCachePolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyConfig = try responseDecoder.decode(responseBody: data)
                self.cachePolicyConfig = output
            } else {
                self.cachePolicyConfig = nil
            }
        } else {
            self.cachePolicyConfig = nil
        }
    }
}

public struct GetCachePolicyConfigOutputResponse: Swift.Equatable {
    /// The cache policy configuration.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

struct GetCachePolicyConfigOutputResponseBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension GetCachePolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension GetCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyInput(id: \(Swift.String(describing: id)))"}
}

extension GetCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInput: Swift.Equatable {
    /// The unique identifier for the cache policy. If the cache policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the cache policy is not attached to a cache behavior, you can get the identifier using ListCachePolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyInputBody: Swift.Equatable {
}

extension GetCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct GetCachePolicyOutputResponse: Swift.Equatable {
    /// The cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct GetCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension GetCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

public struct GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

public struct GetCloudFrontOriginAccessIdentityConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCloudFrontOriginAccessIdentityConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFrontOriginAccessIdentityConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

public struct GetCloudFrontOriginAccessIdentityConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCloudFrontOriginAccessIdentityConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFrontOriginAccessIdentityConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

/// The origin access identity's configuration information. For more information, see [CloudFrontOriginAccessIdentityConfig](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html).
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityConfigOutputResponse(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityConfig = output
            } else {
                self.cloudFrontOriginAccessIdentityConfig = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityConfigOutputResponse: Swift.Equatable {
    /// The origin access identity's configuration information.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityInput(id: \(Swift.String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

public struct GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

public struct GetCloudFrontOriginAccessIdentityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

public struct GetCloudFrontOriginAccessIdentityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

/// The request to get an origin access identity's information.
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the origin access identity's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

extension GetDistributionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetDistributionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDistributionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

public struct GetDistributionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

public struct GetDistributionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDistributionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

public struct GetDistributionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDistributionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

/// The request to get a distribution configuration.
public struct GetDistributionConfigInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionConfigInputBody: Swift.Equatable {
}

extension GetDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigOutputResponse(distributionConfig: \(Swift.String(describing: distributionConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionConfig = try responseDecoder.decode(responseBody: data)
                self.distributionConfig = output
            } else {
                self.distributionConfig = nil
            }
        } else {
            self.distributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionConfigOutputResponse: Swift.Equatable {
    /// The distribution's configuration information.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

struct GetDistributionConfigOutputResponseBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension GetDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension GetDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionInput(id: \(Swift.String(describing: id)))"}
}

extension GetDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

public struct GetDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

public struct GetDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

public struct GetDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

/// The request to get a distribution's information.
public struct GetDistributionInput: Swift.Equatable {
    /// The distribution's ID. If the ID is empty, an empty distribution configuration is returned.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionInputBody: Swift.Equatable {
}

extension GetDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct GetDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension GetDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

extension GetFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)))"}
}

extension GetFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionConfig = output
            } else {
                self.fieldLevelEncryptionConfig = nil
            }
        } else {
            self.fieldLevelEncryptionConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension GetFieldLevelEncryptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInput: Swift.Equatable {
    /// Request the ID for the field-level encryption configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)))"}
}

extension GetFieldLevelEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct GetFieldLevelEncryptionOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption configuration information.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct GetFieldLevelEncryptionOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension GetFieldLevelEncryptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

extension GetFieldLevelEncryptionProfileConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionProfileConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionProfileConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionProfileConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionProfileConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile configuration information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileConfig = output
            } else {
                self.fieldLevelEncryptionProfileConfig = nil
            }
        } else {
            self.fieldLevelEncryptionProfileConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutputResponse: Swift.Equatable {
    /// The current version of the field-level encryption profile configuration result. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile configuration information.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension GetFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Get the ID for the field-level encryption profile information.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)))"}
}

extension GetFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The current version of the field level encryption profile. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the field-level encryption profile information.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension GetFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionInput(name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension GetFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Swift.Equatable {
    /// The name of the function whose code you are getting.
    /// This member is required.
    public var name: Swift.String?
    /// The function’s stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutputResponse(contentType: \(Swift.String(describing: contentType)), eTag: \(Swift.String(describing: eTag)), functionCode: \(Swift.String(describing: functionCode)))"}
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.functionCode = data
        } else {
            self.functionCode = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// The content type (media type) of the response.
    public var contentType: Swift.String?
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// The function code of a CloudFront function.
    public var functionCode: ClientRuntime.Data?

    public init (
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    public let functionCode: ClientRuntime.Data?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension GetInvalidationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInvalidationInput(distributionId: \(Swift.String(describing: distributionId)), id: \(Swift.String(describing: id)))"}
}

extension GetInvalidationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetInvalidationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

public struct GetInvalidationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

public struct GetInvalidationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetInvalidationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInvalidationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

public struct GetInvalidationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetInvalidationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInvalidationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

/// The request to get an invalidation's information.
public struct GetInvalidationInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// The identifier for the invalidation request, for example, IDFDVBD632BHDS5.
    /// This member is required.
    public var id: Swift.String?

    public init (
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

struct GetInvalidationInputBody: Swift.Equatable {
}

extension GetInvalidationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchInvalidation" : self = .noSuchInvalidation(try NoSuchInvalidation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchInvalidation(NoSuchInvalidation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvalidationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInvalidationOutputResponse(invalidation: \(Swift.String(describing: invalidation)))"}
}

extension GetInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetInvalidationOutputResponse: Swift.Equatable {
    /// The invalidation's information. For more information, see [Invalidation Complex Type](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html).
    public var invalidation: CloudFrontClientTypes.Invalidation?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

struct GetInvalidationOutputResponseBody: Swift.Equatable {
    public let invalidation: CloudFrontClientTypes.Invalidation?
}

extension GetInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

extension GetKeyGroupConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetKeyGroupConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKeyGroupConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetKeyGroupConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetKeyGroupConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetKeyGroupConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/key-group/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetKeyGroupConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInput: Swift.Equatable {
    /// The identifier of the key group whose configuration you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupConfigInputBody: Swift.Equatable {
}

extension GetKeyGroupConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupConfigOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension GetKeyGroupConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupConfig = try responseDecoder.decode(responseBody: data)
                self.keyGroupConfig = output
            } else {
                self.keyGroupConfig = nil
            }
        } else {
            self.keyGroupConfig = nil
        }
    }
}

public struct GetKeyGroupConfigOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group configuration.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

struct GetKeyGroupConfigOutputResponseBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension GetKeyGroupConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension GetKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupInput(id: \(Swift.String(describing: id)))"}
}

extension GetKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/key-group/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are getting. To get the identifier, use ListKeyGroups.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupInputBody: Swift.Equatable {
}

extension GetKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension GetKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct GetKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct GetKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension GetKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension GetMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)))"}
}

extension GetMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMonitoringSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributions/\(distributionId.urlPercentEncoding())/monitoring-subscription"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMonitoringSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInput: Swift.Equatable {
    /// The ID of the distribution that you are getting metrics information for.
    /// This member is required.
    public var distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct GetMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension GetMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMonitoringSubscriptionOutputResponse(monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension GetMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct GetMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public var monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct GetMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension GetMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension GetOriginRequestPolicyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetOriginRequestPolicyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOriginRequestPolicyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOriginRequestPolicyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOriginRequestPolicyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOriginRequestPolicyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOriginRequestPolicyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyConfigInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension GetOriginRequestPolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyConfig = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyConfig = output
            } else {
                self.originRequestPolicyConfig = nil
            }
        } else {
            self.originRequestPolicyConfig = nil
        }
    }
}

public struct GetOriginRequestPolicyConfigOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy configuration.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct GetOriginRequestPolicyConfigOutputResponseBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension GetOriginRequestPolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension GetOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyInput(id: \(Swift.String(describing: id)))"}
}

extension GetOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy. If the origin request policy is attached to a distribution’s cache behavior, you can get the policy’s identifier using ListDistributions or GetDistribution. If the origin request policy is not attached to a cache behavior, you can get the identifier using ListOriginRequestPolicies.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension GetOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct GetOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// The origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct GetOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension GetOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension GetPublicKeyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetPublicKeyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPublicKeyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPublicKeyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPublicKeyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPublicKeyConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPublicKeyConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInput: Swift.Equatable {
    /// The identifier of the public key whose configuration you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyConfigInputBody: Swift.Equatable {
}

extension GetPublicKeyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension GetPublicKeyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyConfig = try responseDecoder.decode(responseBody: data)
                self.publicKeyConfig = output
            } else {
                self.publicKeyConfig = nil
            }
        } else {
            self.publicKeyConfig = nil
        }
    }
}

public struct GetPublicKeyConfigOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key configuration.
    public var eTag: Swift.String?
    /// A public key configuration.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

struct GetPublicKeyConfigOutputResponseBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension GetPublicKeyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension GetPublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyInput(id: \(Swift.String(describing: id)))"}
}

extension GetPublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/public-key/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInput: Swift.Equatable {
    /// The identifier of the public key you are getting.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyInputBody: Swift.Equatable {
}

extension GetPublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension GetPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct GetPublicKeyOutputResponse: Swift.Equatable {
    /// The identifier for this version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct GetPublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension GetPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct GetRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

extension GetRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension GetRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension GetRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct GetRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/get-realtime-log-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the real-time log configuration to get.
    public var aRN: Swift.String?
    /// The name of the real-time log configuration to get.
    public var name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct GetRealtimeLogConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let aRN: Swift.String?
}

extension GetRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension GetRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension GetRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct GetRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct GetRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension GetRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

extension GetStreamingDistributionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetStreamingDistributionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingDistributionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

public struct GetStreamingDistributionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

public struct GetStreamingDistributionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetStreamingDistributionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingDistributionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

public struct GetStreamingDistributionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetStreamingDistributionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingDistributionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

/// To request to get a streaming distribution configuration.
public struct GetStreamingDistributionConfigInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionConfigInputBody: Swift.Equatable {
}

extension GetStreamingDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension GetStreamingDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionConfig = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionConfig = output
            } else {
                self.streamingDistributionConfig = nil
            }
        } else {
            self.streamingDistributionConfig = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionConfigOutputResponse: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's configuration information.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct GetStreamingDistributionConfigOutputResponseBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension GetStreamingDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension GetStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionInput(id: \(Swift.String(describing: id)))"}
}

extension GetStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

public struct GetStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

public struct GetStreamingDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

public struct GetStreamingDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

/// The request to get a streaming distribution's information.
public struct GetStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionInputBody: Swift.Equatable {
}

extension GetStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension GetStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct GetStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the streaming distribution's information. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct GetStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension GetStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.Headers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Headers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Headers(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Headers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of HTTP header names.
    public struct Headers: Swift.Equatable {
        /// A list of HTTP header names.
        public var items: [Swift.String]?
        /// The number of header names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum HttpVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http11
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ICPRecordalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
        }
    }
}

extension IllegalDelete: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalDelete(message: \(Swift.String(describing: message)))"}
}

extension IllegalDelete {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalDeleteBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot delete a managed policy.
public struct IllegalDelete: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalDeleteBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalDeleteBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(message: \(Swift.String(describing: message)))"}
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption can't be associated with the specified cache behavior.
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalUpdate(message: \(Swift.String(describing: message)))"}
}

extension IllegalUpdate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IllegalUpdateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The update contains modifications that are not allowed.
public struct IllegalUpdate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUpdateBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InconsistentQuantities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InconsistentQuantities(message: \(Swift.String(describing: message)))"}
}

extension InconsistentQuantities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InconsistentQuantitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of Quantity and the size of Items don't match.
public struct InconsistentQuantities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InconsistentQuantitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InconsistentQuantitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgument(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgument {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidArgumentBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An argument is invalid.
public struct InvalidArgument: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefaultRootObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDefaultRootObject(message: \(Swift.String(describing: message)))"}
}

extension InvalidDefaultRootObject {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDefaultRootObjectBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The default root object file name is too big or contains an invalid character.
public struct InvalidDefaultRootObject: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefaultRootObjectBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDefaultRootObjectBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidErrorCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidErrorCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidErrorCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidErrorCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid error code was specified.
public struct InvalidErrorCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidErrorCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidErrorCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidForwardCookies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidForwardCookies(message: \(Swift.String(describing: message)))"}
}

extension InvalidForwardCookies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidForwardCookiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains forward cookies option which doesn't match with the expectation for the whitelisted list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.
public struct InvalidForwardCookies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidForwardCookiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidForwardCookiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFunctionAssociation(message: \(Swift.String(describing: message)))"}
}

extension InvalidFunctionAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A CloudFront function association is invalid.
public struct InvalidFunctionAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFunctionAssociationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGeoRestrictionParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidGeoRestrictionParameter(message: \(Swift.String(describing: message)))"}
}

extension InvalidGeoRestrictionParameter {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidGeoRestrictionParameterBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified geo restriction parameter is not valid.
public struct InvalidGeoRestrictionParameter: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGeoRestrictionParameterBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidGeoRestrictionParameterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHeadersForS3Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidHeadersForS3Origin(message: \(Swift.String(describing: message)))"}
}

extension InvalidHeadersForS3Origin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidHeadersForS3OriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The headers specified are not valid for an Amazon S3 origin.
public struct InvalidHeadersForS3Origin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHeadersForS3OriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidHeadersForS3OriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIfMatchVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidIfMatchVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidIfMatchVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidIfMatchVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The If-Match version is missing or not valid.
public struct InvalidIfMatchVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIfMatchVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidIfMatchVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLambdaFunctionAssociation(message: \(Swift.String(describing: message)))"}
}

extension InvalidLambdaFunctionAssociation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLambdaFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Lambda@Edge function association is invalid.
public struct InvalidLambdaFunctionAssociation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionAssociationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLambdaFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLocationCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLocationCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidLocationCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidLocationCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The location code specified is not valid.
public struct InvalidLocationCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLocationCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLocationCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMinimumProtocolVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidMinimumProtocolVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidMinimumProtocolVersion {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidMinimumProtocolVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The minimum protocol version specified is not valid.
public struct InvalidMinimumProtocolVersion: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMinimumProtocolVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidMinimumProtocolVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOrigin(message: \(Swift.String(describing: message)))"}
}

extension InvalidOrigin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.
public struct InvalidOrigin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginAccessIdentity(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginAccessIdentity {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The origin access identity is not valid or doesn't exist.
public struct InvalidOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginAccessIdentityBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct InvalidOriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginKeepaliveTimeout: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginKeepaliveTimeout(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginKeepaliveTimeout {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginKeepaliveTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The keep alive timeout specified for the origin is not valid.
public struct InvalidOriginKeepaliveTimeout: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginKeepaliveTimeoutBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginKeepaliveTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginReadTimeout: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginReadTimeout(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginReadTimeout {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOriginReadTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The read timeout specified for the origin is not valid.
public struct InvalidOriginReadTimeout: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginReadTimeoutBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginReadTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProtocolSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidProtocolSettings(message: \(Swift.String(describing: message)))"}
}

extension InvalidProtocolSettings {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidProtocolSettingsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support Server Name Indication (SNI).
public struct InvalidProtocolSettings: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProtocolSettingsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidProtocolSettingsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStringParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidQueryStringParameters(message: \(Swift.String(describing: message)))"}
}

extension InvalidQueryStringParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query string parameters specified are not valid.
public struct InvalidQueryStringParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStringParametersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativePath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRelativePath(message: \(Swift.String(describing: message)))"}
}

extension InvalidRelativePath {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRelativePathBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The relative path is too big, is not URL-encoded, or does not begin with a slash (/).
public struct InvalidRelativePath: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativePathBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRelativePathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequiredProtocol: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequiredProtocol(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequiredProtocol {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRequiredProtocolBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the RequiredProtocols element from your distribution configuration.
public struct InvalidRequiredProtocol: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequiredProtocolBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequiredProtocolBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResponseCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidResponseCode {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidResponseCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A response code is not valid.
public struct InvalidResponseCode: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResponseCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResponseCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTTLOrder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTTLOrder(message: \(Swift.String(describing: message)))"}
}

extension InvalidTTLOrder {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTTLOrderBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The TTL order specified is not valid.
public struct InvalidTTLOrder: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTTLOrderBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTTLOrderBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagging: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagging(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagging {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidTaggingBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tagging specified is not valid.
public struct InvalidTagging: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTaggingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidViewerCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidViewerCertificate(message: \(Swift.String(describing: message)))"}
}

extension InvalidViewerCertificate {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidViewerCertificateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A viewer certificate specified is not valid.
public struct InvalidViewerCertificate: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidViewerCertificateBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidViewerCertificateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebACLId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidWebACLId(message: \(Swift.String(describing: message)))"}
}

extension InvalidWebACLId {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidWebACLIdBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A web ACL ID specified is not valid. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a. To specify a web ACL created using WAF Classic, use the ACL ID, for example 473e64fd-f30b-4765-81a0-62ad96dd167a.
public struct InvalidWebACLId: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebACLIdBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidWebACLIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case invalidationBatch = "InvalidationBatch"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invalidation(createTime: \(Swift.String(describing: createTime)), id: \(Swift.String(describing: id)), invalidationBatch: \(Swift.String(describing: invalidationBatch)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.Invalidation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation.
    public struct Invalidation: Swift.Equatable {
        /// The date and time the invalidation request was first made.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier for the invalidation request. For example: IDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The current invalidation information for the batch request.
        /// This member is required.
        public var invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// The status of the invalidation request. When the invalidation batch is finished, the status is Completed.
        /// This member is required.
        public var status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.InvalidationBatch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case paths = "Paths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let paths = paths {
            try container.encode(paths, forKey: ClientRuntime.Key("Paths"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Paths.self, forKey: .paths)
        paths = pathsDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
    }
}

extension CloudFrontClientTypes.InvalidationBatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationBatch(callerReference: \(Swift.String(describing: callerReference)), paths: \(Swift.String(describing: paths)))"}
}

extension CloudFrontClientTypes.InvalidationBatch: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An invalidation batch.
    public struct InvalidationBatch: Swift.Equatable {
        /// A value that you specify to uniquely identify an invalidation request. CloudFront uses the value to prevent you from accidentally resubmitting an identical request. Whenever you create a new invalidation request, you must specify a new value for CallerReference and change other values in the request as applicable. One way to ensure that the value of CallerReference is unique is to use a timestamp, for example, 20120301090000. If you make a second invalidation request with the same value for CallerReference, and if the rest of the request is the same, CloudFront doesn't create a new invalidation request. Instead, CloudFront returns information about the invalidation request that you previously created with the same CallerReference. If CallerReference is a value you already sent in a previous invalidation batch request but the content of any Path is different from the original request, CloudFront returns an InvalidationBatchAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var paths: CloudFrontClientTypes.Paths?

        public init (
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }

}

extension CloudFrontClientTypes.InvalidationList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for invalidationsummary0 in items {
                try itemsContainer.encode(invalidationsummary0, forKey: ClientRuntime.Key("InvalidationSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct InvalidationSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InvalidationSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.InvalidationSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.InvalidationSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.InvalidationSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.InvalidationList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.InvalidationList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The InvalidationList complex type describes the list of invalidation objects. For more information about invalidation, see [Invalidating Objects (Web Distributions Only)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html) in the Amazon CloudFront Developer Guide.
    public struct InvalidationList: Swift.Equatable {
        /// A flag that indicates whether more invalidation batch requests remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more invalidation batches in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one InvalidationSummary element for each invalidation batch created by the current account.
        public var items: [CloudFrontClientTypes.InvalidationSummary]?
        /// The value that you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value that you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value that you can use for the Marker request parameter to continue listing your invalidation batches where they left off.
        public var nextMarker: Swift.String?
        /// The number of invalidation batches that were created by the current account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.InvalidationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudFrontClientTypes.InvalidationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationSummary(createTime: \(Swift.String(describing: createTime)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.InvalidationSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of an invalidation request.
    public struct InvalidationSummary: Swift.Equatable {
        /// The time that an invalidation request was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for an invalidation request.
        /// This member is required.
        public var id: Swift.String?
        /// The status of an invalidation request.
        /// This member is required.
        public var status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }

}

extension CloudFrontClientTypes {
    public enum ItemSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupId = "KeyGroupId"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupId = keyGroupId {
            try container.encode(keyGroupId, forKey: ClientRuntime.Key("KeyGroupId"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyGroupId)
        keyGroupId = keyGroupIdDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KGKeyPairIds(keyGroupId: \(Swift.String(describing: keyGroupId)), keyPairIds: \(Swift.String(describing: keyPairIds)))"}
}

extension CloudFrontClientTypes.KGKeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of identifiers for the public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct KGKeyPairIds: Swift.Equatable {
        /// The identifier of the key group that contains the public keys.
        public var keyGroupId: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes.KeyGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case keyGroupConfig = "KeyGroupConfig"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CloudFrontClientTypes.KeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroup(id: \(Swift.String(describing: id)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.KeyGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroup: Swift.Equatable {
        /// The identifier for the key group.
        /// This member is required.
        public var id: Swift.String?
        /// The key group configuration.
        /// This member is required.
        public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// The date and time when the key group was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?

        public init (
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension KeyGroupAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension KeyGroupAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KeyGroupAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A key group with this name already exists. You must provide a unique name. To modify an existing key group, use UpdateKeyGroup.
public struct KeyGroupAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KeyGroupAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KeyGroupAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case items = "Items"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("PublicKey"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKey{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKey>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupConfig(comment: \(Swift.String(describing: comment)), items: \(Swift.String(describing: items)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.KeyGroupConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A key group configuration. A key group contains a list of public keys that you can use with [CloudFront signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html).
    public struct KeyGroupConfig: Swift.Equatable {
        /// A comment to describe the key group. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// A list of the identifiers of the public keys in the key group.
        /// This member is required.
        public var items: [Swift.String]?
        /// A name to identify the key group.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.KeyGroupList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for keygroupsummary0 in items {
                try itemsContainer.encode(keygroupsummary0, forKey: ClientRuntime.Key("KeyGroupSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroupSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroupSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KeyGroupSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KeyGroupSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KeyGroupSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyGroupList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.KeyGroupList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups.
    public struct KeyGroupList: Swift.Equatable {
        /// A list of key groups.
        public var items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// The maximum number of key groups requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing key groups.
        public var nextMarker: Swift.String?
        /// The number of key groups returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroup = keyGroup {
            try container.encode(keyGroup, forKey: ClientRuntime.Key("KeyGroup"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupSummary(keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension CloudFrontClientTypes.KeyGroupSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a key group.
    public struct KeyGroupSummary: Swift.Equatable {
        /// A key group.
        /// This member is required.
        public var keyGroup: CloudFrontClientTypes.KeyGroup?

        public init (
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }

}

extension CloudFrontClientTypes.KeyPairIds: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyPairId"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyPairId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyPairId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyPairIds: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyPairIds(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.KeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of CloudFront key pair identifiers.
    public struct KeyPairIds: Swift.Equatable {
        /// A list of CloudFront key pair identifiers.
        public var items: [Swift.String]?
        /// The number of key pair identifiers in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleARN = "RoleARN"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: ClientRuntime.Key("RoleARN"))
        }
        if let streamARN = streamARN {
            try container.encode(streamARN, forKey: ClientRuntime.Key("StreamARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisStreamConfig(roleARN: \(Swift.String(describing: roleARN)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension CloudFrontClientTypes.KinesisStreamConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public struct KinesisStreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management (IAM) role that CloudFront can use to send real-time log data to your Kinesis data stream. For more information the IAM role, see [Real-time log configuration IAM role](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var roleARN: Swift.String?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time log data.
        /// This member is required.
        public var streamARN: Swift.String?

        public init (
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case includeBody = "IncludeBody"
        case lambdaFunctionARN = "LambdaFunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let includeBody = includeBody {
            try container.encode(includeBody, forKey: ClientRuntime.Key("IncludeBody"))
        }
        if let lambdaFunctionARN = lambdaFunctionARN {
            try container.encode(lambdaFunctionARN, forKey: ClientRuntime.Key("LambdaFunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionARN)
        lambdaFunctionARN = lambdaFunctionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let includeBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeBody)
        includeBody = includeBodyDecoded
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionAssociation(eventType: \(Swift.String(describing: eventType)), includeBody: \(Swift.String(describing: includeBody)), lambdaFunctionARN: \(Swift.String(describing: lambdaFunctionARN)))"}
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains a Lambda@Edge function association.
    public struct LambdaFunctionAssociation: Swift.Equatable {
        /// Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:
        ///
        /// * viewer-request: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.
        ///
        /// * origin-request: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * origin-response: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.
        ///
        /// * viewer-response: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        /// This member is required.
        public var eventType: CloudFrontClientTypes.EventType?
        /// A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        public var includeBody: Swift.Bool?
        /// The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        /// This member is required.
        public var lambdaFunctionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for lambdafunctionassociation0 in items {
                try itemsContainer.encode(lambdafunctionassociation0, forKey: ClientRuntime.Key("LambdaFunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct LambdaFunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LambdaFunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.LambdaFunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.LambdaFunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.LambdaFunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionAssociations(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that specifies a list of Lambda@Edge functions associations for a cache behavior. If you want to invoke one or more Lambda@Edge functions triggered by requests that match the PathPattern of the cache behavior, specify the applicable values for Quantity and Items. Note that there can be up to 4 LambdaFunctionAssociation items in this list (one for each possible value of EventType) and each EventType can be associated with only one function. If you don't want to invoke any Lambda@Edge functions for the requests that match PathPattern, specify 0 for Quantity and omit Items.
    public struct LambdaFunctionAssociations: Swift.Equatable {
        /// Optional: A complex type that contains LambdaFunctionAssociation items for this cache behavior. If Quantity is 0, you can omit Items.
        public var items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// The number of Lambda@Edge function associations for this cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ListCachePoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCachePoliciesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), type: \(Swift.String(describing: type)))"}
}

extension ListCachePoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCachePoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCachePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCachePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCachePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/cache-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCachePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of cache policies. The response includes cache policies in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of cache policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of cache policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your account.
    public var type: CloudFrontClientTypes.CachePolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListCachePoliciesInputBody: Swift.Equatable {
}

extension ListCachePoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCachePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCachePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCachePoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCachePoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCachePoliciesOutputResponse(cachePolicyList: \(Swift.String(describing: cachePolicyList)))"}
}

extension ListCachePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyList = try responseDecoder.decode(responseBody: data)
                self.cachePolicyList = output
            } else {
                self.cachePolicyList = nil
            }
        } else {
            self.cachePolicyList = nil
        }
    }
}

public struct ListCachePoliciesOutputResponse: Swift.Equatable {
    /// A list of cache policies.
    public var cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init (
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

struct ListCachePoliciesOutputResponseBody: Swift.Equatable {
    public let cachePolicyList: CloudFrontClientTypes.CachePolicyList?
}

extension ListCachePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyList = "CachePolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyList.self, forKey: .cachePolicyList)
        cachePolicyList = cachePolicyListDecoded
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCloudFrontOriginAccessIdentitiesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListCloudFrontOriginAccessIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

public struct ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

public struct ListCloudFrontOriginAccessIdentitiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCloudFrontOriginAccessIdentitiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCloudFrontOriginAccessIdentitiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

public struct ListCloudFrontOriginAccessIdentitiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCloudFrontOriginAccessIdentitiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCloudFrontOriginAccessIdentitiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

/// The request to list origin access identities.
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of origin access identities. The results include identities in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last identity on that page).
    public var marker: Swift.String?
    /// The maximum number of origin access identities you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Equatable {
}

extension ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCloudFrontOriginAccessIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCloudFrontOriginAccessIdentitiesOutputResponse(cloudFrontOriginAccessIdentityList: \(Swift.String(describing: cloudFrontOriginAccessIdentityList)))"}
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityList = output
            } else {
                self.cloudFrontOriginAccessIdentityList = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListCloudFrontOriginAccessIdentitiesOutputResponse: Swift.Equatable {
    /// The CloudFrontOriginAccessIdentityList type.
    public var cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init (
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

struct ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityList = "CloudFrontOriginAccessIdentityList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.self, forKey: .cloudFrontOriginAccessIdentityList)
        cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityListDecoded
    }
}

extension ListConflictingAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConflictingAliasesInput(alias: \(Swift.String(describing: alias)), distributionId: \(Swift.String(describing: distributionId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListConflictingAliasesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConflictingAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConflictingAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConflictingAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConflictingAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConflictingAliasesOutputError>
}

public struct ListConflictingAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConflictingAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConflictingAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let alias = input.operationInput.alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "Alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            input.builder.withQueryItem(aliasQueryItem)
        }
        if let distributionId = input.operationInput.distributionId {
            let distributionIdQueryItem = ClientRuntime.URLQueryItem(name: "DistributionId".urlPercentEncoding(), value: Swift.String(distributionId).urlPercentEncoding())
            input.builder.withQueryItem(distributionIdQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConflictingAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConflictingAliasesOutputError>
}

public struct ListConflictingAliasesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConflictingAliasesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConflictingAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConflictingAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConflictingAliasesOutputError>
}

public struct ListConflictingAliasesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConflictingAliasesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConflictingAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/conflicting-alias"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConflictingAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConflictingAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConflictingAliasesOutputError>
}

public struct ListConflictingAliasesInput: Swift.Equatable {
    /// The alias (also called a CNAME) to search for conflicting aliases.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of a distribution in your account that has an attached SSL/TLS certificate that includes the provided alias.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in the list of conflicting aliases. The response includes conflicting aliases in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of conflicting aliases that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        alias: Swift.String? = nil,
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListConflictingAliasesInputBody: Swift.Equatable {
}

extension ListConflictingAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConflictingAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListConflictingAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConflictingAliasesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConflictingAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConflictingAliasesOutputResponse(conflictingAliasesList: \(Swift.String(describing: conflictingAliasesList)))"}
}

extension ListConflictingAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.ConflictingAliasesList = try responseDecoder.decode(responseBody: data)
                self.conflictingAliasesList = output
            } else {
                self.conflictingAliasesList = nil
            }
        } else {
            self.conflictingAliasesList = nil
        }
    }
}

public struct ListConflictingAliasesOutputResponse: Swift.Equatable {
    /// A list of conflicting aliases.
    public var conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?

    public init (
        conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList? = nil
    )
    {
        self.conflictingAliasesList = conflictingAliasesList
    }
}

struct ListConflictingAliasesOutputResponseBody: Swift.Equatable {
    public let conflictingAliasesList: CloudFrontClientTypes.ConflictingAliasesList?
}

extension ListConflictingAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictingAliasesList = "ConflictingAliasesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictingAliasesListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ConflictingAliasesList.self, forKey: .conflictingAliasesList)
        conflictingAliasesList = conflictingAliasesListDecoded
    }
}

extension ListDistributionsByCachePolicyIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByCachePolicyIdInput(cachePolicyId: \(Swift.String(describing: cachePolicyId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsByCachePolicyIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByCachePolicyIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByCachePolicyIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByCachePolicyIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByCachePolicyIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let cachePolicyId = input.cachePolicyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("cachePolicyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByCachePolicyIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Equatable {
    /// The ID of the cache policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var cachePolicyId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByCachePolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByCachePolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByCachePolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByCachePolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByCachePolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByCachePolicyIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByCachePolicyIdOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByCachePolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByKeyGroupInput(keyGroupId: \(Swift.String(describing: keyGroupId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsByKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let keyGroupId = input.keyGroupId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("keyGroupId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInput: Swift.Equatable {
    /// The ID of the key group whose associated distribution IDs you are listing.
    /// This member is required.
    public var keyGroupId: Swift.String?
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByKeyGroupInputBody: Swift.Equatable {
}

extension ListDistributionsByKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByKeyGroupOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByKeyGroupOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByKeyGroupOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByOriginRequestPolicyIdInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)))"}
}

extension ListDistributionsByOriginRequestPolicyIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByOriginRequestPolicyIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByOriginRequestPolicyIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByOriginRequestPolicyIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let originRequestPolicyId = input.originRequestPolicyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("originRequestPolicyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByOriginRequestPolicyIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distribution IDs. The response includes distribution IDs in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distribution IDs that you want in the response.
    public var maxItems: Swift.Int?
    /// The ID of the origin request policy whose associated distribution IDs you want to list.
    /// This member is required.
    public var originRequestPolicyId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

struct ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByOriginRequestPolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByOriginRequestPolicyIdOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutputResponse: Swift.Equatable {
    /// A list of distribution IDs.
    public var distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

public struct ListDistributionsByRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByRealtimeLogConfigInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), realtimeLogConfigName: \(Swift.String(describing: realtimeLogConfigName)))"}
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let realtimeLogConfigName = realtimeLogConfigName {
            try container.encode(realtimeLogConfigName, forKey: ClientRuntime.Key("RealtimeLogConfigName"))
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/distributionsByRealtimeLogConfig"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of distributions. The response includes distributions in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of distributions that you want in the response.
    public var maxItems: Swift.Int?
    /// The Amazon Resource Name (ARN) of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigArn: Swift.String?
    /// The name of the real-time log configuration whose associated distributions you want to list.
    public var realtimeLogConfigName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

struct ListDistributionsByRealtimeLogConfigInputBody: Swift.Equatable {
    public let marker: Swift.String?
    public let maxItems: Swift.Int?
    public let realtimeLogConfigName: Swift.String?
    public let realtimeLogConfigArn: Swift.String?
}

extension ListDistributionsByRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let realtimeLogConfigNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigName)
        realtimeLogConfigName = realtimeLogConfigNameDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByRealtimeLogConfigOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A distribution list.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsByWebACLIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByWebACLIdInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension ListDistributionsByWebACLIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByWebACLIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

public struct ListDistributionsByWebACLIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

public struct ListDistributionsByWebACLIdInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByWebACLIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByWebACLIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

public struct ListDistributionsByWebACLIdInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsByWebACLIdInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let webACLId = input.webACLId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("webACLId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distributionsByWebACLId/\(webACLId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsByWebACLIdInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

/// The request to list distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdInput: Swift.Equatable {
    /// Use Marker and MaxItems to control pagination of results. If you have more than MaxItems distributions that satisfy the request, the response includes a NextMarker element. To get the next page of results, submit another request. For the value of Marker, specify the value of NextMarker from the last response. (For the first request, omit Marker.)
    public var marker: Swift.String?
    /// The maximum number of distributions that you want CloudFront to return in the response body. The maximum and default values are both 100.
    public var maxItems: Swift.Int?
    /// The ID of the WAF web ACL that you want to list the associated distributions. If you specify "null" for the ID, the request returns a list of the distributions that aren't associated with a web ACL.
    /// This member is required.
    public var webACLId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

struct ListDistributionsByWebACLIdInputBody: Swift.Equatable {
}

extension ListDistributionsByWebACLIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByWebACLIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByWebACLIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByWebACLIdOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidWebACLId(InvalidWebACLId)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByWebACLIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByWebACLIdOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsByWebACLIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// The response to a request to list the distributions that are associated with a specified WAF web ACL.
public struct ListDistributionsByWebACLIdOutputResponse: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByWebACLIdOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByWebACLIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

public struct ListDistributionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

public struct ListDistributionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

public struct ListDistributionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

/// The request to list your distributions.
public struct ListDistributionsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of distributions. The results include distributions in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last distribution on that page).
    public var marker: Swift.String?
    /// The maximum number of distributions you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsInputBody: Swift.Equatable {
}

extension ListDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListDistributionsOutputResponse: Swift.Equatable {
    /// The DistributionList type.
    public var distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListFieldLevelEncryptionConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionConfigsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFieldLevelEncryptionConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFieldLevelEncryptionConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFieldLevelEncryptionConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/field-level-encryption"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFieldLevelEncryptionConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last configuration on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption configurations you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionConfigsInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionConfigsOutputResponse(fieldLevelEncryptionList: \(Swift.String(describing: fieldLevelEncryptionList)))"}
}

extension ListFieldLevelEncryptionConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionList = output
            } else {
                self.fieldLevelEncryptionList = nil
            }
        } else {
            self.fieldLevelEncryptionList = nil
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutputResponse: Swift.Equatable {
    /// Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.
    public var fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init (
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

struct ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?
}

extension ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionList = "FieldLevelEncryptionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionList.self, forKey: .fieldLevelEncryptionList)
        fieldLevelEncryptionList = fieldLevelEncryptionListDecoded
    }
}

extension ListFieldLevelEncryptionProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionProfilesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFieldLevelEncryptionProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFieldLevelEncryptionProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFieldLevelEncryptionProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/field-level-encryption-profile"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFieldLevelEncryptionProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last profile on that page).
    public var marker: Swift.String?
    /// The maximum number of field-level encryption profiles you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionProfilesInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionProfilesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionProfilesOutputResponse(fieldLevelEncryptionProfileList: \(Swift.String(describing: fieldLevelEncryptionProfileList)))"}
}

extension ListFieldLevelEncryptionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileList = output
            } else {
                self.fieldLevelEncryptionProfileList = nil
            }
        } else {
            self.fieldLevelEncryptionProfileList = nil
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutputResponse: Swift.Equatable {
    /// Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.
    public var fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init (
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

struct ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?
}

extension ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileList = "FieldLevelEncryptionProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileList.self, forKey: .fieldLevelEncryptionProfileList)
        fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileListDecoded
    }
}

extension ListFunctionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), stage: \(Swift.String(describing: stage)))"}
}

extension ListFunctionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFunctionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/function"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFunctionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of functions. The response includes functions in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of functions that you want in the response.
    public var maxItems: Swift.Int?
    /// An optional filter to return only the functions that are in the specified stage, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsOutputResponse(functionList: \(Swift.String(describing: functionList)))"}
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionList = try responseDecoder.decode(responseBody: data)
                self.functionList = output
            } else {
                self.functionList = nil
            }
        } else {
            self.functionList = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// A list of CloudFront functions.
    public var functionList: CloudFrontClientTypes.FunctionList?

    public init (
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    public let functionList: CloudFrontClientTypes.FunctionList?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionList = "FunctionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionList.self, forKey: .functionList)
        functionList = functionListDecoded
    }
}

extension ListInvalidationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvalidationsInput(distributionId: \(Swift.String(describing: distributionId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListInvalidationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListInvalidationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

public struct ListInvalidationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

public struct ListInvalidationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListInvalidationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInvalidationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

public struct ListInvalidationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListInvalidationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let distributionId = input.distributionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("distributionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(distributionId.urlPercentEncoding())/invalidation"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInvalidationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

/// The request to list invalidations.
public struct ListInvalidationsInput: Swift.Equatable {
    /// The distribution's ID.
    /// This member is required.
    public var distributionId: Swift.String?
    /// Use this parameter when paginating results to indicate where to begin in your list of invalidation batches. Because the results are returned in decreasing order from most recent to oldest, the most recent results are on the first page, the second page will contain earlier results, and so on. To get the next page of results, set Marker to the value of the NextMarker from the current page's response. This value is the same as the ID of the last invalidation batch on that page.
    public var marker: Swift.String?
    /// The maximum number of invalidation batches that you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInvalidationsInputBody: Swift.Equatable {
}

extension ListInvalidationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvalidationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInvalidationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvalidationsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvalidationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvalidationsOutputResponse(invalidationList: \(Swift.String(describing: invalidationList)))"}
}

extension ListInvalidationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.InvalidationList = try responseDecoder.decode(responseBody: data)
                self.invalidationList = output
            } else {
                self.invalidationList = nil
            }
        } else {
            self.invalidationList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListInvalidationsOutputResponse: Swift.Equatable {
    /// Information about invalidation batches.
    public var invalidationList: CloudFrontClientTypes.InvalidationList?

    public init (
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

struct ListInvalidationsOutputResponseBody: Swift.Equatable {
    public let invalidationList: CloudFrontClientTypes.InvalidationList?
}

extension ListInvalidationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationList = "InvalidationList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationList.self, forKey: .invalidationList)
        invalidationList = invalidationListDecoded
    }
}

extension ListKeyGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeyGroupsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListKeyGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListKeyGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListKeyGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListKeyGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListKeyGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/key-group"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListKeyGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of key groups. The response includes key groups in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of key groups that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListKeyGroupsInputBody: Swift.Equatable {
}

extension ListKeyGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKeyGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListKeyGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeyGroupsOutputResponse(keyGroupList: \(Swift.String(describing: keyGroupList)))"}
}

extension ListKeyGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupList = try responseDecoder.decode(responseBody: data)
                self.keyGroupList = output
            } else {
                self.keyGroupList = nil
            }
        } else {
            self.keyGroupList = nil
        }
    }
}

public struct ListKeyGroupsOutputResponse: Swift.Equatable {
    /// A list of key groups.
    public var keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init (
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

struct ListKeyGroupsOutputResponseBody: Swift.Equatable {
    public let keyGroupList: CloudFrontClientTypes.KeyGroupList?
}

extension ListKeyGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupList = "KeyGroupList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupList.self, forKey: .keyGroupList)
        keyGroupList = keyGroupListDecoded
    }
}

extension ListOriginRequestPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginRequestPoliciesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), type: \(Swift.String(describing: type)))"}
}

extension ListOriginRequestPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOriginRequestPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOriginRequestPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOriginRequestPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOriginRequestPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/origin-request-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOriginRequestPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of origin request policies. The response includes origin request policies in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of origin request policies that you want in the response.
    public var maxItems: Swift.Int?
    /// A filter to return only the specified kinds of origin request policies. Valid values are:
    ///
    /// * managed – Returns only the managed policies created by Amazon Web Services.
    ///
    /// * custom – Returns only the custom policies created in your account.
    public var type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListOriginRequestPoliciesInputBody: Swift.Equatable {
}

extension ListOriginRequestPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginRequestPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginRequestPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginRequestPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginRequestPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginRequestPoliciesOutputResponse(originRequestPolicyList: \(Swift.String(describing: originRequestPolicyList)))"}
}

extension ListOriginRequestPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyList = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyList = output
            } else {
                self.originRequestPolicyList = nil
            }
        } else {
            self.originRequestPolicyList = nil
        }
    }
}

public struct ListOriginRequestPoliciesOutputResponse: Swift.Equatable {
    /// A list of origin request policies.
    public var originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init (
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

struct ListOriginRequestPoliciesOutputResponseBody: Swift.Equatable {
    public let originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?
}

extension ListOriginRequestPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyList = "OriginRequestPolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyList.self, forKey: .originRequestPolicyList)
        originRequestPolicyList = originRequestPolicyListDecoded
    }
}

extension ListPublicKeysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublicKeysInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListPublicKeysInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPublicKeysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPublicKeysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPublicKeysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPublicKeysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/public-key"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPublicKeysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInput: Swift.Equatable {
    /// Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that occur after the marker. To get the next page of results, set the Marker to the value of the NextMarker from the current page's response (which is also the ID of the last public key on that page).
    public var marker: Swift.String?
    /// The maximum number of public keys you want in the response body.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
}

extension ListPublicKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublicKeysOutputResponse(publicKeyList: \(Swift.String(describing: publicKeyList)))"}
}

extension ListPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyList = try responseDecoder.decode(responseBody: data)
                self.publicKeyList = output
            } else {
                self.publicKeyList = nil
            }
        } else {
            self.publicKeyList = nil
        }
    }
}

public struct ListPublicKeysOutputResponse: Swift.Equatable {
    /// Returns a list of all public keys that have been added to CloudFront for this account.
    public var publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init (
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Swift.Equatable {
    public let publicKeyList: CloudFrontClientTypes.PublicKeyList?
}

extension ListPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyList.self, forKey: .publicKeyList)
        publicKeyList = publicKeyListDecoded
    }
}

extension ListRealtimeLogConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRealtimeLogConfigsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListRealtimeLogConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRealtimeLogConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRealtimeLogConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRealtimeLogConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRealtimeLogConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/realtime-log-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRealtimeLogConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInput: Swift.Equatable {
    /// Use this field when paginating results to indicate where to begin in your list of real-time log configurations. The response includes real-time log configurations in the list that occur after the marker. To get the next page of the list, set this field’s value to the value of NextMarker from the current page’s response.
    public var marker: Swift.String?
    /// The maximum number of real-time log configurations that you want in the response.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListRealtimeLogConfigsInputBody: Swift.Equatable {
}

extension ListRealtimeLogConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRealtimeLogConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRealtimeLogConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRealtimeLogConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRealtimeLogConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRealtimeLogConfigsOutputResponse(realtimeLogConfigs: \(Swift.String(describing: realtimeLogConfigs)))"}
}

extension ListRealtimeLogConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.RealtimeLogConfigs = try responseDecoder.decode(responseBody: data)
                self.realtimeLogConfigs = output
            } else {
                self.realtimeLogConfigs = nil
            }
        } else {
            self.realtimeLogConfigs = nil
        }
    }
}

public struct ListRealtimeLogConfigsOutputResponse: Swift.Equatable {
    /// A list of real-time log configurations.
    public var realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init (
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

struct ListRealtimeLogConfigsOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?
}

extension ListRealtimeLogConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfigs = "RealtimeLogConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfigs.self, forKey: .realtimeLogConfigs)
        realtimeLogConfigs = realtimeLogConfigsDecoded
    }
}

extension ListStreamingDistributionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingDistributionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListStreamingDistributionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStreamingDistributionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

public struct ListStreamingDistributionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

public struct ListStreamingDistributionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListStreamingDistributionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamingDistributionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

public struct ListStreamingDistributionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListStreamingDistributionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/streaming-distribution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamingDistributionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

/// The request to list your streaming distributions.
public struct ListStreamingDistributionsInput: Swift.Equatable {
    /// The value that you provided for the Marker request parameter.
    public var marker: Swift.String?
    /// The value that you provided for the MaxItems request parameter.
    public var maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListStreamingDistributionsInputBody: Swift.Equatable {
}

extension ListStreamingDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStreamingDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingDistributionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingDistributionsOutputResponse(streamingDistributionList: \(Swift.String(describing: streamingDistributionList)))"}
}

extension ListStreamingDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionList = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionList = output
            } else {
                self.streamingDistributionList = nil
            }
        } else {
            self.streamingDistributionList = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListStreamingDistributionsOutputResponse: Swift.Equatable {
    /// The StreamingDistributionList type.
    public var streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init (
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

struct ListStreamingDistributionsOutputResponseBody: Swift.Equatable {
    public let streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?
}

extension ListStreamingDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionList = "StreamingDistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionList.self, forKey: .streamingDistributionList)
        streamingDistributionList = streamingDistributionListDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resource: \(Swift.String(describing: resource)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/tagging"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// The request to list tags for a CloudFront resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Tags = try responseDecoder.decode(responseBody: data)
                self.tags = output
            } else {
                self.tags = nil
            }
        } else {
            self.tags = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init (
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: CloudFrontClientTypes.Tags?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let includeCookies = includeCookies {
            try container.encode(includeCookies, forKey: ClientRuntime.Key("IncludeCookies"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingConfig(bucket: \(Swift.String(describing: bucket)), enabled: \(Swift.String(describing: enabled)), includeCookies: \(Swift.String(describing: includeCookies)), prefix: \(Swift.String(describing: prefix)))"}
}

extension CloudFrontClientTypes.LoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for the distribution.
    public struct LoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a distribution or if you want to disable logging for an existing distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket, prefix, and IncludeCookies, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs, specify true for IncludeCookies. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify false for IncludeCookies.
        /// This member is required.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }
    }

}

extension CloudFrontClientTypes {
    public enum Method: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum MinimumProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case tlsv122021
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .tlsv122021,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case .tlsv122021: return "TLSv1.2_2021"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension MissingBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingBody(message: \(Swift.String(describing: message)))"}
}

extension MissingBody {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<MissingBodyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation requires a body. Ensure that the body is present and the Content-Type header is set.
public struct MissingBody: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingBodyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MissingBodyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionConfig = "RealtimeMetricsSubscriptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig {
            try container.encode(realtimeMetricsSubscriptionConfig, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.self, forKey: .realtimeMetricsSubscriptionConfig)
        realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfigDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonitoringSubscription(realtimeMetricsSubscriptionConfig: \(Swift.String(describing: realtimeMetricsSubscriptionConfig)))"}
}

extension CloudFrontClientTypes.MonitoringSubscription: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A monitoring subscription. This structure contains information about whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    public struct MonitoringSubscription: Swift.Equatable {
        /// A subscription configuration for additional CloudWatch metrics.
        public var realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init (
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }

}

extension NoSuchCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension NoSuchCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cache policy does not exist.
public struct NoSuchCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCloudFrontOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchCloudFrontOriginAccessIdentity(message: \(Swift.String(describing: message)))"}
}

extension NoSuchCloudFrontOriginAccessIdentity {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchCloudFrontOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified origin access identity does not exist.
public struct NoSuchCloudFrontOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCloudFrontOriginAccessIdentityBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchCloudFrontOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchDistribution(message: \(Swift.String(describing: message)))"}
}

extension NoSuchDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified distribution does not exist.
public struct NoSuchDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFieldLevelEncryptionConfig(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFieldLevelEncryptionProfile(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionProfile {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFieldLevelEncryptionProfileBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified profile for field-level encryption doesn't exist.
public struct NoSuchFieldLevelEncryptionProfile: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionProfileBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionProfileBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFunctionExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFunctionExists(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFunctionExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchFunctionExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The function does not exist.
public struct NoSuchFunctionExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFunctionExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFunctionExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchInvalidation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchInvalidation(message: \(Swift.String(describing: message)))"}
}

extension NoSuchInvalidation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchInvalidationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified invalidation does not exist.
public struct NoSuchInvalidation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchInvalidationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchInvalidationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchOrigin(message: \(Swift.String(describing: message)))"}
}

extension NoSuchOrigin {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No origin exists with the specified Origin Id.
public struct NoSuchOrigin: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension NoSuchOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The origin request policy does not exist.
public struct NoSuchOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchPublicKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchPublicKey(message: \(Swift.String(describing: message)))"}
}

extension NoSuchPublicKey {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchPublicKeyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key doesn't exist.
public struct NoSuchPublicKey: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchPublicKeyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchPublicKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRealtimeLogConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchRealtimeLogConfig(message: \(Swift.String(describing: message)))"}
}

extension NoSuchRealtimeLogConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchRealtimeLogConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The real-time log configuration does not exist.
public struct NoSuchRealtimeLogConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRealtimeLogConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchRealtimeLogConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchResource(message: \(Swift.String(describing: message)))"}
}

extension NoSuchResource {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchResourceBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that was specified is not valid.
public struct NoSuchResource: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchResourceBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchStreamingDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchStreamingDistribution(message: \(Swift.String(describing: message)))"}
}

extension NoSuchStreamingDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<NoSuchStreamingDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified streaming distribution does not exist.
public struct NoSuchStreamingDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchStreamingDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchStreamingDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAttempts = "ConnectionAttempts"
        case connectionTimeout = "ConnectionTimeout"
        case customHeaders = "CustomHeaders"
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case originShield = "OriginShield"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let connectionAttempts = connectionAttempts {
            try container.encode(connectionAttempts, forKey: ClientRuntime.Key("ConnectionAttempts"))
        }
        if let connectionTimeout = connectionTimeout {
            try container.encode(connectionTimeout, forKey: ClientRuntime.Key("ConnectionTimeout"))
        }
        if let customHeaders = customHeaders {
            try container.encode(customHeaders, forKey: ClientRuntime.Key("CustomHeaders"))
        }
        if let customOriginConfig = customOriginConfig {
            try container.encode(customOriginConfig, forKey: ClientRuntime.Key("CustomOriginConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let originPath = originPath {
            try container.encode(originPath, forKey: ClientRuntime.Key("OriginPath"))
        }
        if let originShield = originShield {
            try container.encode(originShield, forKey: ClientRuntime.Key("OriginShield"))
        }
        if let s3OriginConfig = s3OriginConfig {
            try container.encode(s3OriginConfig, forKey: ClientRuntime.Key("S3OriginConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originPath)
        originPath = originPathDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomHeaders.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
        let connectionAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionAttempts)
        connectionAttempts = connectionAttemptsDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let originShieldDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginShield.self, forKey: .originShield)
        originShield = originShieldDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Origin(connectionAttempts: \(Swift.String(describing: connectionAttempts)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), customHeaders: \(Swift.String(describing: customHeaders)), customOriginConfig: \(Swift.String(describing: customOriginConfig)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), originPath: \(Swift.String(describing: originPath)), originShield: \(Swift.String(describing: originShield)), s3OriginConfig: \(Swift.String(describing: s3OriginConfig)))"}
}

extension CloudFrontClientTypes.Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin. An origin is the location where content is stored, and from which CloudFront gets content to serve to viewers. To specify an origin:
    ///
    /// * Use S3OriginConfig to specify an Amazon S3 bucket that is not configured with static website hosting.
    ///
    /// * Use CustomOriginConfig to specify all other kinds of origins, including:
    ///
    /// * An Amazon S3 bucket that is configured with static website hosting
    ///
    /// * An Elastic Load Balancing load balancer
    ///
    /// * An AWS Elemental MediaPackage endpoint
    ///
    /// * An AWS Elemental MediaStore container
    ///
    /// * Any other HTTP server, running on an Amazon EC2 instance or any other kind of host
    ///
    ///
    ///
    ///
    ///
    /// For the current maximum number of origins that you can specify per distribution, see [General Quotas on Web Distributions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions) in the Amazon CloudFront Developer Guide (quotas were formerly referred to as limits).
    public struct Origin: Swift.Equatable {
        /// The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don’t specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that’s configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the Amazon CloudFront Developer Guide.
        public var connectionAttempts: Swift.Int?
        /// The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don’t specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the Amazon CloudFront Developer Guide.
        public var connectionTimeout: Swift.Int?
        /// A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the Amazon CloudFront Developer Guide.
        public var customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var domainName: Swift.String?
        /// A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the TargetOriginId in a CacheBehavior or DefaultCacheBehavior.
        /// This member is required.
        public var id: Swift.String?
        /// An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the Amazon CloudFront Developer Guide.
        public var originPath: Swift.String?
        /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
        public var originShield: CloudFrontClientTypes.OriginShield?
        /// Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the CustomOriginConfig type instead.
        public var s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init (
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerName = headerName {
            try container.encode(headerName, forKey: ClientRuntime.Key("HeaderName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: ClientRuntime.Key("HeaderValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginCustomHeader(headerName: \(Swift.String(describing: headerName)), headerValue: \(Swift.String(describing: headerValue)))"}
}

extension CloudFrontClientTypes.OriginCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains HeaderName and HeaderValue elements, if any, for this distribution.
    public struct OriginCustomHeader: Swift.Equatable {
        /// The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var headerName: Swift.String?
        /// The value for the header that you specified in the HeaderName field.
        /// This member is required.
        public var headerValue: Swift.String?

        public init (
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension CloudFrontClientTypes.OriginGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverCriteria = "FailoverCriteria"
        case id = "Id"
        case members = "Members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let failoverCriteria = failoverCriteria {
            try container.encode(failoverCriteria, forKey: ClientRuntime.Key("FailoverCriteria"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let members = members {
            try container.encode(members, forKey: ClientRuntime.Key("Members"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupFailoverCriteria.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
        let membersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupMembers.self, forKey: .members)
        members = membersDecoded
    }
}

extension CloudFrontClientTypes.OriginGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroup(failoverCriteria: \(Swift.String(describing: failoverCriteria)), id: \(Swift.String(describing: id)), members: \(Swift.String(describing: members)))"}
}

extension CloudFrontClientTypes.OriginGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify. You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin under the failover conditions that you've chosen.
    public struct OriginGroup: Swift.Equatable {
        /// A complex type that contains information about the failover criteria for an origin group.
        /// This member is required.
        public var failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// The origin group's ID.
        /// This member is required.
        public var id: Swift.String?
        /// A complex type that contains information about the origins in an origin group.
        /// This member is required.
        public var members: CloudFrontClientTypes.OriginGroupMembers?

        public init (
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }

}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: ClientRuntime.Key("StatusCodes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupFailoverCriteria(statusCodes: \(Swift.String(describing: statusCodes)))"}
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
    public struct OriginGroupFailoverCriteria: Swift.Equatable {
        /// The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin.
        /// This member is required.
        public var statusCodes: CloudFrontClientTypes.StatusCodes?

        public init (
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originId = "OriginId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originId = originId {
            try container.encode(originId, forKey: ClientRuntime.Key("OriginId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originId)
        originId = originIdDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupMember(originId: \(Swift.String(describing: originId)))"}
}

extension CloudFrontClientTypes.OriginGroupMember: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin in an origin group.
    public struct OriginGroupMember: Swift.Equatable {
        /// The ID for an origin in an origin group.
        /// This member is required.
        public var originId: Swift.String?

        public init (
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroupmember0 in items {
                try itemsContainer.encode(origingroupmember0, forKey: ClientRuntime.Key("OriginGroupMember"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroupMember{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroupMember>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroupMember].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroupMember]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroupMember]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupMembers(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginGroupMembers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origins included in an origin group.
    public struct OriginGroupMembers: Swift.Equatable {
        /// Items (origins) in an origin group.
        /// This member is required.
        public var items: [CloudFrontClientTypes.OriginGroupMember]?
        /// The number of origins in an origin group.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.OriginGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroup0 in items {
                try itemsContainer.encode(origingroup0, forKey: ClientRuntime.Key("OriginGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroup].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroup]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroup]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroups(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the origin groups specified for a distribution.
    public struct OriginGroups: Swift.Equatable {
        /// The items (origin groups) in a distribution.
        public var items: [CloudFrontClientTypes.OriginGroup]?
        /// The number of origin groups.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicy(id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy. When it’s attached to a cache behavior, the origin request policy determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can’t find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicy: Swift.Equatable {
        /// The unique identifier for the origin request policy.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the origin request policy was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The origin request policy configuration.
        /// This member is required.
        public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init (
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }

}

extension OriginRequestPolicyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension OriginRequestPolicyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An origin request policy with this name already exists. You must provide a unique name. To modify an existing origin request policy, use UpdateOriginRequestPolicy.
public struct OriginRequestPolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OriginRequestPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case cookiesConfig = "CookiesConfig"
        case headersConfig = "HeadersConfig"
        case name = "Name"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyConfig(comment: \(Swift.String(describing: comment)), cookiesConfig: \(Swift.String(describing: cookiesConfig)), headersConfig: \(Swift.String(describing: headersConfig)), name: \(Swift.String(describing: name)), queryStringsConfig: \(Swift.String(describing: queryStringsConfig)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An origin request policy configuration. This configuration determines the values that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to the origin includes the following:
    ///
    /// * The request body and the URL path (without the domain name) from the viewer request.
    ///
    /// * The headers that CloudFront automatically includes in every origin request, including Host, User-Agent, and X-Amz-Cf-Id.
    ///
    /// * All HTTP headers, cookies, and URL query strings that are specified in the cache policy or the origin request policy. These can include items from the viewer request and, in the case of headers, additional ones that are added by CloudFront.
    ///
    ///
    /// CloudFront sends a request when it can’t find an object in its cache that matches the request. If you want to send values to the origin and also include them in the cache key, use CachePolicy.
    public struct OriginRequestPolicyConfig: Swift.Equatable {
        /// A comment to describe the origin request policy. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The cookies from viewer requests to include in origin requests.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// The HTTP headers to include in origin requests. These can include headers from viewer requests and additional headers added by CloudFront.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// A unique name to identify the origin request policy.
        /// This member is required.
        public var name: Swift.String?
        /// The URL query strings from viewer requests to include in origin requests.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init (
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyCookiesConfig(cookieBehavior: \(Swift.String(describing: cookieBehavior)), cookies: \(Swift.String(describing: cookies)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyCookiesConfig: Swift.Equatable {
        /// Determines whether cookies in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Cookies in viewer requests are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any cookies that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The cookies in viewer requests that are listed in the CookieNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All cookies in viewer requests are included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// Contains a list of cookie names.
        public var cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyHeadersConfig(headerBehavior: \(Swift.String(describing: headerBehavior)), headers: \(Swift.String(describing: headers)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any HTTP headers (and if so, which headers) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyHeadersConfig: Swift.Equatable {
        /// Determines whether any HTTP headers are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – HTTP headers are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any headers that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The HTTP headers that are listed in the Headers type are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewer – All HTTP headers in viewer requests are included in requests that CloudFront sends to the origin.
        ///
        /// * allViewerAndWhitelistCloudFront – All HTTP headers in viewer requests and the additional CloudFront headers that are listed in the Headers type are included in requests that CloudFront sends to the origin. The additional headers are added by CloudFront.
        /// This member is required.
        public var headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// Contains a list of HTTP header names.
        public var headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension OriginRequestPolicyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyInUse(message: \(Swift.String(describing: message)))"}
}

extension OriginRequestPolicyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OriginRequestPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the origin request policy because it is attached to one or more cache behaviors.
public struct OriginRequestPolicyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OriginRequestPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for originrequestpolicysummary0 in items {
                try itemsContainer.encode(originrequestpolicysummary0, forKey: ClientRuntime.Key("OriginRequestPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginRequestPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginRequestPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginRequestPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginRequestPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginRequestPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of origin request policies.
    public struct OriginRequestPolicyList: Swift.Equatable {
        /// Contains the origin request policies in the list.
        public var items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// The maximum number of origin request policies requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing origin request policies where you left off.
        public var nextMarker: Swift.String?
        /// The total number of origin request policies returned in the response.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyQueryStringsConfig(queryStringBehavior: \(Swift.String(describing: queryStringBehavior)), queryStrings: \(Swift.String(describing: queryStrings)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in requests that CloudFront sends to the origin.
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Equatable {
        /// Determines whether any URL query strings in viewer requests are included in requests that CloudFront sends to the origin. Valid values are:
        ///
        /// * none – Query strings in viewer requests are not included in requests that CloudFront sends to the origin. Even when this field is set to none, any query strings that are listed in a CachePolicy are included in origin requests.
        ///
        /// * whitelist – The query strings in viewer requests that are listed in the QueryStringNames type are included in requests that CloudFront sends to the origin.
        ///
        /// * all – All query strings in viewer requests are included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// Contains a list of the query strings in viewer requests that are included in requests that CloudFront sends to the origin.
        public var queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicy = originRequestPolicy {
            try container.encode(originRequestPolicy, forKey: ClientRuntime.Key("OriginRequestPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyType.self, forKey: .type)
        type = typeDecoded
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicySummary(originRequestPolicy: \(Swift.String(describing: originRequestPolicy)), type: \(Swift.String(describing: type)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains an origin request policy.
    public struct OriginRequestPolicySummary: Swift.Equatable {
        /// The origin request policy.
        /// This member is required.
        public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// The type of origin request policy, either managed (created by Amazon Web Services) or custom (created in this account).
        /// This member is required.
        public var type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init (
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case originShieldRegion = "OriginShieldRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let originShieldRegion = originShieldRegion {
            try container.encode(originShieldRegion, forKey: ClientRuntime.Key("OriginShieldRegion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let originShieldRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originShieldRegion)
        originShieldRegion = originShieldRegionDecoded
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginShield(enabled: \(Swift.String(describing: enabled)), originShieldRegion: \(Swift.String(describing: originShieldRegion)))"}
}

extension CloudFrontClientTypes.OriginShield: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the Amazon CloudFront Developer Guide.
    public struct OriginShield: Swift.Equatable {
        /// A flag that specifies whether Origin Shield is enabled. When it’s enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it’s disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Region for Origin Shield. Specify the Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2. When you enable CloudFront Origin Shield, you must specify the Region for Origin Shield. For the list of Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the Region for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the Amazon CloudFront Developer Guide.
        public var originShieldRegion: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }

}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for sslprotocol0 in items {
                try itemsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("SslProtocol"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct SslProtocol{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SslProtocol>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.SslProtocol].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.SslProtocol]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.SslProtocol]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginSslProtocols(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginSslProtocols: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct OriginSslProtocols: Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        /// This member is required.
        public var items: [CloudFrontClientTypes.SslProtocol]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.Origins: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origin0 in items {
                try itemsContainer.encode(origin0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Origin].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Origin]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Origin]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Origins: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Origins(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Origins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about the origins for this distribution.
    public struct Origins: Swift.Equatable {
        /// A list of origins.
        /// This member is required.
        public var items: [CloudFrontClientTypes.Origin]?
        /// The number of origins for this distribution.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookiesConfig = "CookiesConfig"
        case enableAcceptEncodingBrotli = "EnableAcceptEncodingBrotli"
        case enableAcceptEncodingGzip = "EnableAcceptEncodingGzip"
        case headersConfig = "HeadersConfig"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let enableAcceptEncodingBrotli = enableAcceptEncodingBrotli {
            try container.encode(enableAcceptEncodingBrotli, forKey: ClientRuntime.Key("EnableAcceptEncodingBrotli"))
        }
        if let enableAcceptEncodingGzip = enableAcceptEncodingGzip {
            try container.encode(enableAcceptEncodingGzip, forKey: ClientRuntime.Key("EnableAcceptEncodingGzip"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAcceptEncodingGzipDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingGzip)
        enableAcceptEncodingGzip = enableAcceptEncodingGzipDecoded
        let enableAcceptEncodingBrotliDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingBrotli)
        enableAcceptEncodingBrotli = enableAcceptEncodingBrotliDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParametersInCacheKeyAndForwardedToOrigin(cookiesConfig: \(Swift.String(describing: cookiesConfig)), enableAcceptEncodingBrotli: \(Swift.String(describing: enableAcceptEncodingBrotli)), enableAcceptEncodingGzip: \(Swift.String(describing: enableAcceptEncodingGzip)), headersConfig: \(Swift.String(describing: headersConfig)), queryStringsConfig: \(Swift.String(describing: queryStringsConfig)))"}
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This object determines the values that CloudFront includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an object in its cache that it can return to the viewer. The headers, cookies, and query strings that are included in the cache key are automatically included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t find an object in its cache that matches the request’s cache key. If you want to send values to the origin but not include them in the cache key, use OriginRequestPolicy.
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Equatable {
        /// An object that determines whether any cookies in viewer requests (and if so, which cookies) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingGzip field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer’s Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it’s not included in the cache key and it’s not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        public var enableAcceptEncodingBrotli: Swift.Bool?
        /// A flag that can affect whether the Accept-Encoding HTTP header is included in the cache key and included in requests that CloudFront sends to the origin. This field is related to the EnableAcceptEncodingBrotli field. If one or both of these fields is true and the viewer request includes the Accept-Encoding header, then CloudFront does the following:
        ///
        /// * Normalizes the value of the viewer’s Accept-Encoding header
        ///
        /// * Includes the normalized header in the cache key
        ///
        /// * Includes the normalized header in the request to the origin, if a request is necessary
        ///
        ///
        /// For more information, see [Compression support](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects) in the Amazon CloudFront Developer Guide. If you set this value to true, and this cache behavior also has an origin request policy attached, do not include the Accept-Encoding header in the origin request policy. CloudFront always includes the Accept-Encoding header in origin requests when the value of this field is true, so including this header in an origin request policy has no effect. If both of these fields are false, then CloudFront treats the Accept-Encoding header the same as any other HTTP header in the viewer request. By default, it’s not included in the cache key and it’s not included in origin requests. In this case, you can manually add Accept-Encoding to the headers whitelist like any other HTTP header.
        /// This member is required.
        public var enableAcceptEncodingGzip: Swift.Bool?
        /// An object that determines whether any HTTP headers (and if so, which headers) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// An object that determines whether any URL query strings in viewer requests (and if so, which query strings) are included in the cache key and automatically included in requests that CloudFront sends to the origin.
        /// This member is required.
        public var queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init (
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes.Paths: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Path"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Path{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Path>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Paths: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Paths(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Paths: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the objects that you want to invalidate. For more information, see [Specifying the Objects to Invalidate](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects) in the Amazon CloudFront Developer Guide.
    public struct Paths: Swift.Equatable {
        /// A complex type that contains a list of the paths that you want to invalidate.
        public var items: [Swift.String]?
        /// The number of invalidation paths specified for the objects that you want to invalidate.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension PreconditionFailed: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionFailed(message: \(Swift.String(describing: message)))"}
}

extension PreconditionFailed {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PreconditionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The precondition in one or more of the request fields evaluated to false.
public struct PreconditionFailed: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreconditionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum PriceClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case id = "Id"
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKey(createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension CloudFrontClientTypes.PublicKey: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKey: Swift.Equatable {
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }

}

extension PublicKeyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension PublicKeyAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key already exists.
public struct PublicKeyAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicKeyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encodedKey = "EncodedKey"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), encodedKey: \(Swift.String(describing: encodedKey)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.PublicKeyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration information about a public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyConfig: Swift.Equatable {
        /// A string included in the request to help make sure that the request can’t be replayed.
        /// This member is required.
        public var callerReference: Swift.String?
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The public key that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
        /// This member is required.
        public var encodedKey: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }

}

extension PublicKeyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyInUse(message: \(Swift.String(describing: message)))"}
}

extension PublicKeyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PublicKeyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified public key is in use.
public struct PublicKeyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicKeyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for publickeysummary0 in items {
                try itemsContainer.encode(publickeysummary0, forKey: ClientRuntime.Key("PublicKeySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKeySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKeySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.PublicKeySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.PublicKeySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.PublicKeySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.PublicKeyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of public keys that you can use with [signed URLs and signed cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html), or with [field-level encryption](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html).
    public struct PublicKeyList: Swift.Equatable {
        /// A list of public keys.
        public var items: [CloudFrontClientTypes.PublicKeySummary]?
        /// The maximum number of public keys you want in the response.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more elements to be listed, this element is present and contains the value that you can use for the Marker request parameter to continue listing your public keys where you left off.
        public var nextMarker: Swift.String?
        /// The number of public keys in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.PublicKeySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createdTime = "CreatedTime"
        case encodedKey = "EncodedKey"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeySummary(comment: \(Swift.String(describing: comment)), createdTime: \(Swift.String(describing: createdTime)), encodedKey: \(Swift.String(describing: encodedKey)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.PublicKeySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains information about a public key.
    public struct PublicKeySummary: Swift.Equatable {
        /// A comment to describe the public key. The comment cannot be longer than 128 characters.
        public var comment: Swift.String?
        /// The date and time when the public key was uploaded.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The public key.
        /// This member is required.
        public var encodedKey: Swift.String?
        /// The identifier of the public key.
        /// This member is required.
        public var id: Swift.String?
        /// A name to help identify the public key.
        /// This member is required.
        public var name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }

}

extension PublishFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension PublishFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct PublishFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PublishFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PublishFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())/publish"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PublishFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInput: Swift.Equatable {
    /// The current version (ETag value) of the function that you are publishing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are publishing.
    /// This member is required.
    public var name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct PublishFunctionInputBody: Swift.Equatable {
}

extension PublishFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PublishFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishFunctionOutputResponse(functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension PublishFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct PublishFunctionOutputResponse: Swift.Equatable {
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

struct PublishFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension PublishFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
        case queryArg = "QueryArg"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
        if let queryArg = queryArg {
            try container.encode(queryArg, forKey: ClientRuntime.Key("QueryArg"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArg)
        queryArg = queryArgDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfile(profileId: \(Swift.String(describing: profileId)), queryArg: \(Swift.String(describing: queryArg)))"}
}

extension CloudFrontClientTypes.QueryArgProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfile: Swift.Equatable {
        /// ID of profile to use for field-level encryption query argument-profile mapping
        /// This member is required.
        public var profileId: Swift.String?
        /// Query argument for field-level encryption query argument-profile mapping.
        /// This member is required.
        public var queryArg: Swift.String?

        public init (
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }

}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardWhenQueryArgProfileIsUnknown = "ForwardWhenQueryArgProfileIsUnknown"
        case queryArgProfiles = "QueryArgProfiles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown {
            try container.encode(forwardWhenQueryArgProfileIsUnknown, forKey: ClientRuntime.Key("ForwardWhenQueryArgProfileIsUnknown"))
        }
        if let queryArgProfiles = queryArgProfiles {
            try container.encode(queryArgProfiles, forKey: ClientRuntime.Key("QueryArgProfiles"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenQueryArgProfileIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenQueryArgProfileIsUnknown)
        forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknownDecoded
        let queryArgProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfiles.self, forKey: .queryArgProfiles)
        queryArgProfiles = queryArgProfilesDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfileConfig(forwardWhenQueryArgProfileIsUnknown: \(Swift.String(describing: forwardWhenQueryArgProfileIsUnknown)), queryArgProfiles: \(Swift.String(describing: queryArgProfiles)))"}
}

extension CloudFrontClientTypes.QueryArgProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Configuration for query argument-profile mapping for field-level encryption.
    public struct QueryArgProfileConfig: Swift.Equatable {
        /// Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument, fle-profile, is unknown.
        /// This member is required.
        public var forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// Profiles specified for query argument-profile mapping for field-level encryption.
        public var queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init (
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }

}

extension QueryArgProfileEmpty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfileEmpty(message: \(Swift.String(describing: message)))"}
}

extension QueryArgProfileEmpty {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<QueryArgProfileEmptyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No profile specified for the field-level encryption query argument.
public struct QueryArgProfileEmpty: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryArgProfileEmptyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension QueryArgProfileEmptyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for queryargprofile0 in items {
                try itemsContainer.encode(queryargprofile0, forKey: ClientRuntime.Key("QueryArgProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct QueryArgProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.QueryArgProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.QueryArgProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.QueryArgProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.QueryArgProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfiles(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryArgProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Query argument-profile mapping for field-level encryption.
    public struct QueryArgProfiles: Swift.Equatable {
        /// Number of items for query argument-profile mapping for field-level encryption.
        public var items: [CloudFrontClientTypes.QueryArgProfile]?
        /// Number of profiles for query argument-profile mapping for field-level encryption.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringCacheKeys(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryStringCacheKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use QueryStringsConfig in a cache policy. See CachePolicy. If you want to send query strings to the origin but not include them in the cache key, use QueryStringsConfig in an origin request policy. See OriginRequestPolicy. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for a cache behavior.
    public struct QueryStringCacheKeys: Swift.Equatable {
        /// A list that contains the query string parameters that you want CloudFront to use as a basis for caching for a cache behavior. If Quantity is 0, you can omit Items.
        public var items: [Swift.String]?
        /// The number of whitelisted query string parameters for a cache behavior.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringNames: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringNames: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringNames(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryStringNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains a list of query string names.
    public struct QueryStringNames: Swift.Equatable {
        /// A list of query string names.
        public var items: [Swift.String]?
        /// The number of query string names in the Items list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfig(aRN: \(Swift.String(describing: aRN)), endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension CloudFrontClientTypes.RealtimeLogConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A real-time log configuration.
    public struct RealtimeLogConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this real-time log configuration.
        /// This member is required.
        public var aRN: Swift.String?
        /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data for this real-time log configuration.
        /// This member is required.
        public var endPoints: [CloudFrontClientTypes.EndPoint]?
        /// A list of fields that are included in each real-time log record. In an API response, the fields are provided in the same order in which they are sent to the Amazon Kinesis data stream. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var fields: [Swift.String]?
        /// The unique name of this real-time log configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. The sampling rate is an integer between 1 and 100, inclusive.
        /// This member is required.
        public var samplingRate: Swift.Int?

        public init (
            aRN: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.aRN = aRN
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }

}

extension RealtimeLogConfigAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A real-time log configuration with this name already exists. You must provide a unique name. To modify an existing real-time log configuration, use UpdateRealtimeLogConfig.
public struct RealtimeLogConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigInUse(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete the real-time log configuration because it is attached to one or more cache behaviors.
public struct RealtimeLogConfigInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigOwnerMismatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigOwnerMismatch(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigOwnerMismatch {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RealtimeLogConfigOwnerMismatchBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified real-time log configuration belongs to a different account.
public struct RealtimeLogConfigOwnerMismatch: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigOwnerMismatchBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigOwnerMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for realtimelogconfig0 in items {
                try itemsContainer.encode(realtimelogconfig0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct member{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.RealtimeLogConfig].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.RealtimeLogConfig]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.RealtimeLogConfig]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigs(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension CloudFrontClientTypes.RealtimeLogConfigs: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of real-time log configurations.
    public struct RealtimeLogConfigs: Swift.Equatable {
        /// A flag that indicates whether there are more real-time log configurations than are contained in this list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// Contains the list of real-time log configurations.
        public var items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// This parameter indicates where this list of real-time log configurations begins. This list includes real-time log configurations that occur after the marker.
        /// This member is required.
        public var marker: Swift.String?
        /// The maximum number of real-time log configurations requested.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If there are more items in the list than are in this response, this element is present. It contains the value that you should use in the Marker field of a subsequent request to continue listing real-time log configurations where you left off.
        public var nextMarker: Swift.String?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }

}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionStatus = "RealtimeMetricsSubscriptionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus {
            try container.encode(realtimeMetricsSubscriptionStatus, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus.self, forKey: .realtimeMetricsSubscriptionStatus)
        realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatusDecoded
    }
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeMetricsSubscriptionConfig(realtimeMetricsSubscriptionStatus: \(Swift.String(describing: realtimeMetricsSubscriptionStatus)))"}
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A subscription configuration for additional CloudWatch metrics.
    public struct RealtimeMetricsSubscriptionConfig: Swift.Equatable {
        /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
        /// This member is required.
        public var realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init (
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }

}

extension CloudFrontClientTypes {
    public enum RealtimeMetricsSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUse(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot delete this resource because it is in use.
public struct ResourceInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoRestriction = "GeoRestriction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let geoRestriction = geoRestriction {
            try container.encode(geoRestriction, forKey: ClientRuntime.Key("GeoRestriction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoRestrictionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestriction.self, forKey: .geoRestriction)
        geoRestriction = geoRestrictionDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Restrictions(geoRestriction: \(Swift.String(describing: geoRestriction)))"}
}

extension CloudFrontClientTypes.Restrictions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that identifies ways in which you want to restrict distribution of your content.
    public struct Restrictions: Swift.Equatable {
        /// A complex type that controls the countries in which your content is distributed. CloudFront determines the location of your users using MaxMind GeoIP databases.
        /// This member is required.
        public var geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init (
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }

}

extension CloudFrontClientTypes.S3Origin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Origin(domainName: \(Swift.String(describing: domainName)), originAccessIdentity: \(Swift.String(describing: originAccessIdentity)))"}
}

extension CloudFrontClientTypes.S3Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
    public struct S3Origin: Swift.Equatable {
        /// The DNS name of the Amazon S3 origin.
        /// This member is required.
        public var domainName: Swift.String?
        /// The CloudFront origin access identity to associate with the distribution. Use an origin access identity to configure the distribution so that end users can only access objects in an Amazon S3 bucket through CloudFront. If you want end users to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information, see [Using an Origin Access Identity to Restrict Access to Your Amazon S3 Content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes.S3OriginConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3OriginConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3OriginConfig(originAccessIdentity: \(Swift.String(describing: originAccessIdentity)))"}
}

extension CloudFrontClientTypes.S3OriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the CustomOriginConfig element instead.
    public struct S3OriginConfig: Swift.Equatable {
        /// The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can only access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/ID-of-origin-access-identity where  ID-of-origin-access-identity  is the value that CloudFront returned in the ID element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty OriginAccessIdentity element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty OriginAccessIdentity element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var originAccessIdentity: Swift.String?

        public init (
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes {
    public enum SSLSupportMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.Signer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber = "AwsAccountNumber"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let awsAccountNumber = awsAccountNumber {
            try container.encode(awsAccountNumber, forKey: ClientRuntime.Key("AwsAccountNumber"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.Signer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Signer(awsAccountNumber: \(Swift.String(describing: awsAccountNumber)), keyPairIds: \(Swift.String(describing: keyPairIds)))"}
}

extension CloudFrontClientTypes.Signer: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of accounts and the active CloudFront key pairs in each account that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct Signer: Swift.Equatable {
        /// An account number that contains active CloudFront key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies. If the account that owns the key pairs is the same account that owns the CloudFront distribution, the value of this field is self.
        public var awsAccountNumber: Swift.String?
        /// A list of CloudFront key pair identifiers.
        public var keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes {
    public enum SslProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for integer0 in items {
                try itemsContainer.encode(integer0, forKey: ClientRuntime.Key("StatusCode"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StatusCode{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StatusCode>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.Int].self, forKey: .member)
                var itemsBuffer:[Swift.Int]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.Int]()
                    for integerContainer0 in itemsContainer {
                        itemsBuffer?.append(integerContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatusCodes(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.StatusCodes: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
    public struct StatusCodes: Swift.Equatable {
        /// The items (status codes) for an origin group.
        /// This member is required.
        public var items: [Swift.Int]?
        /// The number of status codes.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.StreamingDistribution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case domainName = "DomainName"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistribution(aRN: \(Swift.String(describing: aRN)), activeTrustedSigners: \(Swift.String(describing: activeTrustedSigners)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension CloudFrontClientTypes.StreamingDistribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to track and manage content delivery.
    public struct StreamingDistribution: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the distribution. For example: arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5, where 123456789012 is your account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// A complex type that lists the accounts, if any, that you included in the TrustedSigners complex type for this distribution. These are the accounts that you want to allow to create signed URLs for private content. The Signer complex type lists the account number of the trusted signer or self if the signer is the account that created the distribution. The Signer element also includes the IDs of any active CloudFront key pairs that are associated with the trusted signer's account. If no KeyPairId element appears for a Signer, that signer can't create signed URLs. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// The domain name that corresponds to the streaming distribution, for example, s5c39gqb8ow64r.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// The identifier for the RTMP distribution. For example: EGTXBD79EXAMPLE.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the distribution was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The current status of the RTMP distribution. When the status is Deployed, the distribution's information is propagated to all CloudFront edge locations.
        /// This member is required.
        public var status: Swift.String?
        /// The current configuration information for the RTMP distribution.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedSigners = activeTrustedSigners
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }

}

extension StreamingDistributionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension StreamingDistributionAlreadyExists {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller reference you attempted to create the streaming distribution with is associated with another distribution
public struct StreamingDistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StreamingDistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case enabled = "Enabled"
        case logging = "Logging"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingLoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionConfig(aliases: \(Swift.String(describing: aliases)), callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), enabled: \(Swift.String(describing: enabled)), logging: \(Swift.String(describing: logging)), priceClass: \(Swift.String(describing: priceClass)), s3Origin: \(Swift.String(describing: s3Origin)), trustedSigners: \(Swift.String(describing: trustedSigners)))"}
}

extension CloudFrontClientTypes.StreamingDistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// The RTMP distribution's configuration information.
    public struct StreamingDistributionConfig: Swift.Equatable {
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// A unique value (for example, a date-time stamp) that ensures that the request can't be replayed. If the value of CallerReference is new (regardless of the content of the StreamingDistributionConfig object), CloudFront creates a new distribution. If CallerReference is a value that you already sent in a previous request to create a distribution, CloudFront returns a DistributionAlreadyExists error.
        /// This member is required.
        public var callerReference: Swift.String?
        /// Any comments you want to include about the streaming distribution.
        /// This member is required.
        public var comment: Swift.String?
        /// Whether the streaming distribution is enabled to accept user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A complex type that controls whether access logs are written for the streaming distribution.
        public var logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// A complex type that contains information about price class for this streaming distribution.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// A complex type that specifies any accounts that you want to permit to create signed URLs for private content. If you want the distribution to use signed URLs, include this element; if you want the distribution to use public URLs, remove this element. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionConfigWithTags(streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)), tags: \(Swift.String(describing: tags)))"}
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution Configuration and a list of tags to be associated with the streaming distribution.
    public struct StreamingDistributionConfigWithTags: Swift.Equatable {
        /// A streaming distribution Configuration.
        /// This member is required.
        public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// A complex type that contains zero or more Tag elements.
        /// This member is required.
        public var tags: CloudFrontClientTypes.Tags?

        public init (
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for streamingdistributionsummary0 in items {
                try itemsContainer.encode(streamingdistributionsummary0, forKey: ClientRuntime.Key("StreamingDistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StreamingDistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StreamingDistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.StreamingDistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.StreamingDistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.StreamingDistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.StreamingDistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A streaming distribution list.
    public struct StreamingDistributionList: Swift.Equatable {
        /// A flag that indicates whether more streaming distributions remain to be listed. If your results were truncated, you can make a follow-up pagination request using the Marker request parameter to retrieve more distributions in the list.
        /// This member is required.
        public var isTruncated: Swift.Bool?
        /// A complex type that contains one StreamingDistributionSummary element for each distribution that was created by the current account.
        public var items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// The value you provided for the Marker request parameter.
        /// This member is required.
        public var marker: Swift.String?
        /// The value you provided for the MaxItems request parameter.
        /// This member is required.
        public var maxItems: Swift.Int?
        /// If IsTruncated is true, this element is present and contains the value you can use for the Marker request parameter to continue listing your RTMP distributions where they left off.
        public var nextMarker: Swift.String?
        /// The number of streaming distributions that were created by the current account.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension StreamingDistributionNotDisabled: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionNotDisabled(message: \(Swift.String(describing: message)))"}
}

extension StreamingDistributionNotDisabled {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StreamingDistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CloudFront distribution is not disabled. You must disable the distribution before you can delete it.
public struct StreamingDistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionNotDisabledBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StreamingDistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliases = "Aliases"
        case comment = "Comment"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case status = "Status"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionSummary(aRN: \(Swift.String(describing: aRN)), aliases: \(Swift.String(describing: aliases)), comment: \(Swift.String(describing: comment)), domainName: \(Swift.String(describing: domainName)), enabled: \(Swift.String(describing: enabled)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), priceClass: \(Swift.String(describing: priceClass)), s3Origin: \(Swift.String(describing: s3Origin)), status: \(Swift.String(describing: status)), trustedSigners: \(Swift.String(describing: trustedSigners)))"}
}

extension CloudFrontClientTypes.StreamingDistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A summary of the information for a CloudFront streaming distribution.
    public struct StreamingDistributionSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the streaming distribution. For example: arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5, where 123456789012 is your account ID.
        /// This member is required.
        public var aRN: Swift.String?
        /// A complex type that contains information about CNAMEs (alternate domain names), if any, for this streaming distribution.
        /// This member is required.
        public var aliases: CloudFrontClientTypes.Aliases?
        /// The comment originally specified when this distribution was created.
        /// This member is required.
        public var comment: Swift.String?
        /// The domain name corresponding to the distribution, for example, d111111abcdef8.cloudfront.net.
        /// This member is required.
        public var domainName: Swift.String?
        /// Whether the distribution is enabled to accept end user requests for content.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The identifier for the distribution, for example, EDFDVBD632BHDS5.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the distribution was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// A complex type that contains information about price class for this streaming distribution.
        /// This member is required.
        public var priceClass: CloudFrontClientTypes.PriceClass?
        /// A complex type that contains information about the Amazon S3 bucket from which you want CloudFront to get your media files for distribution.
        /// This member is required.
        public var s3Origin: CloudFrontClientTypes.S3Origin?
        /// Indicates the current status of the distribution. When the status is Deployed, the distribution's information is fully propagated throughout the Amazon CloudFront system.
        /// This member is required.
        public var status: Swift.String?
        /// A complex type that specifies the accounts, if any, that you want to allow to create signed URLs for private content. If you want to require signed URLs in requests for objects in the target origin that match the PathPattern for this cache behavior, specify true for Enabled, and specify the applicable values for Quantity and Items.If you don't want to require signed URLs in requests for objects that match PathPattern, specify false for Enabled and 0 for Quantity. Omit Items. To add, change, or remove one or more trusted signers, change Enabled to true (if it's currently false), change Quantity as applicable, and specify all of the trusted signers that you want to include in the updated distribution. For more information, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the Amazon CloudFront Developer Guide.
        /// This member is required.
        public var trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aRN: Swift.String? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aRN = aRN
            self.aliases = aliases
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingLoggingConfig(bucket: \(Swift.String(describing: bucket)), enabled: \(Swift.String(describing: enabled)), prefix: \(Swift.String(describing: prefix)))"}
}

extension CloudFrontClientTypes.StreamingLoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that controls whether access logs are written for this streaming distribution.
    public struct StreamingLoggingConfig: Swift.Equatable {
        /// The Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com.
        /// This member is required.
        public var bucket: Swift.String?
        /// Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't want to enable logging when you create a streaming distribution or if you want to disable logging for an existing streaming distribution, specify false for Enabled, and specify empty Bucket and Prefix elements. If you specify false for Enabled but you specify values for Bucket and Prefix, the values are automatically deleted.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example, myprefix/. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty Prefix element in the Logging element.
        /// This member is required.
        public var prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }
    }

}

extension CloudFrontClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudFrontClientTypes.Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains Tag key and Tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains Tag key. The string length should be between 1 and 128 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        /// This member is required.
        public var key: Swift.String?
        /// A string that contains an optional Tag value. The string length should be between 0 and 256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . : / = + @.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.TagKeys: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tagkey0 in items {
                try itemsContainer.encode(tagkey0, forKey: ClientRuntime.Key("Key"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Key{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Key>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TagKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagKeys(items: \(Swift.String(describing: items)))"}
}

extension CloudFrontClientTypes.TagKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct TagKeys: Swift.Equatable {
        /// A complex type that contains Tag key elements.
        public var items: [Swift.String]?

        public init (
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tags = input.operationInput.tags {
            do {
                let encoder = context.getEncoder()
                let tagsdata = try encoder.encode(tags)
                let tagsbody = ClientRuntime.HttpBody.data(tagsdata)
                input.builder.withBody(tagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resource: \(Swift.String(describing: resource)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "Operation", value: "Tag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/tagging"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// The request to add tags to a CloudFront resource.
public struct TagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag elements.
    /// This member is required.
    public var tags: CloudFrontClientTypes.Tags?

    public init (
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: CloudFrontClientTypes.Tags?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudFrontClientTypes.Tags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tag0 in items {
                try itemsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Tag{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Tag].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Tag]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Tag]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Tags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tags(items: \(Swift.String(describing: items)))"}
}

extension CloudFrontClientTypes.Tags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that contains zero or more Tag elements.
    public struct Tags: Swift.Equatable {
        /// A complex type that contains Tag elements.
        public var items: [CloudFrontClientTypes.Tag]?

        public init (
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TestFunctionFailed: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionFailed(message: \(Swift.String(describing: message)))"}
}

extension TestFunctionFailed {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TestFunctionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The CloudFront function failed.
public struct TestFunctionFailed: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TestFunctionFailedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TestFunctionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

extension TestFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionInput(eventObject: \(Swift.String(describing: eventObject)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension TestFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TestFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventObject = eventObject {
            try container.encode(eventObject, forKey: ClientRuntime.Key("EventObject"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }
}

public struct TestFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TestFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TestFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TestFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())/test"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TestFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInput: Swift.Equatable {
    /// The event object to test the function with. For more information about the structure of the event object, see [Testing functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var eventObject: ClientRuntime.Data?
    /// The current version (ETag value) of the function that you are testing, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are testing.
    /// This member is required.
    public var name: Swift.String?
    /// The stage of the function that you are testing, either DEVELOPMENT or LIVE.
    public var stage: CloudFrontClientTypes.FunctionStage?

    public init (
        eventObject: ClientRuntime.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

struct TestFunctionInputBody: Swift.Equatable {
    public let stage: CloudFrontClientTypes.FunctionStage?
    public let eventObject: ClientRuntime.Data?
}

extension TestFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        if containerValues.contains(.eventObject) {
            do {
                let eventObjectDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .eventObject)
                eventObject = eventObjectDecoded
            } catch {
                eventObject = "".data(using: .utf8)
            }
        } else {
            eventObject = nil
        }
    }
}

extension TestFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TestFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TestFunctionFailed" : self = .testFunctionFailed(try TestFunctionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case testFunctionFailed(TestFunctionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionOutputResponse(testResult: \(Swift.String(describing: testResult)))"}
}

extension TestFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.TestResult = try responseDecoder.decode(responseBody: data)
                self.testResult = output
            } else {
                self.testResult = nil
            }
        } else {
            self.testResult = nil
        }
    }
}

public struct TestFunctionOutputResponse: Swift.Equatable {
    /// An object that represents the result of running the function with the provided event object.
    public var testResult: CloudFrontClientTypes.TestResult?

    public init (
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

struct TestFunctionOutputResponseBody: Swift.Equatable {
    public let testResult: CloudFrontClientTypes.TestResult?
}

extension TestFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testResult = "TestResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testResultDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeUtilization = "ComputeUtilization"
        case functionErrorMessage = "FunctionErrorMessage"
        case functionExecutionLogs = "FunctionExecutionLogs"
        case functionOutput = "FunctionOutput"
        case functionSummary = "FunctionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let computeUtilization = computeUtilization {
            try container.encode(computeUtilization, forKey: ClientRuntime.Key("ComputeUtilization"))
        }
        if let functionErrorMessage = functionErrorMessage {
            try container.encode(functionErrorMessage, forKey: ClientRuntime.Key("FunctionErrorMessage"))
        }
        if let functionExecutionLogs = functionExecutionLogs {
            var functionExecutionLogsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FunctionExecutionLogs"))
            for string0 in functionExecutionLogs {
                try functionExecutionLogsContainer.encode(string0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let functionOutput = functionOutput {
            try container.encode(functionOutput, forKey: ClientRuntime.Key("FunctionOutput"))
        }
        if let functionSummary = functionSummary {
            try container.encode(functionSummary, forKey: ClientRuntime.Key("FunctionSummary"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
        let computeUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computeUtilization)
        computeUtilization = computeUtilizationDecoded
        if containerValues.contains(.functionExecutionLogs) {
            struct KeyVal0{struct member{}}
            let functionExecutionLogsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .functionExecutionLogs)
            if let functionExecutionLogsWrappedContainer = functionExecutionLogsWrappedContainer {
                let functionExecutionLogsContainer = try functionExecutionLogsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var functionExecutionLogsBuffer:[Swift.String]? = nil
                if let functionExecutionLogsContainer = functionExecutionLogsContainer {
                    functionExecutionLogsBuffer = [Swift.String]()
                    for stringContainer0 in functionExecutionLogsContainer {
                        functionExecutionLogsBuffer?.append(stringContainer0)
                    }
                }
                functionExecutionLogs = functionExecutionLogsBuffer
            } else {
                functionExecutionLogs = []
            }
        } else {
            functionExecutionLogs = nil
        }
        let functionErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionErrorMessage)
        functionErrorMessage = functionErrorMessageDecoded
        let functionOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionOutput)
        functionOutput = functionOutputDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(computeUtilization: \(Swift.String(describing: computeUtilization)), functionErrorMessage: \(Swift.String(describing: functionErrorMessage)), functionExecutionLogs: \(Swift.String(describing: functionExecutionLogs)), functionOutput: \(Swift.String(describing: functionOutput)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension CloudFrontClientTypes.TestResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// Contains the result of testing a CloudFront function with TestFunction.
    public struct TestResult: Swift.Equatable {
        /// The amount of time that the function took to run as a percentage of the maximum allowed time. For example, a compute utilization of 35 means that the function completed in 35% of the maximum allowed time.
        public var computeUtilization: Swift.String?
        /// If the result of testing the function was an error, this field contains the error message.
        public var functionErrorMessage: Swift.String?
        /// Contains the log lines that the function wrote (if any) when running the test.
        public var functionExecutionLogs: [Swift.String]?
        /// The event object returned by the function. For more information about the structure of the event object, see [Event object structure](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html) in the Amazon CloudFront Developer Guide.
        public var functionOutput: Swift.String?
        /// Contains configuration information and metadata about the CloudFront function that was tested.
        public var functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init (
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }

}

extension TooManyCacheBehaviors: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCacheBehaviors(message: \(Swift.String(describing: message)))"}
}

extension TooManyCacheBehaviors {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCacheBehaviorsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create more cache behaviors for the distribution.
public struct TooManyCacheBehaviors: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCacheBehaviorsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCacheBehaviorsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCachePolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCachePolicies(message: \(Swift.String(describing: message)))"}
}

extension TooManyCachePolicies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCachePoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of cache policies for this account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCachePolicies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCachePoliciesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCachePoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCertificates(message: \(Swift.String(describing: message)))"}
}

extension TooManyCertificates {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCertificatesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create anymore custom SSL/TLS certificates.
public struct TooManyCertificates: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCertificatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCloudFrontOriginAccessIdentities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCloudFrontOriginAccessIdentities(message: \(Swift.String(describing: message)))"}
}

extension TooManyCloudFrontOriginAccessIdentities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCloudFrontOriginAccessIdentitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin access identities allowed.
public struct TooManyCloudFrontOriginAccessIdentities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookieNamesInWhiteList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookieNamesInWhiteList(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookieNamesInWhiteList {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookieNamesInWhiteListBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more cookie names in the whitelist than are allowed per cache behavior.
public struct TooManyCookieNamesInWhiteList: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookieNamesInWhiteListBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookieNamesInWhiteListBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookiesInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookiesInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of cookies in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookiesInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookiesInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookiesInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyCookiesInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of cookies in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyCookiesInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookiesInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionCNAMEs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionCNAMEs(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionCNAMEs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionCNAMEsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributions(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of distributions allowed.
public struct TooManyDistributions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified cache policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified configuration for field-level encryption.
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToKeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToKeyGroup(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToKeyGroup {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of distributions that reference this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToKeyGroup: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToKeyGroupBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsAssociatedToOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified origin request policy. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyDistributionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of distributions that are associated with a CloudFront function. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyDistributionsWithFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithLambdaAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithLambdaAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithLambdaAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithLambdaAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause the maximum number of distributions with Lambda@Edge function associations per owner to be exceeded.
public struct TooManyDistributionsWithLambdaAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithLambdaAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithLambdaAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithSingleFunctionARN: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithSingleFunctionARN(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithSingleFunctionARN {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyDistributionsWithSingleFunctionARNBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of distributions have been associated with the specified Lambda@Edge function.
public struct TooManyDistributionsWithSingleFunctionARN: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithSingleFunctionARNBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithSingleFunctionARNBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionConfigs(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionConfigs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of configurations for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionConfigs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionConfigsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionContentTypeProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionContentTypeProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionContentTypeProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of content type profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionContentTypeProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionEncryptionEntities(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionEncryptionEntities {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionEncryptionEntitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of encryption entities for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionEncryptionEntities: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionFieldPatterns(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionFieldPatterns {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionFieldPatternsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of field patterns for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionFieldPatterns: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionQueryArgProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionQueryArgProfiles {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFieldLevelEncryptionQueryArgProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of query arg profiles for field-level encryption have been created.
public struct TooManyFieldLevelEncryptionQueryArgProfiles: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of CloudFront function associations for this distribution. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFunctions(message: \(Swift.String(describing: message)))"}
}

extension TooManyFunctions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyFunctionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of CloudFront functions for this account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyFunctions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFunctionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of headers in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInForwardedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInForwardedValues(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInForwardedValues {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInForwardedValuesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many headers in forwarded values.
public struct TooManyHeadersInForwardedValues: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInForwardedValuesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInForwardedValuesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyHeadersInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of headers in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyHeadersInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyInvalidationsInProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyInvalidationsInProgress(message: \(Swift.String(describing: message)))"}
}

extension TooManyInvalidationsInProgress {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyInvalidationsInProgressBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.
public struct TooManyInvalidationsInProgress: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyInvalidationsInProgressBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyInvalidationsInProgressBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyKeyGroups(message: \(Swift.String(describing: message)))"}
}

extension TooManyKeyGroups {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of key groups for this account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroups: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyKeyGroupsAssociatedToDistribution(message: \(Swift.String(describing: message)))"}
}

extension TooManyKeyGroupsAssociatedToDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyKeyGroupsAssociatedToDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of key groups referenced by this distribution is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyKeyGroupsAssociatedToDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyKeyGroupsAssociatedToDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyKeyGroupsAssociatedToDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyKeyGroupsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyKeyGroupsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLambdaFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyLambdaFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyLambdaFunctionAssociations {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyLambdaFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more Lambda@Edge function associations than are allowed per distribution.
public struct TooManyLambdaFunctionAssociations: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLambdaFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyLambdaFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginCustomHeaders: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginCustomHeaders(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginCustomHeaders {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginCustomHeadersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many origin custom headers.
public struct TooManyOriginCustomHeaders: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginCustomHeadersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginCustomHeadersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginGroupsPerDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginGroupsPerDistribution(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginGroupsPerDistribution {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginGroupsPerDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of origin groups allowed.
public struct TooManyOriginGroupsPerDistribution: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginGroupsPerDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginGroupsPerDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginRequestPolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginRequestPolicies(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginRequestPolicies {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginRequestPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of origin request policies for this account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyOriginRequestPolicies: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginRequestPoliciesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginRequestPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOrigins: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOrigins(message: \(Swift.String(describing: message)))"}
}

extension TooManyOrigins {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyOriginsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You cannot create more origins for the distribution.
public struct TooManyOrigins: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyPublicKeys(message: \(Swift.String(describing: message)))"}
}

extension TooManyPublicKeys {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.
public struct TooManyPublicKeys: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyPublicKeysBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeysInKeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyPublicKeysInKeyGroup(message: \(Swift.String(describing: message)))"}
}

extension TooManyPublicKeysInKeyGroup {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPublicKeysInKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of public keys in this key group is more than the maximum allowed. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyPublicKeysInKeyGroup: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysInKeyGroupBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyPublicKeysInKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringParameters(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringParameters {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains too many query string parameters.
public struct TooManyQueryStringParameters: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringParametersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringsInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringsInCachePolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of query strings in the cache policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInCachePolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringsInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringsInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringsInOriginRequestPolicy {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyQueryStringsInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of query strings in the origin request policy exceeds the maximum. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyQueryStringsInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringsInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRealtimeLogConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRealtimeLogConfigs(message: \(Swift.String(describing: message)))"}
}

extension TooManyRealtimeLogConfigs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyRealtimeLogConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of real-time log configurations for this account. For more information, see [Quotas](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html) (formerly known as limits) in the Amazon CloudFront Developer Guide.
public struct TooManyRealtimeLogConfigs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRealtimeLogConfigsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRealtimeLogConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributionCNAMEs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyStreamingDistributionCNAMEs(message: \(Swift.String(describing: message)))"}
}

extension TooManyStreamingDistributionCNAMEs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more CNAMEs than are allowed per distribution.
public struct TooManyStreamingDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionCNAMEsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyStreamingDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyStreamingDistributions(message: \(Swift.String(describing: message)))"}
}

extension TooManyStreamingDistributions {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyStreamingDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Processing your request would cause you to exceed the maximum number of streaming distributions allowed.
public struct TooManyStreamingDistributions: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyStreamingDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTrustedSigners(message: \(Swift.String(describing: message)))"}
}

extension TooManyTrustedSigners {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTrustedSignersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request contains more trusted signers than are allowed per distribution.
public struct TooManyTrustedSigners: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTrustedSignersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTrustedSignersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedKeyGroupDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedKeyGroupDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension TrustedKeyGroupDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedKeyGroupDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified key group does not exist.
public struct TrustedKeyGroupDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedKeyGroupDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TrustedKeyGroupDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedKeyGroups(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.TrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of key groups whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedKeyGroups: Swift.Equatable {
        /// This field is true if any of the key groups in the list have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of key groups identifiers.
        public var items: [Swift.String]?
        /// The number of key groups in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension TrustedSignerDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedSignerDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension TrustedSignerDoesNotExist {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<TrustedSignerDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of your trusted signers don't exist.
public struct TrustedSignerDoesNotExist: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedSignerDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TrustedSignerDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("AwsAccountNumber"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct AwsAccountNumber{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AwsAccountNumber>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedSigners(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.TrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A list of accounts whose public keys CloudFront can use to verify the signatures of signed URLs and signed cookies.
    public struct TrustedSigners: Swift.Equatable {
        /// This field is true if any of the accounts have public keys that CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this field is false.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A list of account identifiers.
        public var items: [Swift.String]?
        /// The number of accounts in the list.
        /// This member is required.
        public var quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension UnsupportedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperation(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<UnsupportedOperationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not supported in this region.
public struct UnsupportedOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            do {
                let encoder = context.getEncoder()
                let tagKeysdata = try encoder.encode(tagKeys)
                let tagKeysbody = ClientRuntime.HttpBody.data(tagKeysdata)
                input.builder.withBody(tagKeysbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resource: \(Swift.String(describing: resource)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagKeys = tagKeys {
            try container.encode(tagKeys, forKey: ClientRuntime.Key("TagKeys"))
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "Operation", value: "Untag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/tagging"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

/// The request to remove tags from a CloudFront resource.
public struct UntagResourceInput: Swift.Equatable {
    /// An ARN of a CloudFront resource.
    /// This member is required.
    public var resource: Swift.String?
    /// A complex type that contains zero or more Tag key elements.
    /// This member is required.
    public var tagKeys: CloudFrontClientTypes.TagKeys?

    public init (
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let tagKeys: CloudFrontClientTypes.TagKeys?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TagKeys.self, forKey: .tagKeys)
        tagKeys = tagKeysDecoded
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

extension UpdateCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCachePolicyInput(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

public struct UpdateCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateCachePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/cache-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCachePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInput: Swift.Equatable {
    /// A cache policy configuration.
    /// This member is required.
    public var cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// The unique identifier for the cache policy that you are updating. The identifier is returned in a cache behavior’s CachePolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the cache policy that you are updating. The version is returned in the cache policy’s ETag field in the response to GetCachePolicyConfig.
    public var ifMatch: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCachePolicyInputBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension UpdateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension UpdateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct UpdateCachePolicyOutputResponse: Swift.Equatable {
    /// A cache policy.
    public var cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// The current version of the cache policy.
    public var eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct UpdateCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension UpdateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

public struct UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

public struct UpdateCloudFrontOriginAccessIdentityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

public struct UpdateCloudFrontOriginAccessIdentityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateCloudFrontOriginAccessIdentityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCloudFrontOriginAccessIdentityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

/// The request to update an origin access identity.
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// The identity's configuration information.
    /// This member is required.
    public var cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// The identity's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the identity's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case missingBody(MissingBody)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// The origin access identity's information.
    public var cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct UpdateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

extension UpdateDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionInput(distributionConfig: \(Swift.String(describing: distributionConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

public struct UpdateDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

public struct UpdateDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

public struct UpdateDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

public struct UpdateDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/distribution/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

/// The request to update a distribution.
public struct UpdateDistributionInput: Swift.Equatable {
    /// The distribution's configuration information.
    /// This member is required.
    public var distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// The distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateDistributionInputBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension UpdateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension UpdateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case preconditionFailed(PreconditionFailed)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateDistributionOutputResponse: Swift.Equatable {
    /// The distribution's information.
    public var distribution: CloudFrontClientTypes.Distribution?
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension UpdateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct UpdateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFieldLevelEncryptionConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFieldLevelEncryptionConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// Request to update a field-level encryption configuration.
    /// This member is required.
    public var fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// The ID of the configuration you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the configuration identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension UpdateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)))"}
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// The value of the ETag header that you received when updating the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// Return the results of updating the configuration.
    public var fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct UpdateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFieldLevelEncryptionProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/field-level-encryption-profile/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFieldLevelEncryptionProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// Request to update a field-level encryption profile.
    /// This member is required.
    public var fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// The ID of the field-level encryption profile request.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the profile identity to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension UpdateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)))"}
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// The result of the field-level encryption profile request.
    public var eTag: Swift.String?
    /// Return the results of updating the profile.
    public var fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct UpdateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(functionCode: \(Swift.String(describing: functionCode)), functionConfig: \(Swift.String(describing: functionConfig)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension UpdateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
    }
}

public struct UpdateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFunctionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/function/\(name.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFunctionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// The function code. For more information about writing a CloudFront function, see [Writing function code for CloudFront Functions](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html) in the Amazon CloudFront Developer Guide.
    /// This member is required.
    public var functionCode: ClientRuntime.Data?
    /// Configuration information about the function.
    /// This member is required.
    public var functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// The current version (ETag value) of the function that you are updating, which you can get using DescribeFunction.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The name of the function that you are updating.
    /// This member is required.
    public var name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    public let functionCode: ClientRuntime.Data?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension UpdateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension UpdateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Swift.Equatable {
    /// The version identifier for the current version of the CloudFront function.
    public var eTag: Swift.String?
    /// Contains configuration information and metadata about a CloudFront function.
    public var functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct UpdateFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension UpdateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct UpdateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

extension UpdateKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKeyGroupInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension UpdateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

public struct UpdateKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateKeyGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/key-group/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateKeyGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInput: Swift.Equatable {
    /// The identifier of the key group that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the key group that you are updating. The version is the key group’s ETag value.
    public var ifMatch: Swift.String?
    /// The key group configuration.
    /// This member is required.
    public var keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

struct UpdateKeyGroupInputBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension UpdateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension UpdateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension UpdateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct UpdateKeyGroupOutputResponse: Swift.Equatable {
    /// The identifier for this version of the key group.
    public var eTag: Swift.String?
    /// The key group that was just updated.
    public var keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct UpdateKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension UpdateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct UpdateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

extension UpdateOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginRequestPolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct UpdateOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateOriginRequestPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/origin-request-policy/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOriginRequestPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInput: Swift.Equatable {
    /// The unique identifier for the origin request policy that you are updating. The identifier is returned in a cache behavior’s OriginRequestPolicyId field in the response to GetDistributionConfig.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the origin request policy that you are updating. The version is returned in the origin request policy’s ETag field in the response to GetOriginRequestPolicyConfig.
    public var ifMatch: Swift.String?
    /// An origin request policy configuration.
    /// This member is required.
    public var originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct UpdateOriginRequestPolicyInputBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension UpdateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension UpdateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension UpdateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct UpdateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// The current version of the origin request policy.
    public var eTag: Swift.String?
    /// An origin request policy.
    public var originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct UpdateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension UpdateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct UpdatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

extension UpdatePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicKeyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension UpdatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdatePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

public struct UpdatePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePublicKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/public-key/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePublicKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInput: Swift.Equatable {
    /// The identifier of the public key that you are updating.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the public key to update. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// A public key configuration.
    /// This member is required.
    public var publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

struct UpdatePublicKeyInputBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension UpdatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension UpdatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotChangeImmutablePublicKeyFields" : self = .cannotChangeImmutablePublicKeyFields(try CannotChangeImmutablePublicKeyFields(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cannotChangeImmutablePublicKeyFields(CannotChangeImmutablePublicKeyFields)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension UpdatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct UpdatePublicKeyOutputResponse: Swift.Equatable {
    /// The identifier of the current version of the public key.
    public var eTag: Swift.String?
    /// The public key.
    public var publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct UpdatePublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension UpdatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct UpdateRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

extension UpdateRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

public struct UpdateRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRealtimeLogConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/2020-05-31/realtime-log-config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRealtimeLogConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for this real-time log configuration.
    public var aRN: Swift.String?
    /// Contains information about the Amazon Kinesis data stream where you are sending real-time log data.
    public var endPoints: [CloudFrontClientTypes.EndPoint]?
    /// A list of fields to include in each real-time log record. For more information about fields, see [Real-time log configuration fields](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields) in the Amazon CloudFront Developer Guide.
    public var fields: [Swift.String]?
    /// The name for this real-time log configuration.
    public var name: Swift.String?
    /// The sampling rate for this real-time log configuration. The sampling rate determines the percentage of viewer requests that are represented in the real-time log data. You must provide an integer between 1 and 100, inclusive.
    public var samplingRate: Swift.Int?

    public init (
        aRN: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.aRN = aRN
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct UpdateRealtimeLogConfigInputBody: Swift.Equatable {
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    public let fields: [Swift.String]?
    public let name: Swift.String?
    public let aRN: Swift.String?
    public let samplingRate: Swift.Int?
}

extension UpdateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension UpdateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension UpdateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct UpdateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// A real-time log configuration.
    public var realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct UpdateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension UpdateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct UpdateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

extension UpdateStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension UpdateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

public struct UpdateStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

public struct UpdateStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

public struct UpdateStreamingDistributionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

public struct UpdateStreamingDistributionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateStreamingDistributionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/2020-05-31/streaming-distribution/\(id.urlPercentEncoding())/config"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStreamingDistributionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

/// The request to update a streaming distribution.
public struct UpdateStreamingDistributionInput: Swift.Equatable {
    /// The streaming distribution's id.
    /// This member is required.
    public var id: Swift.String?
    /// The value of the ETag header that you received when retrieving the streaming distribution's configuration. For example: E2QWRUHAPOMQZL.
    public var ifMatch: Swift.String?
    /// The streaming distribution's configuration information.
    /// This member is required.
    public var streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct UpdateStreamingDistributionInputBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension UpdateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension UpdateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension UpdateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// The returned result of the corresponding request.
public struct UpdateStreamingDistributionOutputResponse: Swift.Equatable {
    /// The current version of the configuration. For example: E2QWRUHAPOMQZL.
    public var eTag: Swift.String?
    /// The streaming distribution's information.
    public var streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct UpdateStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension UpdateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aCMCertificateArn = "ACMCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iAMCertificateId = "IAMCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sSLSupportMethod = "SSLSupportMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aCMCertificateArn = aCMCertificateArn {
            try container.encode(aCMCertificateArn, forKey: ClientRuntime.Key("ACMCertificateArn"))
        }
        if let certificate = certificate {
            try container.encode(certificate, forKey: ClientRuntime.Key("Certificate"))
        }
        if let certificateSource = certificateSource {
            try container.encode(certificateSource, forKey: ClientRuntime.Key("CertificateSource"))
        }
        if let cloudFrontDefaultCertificate = cloudFrontDefaultCertificate {
            try container.encode(cloudFrontDefaultCertificate, forKey: ClientRuntime.Key("CloudFrontDefaultCertificate"))
        }
        if let iAMCertificateId = iAMCertificateId {
            try container.encode(iAMCertificateId, forKey: ClientRuntime.Key("IAMCertificateId"))
        }
        if let minimumProtocolVersion = minimumProtocolVersion {
            try container.encode(minimumProtocolVersion, forKey: ClientRuntime.Key("MinimumProtocolVersion"))
        }
        if let sSLSupportMethod = sSLSupportMethod {
            try container.encode(sSLSupportMethod, forKey: ClientRuntime.Key("SSLSupportMethod"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudFrontDefaultCertificate)
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iAMCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMCertificateId)
        iAMCertificateId = iAMCertificateIdDecoded
        let aCMCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aCMCertificateArn)
        aCMCertificateArn = aCMCertificateArnDecoded
        let sSLSupportMethodDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.SSLSupportMethod.self, forKey: .sSLSupportMethod)
        sSLSupportMethod = sSLSupportMethodDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MinimumProtocolVersion.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CertificateSource.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewerCertificate(aCMCertificateArn: \(Swift.String(describing: aCMCertificateArn)), certificate: \(Swift.String(describing: certificate)), certificateSource: \(Swift.String(describing: certificateSource)), cloudFrontDefaultCertificate: \(Swift.String(describing: cloudFrontDefaultCertificate)), iAMCertificateId: \(Swift.String(describing: iAMCertificateId)), minimumProtocolVersion: \(Swift.String(describing: minimumProtocolVersion)), sSLSupportMethod: \(Swift.String(describing: sSLSupportMethod)))"}
}

extension CloudFrontClientTypes.ViewerCertificate: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// A complex type that determines the distribution’s SSL/TLS configuration for communicating with viewers. If the distribution doesn’t use Aliases (also known as alternate domain names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net—set CloudFrontDefaultCertificate to true and leave all other fields empty. If the distribution uses Aliases (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:
    ///
    /// * Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don’t support SNI.
    ///
    /// * To accept HTTPS connections from only viewers that support SNI, set SSLSupportMethod to sni-only. This is recommended. Most browsers and clients support SNI.
    ///
    /// * To accept HTTPS connections from all viewers, including those that don’t support SNI, set SSLSupportMethod to vip. This is not recommended, and results in additional monthly charges from CloudFront.
    ///
    ///
    ///
    ///
    /// * The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for MinimumProtocolVersion. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the Amazon CloudFront Developer Guide.
    ///
    /// * The location of the SSL/TLS certificate, [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):
    ///
    /// * ACMCertificateArn
    ///
    /// * IAMCertificateId
    ///
    ///
    ///
    ///
    ///
    /// All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ViewerProtocolPolicy in the CacheBehavior or DefaultCacheBehavior. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use CustomOriginConfig. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [ Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the Amazon CloudFront Developer Guide.
    public struct ViewerCertificate: Swift.Equatable {
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Certificate Manager (ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (us-east-1). If you specify an ACM certificate ARN, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var aCMCertificateArn: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificate: Swift.String?
        /// This field is deprecated. Use one of the following fields instead:
        ///
        /// * ACMCertificateArn
        ///
        /// * IAMCertificateId
        ///
        /// * CloudFrontDefaultCertificate
        @available(*, deprecated)
        public var certificateSource: CloudFrontClientTypes.CertificateSource?
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, set this field to true. If the distribution uses Aliases (alternate domain names or CNAMEs), set this field to false and specify values for the following fields:
        ///
        /// * ACMCertificateArn or IAMCertificateId (specify a value for one, not both)
        ///
        /// * MinimumProtocolVersion
        ///
        /// * SSLSupportMethod
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [Identity and Access Management (IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for MinimumProtocolVersion and SSLSupportMethod.
        public var iAMCertificateId: Swift.String?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:
        ///
        /// * The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.
        ///
        /// * The ciphers that CloudFront can use to encrypt the content that it returns to viewers.
        ///
        ///
        /// For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the Amazon CloudFront Developer Guide. On the CloudFront console, this setting is called Security Policy. When you’re using SNI only (you set SSLSupportMethod to sni-only), you must specify TLSv1 or higher. If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net (you set CloudFrontDefaultCertificate to true), CloudFront automatically sets the security policy to TLSv1 regardless of the value that you set here.
        public var minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// If the distribution uses Aliases (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.
        ///
        /// * sni-only – The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.
        ///
        /// * vip – The distribution accepts HTTPS connections from all viewers including those that don’t support SNI. This is not recommended, and results in additional monthly charges from CloudFront.
        ///
        /// * static-ip - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home).
        ///
        ///
        /// If the distribution uses the CloudFront domain name such as d111111abcdef8.cloudfront.net, don’t set a value for this field.
        public var sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init (
            aCMCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iAMCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.aCMCertificateArn = aCMCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iAMCertificateId = iAMCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sSLSupportMethod = sSLSupportMethod
        }
    }

}

extension CloudFrontClientTypes {
    public enum ViewerProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}
