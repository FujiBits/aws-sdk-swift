// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppStreamClientTypes.AccessEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case vpceId = "VpceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let vpceId = vpceId {
            try encodeContainer.encode(vpceId, forKey: .vpceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AccessEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let vpceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceId)
        vpceId = vpceIdDecoded
    }
}

extension AppStreamClientTypes.AccessEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessEndpoint(endpointType: \(Swift.String(describing: endpointType)), vpceId: \(Swift.String(describing: vpceId)))"}
}

extension AppStreamClientTypes {
    /// Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.
    public struct AccessEndpoint: Swift.Equatable {
        /// The type of interface endpoint.
        /// This member is required.
        public var endpointType: AppStreamClientTypes.AccessEndpointType?
        /// The identifier (ID) of the VPC in which the interface endpoint is used.
        public var vpceId: Swift.String?

        public init (
            endpointType: AppStreamClientTypes.AccessEndpointType? = nil,
            vpceId: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.vpceId = vpceId
        }
    }

}

extension AppStreamClientTypes {
    public enum AccessEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEndpointType] {
            return [
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessEndpointType(rawValue: rawValue) ?? AccessEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clipboardCopyFromLocalDevice
        case clipboardCopyToLocalDevice
        case domainPasswordSignin
        case domainSmartCardSignin
        case fileDownload
        case fileUpload
        case printingToLocalDevice
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .clipboardCopyFromLocalDevice,
                .clipboardCopyToLocalDevice,
                .domainPasswordSignin,
                .domainSmartCardSignin,
                .fileDownload,
                .fileUpload,
                .printingToLocalDevice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
            case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
            case .domainPasswordSignin: return "DOMAIN_PASSWORD_SIGNIN"
            case .domainSmartCardSignin: return "DOMAIN_SMART_CARD_SIGNIN"
            case .fileDownload: return "FILE_DOWNLOAD"
            case .fileUpload: return "FILE_UPLOAD"
            case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.Application: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case enabled = "Enabled"
        case iconURL = "IconURL"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let iconURL = iconURL {
            try encodeContainer.encode(iconURL, forKey: .iconURL)
        }
        if let launchParameters = launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iconURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconURL)
        iconURL = iconURLDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension AppStreamClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(displayName: \(Swift.String(describing: displayName)), enabled: \(Swift.String(describing: enabled)), iconURL: \(Swift.String(describing: iconURL)), launchParameters: \(Swift.String(describing: launchParameters)), launchPath: \(Swift.String(describing: launchPath)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension AppStreamClientTypes {
    /// Describes an application in the application catalog.
    public struct Application: Swift.Equatable {
        /// The application name to display.
        public var displayName: Swift.String?
        /// If there is a problem, the application can be disabled after image creation.
        public var enabled: Swift.Bool
        /// The URL for the application icon. This URL might be time-limited.
        public var iconURL: Swift.String?
        /// The arguments that are passed to the application at launch.
        public var launchParameters: Swift.String?
        /// The path to the application executable in the instance.
        public var launchPath: Swift.String?
        /// Additional attributes that describe the application.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the application.
        public var name: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            enabled: Swift.Bool = false,
            iconURL: Swift.String? = nil,
            launchParameters: Swift.String? = nil,
            launchPath: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.enabled = enabled
            self.iconURL = iconURL
            self.launchParameters = launchParameters
            self.launchPath = launchPath
            self.metadata = metadata
            self.name = name
        }
    }

}

extension AppStreamClientTypes.ApplicationSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
    }
}

extension AppStreamClientTypes.ApplicationSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationSettings(enabled: \(Swift.String(describing: enabled)), settingsGroup: \(Swift.String(describing: settingsGroup)))"}
}

extension AppStreamClientTypes {
    /// The persistent application settings for users of a stack.
    public struct ApplicationSettings: Swift.Equatable {
        /// Enables or disables persistent application settings for users during their streaming sessions.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack.
        public var settingsGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.settingsGroup = settingsGroup
        }
    }

}

extension AppStreamClientTypes.ApplicationSettingsResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension AppStreamClientTypes.ApplicationSettingsResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationSettingsResponse(enabled: \(Swift.String(describing: enabled)), s3BucketName: \(Swift.String(describing: s3BucketName)), settingsGroup: \(Swift.String(describing: settingsGroup)))"}
}

extension AppStreamClientTypes {
    /// Describes the persistent application settings for users of a stack.
    public struct ApplicationSettingsResponse: Swift.Equatable {
        /// Specifies whether persistent application settings are enabled for users during their streaming sessions.
        public var enabled: Swift.Bool
        /// The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region.
        public var s3BucketName: Swift.String?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored.
        public var settingsGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
        }
    }

}

public struct AssociateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFleetOutputError>
}

extension AssociateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFleetInput(fleetName: \(Swift.String(describing: fleetName)), stackName: \(Swift.String(describing: stackName)))"}
}

extension AssociateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct AssociateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFleetOutputError>
}

public struct AssociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct AssociateFleetInputBody: Swift.Equatable {
    public let fleetName: Swift.String?
    public let stackName: Swift.String?
}

extension AssociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension AssociateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFleetOutputResponse()"}
}

extension AssociateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateFleetOutputResponseBody: Swift.Equatable {
}

extension AssociateFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppStreamClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case saml
        case userpool
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .api,
                .saml,
                .userpool,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .saml: return "SAML"
            case .userpool: return "USERPOOL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

public struct BatchAssociateUserStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateUserStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateUserStackOutputError>
}

extension BatchAssociateUserStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateUserStackInput(userStackAssociations: \(Swift.String(describing: userStackAssociations)))"}
}

extension BatchAssociateUserStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

public struct BatchAssociateUserStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateUserStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateUserStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateUserStackInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchAssociateUserStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateUserStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateUserStackInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchAssociateUserStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateUserStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateUserStackOutputError>
}

public struct BatchAssociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchAssociateUserStackInputBody: Swift.Equatable {
    public let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchAssociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchAssociateUserStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateUserStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateUserStackOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateUserStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateUserStackOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchAssociateUserStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateUserStackOutputResponse: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init (
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateUserStackOutputResponseBody: Swift.Equatable {
    public let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchAssociateUserStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDisassociateUserStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateUserStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateUserStackOutputError>
}

extension BatchDisassociateUserStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateUserStackInput(userStackAssociations: \(Swift.String(describing: userStackAssociations)))"}
}

extension BatchDisassociateUserStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

public struct BatchDisassociateUserStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateUserStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateUserStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateUserStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateUserStackInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDisassociateUserStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateUserStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateUserStackInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDisassociateUserStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateUserStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateUserStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateUserStackOutputError>
}

public struct BatchDisassociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchDisassociateUserStackInputBody: Swift.Equatable {
    public let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchDisassociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchDisassociateUserStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateUserStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateUserStackOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateUserStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateUserStackOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchDisassociateUserStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateUserStackOutputResponse: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init (
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateUserStackOutputResponseBody: Swift.Equatable {
    public let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchDisassociateUserStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AppStreamClientTypes.ComputeCapacity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstances = "DesiredInstances"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredInstances = desiredInstances {
            try encodeContainer.encode(desiredInstances, forKey: .desiredInstances)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredInstances)
        desiredInstances = desiredInstancesDecoded
    }
}

extension AppStreamClientTypes.ComputeCapacity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeCapacity(desiredInstances: \(Swift.String(describing: desiredInstances)))"}
}

extension AppStreamClientTypes {
    /// Describes the capacity for a fleet.
    public struct ComputeCapacity: Swift.Equatable {
        /// The desired number of streaming instances.
        /// This member is required.
        public var desiredInstances: Swift.Int?

        public init (
            desiredInstances: Swift.Int? = nil
        )
        {
            self.desiredInstances = desiredInstances
        }
    }

}

extension AppStreamClientTypes.ComputeCapacityStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case available = "Available"
        case desired = "Desired"
        case inUse = "InUse"
        case running = "Running"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let available = available {
            try encodeContainer.encode(available, forKey: .available)
        }
        if let desired = desired {
            try encodeContainer.encode(desired, forKey: .desired)
        }
        if let inUse = inUse {
            try encodeContainer.encode(inUse, forKey: .inUse)
        }
        if let running = running {
            try encodeContainer.encode(running, forKey: .running)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desired)
        desired = desiredDecoded
        let runningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .running)
        running = runningDecoded
        let inUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inUse)
        inUse = inUseDecoded
        let availableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .available)
        available = availableDecoded
    }
}

extension AppStreamClientTypes.ComputeCapacityStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeCapacityStatus(available: \(Swift.String(describing: available)), desired: \(Swift.String(describing: desired)), inUse: \(Swift.String(describing: inUse)), running: \(Swift.String(describing: running)))"}
}

extension AppStreamClientTypes {
    /// Describes the capacity status for a fleet.
    public struct ComputeCapacityStatus: Swift.Equatable {
        /// The number of currently available instances that can be used to stream sessions.
        public var available: Swift.Int?
        /// The desired number of streaming instances.
        /// This member is required.
        public var desired: Swift.Int?
        /// The number of instances in use for streaming.
        public var inUse: Swift.Int?
        /// The total number of simultaneous streaming instances that are running.
        public var running: Swift.Int?

        public init (
            available: Swift.Int? = nil,
            desired: Swift.Int? = nil,
            inUse: Swift.Int? = nil,
            running: Swift.Int? = nil
        )
        {
            self.available = available
            self.desired = desired
            self.inUse = inUse
            self.running = running
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An API error occurred. Wait a few minutes and try again.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CopyImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyImageOutputError>
}

extension CopyImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyImageInput(destinationImageDescription: \(Swift.String(describing: destinationImageDescription)), destinationImageName: \(Swift.String(describing: destinationImageName)), destinationRegion: \(Swift.String(describing: destinationRegion)), sourceImageName: \(Swift.String(describing: sourceImageName)))"}
}

extension CopyImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationImageDescription = destinationImageDescription {
            try encodeContainer.encode(destinationImageDescription, forKey: .destinationImageDescription)
        }
        if let destinationImageName = destinationImageName {
            try encodeContainer.encode(destinationImageName, forKey: .destinationImageName)
        }
        if let destinationRegion = destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let sourceImageName = sourceImageName {
            try encodeContainer.encode(sourceImageName, forKey: .sourceImageName)
        }
    }
}

public struct CopyImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyImageOutputError>
}

public struct CopyImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyImageOutputError>
}

public struct CopyImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CopyImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyImageOutputError>
}

public struct CopyImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CopyImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyImageOutputError>
}

public struct CopyImageInput: Swift.Equatable {
    /// The description that the image will have when it is copied to the destination.
    public var destinationImageDescription: Swift.String?
    /// The name that the image will have when it is copied to the destination.
    /// This member is required.
    public var destinationImageName: Swift.String?
    /// The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the image to copy.
    /// This member is required.
    public var sourceImageName: Swift.String?

    public init (
        destinationImageDescription: Swift.String? = nil,
        destinationImageName: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        sourceImageName: Swift.String? = nil
    )
    {
        self.destinationImageDescription = destinationImageDescription
        self.destinationImageName = destinationImageName
        self.destinationRegion = destinationRegion
        self.sourceImageName = sourceImageName
    }
}

struct CopyImageInputBody: Swift.Equatable {
    public let sourceImageName: Swift.String?
    public let destinationImageName: Swift.String?
    public let destinationRegion: Swift.String?
    public let destinationImageDescription: Swift.String?
}

extension CopyImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageName)
        sourceImageName = sourceImageNameDecoded
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let destinationImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageDescription)
        destinationImageDescription = destinationImageDescriptionDecoded
    }
}

extension CopyImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyImageOutputError: Swift.Error, Swift.Equatable {
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyImageOutputResponse(destinationImageName: \(Swift.String(describing: destinationImageName)))"}
}

extension CopyImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationImageName = output.destinationImageName
        } else {
            self.destinationImageName = nil
        }
    }
}

public struct CopyImageOutputResponse: Swift.Equatable {
    /// The name of the destination image.
    public var destinationImageName: Swift.String?

    public init (
        destinationImageName: Swift.String? = nil
    )
    {
        self.destinationImageName = destinationImageName
    }
}

struct CopyImageOutputResponseBody: Swift.Equatable {
    public let destinationImageName: Swift.String?
}

extension CopyImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageName = "DestinationImageName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
    }
}

public struct CreateDirectoryConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryConfigOutputError>
}

extension CreateDirectoryConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDirectoryConfigInput(directoryName: \(Swift.String(describing: directoryName)), organizationalUnitDistinguishedNames: \(Swift.String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(Swift.String(describing: serviceAccountCredentials)))"}
}

extension CreateDirectoryConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

public struct CreateDirectoryConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDirectoryConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDirectoryConfigOutputError>
}

public struct CreateDirectoryConfigInput: Swift.Equatable {
    /// The fully qualified name of the directory (for example, corp.example.com).
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    /// This member is required.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init (
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct CreateDirectoryConfigInputBody: Swift.Equatable {
    public let directoryName: Swift.String?
    public let organizationalUnitDistinguishedNames: [Swift.String]?
    public let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
}

extension CreateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension CreateDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDirectoryConfigOutputResponse(directoryConfig: \(Swift.String(describing: directoryConfig)))"}
}

extension CreateDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct CreateDirectoryConfigOutputResponse: Swift.Equatable {
    /// Information about the directory configuration.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init (
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct CreateDirectoryConfigOutputResponseBody: Swift.Equatable {
    public let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension CreateDirectoryConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

public struct CreateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetInput(computeCapacity: \(Swift.String(describing: computeCapacity)), description: \(Swift.String(describing: description)), disconnectTimeoutInSeconds: \(Swift.String(describing: disconnectTimeoutInSeconds)), displayName: \(Swift.String(describing: displayName)), domainJoinInfo: \(Swift.String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(Swift.String(describing: enableDefaultInternetAccess)), fleetType: \(Swift.String(describing: fleetType)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(Swift.String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(Swift.String(describing: imageArn)), imageName: \(Swift.String(describing: imageName)), instanceType: \(Swift.String(describing: instanceType)), maxUserDurationInSeconds: \(Swift.String(describing: maxUserDurationInSeconds)), name: \(Swift.String(describing: name)), streamView: \(Swift.String(describing: streamView)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Swift.Equatable {
    /// The desired capacity for the fleet.
    /// This member is required.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
    public var fleetType: AppStreamClientTypes.FleetType?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If they try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The tags to associate with the fleet. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration for the fleet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        fleetType: AppStreamClientTypes.FleetType? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.computeCapacity = computeCapacity
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.streamView = streamView
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let imageName: Swift.String?
    public let imageArn: Swift.String?
    public let instanceType: Swift.String?
    public let fleetType: AppStreamClientTypes.FleetType?
    public let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    public let vpcConfig: AppStreamClientTypes.VpcConfig?
    public let maxUserDurationInSeconds: Swift.Int?
    public let disconnectTimeoutInSeconds: Swift.Int?
    public let description: Swift.String?
    public let displayName: Swift.String?
    public let enableDefaultInternetAccess: Swift.Bool?
    public let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    public let tags: [Swift.String:Swift.String]?
    public let idleDisconnectTimeoutInSeconds: Swift.Int?
    public let iamRoleArn: Swift.String?
    public let streamView: AppStreamClientTypes.StreamView?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetOutputResponse(fleet: \(Swift.String(describing: fleet)))"}
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init (
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    public let fleet: AppStreamClientTypes.Fleet?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

public struct CreateImageBuilderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderOutputError>
}

extension CreateImageBuilderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageBuilderInput(accessEndpoints: \(Swift.String(describing: accessEndpoints)), appstreamAgentVersion: \(Swift.String(describing: appstreamAgentVersion)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), domainJoinInfo: \(Swift.String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(Swift.String(describing: enableDefaultInternetAccess)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), imageArn: \(Swift.String(describing: imageArn)), imageName: \(Swift.String(describing: imageName)), instanceType: \(Swift.String(describing: instanceType)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension CreateImageBuilderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateImageBuilderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderOutputError>
}

public struct CreateImageBuilderInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the image builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The description to display.
    public var description: Swift.String?
    /// The image builder name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the image builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the image builder.
    public var imageName: Swift.String?
    /// The instance type to use when launching the image builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// A unique name for the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to associate with the image builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration for the image builder. You can specify only one subnet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        appstreamAgentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.name = name
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateImageBuilderInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let imageName: Swift.String?
    public let imageArn: Swift.String?
    public let instanceType: Swift.String?
    public let description: Swift.String?
    public let displayName: Swift.String?
    public let vpcConfig: AppStreamClientTypes.VpcConfig?
    public let iamRoleArn: Swift.String?
    public let enableDefaultInternetAccess: Swift.Bool?
    public let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    public let appstreamAgentVersion: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
}

extension CreateImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension CreateImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageBuilderOutputResponse(imageBuilder: \(Swift.String(describing: imageBuilder)))"}
}

extension CreateImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct CreateImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct CreateImageBuilderOutputResponseBody: Swift.Equatable {
    public let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension CreateImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct CreateImageBuilderStreamingURLInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderStreamingURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderStreamingURLOutputError>
}

extension CreateImageBuilderStreamingURLInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageBuilderStreamingURLInput(name: \(Swift.String(describing: name)), validity: \(Swift.String(describing: validity)))"}
}

extension CreateImageBuilderStreamingURLInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateImageBuilderStreamingURLInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderStreamingURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderStreamingURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageBuilderStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderStreamingURLInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateImageBuilderStreamingURLInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageBuilderStreamingURLInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageBuilderStreamingURLInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateImageBuilderStreamingURLInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageBuilderStreamingURLInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageBuilderStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageBuilderStreamingURLOutputError>
}

public struct CreateImageBuilderStreamingURLInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init (
        name: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.name = name
        self.validity = validity
    }
}

struct CreateImageBuilderStreamingURLInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let validity: Swift.Int?
}

extension CreateImageBuilderStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CreateImageBuilderStreamingURLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderStreamingURLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderStreamingURLOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderStreamingURLOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageBuilderStreamingURLOutputResponse(expires: \(Swift.String(describing: expires)), streamingURL: \(Swift.String(describing: streamingURL)))"}
}

extension CreateImageBuilderStreamingURLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageBuilderStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateImageBuilderStreamingURLOutputResponse: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateImageBuilderStreamingURLOutputResponseBody: Swift.Equatable {
    public let streamingURL: Swift.String?
    public let expires: ClientRuntime.Date?
}

extension CreateImageBuilderStreamingURLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

extension CreateStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStackInput(accessEndpoints: \(Swift.String(describing: accessEndpoints)), applicationSettings: \(Swift.String(describing: applicationSettings)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), embedHostDomains: \(Swift.String(describing: embedHostDomains)), feedbackURL: \(Swift.String(describing: feedbackURL)), name: \(Swift.String(describing: name)), redirectURL: \(Swift.String(describing: redirectURL)), storageConnectors: \(Swift.String(describing: storageConnectors)), tags: \(Swift.String(describing: tags)), userSettings: \(Swift.String(describing: userSettings)))"}
}

extension CreateStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

public struct CreateStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStackInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStackOutputError>
}

public struct CreateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The tags to associate with the stack. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.tags = tags
        self.userSettings = userSettings
    }
}

struct CreateStackInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let displayName: Swift.String?
    public let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    public let redirectURL: Swift.String?
    public let feedbackURL: Swift.String?
    public let userSettings: [AppStreamClientTypes.UserSetting]?
    public let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    public let tags: [Swift.String:Swift.String]?
    public let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    public let embedHostDomains: [Swift.String]?
}

extension CreateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension CreateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStackOutputResponse(stack: \(Swift.String(describing: stack)))"}
}

extension CreateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct CreateStackOutputResponse: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init (
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct CreateStackOutputResponseBody: Swift.Equatable {
    public let stack: AppStreamClientTypes.Stack?
}

extension CreateStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

public struct CreateStreamingURLInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingURLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingURLOutputError>
}

extension CreateStreamingURLInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingURLInput(applicationId: \(Swift.String(describing: applicationId)), fleetName: \(Swift.String(describing: fleetName)), sessionContext: \(Swift.String(describing: sessionContext)), stackName: \(Swift.String(describing: stackName)), userId: \(Swift.String(describing: userId)), validity: \(Swift.String(describing: validity)))"}
}

extension CreateStreamingURLInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateStreamingURLInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingURLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingURLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingURLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingURLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingURLInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingURLInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingURLInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingURLInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateStreamingURLInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingURLInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingURLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingURLOutputError>
}

public struct CreateStreamingURLInput: Swift.Equatable {
    /// The name of the application to launch after the session starts. This is the name that you specified as Name in the Image Assistant. If your fleet is enabled for the Desktop stream view, you can also choose to launch directly to the operating system desktop. To do so, specify Desktop.
    public var applicationId: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The session context. For more information, see [Session Context](https://docs.aws.amazon.com/appstream2/latest/developerguide/managing-stacks-fleets.html#managing-stacks-fleets-parameters) in the Amazon AppStream 2.0 Administration Guide.
    public var sessionContext: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 60 seconds.
    public var validity: Swift.Int?

    public init (
        applicationId: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        sessionContext: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.fleetName = fleetName
        self.sessionContext = sessionContext
        self.stackName = stackName
        self.userId = userId
        self.validity = validity
    }
}

struct CreateStreamingURLInputBody: Swift.Equatable {
    public let stackName: Swift.String?
    public let fleetName: Swift.String?
    public let userId: Swift.String?
    public let applicationId: Swift.String?
    public let validity: Swift.Int?
    public let sessionContext: Swift.String?
}

extension CreateStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension CreateStreamingURLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingURLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingURLOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingURLOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingURLOutputResponse(expires: \(Swift.String(describing: expires)), streamingURL: \(Swift.String(describing: streamingURL)))"}
}

extension CreateStreamingURLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateStreamingURLOutputResponse: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateStreamingURLOutputResponseBody: Swift.Equatable {
    public let streamingURL: Swift.String?
    public let expires: ClientRuntime.Date?
}

extension CreateStreamingURLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateUpdatedImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUpdatedImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUpdatedImageOutputError>
}

extension CreateUpdatedImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUpdatedImageInput(dryRun: \(Swift.String(describing: dryRun)), existingImageName: \(Swift.String(describing: existingImageName)), newImageDescription: \(Swift.String(describing: newImageDescription)), newImageDisplayName: \(Swift.String(describing: newImageDisplayName)), newImageName: \(Swift.String(describing: newImageName)), newImageTags: \(Swift.String(describing: newImageTags)))"}
}

extension CreateUpdatedImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let existingImageName = existingImageName {
            try encodeContainer.encode(existingImageName, forKey: .existingImageName)
        }
        if let newImageDescription = newImageDescription {
            try encodeContainer.encode(newImageDescription, forKey: .newImageDescription)
        }
        if let newImageDisplayName = newImageDisplayName {
            try encodeContainer.encode(newImageDisplayName, forKey: .newImageDisplayName)
        }
        if let newImageName = newImageName {
            try encodeContainer.encode(newImageName, forKey: .newImageName)
        }
        if let newImageTags = newImageTags {
            var newImageTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .newImageTags)
            for (dictKey0, tags0) in newImageTags {
                try newImageTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateUpdatedImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUpdatedImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUpdatedImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUpdatedImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUpdatedImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUpdatedImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUpdatedImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUpdatedImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUpdatedImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUpdatedImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUpdatedImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUpdatedImageOutputError>
}

public struct CreateUpdatedImageInput: Swift.Equatable {
    /// Indicates whether to display the status of image update availability before AppStream 2.0 initiates the process of creating a new updated image. If this value is set to true, AppStream 2.0 displays whether image updates are available. If this value is set to false, AppStream 2.0 initiates the process of creating a new updated image without displaying whether image updates are available.
    public var dryRun: Swift.Bool
    /// The name of the image to update.
    /// This member is required.
    public var existingImageName: Swift.String?
    /// The description to display for the new image.
    public var newImageDescription: Swift.String?
    /// The name to display for the new image.
    public var newImageDisplayName: Swift.String?
    /// The name of the new image. The name must be unique within the AWS account and Region.
    /// This member is required.
    public var newImageName: Swift.String?
    /// The tags to associate with the new image. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var newImageTags: [Swift.String:Swift.String]?

    public init (
        dryRun: Swift.Bool = false,
        existingImageName: Swift.String? = nil,
        newImageDescription: Swift.String? = nil,
        newImageDisplayName: Swift.String? = nil,
        newImageName: Swift.String? = nil,
        newImageTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dryRun = dryRun
        self.existingImageName = existingImageName
        self.newImageDescription = newImageDescription
        self.newImageDisplayName = newImageDisplayName
        self.newImageName = newImageName
        self.newImageTags = newImageTags
    }
}

struct CreateUpdatedImageInputBody: Swift.Equatable {
    public let existingImageName: Swift.String?
    public let newImageName: Swift.String?
    public let newImageDescription: Swift.String?
    public let newImageDisplayName: Swift.String?
    public let newImageTags: [Swift.String:Swift.String]?
    public let dryRun: Swift.Bool
}

extension CreateUpdatedImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingImageName)
        existingImageName = existingImageNameDecoded
        let newImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageName)
        newImageName = newImageNameDecoded
        let newImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDescription)
        newImageDescription = newImageDescriptionDecoded
        let newImageDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDisplayName)
        newImageDisplayName = newImageDisplayNameDecoded
        let newImageTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .newImageTags)
        var newImageTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let newImageTagsContainer = newImageTagsContainer {
            newImageTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in newImageTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    newImageTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        newImageTags = newImageTagsDecoded0
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateUpdatedImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUpdatedImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUpdatedImageOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUpdatedImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUpdatedImageOutputResponse(canUpdateImage: \(Swift.String(describing: canUpdateImage)), image: \(Swift.String(describing: image)))"}
}

extension CreateUpdatedImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUpdatedImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canUpdateImage = output.canUpdateImage
            self.image = output.image
        } else {
            self.canUpdateImage = false
            self.image = nil
        }
    }
}

public struct CreateUpdatedImageOutputResponse: Swift.Equatable {
    /// Indicates whether a new image can be created.
    public var canUpdateImage: Swift.Bool
    /// Describes an image.
    public var image: AppStreamClientTypes.Image?

    public init (
        canUpdateImage: Swift.Bool = false,
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.canUpdateImage = canUpdateImage
        self.image = image
    }
}

struct CreateUpdatedImageOutputResponseBody: Swift.Equatable {
    public let image: AppStreamClientTypes.Image?
    public let canUpdateImage: Swift.Bool
}

extension CreateUpdatedImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUpdateImage
        case image
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
        let canUpdateImageDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUpdateImage)
        canUpdateImage = canUpdateImageDecoded
    }
}

extension CreateUsageReportSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUsageReportSubscriptionInput()"}
}

extension CreateUsageReportSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CreateUsageReportSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageReportSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUsageReportSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageReportSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUsageReportSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageReportSubscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUsageReportSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUsageReportSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUsageReportSubscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUsageReportSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUsageReportSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUsageReportSubscriptionOutputError>
}

public struct CreateUsageReportSubscriptionInput: Swift.Equatable {

    public init() {}
}

struct CreateUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension CreateUsageReportSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsageReportSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsageReportSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsageReportSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUsageReportSubscriptionOutputResponse(s3BucketName: \(Swift.String(describing: s3BucketName)), schedule: \(Swift.String(describing: schedule)))"}
}

extension CreateUsageReportSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUsageReportSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3BucketName = output.s3BucketName
            self.schedule = output.schedule
        } else {
            self.s3BucketName = nil
            self.schedule = nil
        }
    }
}

public struct CreateUsageReportSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
    public var s3BucketName: Swift.String?
    /// The schedule for generating usage reports.
    public var schedule: AppStreamClientTypes.UsageReportSchedule?

    public init (
        s3BucketName: Swift.String? = nil,
        schedule: AppStreamClientTypes.UsageReportSchedule? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.schedule = schedule
    }
}

struct CreateUsageReportSubscriptionOutputResponseBody: Swift.Equatable {
    public let s3BucketName: Swift.String?
    public let schedule: AppStreamClientTypes.UsageReportSchedule?
}

extension CreateUsageReportSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

public struct CreateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(authenticationType: \(Swift.String(describing: authenticationType)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), messageAction: \(Swift.String(describing: messageAction)), userName: \(Swift.String(describing: userName)))"}
}

extension CreateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let messageAction = messageAction {
            try encodeContainer.encode(messageAction.rawValue, forKey: .messageAction)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The first name, or given name, of the user.
    public var firstName: Swift.String?
    /// The last name, or surname, of the user.
    public var lastName: Swift.String?
    /// The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent. The temporary password in the welcome email is valid for only 7 days. If users don’t set their passwords within 7 days, you must send them a new welcome email.
    public var messageAction: AppStreamClientTypes.MessageAction?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        messageAction: AppStreamClientTypes.MessageAction? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.firstName = firstName
        self.lastName = lastName
        self.messageAction = messageAction
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    public let userName: Swift.String?
    public let messageAction: AppStreamClientTypes.MessageAction?
    public let firstName: Swift.String?
    public let lastName: Swift.String?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let messageActionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.MessageAction.self, forKey: .messageAction)
        messageAction = messageActionDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserOutputResponse()"}
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateUserOutputResponseBody: Swift.Equatable {
}

extension CreateUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDirectoryConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryConfigOutputError>
}

extension DeleteDirectoryConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDirectoryConfigInput(directoryName: \(Swift.String(describing: directoryName)))"}
}

extension DeleteDirectoryConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
    }
}

public struct DeleteDirectoryConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDirectoryConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDirectoryConfigOutputError>
}

public struct DeleteDirectoryConfigInput: Swift.Equatable {
    /// The name of the directory configuration.
    /// This member is required.
    public var directoryName: Swift.String?

    public init (
        directoryName: Swift.String? = nil
    )
    {
        self.directoryName = directoryName
    }
}

struct DeleteDirectoryConfigInputBody: Swift.Equatable {
    public let directoryName: Swift.String?
}

extension DeleteDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
    }
}

extension DeleteDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDirectoryConfigOutputResponse()"}
}

extension DeleteDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDirectoryConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDirectoryConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteDirectoryConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Swift.Equatable {
}

extension DeleteFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteImageBuilderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageBuilderOutputError>
}

extension DeleteImageBuilderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageBuilderInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteImageBuilderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteImageBuilderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageBuilderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageBuilderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageBuilderOutputError>
}

public struct DeleteImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageBuilderInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageBuilderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageBuilderOutputResponse(imageBuilder: \(Swift.String(describing: imageBuilder)))"}
}

extension DeleteImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct DeleteImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct DeleteImageBuilderOutputResponseBody: Swift.Equatable {
    public let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension DeleteImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct DeleteImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

extension DeleteImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInput: Swift.Equatable {
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageOutputResponse(image: \(Swift.String(describing: image)))"}
}

extension DeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct DeleteImageOutputResponse: Swift.Equatable {
    /// Information about the image.
    public var image: AppStreamClientTypes.Image?

    public init (
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct DeleteImageOutputResponseBody: Swift.Equatable {
    public let image: AppStreamClientTypes.Image?
}

extension DeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image = "Image"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct DeleteImagePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePermissionsOutputError>
}

extension DeleteImagePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImagePermissionsInput(name: \(Swift.String(describing: name)), sharedAccountId: \(Swift.String(describing: sharedAccountId)))"}
}

extension DeleteImagePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

public struct DeleteImagePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePermissionsOutputError>
}

public struct DeleteImagePermissionsInput: Swift.Equatable {
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which to delete image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct DeleteImagePermissionsInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let sharedAccountId: Swift.String?
}

extension DeleteImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension DeleteImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImagePermissionsOutputResponse()"}
}

extension DeleteImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteImagePermissionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteImagePermissionsOutputResponseBody: Swift.Equatable {
}

extension DeleteImagePermissionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

extension DeleteStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStackInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStackInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStackOutputError>
}

public struct DeleteStackInput: Swift.Equatable {
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteStackInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStackOutputResponse()"}
}

extension DeleteStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStackOutputResponseBody: Swift.Equatable {
}

extension DeleteStackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUsageReportSubscriptionInput()"}
}

extension DeleteUsageReportSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteUsageReportSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageReportSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUsageReportSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageReportSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUsageReportSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUsageReportSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageReportSubscriptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUsageReportSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUsageReportSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUsageReportSubscriptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUsageReportSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUsageReportSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUsageReportSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUsageReportSubscriptionOutputError>
}

public struct DeleteUsageReportSubscriptionInput: Swift.Equatable {

    public init() {}
}

struct DeleteUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension DeleteUsageReportSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsageReportSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsageReportSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsageReportSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUsageReportSubscriptionOutputResponse()"}
}

extension DeleteUsageReportSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsageReportSubscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUsageReportSubscriptionOutputResponseBody: Swift.Equatable {
}

extension DeleteUsageReportSubscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \(Swift.String(describing: userName)))"}
}

extension DeleteUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    public let userName: Swift.String?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
}

extension DeleteUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeDirectoryConfigsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDirectoryConfigsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDirectoryConfigsOutputError>
}

extension DescribeDirectoryConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDirectoryConfigsInput(directoryNames: \(Swift.String(describing: directoryNames)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDirectoryConfigsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryNames = directoryNames {
            var directoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryNames)
            for directorynamelist0 in directoryNames {
                try directoryNamesContainer.encode(directorynamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDirectoryConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDirectoryConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDirectoryConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDirectoryConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDirectoryConfigsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDirectoryConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDirectoryConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDirectoryConfigsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDirectoryConfigsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDirectoryConfigsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDirectoryConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDirectoryConfigsOutputError>
}

public struct DescribeDirectoryConfigsInput: Swift.Equatable {
    /// The directory names.
    public var directoryNames: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        directoryNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryNames = directoryNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsInputBody: Swift.Equatable {
    public let directoryNames: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryNames)
        var directoryNamesDecoded0:[Swift.String]? = nil
        if let directoryNamesContainer = directoryNamesContainer {
            directoryNamesDecoded0 = [Swift.String]()
            for string0 in directoryNamesContainer {
                if let string0 = string0 {
                    directoryNamesDecoded0?.append(string0)
                }
            }
        }
        directoryNames = directoryNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectoryConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectoryConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectoryConfigsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectoryConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDirectoryConfigsOutputResponse(directoryConfigs: \(Swift.String(describing: directoryConfigs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDirectoryConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectoryConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfigs = output.directoryConfigs
            self.nextToken = output.nextToken
        } else {
            self.directoryConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectoryConfigsOutputResponse: Swift.Equatable {
    /// Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response.
    public var directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        directoryConfigs: [AppStreamClientTypes.DirectoryConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryConfigs = directoryConfigs
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsOutputResponseBody: Swift.Equatable {
    public let directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    public let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfigs = "DirectoryConfigs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.DirectoryConfig?].self, forKey: .directoryConfigs)
        var directoryConfigsDecoded0:[AppStreamClientTypes.DirectoryConfig]? = nil
        if let directoryConfigsContainer = directoryConfigsContainer {
            directoryConfigsDecoded0 = [AppStreamClientTypes.DirectoryConfig]()
            for structure0 in directoryConfigsContainer {
                if let structure0 = structure0 {
                    directoryConfigsDecoded0?.append(structure0)
                }
            }
        }
        directoryConfigs = directoryConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFleetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetsOutputError>
}

extension DescribeFleetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetsInput(names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFleetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFleetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFleetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFleetsOutputError>
}

public struct DescribeFleetsInput: Swift.Equatable {
    /// The names of the fleets to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeFleetsInputBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let nextToken: Swift.String?
}

extension DescribeFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFleetsOutputResponse(fleets: \(Swift.String(describing: fleets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetsOutputResponse: Swift.Equatable {
    /// Information about the fleets.
    public var fleets: [AppStreamClientTypes.Fleet]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        fleets: [AppStreamClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct DescribeFleetsOutputResponseBody: Swift.Equatable {
    public let fleets: [AppStreamClientTypes.Fleet]?
    public let nextToken: Swift.String?
}

extension DescribeFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets = "Fleets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Fleet?].self, forKey: .fleets)
        var fleetsDecoded0:[AppStreamClientTypes.Fleet]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [AppStreamClientTypes.Fleet]()
            for structure0 in fleetsContainer {
                if let structure0 = structure0 {
                    fleetsDecoded0?.append(structure0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImageBuildersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageBuildersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageBuildersOutputError>
}

extension DescribeImageBuildersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageBuildersInput(maxResults: \(Swift.String(describing: maxResults)), names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImageBuildersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeImageBuildersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageBuildersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageBuildersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageBuildersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageBuildersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeImageBuildersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImageBuildersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageBuildersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeImageBuildersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImageBuildersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageBuildersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageBuildersOutputError>
}

public struct DescribeImageBuildersInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the image builders to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersInputBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeImageBuildersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImageBuildersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageBuildersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageBuildersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageBuildersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageBuildersOutputResponse(imageBuilders: \(Swift.String(describing: imageBuilders)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImageBuildersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImageBuildersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilders = output.imageBuilders
            self.nextToken = output.nextToken
        } else {
            self.imageBuilders = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageBuildersOutputResponse: Swift.Equatable {
    /// Information about the image builders.
    public var imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        imageBuilders: [AppStreamClientTypes.ImageBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuilders = imageBuilders
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersOutputResponseBody: Swift.Equatable {
    public let imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    public let nextToken: Swift.String?
}

extension DescribeImageBuildersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilders = "ImageBuilders"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ImageBuilder?].self, forKey: .imageBuilders)
        var imageBuildersDecoded0:[AppStreamClientTypes.ImageBuilder]? = nil
        if let imageBuildersContainer = imageBuildersContainer {
            imageBuildersDecoded0 = [AppStreamClientTypes.ImageBuilder]()
            for structure0 in imageBuildersContainer {
                if let structure0 = structure0 {
                    imageBuildersDecoded0?.append(structure0)
                }
            }
        }
        imageBuilders = imageBuildersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagePermissionsOutputError>
}

extension DescribeImagePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagePermissionsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), sharedAwsAccountIds: \(Swift.String(describing: sharedAwsAccountIds)))"}
}

extension DescribeImagePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sharedAwsAccountIds = sharedAwsAccountIds {
            var sharedAwsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAwsAccountIds)
            for awsaccountidlist0 in sharedAwsAccountIds {
                try sharedAwsAccountIdsContainer.encode(awsaccountidlist0)
            }
        }
    }
}

public struct DescribeImagePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagePermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagePermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagePermissionsOutputError>
}

public struct DescribeImagePermissionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the private image for which to describe permissions. The image must be one that you own.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The 12-digit identifier of one or more AWS accounts with which the image is shared.
    public var sharedAwsAccountIds: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedAwsAccountIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.sharedAwsAccountIds = sharedAwsAccountIds
    }
}

struct DescribeImagePermissionsInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let maxResults: Swift.Int?
    public let sharedAwsAccountIds: [Swift.String]?
    public let nextToken: Swift.String?
}

extension DescribeImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sharedAwsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedAwsAccountIds)
        var sharedAwsAccountIdsDecoded0:[Swift.String]? = nil
        if let sharedAwsAccountIdsContainer = sharedAwsAccountIdsContainer {
            sharedAwsAccountIdsDecoded0 = [Swift.String]()
            for string0 in sharedAwsAccountIdsContainer {
                if let string0 = string0 {
                    sharedAwsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        sharedAwsAccountIds = sharedAwsAccountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagePermissionsOutputResponse(name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), sharedImagePermissionsList: \(Swift.String(describing: sharedImagePermissionsList)))"}
}

extension DescribeImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.nextToken = output.nextToken
            self.sharedImagePermissionsList = output.sharedImagePermissionsList
        } else {
            self.name = nil
            self.nextToken = nil
            self.sharedImagePermissionsList = nil
        }
    }
}

public struct DescribeImagePermissionsOutputResponse: Swift.Equatable {
    /// The name of the private image.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The permissions for a private image that you own.
    public var sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?

    public init (
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
        self.sharedImagePermissionsList = sharedImagePermissionsList
    }
}

struct DescribeImagePermissionsOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?
    public let nextToken: Swift.String?
}

extension DescribeImagePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case nextToken = "NextToken"
        case sharedImagePermissionsList = "SharedImagePermissionsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedImagePermissionsListContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.SharedImagePermissions?].self, forKey: .sharedImagePermissionsList)
        var sharedImagePermissionsListDecoded0:[AppStreamClientTypes.SharedImagePermissions]? = nil
        if let sharedImagePermissionsListContainer = sharedImagePermissionsListContainer {
            sharedImagePermissionsListDecoded0 = [AppStreamClientTypes.SharedImagePermissions]()
            for structure0 in sharedImagePermissionsListContainer {
                if let structure0 = structure0 {
                    sharedImagePermissionsListDecoded0?.append(structure0)
                }
            }
        }
        sharedImagePermissionsList = sharedImagePermissionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesInput(arns: \(Swift.String(describing: arns)), maxResults: \(Swift.String(describing: maxResults)), names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)), type: \(Swift.String(describing: type)))"}
}

extension DescribeImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arnlist0 in arns {
                try arnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The ARNs of the public, private, and shared images to describe.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the public or private images to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of image (public, private, or shared) to describe.
    public var type: AppStreamClientTypes.VisibilityType?

    public init (
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        type: AppStreamClientTypes.VisibilityType? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let arns: [Swift.String]?
    public let type: AppStreamClientTypes.VisibilityType?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesOutputResponse(images: \(Swift.String(describing: images)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Swift.Equatable {
    /// Information about the images.
    public var images: [AppStreamClientTypes.Image]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        images: [AppStreamClientTypes.Image]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Swift.Equatable {
    public let images: [AppStreamClientTypes.Image]?
    public let nextToken: Swift.String?
}

extension DescribeImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Image?].self, forKey: .images)
        var imagesDecoded0:[AppStreamClientTypes.Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [AppStreamClientTypes.Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSessionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

extension DescribeSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSessionsInput(authenticationType: \(Swift.String(describing: authenticationType)), fleetName: \(Swift.String(describing: fleetName)), limit: \(Swift.String(describing: limit)), nextToken: \(Swift.String(describing: nextToken)), stackName: \(Swift.String(describing: stackName)), userId: \(Swift.String(describing: userId)))"}
}

extension DescribeSessionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DescribeSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSessionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInput: Swift.Equatable {
    /// The authentication method. Specify API for a user authenticated using a streaming URL or SAML for a SAML federated user. The default is to authenticate users using a streaming URL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The name of the fleet. This value is case-sensitive.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The size of each page of results. The default value is 20 and the maximum value is 50.
    public var limit: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack. This value is case-sensitive.
    /// This member is required.
    public var stackName: Swift.String?
    /// The user identifier (ID). If you specify a user ID, you must also specify the authentication type.
    public var userId: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        fleetName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.fleetName = fleetName
        self.limit = limit
        self.nextToken = nextToken
        self.stackName = stackName
        self.userId = userId
    }
}

struct DescribeSessionsInputBody: Swift.Equatable {
    public let stackName: Swift.String?
    public let fleetName: Swift.String?
    public let userId: Swift.String?
    public let nextToken: Swift.String?
    public let limit: Swift.Int?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DescribeSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DescribeSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sessions: \(Swift.String(describing: sessions)))"}
}

extension DescribeSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the streaming sessions.
    public var sessions: [AppStreamClientTypes.Session]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [AppStreamClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Swift.Equatable {
    public let sessions: [AppStreamClientTypes.Session]?
    public let nextToken: Swift.String?
}

extension DescribeSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Session?].self, forKey: .sessions)
        var sessionsDecoded0:[AppStreamClientTypes.Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [AppStreamClientTypes.Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeStacksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

extension DescribeStacksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStacksInput(names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeStacksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeStacksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeStacksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStacksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStacksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeStacksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStacksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInput: Swift.Equatable {
    /// The names of the stacks to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeStacksInputBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let nextToken: Swift.String?
}

extension DescribeStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStacksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), stacks: \(Swift.String(describing: stacks)))"}
}

extension DescribeStacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stacks = output.stacks
        } else {
            self.nextToken = nil
            self.stacks = nil
        }
    }
}

public struct DescribeStacksOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the stacks.
    public var stacks: [AppStreamClientTypes.Stack]?

    public init (
        nextToken: Swift.String? = nil,
        stacks: [AppStreamClientTypes.Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Swift.Equatable {
    public let stacks: [AppStreamClientTypes.Stack]?
    public let nextToken: Swift.String?
}

extension DescribeStacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stacks = "Stacks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Stack?].self, forKey: .stacks)
        var stacksDecoded0:[AppStreamClientTypes.Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [AppStreamClientTypes.Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUsageReportSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageReportSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageReportSubscriptionsOutputError>
}

extension DescribeUsageReportSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsageReportSubscriptionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeUsageReportSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeUsageReportSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageReportSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageReportSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsageReportSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageReportSubscriptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeUsageReportSubscriptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUsageReportSubscriptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsageReportSubscriptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeUsageReportSubscriptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUsageReportSubscriptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsageReportSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsageReportSubscriptionsOutputError>
}

public struct DescribeUsageReportSubscriptionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsageReportSubscriptionsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsageReportSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsageReportSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsageReportSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsageReportSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsageReportSubscriptionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), usageReportSubscriptions: \(Swift.String(describing: usageReportSubscriptions)))"}
}

extension DescribeUsageReportSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsageReportSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageReportSubscriptions = output.usageReportSubscriptions
        } else {
            self.nextToken = nil
            self.usageReportSubscriptions = nil
        }
    }
}

public struct DescribeUsageReportSubscriptionsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the usage report subscription.
    public var usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?

    public init (
        nextToken: Swift.String? = nil,
        usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageReportSubscriptions = usageReportSubscriptions
    }
}

struct DescribeUsageReportSubscriptionsOutputResponseBody: Swift.Equatable {
    public let usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?
    public let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case usageReportSubscriptions = "UsageReportSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageReportSubscriptionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UsageReportSubscription?].self, forKey: .usageReportSubscriptions)
        var usageReportSubscriptionsDecoded0:[AppStreamClientTypes.UsageReportSubscription]? = nil
        if let usageReportSubscriptionsContainer = usageReportSubscriptionsContainer {
            usageReportSubscriptionsDecoded0 = [AppStreamClientTypes.UsageReportSubscription]()
            for structure0 in usageReportSubscriptionsContainer {
                if let structure0 = structure0 {
                    usageReportSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        usageReportSubscriptions = usageReportSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUserStackAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserStackAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserStackAssociationsOutputError>
}

extension DescribeUserStackAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserStackAssociationsInput(authenticationType: \(Swift.String(describing: authenticationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), stackName: \(Swift.String(describing: stackName)), userName: \(Swift.String(describing: userName)))"}
}

extension DescribeUserStackAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DescribeUserStackAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserStackAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserStackAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserStackAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserStackAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeUserStackAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserStackAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserStackAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeUserStackAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserStackAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserStackAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserStackAssociationsOutputError>
}

public struct DescribeUserStackAssociationsInput: Swift.Equatable {
    /// The authentication type for the user who is associated with the stack. You must specify USERPOOL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack that is associated with the user.
    public var stackName: Swift.String?
    /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.userName = userName
    }
}

struct DescribeUserStackAssociationsInputBody: Swift.Equatable {
    public let stackName: Swift.String?
    public let userName: Swift.String?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUserStackAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserStackAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserStackAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserStackAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserStackAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), userStackAssociations: \(Swift.String(describing: userStackAssociations)))"}
}

extension DescribeUserStackAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserStackAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userStackAssociations = output.userStackAssociations
        } else {
            self.nextToken = nil
            self.userStackAssociations = nil
        }
    }
}

public struct DescribeUserStackAssociationsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The UserStackAssociation objects.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.userStackAssociations = userStackAssociations
    }
}

struct DescribeUserStackAssociationsOutputResponseBody: Swift.Equatable {
    public let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
    public let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeUsersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsersOutputError>
}

extension DescribeUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsersInput(authenticationType: \(Swift.String(describing: authenticationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeUsersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUsersOutputError>
}

public struct DescribeUsersInput: Swift.Equatable {
    /// The authentication type for the users in the user pool to describe. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), users: \(Swift.String(describing: users)))"}
}

extension DescribeUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about users in the user pool.
    public var users: [AppStreamClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [AppStreamClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct DescribeUsersOutputResponseBody: Swift.Equatable {
    public let users: [AppStreamClientTypes.User]?
    public let nextToken: Swift.String?
}

extension DescribeUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[AppStreamClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [AppStreamClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppStreamClientTypes.DirectoryConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AppStreamClientTypes.DirectoryConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryConfig(createdTime: \(Swift.String(describing: createdTime)), directoryName: \(Swift.String(describing: directoryName)), organizationalUnitDistinguishedNames: \(Swift.String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(Swift.String(describing: serviceAccountCredentials)))"}
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DirectoryConfig: Swift.Equatable {
        /// The time the directory configuration was created.
        public var createdTime: ClientRuntime.Date?
        /// The fully qualified name of the directory (for example, corp.example.com).
        /// This member is required.
        public var directoryName: Swift.String?
        /// The distinguished names of the organizational units for computer accounts.
        public var organizationalUnitDistinguishedNames: [Swift.String]?
        /// The credentials for the service account used by the fleet or image builder to connect to the directory.
        public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedNames: [Swift.String]? = nil,
            serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
        )
        {
            self.createdTime = createdTime
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.serviceAccountCredentials = serviceAccountCredentials
        }
    }

}

public struct DisableUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableUserOutputError>
}

extension DisableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \(Swift.String(describing: userName)))"}
}

extension DisableUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DisableUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableUserOutputError>
}

public struct DisableUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableUserOutputError>
}

public struct DisableUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisableUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableUserOutputError>
}

public struct DisableUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisableUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableUserOutputError>
}

public struct DisableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DisableUserInputBody: Swift.Equatable {
    public let userName: Swift.String?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DisableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DisableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableUserOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableUserOutputResponse()"}
}

extension DisableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisableUserOutputResponseBody: Swift.Equatable {
}

extension DisableUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFleetOutputError>
}

extension DisassociateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFleetInput(fleetName: \(Swift.String(describing: fleetName)), stackName: \(Swift.String(describing: stackName)))"}
}

extension DisassociateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct DisassociateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFleetOutputError>
}

public struct DisassociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct DisassociateFleetInputBody: Swift.Equatable {
    public let fleetName: Swift.String?
    public let stackName: Swift.String?
}

extension DisassociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DisassociateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFleetOutputResponse()"}
}

extension DisassociateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateFleetOutputResponseBody: Swift.Equatable {
}

extension DisassociateFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppStreamClientTypes.DomainJoinInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension AppStreamClientTypes.DomainJoinInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainJoinInfo(directoryName: \(Swift.String(describing: directoryName)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)))"}
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DomainJoinInfo: Swift.Equatable {
        /// The fully qualified name of the directory (for example, corp.example.com).
        public var directoryName: Swift.String?
        /// The distinguished name of the organizational unit for computer accounts.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init (
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

public struct EnableUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableUserOutputError>
}

extension EnableUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableUserInput(authenticationType: \(Swift.String(describing: authenticationType)), userName: \(Swift.String(describing: userName)))"}
}

extension EnableUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct EnableUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableUserOutputError>
}

public struct EnableUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableUserOutputError>
}

public struct EnableUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: EnableUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableUserOutputError>
}

public struct EnableUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: EnableUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableUserOutputError>
}

public struct EnableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct EnableUserInputBody: Swift.Equatable {
    public let userName: Swift.String?
    public let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension EnableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension EnableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableUserOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableUserOutputResponse()"}
}

extension EnableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct EnableUserOutputResponseBody: Swift.Equatable {
}

extension EnableUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct ExpireSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExpireSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExpireSessionOutputError>
}

extension ExpireSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpireSessionInput(sessionId: \(Swift.String(describing: sessionId)))"}
}

extension ExpireSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct ExpireSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExpireSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExpireSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExpireSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExpireSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExpireSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ExpireSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExpireSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExpireSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ExpireSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExpireSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExpireSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExpireSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExpireSessionOutputError>
}

public struct ExpireSessionInput: Swift.Equatable {
    /// The identifier of the streaming session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ExpireSessionInputBody: Swift.Equatable {
    public let sessionId: Swift.String?
}

extension ExpireSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ExpireSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExpireSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExpireSessionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ExpireSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpireSessionOutputResponse()"}
}

extension ExpireSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ExpireSessionOutputResponse: Swift.Equatable {

    public init() {}
}

struct ExpireSessionOutputResponseBody: Swift.Equatable {
}

extension ExpireSessionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppStreamClientTypes.Fleet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computeCapacityStatus = "ComputeCapacityStatus"
        case createdTime = "CreatedTime"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetErrors = "FleetErrors"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case state = "State"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeCapacityStatus = computeCapacityStatus {
            try encodeContainer.encode(computeCapacityStatus, forKey: .computeCapacityStatus)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetErrors = fleetErrors {
            var fleetErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fleetErrors)
            for fleeterrors0 in fleetErrors {
                try fleetErrorsContainer.encode(fleeterrors0)
            }
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityStatusDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacityStatus.self, forKey: .computeCapacityStatus)
        computeCapacityStatus = computeCapacityStatusDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetState.self, forKey: .state)
        state = stateDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let fleetErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetError?].self, forKey: .fleetErrors)
        var fleetErrorsDecoded0:[AppStreamClientTypes.FleetError]? = nil
        if let fleetErrorsContainer = fleetErrorsContainer {
            fleetErrorsDecoded0 = [AppStreamClientTypes.FleetError]()
            for structure0 in fleetErrorsContainer {
                if let structure0 = structure0 {
                    fleetErrorsDecoded0?.append(structure0)
                }
            }
        }
        fleetErrors = fleetErrorsDecoded0
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension AppStreamClientTypes.Fleet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Fleet(arn: \(Swift.String(describing: arn)), computeCapacityStatus: \(Swift.String(describing: computeCapacityStatus)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), disconnectTimeoutInSeconds: \(Swift.String(describing: disconnectTimeoutInSeconds)), displayName: \(Swift.String(describing: displayName)), domainJoinInfo: \(Swift.String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(Swift.String(describing: enableDefaultInternetAccess)), fleetErrors: \(Swift.String(describing: fleetErrors)), fleetType: \(Swift.String(describing: fleetType)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(Swift.String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(Swift.String(describing: imageArn)), imageName: \(Swift.String(describing: imageName)), instanceType: \(Swift.String(describing: instanceType)), maxUserDurationInSeconds: \(Swift.String(describing: maxUserDurationInSeconds)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), streamView: \(Swift.String(describing: streamView)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension AppStreamClientTypes {
    /// Describes a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The capacity status for the fleet.
        /// This member is required.
        public var computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus?
        /// The time the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
        public var disconnectTimeoutInSeconds: Swift.Int?
        /// The fleet name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Indicates whether default internet access is enabled for the fleet.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The fleet errors.
        public var fleetErrors: [AppStreamClientTypes.FleetError]?
        /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
        public var fleetType: AppStreamClientTypes.FleetType?
        /// The ARN of the IAM role that is applied to the fleet. To assume a role, the fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
        public var idleDisconnectTimeoutInSeconds: Swift.Int?
        /// The ARN for the public, private, or shared image.
        public var imageArn: Swift.String?
        /// The name of the image used to create the fleet.
        public var imageName: Swift.String?
        /// The instance type to use when launching fleet instances. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        /// This member is required.
        public var instanceType: Swift.String?
        /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
        public var maxUserDurationInSeconds: Swift.Int?
        /// The name of the fleet.
        /// This member is required.
        public var name: Swift.String?
        /// The current state for the fleet.
        /// This member is required.
        public var state: AppStreamClientTypes.FleetState?
        /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
        public var streamView: AppStreamClientTypes.StreamView?
        /// The VPC configuration for the fleet.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disconnectTimeoutInSeconds: Swift.Int? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            fleetErrors: [AppStreamClientTypes.FleetError]? = nil,
            fleetType: AppStreamClientTypes.FleetType? = nil,
            iamRoleArn: Swift.String? = nil,
            idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
            imageArn: Swift.String? = nil,
            imageName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            maxUserDurationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            state: AppStreamClientTypes.FleetState? = nil,
            streamView: AppStreamClientTypes.StreamView? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.computeCapacityStatus = computeCapacityStatus
            self.createdTime = createdTime
            self.description = description
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.fleetErrors = fleetErrors
            self.fleetType = fleetType
            self.iamRoleArn = iamRoleArn
            self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
            self.imageArn = imageArn
            self.imageName = imageName
            self.instanceType = instanceType
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.name = name
            self.state = state
            self.streamView = streamView
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    /// The fleet attribute.
    public enum FleetAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinInfo
        case iamRoleArn
        case vpcConfiguration
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetAttribute] {
            return [
                .domainJoinInfo,
                .iamRoleArn,
                .vpcConfiguration,
                .vpcConfigurationSecurityGroupIds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinInfo: return "DOMAIN_JOIN_INFO"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .vpcConfiguration: return "VPC_CONFIGURATION"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetAttribute(rawValue: rawValue) ?? FleetAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.FleetError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes.FleetError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FleetError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension AppStreamClientTypes {
    /// Describes a fleet error.
    public struct FleetError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum FleetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinErrorAccessDenied
        case domainJoinErrorDsMachineAccountQuotaExceeded
        case domainJoinErrorFileNotFound
        case domainJoinErrorInvalidParameter
        case domainJoinErrorLogonFailure
        case domainJoinErrorMoreData
        case domainJoinErrorNotSupported
        case domainJoinErrorNoSuchDomain
        case domainJoinInternalServiceError
        case domainJoinNerrInvalidWorkgroupName
        case domainJoinNerrPasswordExpired
        case domainJoinNerrWorkstationNotStarted
        case fleetInstanceProvisioningFailure
        case fleetStopped
        case iamServiceRoleIsMissing
        case iamServiceRoleMissingDescribeSecurityGroupsAction
        case iamServiceRoleMissingDescribeSubnetAction
        case iamServiceRoleMissingEniCreateAction
        case iamServiceRoleMissingEniDeleteAction
        case iamServiceRoleMissingEniDescribeAction
        case igwNotAttached
        case imageNotFound
        case internalServiceError
        case invalidSubnetConfiguration
        case machineRoleIsMissing
        case networkInterfaceLimitExceeded
        case securityGroupsNotFound
        case stsDisabledInRegion
        case subnetHasInsufficientIpAddresses
        case subnetNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetErrorCode] {
            return [
                .domainJoinErrorAccessDenied,
                .domainJoinErrorDsMachineAccountQuotaExceeded,
                .domainJoinErrorFileNotFound,
                .domainJoinErrorInvalidParameter,
                .domainJoinErrorLogonFailure,
                .domainJoinErrorMoreData,
                .domainJoinErrorNotSupported,
                .domainJoinErrorNoSuchDomain,
                .domainJoinInternalServiceError,
                .domainJoinNerrInvalidWorkgroupName,
                .domainJoinNerrPasswordExpired,
                .domainJoinNerrWorkstationNotStarted,
                .fleetInstanceProvisioningFailure,
                .fleetStopped,
                .iamServiceRoleIsMissing,
                .iamServiceRoleMissingDescribeSecurityGroupsAction,
                .iamServiceRoleMissingDescribeSubnetAction,
                .iamServiceRoleMissingEniCreateAction,
                .iamServiceRoleMissingEniDeleteAction,
                .iamServiceRoleMissingEniDescribeAction,
                .igwNotAttached,
                .imageNotFound,
                .internalServiceError,
                .invalidSubnetConfiguration,
                .machineRoleIsMissing,
                .networkInterfaceLimitExceeded,
                .securityGroupsNotFound,
                .stsDisabledInRegion,
                .subnetHasInsufficientIpAddresses,
                .subnetNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
            case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
            case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
            case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
            case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
            case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
            case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
            case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
            case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
            case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
            case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
            case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
            case .fleetInstanceProvisioningFailure: return "FLEET_INSTANCE_PROVISIONING_FAILURE"
            case .fleetStopped: return "FLEET_STOPPED"
            case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
            case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
            case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
            case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
            case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
            case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
            case .igwNotAttached: return "IGW_NOT_ATTACHED"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
            case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
            case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
            case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
            case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
            case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetErrorCode(rawValue: rawValue) ?? FleetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetState(rawValue: rawValue) ?? FleetState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case onDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetType] {
            return [
                .alwaysOn,
                .onDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .onDemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetType(rawValue: rawValue) ?? FleetType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.Image: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case baseImageArn = "BaseImageArn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case imageBuilderName = "ImageBuilderName"
        case imageBuilderSupported = "ImageBuilderSupported"
        case imageErrors = "ImageErrors"
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case platform = "Platform"
        case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applications0 in applications {
                try applicationsContainer.encode(applications0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseImageArn = baseImageArn {
            try encodeContainer.encode(baseImageArn, forKey: .baseImageArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let imageBuilderName = imageBuilderName {
            try encodeContainer.encode(imageBuilderName, forKey: .imageBuilderName)
        }
        if imageBuilderSupported != false {
            try encodeContainer.encode(imageBuilderSupported, forKey: .imageBuilderSupported)
        }
        if let imageErrors = imageErrors {
            var imageErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageErrors)
            for resourceerrors0 in imageErrors {
                try imageErrorsContainer.encode(resourceerrors0)
            }
        }
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publicBaseImageReleasedDate = publicBaseImageReleasedDate {
            try encodeContainer.encode(publicBaseImageReleasedDate.timeIntervalSince1970, forKey: .publicBaseImageReleasedDate)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let baseImageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseImageArn)
        baseImageArn = baseImageArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let imageBuilderSupportedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .imageBuilderSupported)
        imageBuilderSupported = imageBuilderSupportedDecoded
        let imageBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuilderName)
        imageBuilderName = imageBuilderNameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[AppStreamClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppStreamClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let publicBaseImageReleasedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .publicBaseImageReleasedDate)
        publicBaseImageReleasedDate = publicBaseImageReleasedDateDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
        let imageErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageErrors)
        var imageErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageErrorsContainer = imageErrorsContainer {
            imageErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageErrorsContainer {
                if let structure0 = structure0 {
                    imageErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageErrors = imageErrorsDecoded0
    }
}

extension AppStreamClientTypes.Image: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Image(applications: \(Swift.String(describing: applications)), appstreamAgentVersion: \(Swift.String(describing: appstreamAgentVersion)), arn: \(Swift.String(describing: arn)), baseImageArn: \(Swift.String(describing: baseImageArn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), imageBuilderName: \(Swift.String(describing: imageBuilderName)), imageBuilderSupported: \(Swift.String(describing: imageBuilderSupported)), imageErrors: \(Swift.String(describing: imageErrors)), imagePermissions: \(Swift.String(describing: imagePermissions)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), publicBaseImageReleasedDate: \(Swift.String(describing: publicBaseImageReleasedDate)), state: \(Swift.String(describing: state)), stateChangeReason: \(Swift.String(describing: stateChangeReason)), visibility: \(Swift.String(describing: visibility)))"}
}

extension AppStreamClientTypes {
    /// Describes an image.
    public struct Image: Swift.Equatable {
        /// The applications associated with the image.
        public var applications: [AppStreamClientTypes.Application]?
        /// The version of the AppStream 2.0 agent to use for instances that are launched from this image.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN of the image.
        public var arn: Swift.String?
        /// The ARN of the image from which this image was created.
        public var baseImageArn: Swift.String?
        /// The time the image was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image name to display.
        public var displayName: Swift.String?
        /// The name of the image builder that was used to create the private image. If the image is shared, this value is null.
        public var imageBuilderName: Swift.String?
        /// Indicates whether an image builder can be launched from this image.
        public var imageBuilderSupported: Swift.Bool
        /// Describes the errors that are returned when a new image can't be created.
        public var imageErrors: [AppStreamClientTypes.ResourceError]?
        /// The permissions to provide to the destination AWS account for the specified image.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The name of the image.
        /// This member is required.
        public var name: Swift.String?
        /// The operating system platform of the image.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public var publicBaseImageReleasedDate: ClientRuntime.Date?
        /// The image starts in the PENDING state. If image creation succeeds, the state is AVAILABLE. If image creation fails, the state is FAILED.
        public var state: AppStreamClientTypes.ImageState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageStateChangeReason?
        /// Indicates whether the image is public or private.
        public var visibility: AppStreamClientTypes.VisibilityType?

        public init (
            applications: [AppStreamClientTypes.Application]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseImageArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            imageBuilderName: Swift.String? = nil,
            imageBuilderSupported: Swift.Bool = false,
            imageErrors: [AppStreamClientTypes.ResourceError]? = nil,
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            publicBaseImageReleasedDate: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.ImageState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageStateChangeReason? = nil,
            visibility: AppStreamClientTypes.VisibilityType? = nil
        )
        {
            self.applications = applications
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.baseImageArn = baseImageArn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.imageBuilderName = imageBuilderName
            self.imageBuilderSupported = imageBuilderSupported
            self.imageErrors = imageErrors
            self.imagePermissions = imagePermissions
            self.name = name
            self.platform = platform
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.visibility = visibility
        }
    }

}

extension AppStreamClientTypes.ImageBuilder: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageBuilderErrors = "ImageBuilderErrors"
        case instanceType = "InstanceType"
        case name = "Name"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case platform = "Platform"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageBuilderErrors = imageBuilderErrors {
            var imageBuilderErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageBuilderErrors)
            for resourceerrors0 in imageBuilderErrors {
                try imageBuilderErrorsContainer.encode(resourceerrors0)
            }
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
        let imageBuilderErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageBuilderErrors)
        var imageBuilderErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageBuilderErrorsContainer = imageBuilderErrorsContainer {
            imageBuilderErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageBuilderErrorsContainer {
                if let structure0 = structure0 {
                    imageBuilderErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageBuilderErrors = imageBuilderErrorsDecoded0
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension AppStreamClientTypes.ImageBuilder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageBuilder(accessEndpoints: \(Swift.String(describing: accessEndpoints)), appstreamAgentVersion: \(Swift.String(describing: appstreamAgentVersion)), arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), domainJoinInfo: \(Swift.String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(Swift.String(describing: enableDefaultInternetAccess)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), imageArn: \(Swift.String(describing: imageArn)), imageBuilderErrors: \(Swift.String(describing: imageBuilderErrors)), instanceType: \(Swift.String(describing: instanceType)), name: \(Swift.String(describing: name)), networkAccessConfiguration: \(Swift.String(describing: networkAccessConfiguration)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), stateChangeReason: \(Swift.String(describing: stateChangeReason)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension AppStreamClientTypes {
    /// Describes a virtual machine that is used to create an image.
    public struct ImageBuilder: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Administrators can connect to the image builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The version of the AppStream 2.0 agent that is currently being used by the image builder.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN for the image builder.
        public var arn: Swift.String?
        /// The time stamp when the image builder was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image builder name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Enables or disables default internet access for the image builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The ARN of the image from which this builder was created.
        public var imageArn: Swift.String?
        /// The image builder errors.
        public var imageBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The instance type for the image builder. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        public var instanceType: Swift.String?
        /// The name of the image builder.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the network details of the fleet or image builder instance.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The operating system platform of the image builder.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The state of the image builder.
        public var state: AppStreamClientTypes.ImageBuilderState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason?
        /// The VPC configuration of the image builder.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init (
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            imageArn: Swift.String? = nil,
            imageBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            state: AppStreamClientTypes.ImageBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.imageArn = imageArn
            self.imageBuilderErrors = imageBuilderErrors
            self.instanceType = instanceType
            self.name = name
            self.networkAccessConfiguration = networkAccessConfiguration
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case pending
        case pendingQualification
        case rebooting
        case running
        case snapshotting
        case stopped
        case stopping
        case updating
        case updatingAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderState] {
            return [
                .deleting,
                .failed,
                .pending,
                .pendingQualification,
                .rebooting,
                .running,
                .snapshotting,
                .stopped,
                .stopping,
                .updating,
                .updatingAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .pendingQualification: return "PENDING_QUALIFICATION"
            case .rebooting: return "REBOOTING"
            case .running: return "RUNNING"
            case .snapshotting: return "SNAPSHOTTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case .updatingAgent: return "UPDATING_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderState(rawValue: rawValue) ?? ImageBuilderState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageBuilderStateChangeReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ImageBuilderStateChangeReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageBuilderStateChangeReason(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image builder state change occurred.
    public struct ImageBuilderStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init (
            code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageUnavailable
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderStateChangeReasonCode] {
            return [
                .imageUnavailable,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageUnavailable: return "IMAGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderStateChangeReasonCode(rawValue: rawValue) ?? ImageBuilderStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImagePermissions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowFleet
        case allowImageBuilder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowFleet = allowFleet {
            try encodeContainer.encode(allowFleet, forKey: .allowFleet)
        }
        if let allowImageBuilder = allowImageBuilder {
            try encodeContainer.encode(allowImageBuilder, forKey: .allowImageBuilder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowFleetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowFleet)
        allowFleet = allowFleetDecoded
        let allowImageBuilderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowImageBuilder)
        allowImageBuilder = allowImageBuilderDecoded
    }
}

extension AppStreamClientTypes.ImagePermissions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImagePermissions(allowFleet: \(Swift.String(describing: allowFleet)), allowImageBuilder: \(Swift.String(describing: allowImageBuilder)))"}
}

extension AppStreamClientTypes {
    /// Describes the permissions for an image.
    public struct ImagePermissions: Swift.Equatable {
        /// Indicates whether the image can be used for a fleet.
        public var allowFleet: Swift.Bool?
        /// Indicates whether the image can be used for an image builder.
        public var allowImageBuilder: Swift.Bool?

        public init (
            allowFleet: Swift.Bool? = nil,
            allowImageBuilder: Swift.Bool? = nil
        )
        {
            self.allowFleet = allowFleet
            self.allowImageBuilder = allowImageBuilder
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case copying
        case creating
        case deleting
        case failed
        case importing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageState] {
            return [
                .available,
                .copying,
                .creating,
                .deleting,
                .failed,
                .importing,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageState(rawValue: rawValue) ?? ImageState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageStateChangeReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ImageStateChangeReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageStateChangeReason(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image state change occurred.
    public struct ImageStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init (
            code: AppStreamClientTypes.ImageStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageBuilderNotAvailable
        case imageCopyFailure
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStateChangeReasonCode] {
            return [
                .imageBuilderNotAvailable,
                .imageCopyFailure,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageBuilderNotAvailable: return "IMAGE_BUILDER_NOT_AVAILABLE"
            case .imageCopyFailure: return "IMAGE_COPY_FAILURE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStateChangeReasonCode(rawValue: rawValue) ?? ImageStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension IncompatibleImageException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleImageException(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleImageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleImageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image can't be updated because it's not compatible for updates.
public struct IncompatibleImageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleImageExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleImageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAccountStatusException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAccountStatusException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAccountStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAccountStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be created because your AWS account is suspended. For assistance, contact AWS Support.
public struct InvalidAccountStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAccountStatusExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAccountStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterCombinationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates an incorrect combination of parameters, or a missing parameter.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRoleException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified role is invalid.
public struct InvalidRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.LastReportGenerationExecutionError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportExecutionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes.LastReportGenerationExecutionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LastReportGenerationExecutionError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a usage report can't be generated.
    public struct LastReportGenerationExecutionError: Swift.Equatable {
        /// The error code for the error that is returned when a usage report can't be generated.
        public var errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode?
        /// The error message for the error that is returned when a usage report can't be generated.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested limit exceeds the permitted limit for an account.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAssociatedFleetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedFleetsOutputError>
}

extension ListAssociatedFleetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedFleetsInput(nextToken: \(Swift.String(describing: nextToken)), stackName: \(Swift.String(describing: stackName)))"}
}

extension ListAssociatedFleetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct ListAssociatedFleetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedFleetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedFleetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAssociatedFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociatedFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedFleetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAssociatedFleetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociatedFleetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedFleetsOutputError>
}

public struct ListAssociatedFleetsInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct ListAssociatedFleetsInputBody: Swift.Equatable {
    public let stackName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListAssociatedFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedFleetsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedFleetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedFleetsOutputResponse(names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedFleetsOutputResponse: Swift.Equatable {
    /// The name of the fleet.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedFleetsOutputResponseBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssociatedFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssociatedStacksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedStacksOutputError>
}

extension ListAssociatedStacksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedStacksInput(fleetName: \(Swift.String(describing: fleetName)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedStacksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociatedStacksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedStacksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedStacksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAssociatedStacksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociatedStacksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedStacksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAssociatedStacksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociatedStacksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedStacksOutputError>
}

public struct ListAssociatedStacksInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksInputBody: Swift.Equatable {
    public let fleetName: Swift.String?
    public let nextToken: Swift.String?
}

extension ListAssociatedStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedStacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedStacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedStacksOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedStacksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedStacksOutputResponse(names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedStacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedStacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedStacksOutputResponse: Swift.Equatable {
    /// The name of the stack.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksOutputResponseBody: Swift.Equatable {
    public let names: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAssociatedStacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppStreamClientTypes {
    public enum MessageAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resend
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageAction] {
            return [
                .resend,
                .suppress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resend: return "RESEND"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageAction(rawValue: rawValue) ?? MessageAction.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.NetworkAccessConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniId = "EniId"
        case eniPrivateIpAddress = "EniPrivateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniId = eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniPrivateIpAddress = eniPrivateIpAddress {
            try encodeContainer.encode(eniPrivateIpAddress, forKey: .eniPrivateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eniPrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniPrivateIpAddress)
        eniPrivateIpAddress = eniPrivateIpAddressDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
    }
}

extension AppStreamClientTypes.NetworkAccessConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkAccessConfiguration(eniId: \(Swift.String(describing: eniId)), eniPrivateIpAddress: \(Swift.String(describing: eniPrivateIpAddress)))"}
}

extension AppStreamClientTypes {
    /// Describes the network details of the fleet or image builder instance.
    public struct NetworkAccessConfiguration: Swift.Equatable {
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public var eniId: Swift.String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public var eniPrivateIpAddress: Swift.String?

        public init (
            eniId: Swift.String? = nil,
            eniPrivateIpAddress: Swift.String? = nil
        )
        {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }
    }

}

extension OperationNotPermittedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotPermittedException(message: \(Swift.String(describing: message)))"}
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The attempted operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case windows
        case windowsServer2016
        case windowsServer2019
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .windows,
                .windowsServer2016,
                .windowsServer2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .windows: return "WINDOWS"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension RequestLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension RequestLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AppStream 2.0 can’t process the request right now because the Describe calls from your AWS account are being throttled by Amazon EC2. Try again later.
public struct RequestLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ResourceError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case errorTimestamp = "ErrorTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorTimestamp = errorTimestamp {
            try encodeContainer.encode(errorTimestamp.timeIntervalSince1970, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension AppStreamClientTypes.ResourceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), errorTimestamp: \(Swift.String(describing: errorTimestamp)))"}
}

extension AppStreamClientTypes {
    /// Describes a resource error.
    public struct ResourceError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The time the error occurred.
        public var errorTimestamp: ClientRuntime.Date?

        public init (
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotAvailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotAvailableException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotAvailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource exists and is not in use, but isn't available.
public struct ResourceNotAvailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotAvailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case accountPassword = "AccountPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let accountPassword = accountPassword {
            try encodeContainer.encode(accountPassword, forKey: .accountPassword)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountPassword)
        accountPassword = accountPasswordDecoded
    }
}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceAccountCredentials(accountName: \(Swift.String(describing: accountName)), accountPassword: \(Swift.String(describing: accountPassword)))"}
}

extension AppStreamClientTypes {
    /// Describes the credentials for the service account used by the fleet or image builder to connect to the directory.
    public struct ServiceAccountCredentials: Swift.Equatable {
        /// The user name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
        /// This member is required.
        public var accountName: Swift.String?
        /// The password for the account.
        /// This member is required.
        public var accountPassword: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            accountPassword: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountPassword = accountPassword
        }
    }

}

extension AppStreamClientTypes.Session: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case connectionState = "ConnectionState"
        case fleetName = "FleetName"
        case id = "Id"
        case maxExpirationTime = "MaxExpirationTime"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case stackName = "StackName"
        case startTime = "StartTime"
        case state = "State"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxExpirationTime = maxExpirationTime {
            try encodeContainer.encode(maxExpirationTime.timeIntervalSince1970, forKey: .maxExpirationTime)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let maxExpirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .maxExpirationTime)
        maxExpirationTime = maxExpirationTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
    }
}

extension AppStreamClientTypes.Session: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Session(authenticationType: \(Swift.String(describing: authenticationType)), connectionState: \(Swift.String(describing: connectionState)), fleetName: \(Swift.String(describing: fleetName)), id: \(Swift.String(describing: id)), maxExpirationTime: \(Swift.String(describing: maxExpirationTime)), networkAccessConfiguration: \(Swift.String(describing: networkAccessConfiguration)), stackName: \(Swift.String(describing: stackName)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), userId: \(Swift.String(describing: userId)))"}
}

extension AppStreamClientTypes {
    /// Describes a streaming session.
    public struct Session: Swift.Equatable {
        /// The authentication method. The user is authenticated using a streaming URL (API) or SAML 2.0 federation (SAML).
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a user is connected to the streaming session.
        public var connectionState: AppStreamClientTypes.SessionConnectionState?
        /// The name of the fleet for the streaming session.
        /// This member is required.
        public var fleetName: Swift.String?
        /// The identifier of the streaming session.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the streaming session is set to expire. This time is based on the MaxUserDurationinSeconds value, which determines the maximum length of time that a streaming session can run. A streaming session might end earlier than the time specified in SessionMaxExpirationTime, when the DisconnectTimeOutInSeconds elapses or the user chooses to end his or her session. If the DisconnectTimeOutInSeconds elapses, or the user chooses to end his or her session, the streaming instance is terminated and the streaming session ends.
        public var maxExpirationTime: ClientRuntime.Date?
        /// The network details for the streaming session.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The name of the stack for the streaming session.
        /// This member is required.
        public var stackName: Swift.String?
        /// The time when a streaming instance is dedicated for the user.
        public var startTime: ClientRuntime.Date?
        /// The current state of the streaming session.
        /// This member is required.
        public var state: AppStreamClientTypes.SessionState?
        /// The identifier of the user for whom the session was created.
        /// This member is required.
        public var userId: Swift.String?

        public init (
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            connectionState: AppStreamClientTypes.SessionConnectionState? = nil,
            fleetName: Swift.String? = nil,
            id: Swift.String? = nil,
            maxExpirationTime: ClientRuntime.Date? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            stackName: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.SessionState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.connectionState = connectionState
            self.fleetName = fleetName
            self.id = id
            self.maxExpirationTime = maxExpirationTime
            self.networkAccessConfiguration = networkAccessConfiguration
            self.stackName = stackName
            self.startTime = startTime
            self.state = state
            self.userId = userId
        }
    }

}

extension AppStreamClientTypes {
    public enum SessionConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionConnectionState] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionConnectionState(rawValue: rawValue) ?? SessionConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    /// Possible values for the state of a streaming session.
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .expired,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.SharedImagePermissions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions
        case sharedAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension AppStreamClientTypes.SharedImagePermissions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedImagePermissions(imagePermissions: \(Swift.String(describing: imagePermissions)), sharedAccountId: \(Swift.String(describing: sharedAccountId)))"}
}

extension AppStreamClientTypes {
    /// Describes the permissions that are available to the specified AWS account for a shared image.
    public struct SharedImagePermissions: Swift.Equatable {
        /// Describes the permissions for a shared image.
        /// This member is required.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The 12-digit identifier of the AWS account with which the image is shared.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init (
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension AppStreamClientTypes.Stack: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case stackErrors = "StackErrors"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let stackErrors = stackErrors {
            var stackErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackErrors)
            for stackerrors0 in stackErrors {
                try stackErrorsContainer.encode(stackerrors0)
            }
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let stackErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackError?].self, forKey: .stackErrors)
        var stackErrorsDecoded0:[AppStreamClientTypes.StackError]? = nil
        if let stackErrorsContainer = stackErrorsContainer {
            stackErrorsDecoded0 = [AppStreamClientTypes.StackError]()
            for structure0 in stackErrorsContainer {
                if let structure0 = structure0 {
                    stackErrorsDecoded0?.append(structure0)
                }
            }
        }
        stackErrors = stackErrorsDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettingsResponse.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension AppStreamClientTypes.Stack: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Stack(accessEndpoints: \(Swift.String(describing: accessEndpoints)), applicationSettings: \(Swift.String(describing: applicationSettings)), arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), embedHostDomains: \(Swift.String(describing: embedHostDomains)), feedbackURL: \(Swift.String(describing: feedbackURL)), name: \(Swift.String(describing: name)), redirectURL: \(Swift.String(describing: redirectURL)), stackErrors: \(Swift.String(describing: stackErrors)), storageConnectors: \(Swift.String(describing: storageConnectors)), userSettings: \(Swift.String(describing: userSettings)))"}
}

extension AppStreamClientTypes {
    /// Describes a stack.
    public struct Stack: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The persistent application settings for users of the stack.
        public var applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse?
        /// The ARN of the stack.
        public var arn: Swift.String?
        /// The time the stack was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The stack name to display.
        public var displayName: Swift.String?
        /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
        public var embedHostDomains: [Swift.String]?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public var feedbackURL: Swift.String?
        /// The name of the stack.
        /// This member is required.
        public var name: Swift.String?
        /// The URL that users are redirected to after their streaming session ends.
        public var redirectURL: Swift.String?
        /// The errors for the stack.
        public var stackErrors: [AppStreamClientTypes.StackError]?
        /// The storage connectors to enable.
        public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.
        public var userSettings: [AppStreamClientTypes.UserSetting]?

        public init (
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            embedHostDomains: [Swift.String]? = nil,
            feedbackURL: Swift.String? = nil,
            name: Swift.String? = nil,
            redirectURL: Swift.String? = nil,
            stackErrors: [AppStreamClientTypes.StackError]? = nil,
            storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
            userSettings: [AppStreamClientTypes.UserSetting]? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.applicationSettings = applicationSettings
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.embedHostDomains = embedHostDomains
            self.feedbackURL = feedbackURL
            self.name = name
            self.redirectURL = redirectURL
            self.stackErrors = stackErrors
            self.storageConnectors = storageConnectors
            self.userSettings = userSettings
        }
    }

}

extension AppStreamClientTypes {
    public enum StackAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessEndpoints
        case embedHostDomains
        case feedbackUrl
        case iamRoleArn
        case redirectUrl
        case storageConnectors
        case storageConnectorGoogleDrive
        case storageConnectorHomefolders
        case storageConnectorOneDrive
        case themeName
        case userSettings
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttribute] {
            return [
                .accessEndpoints,
                .embedHostDomains,
                .feedbackUrl,
                .iamRoleArn,
                .redirectUrl,
                .storageConnectors,
                .storageConnectorGoogleDrive,
                .storageConnectorHomefolders,
                .storageConnectorOneDrive,
                .themeName,
                .userSettings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .embedHostDomains: return "EMBED_HOST_DOMAINS"
            case .feedbackUrl: return "FEEDBACK_URL"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .redirectUrl: return "REDIRECT_URL"
            case .storageConnectors: return "STORAGE_CONNECTORS"
            case .storageConnectorGoogleDrive: return "STORAGE_CONNECTOR_GOOGLE_DRIVE"
            case .storageConnectorHomefolders: return "STORAGE_CONNECTOR_HOMEFOLDERS"
            case .storageConnectorOneDrive: return "STORAGE_CONNECTOR_ONE_DRIVE"
            case .themeName: return "THEME_NAME"
            case .userSettings: return "USER_SETTINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackAttribute(rawValue: rawValue) ?? StackAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.StackError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StackErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes.StackError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StackError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension AppStreamClientTypes {
    /// Describes a stack error.
    public struct StackError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.StackErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.StackErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum StackErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServiceError
        case storageConnectorError
        case sdkUnknown(Swift.String)

        public static var allCases: [StackErrorCode] {
            return [
                .internalServiceError,
                .storageConnectorError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .storageConnectorError: return "STORAGE_CONNECTOR_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackErrorCode(rawValue: rawValue) ?? StackErrorCode.sdkUnknown(rawValue)
        }
    }
}

public struct StartFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFleetOutputError>
}

extension StartFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFleetInput(name: \(Swift.String(describing: name)))"}
}

extension StartFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFleetOutputError>
}

public struct StartFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFleetOutputError>
}

public struct StartFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFleetOutputError>
}

public struct StartFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFleetOutputError>
}

public struct StartFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartFleetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension StartFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFleetOutputResponse()"}
}

extension StartFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartFleetOutputResponseBody: Swift.Equatable {
}

extension StartFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StartImageBuilderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageBuilderOutputError>
}

extension StartImageBuilderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImageBuilderInput(appstreamAgentVersion: \(Swift.String(describing: appstreamAgentVersion)), name: \(Swift.String(describing: name)))"}
}

extension StartImageBuilderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartImageBuilderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageBuilderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageBuilderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageBuilderOutputError>
}

public struct StartImageBuilderInput: Swift.Equatable {
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appstreamAgentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appstreamAgentVersion = appstreamAgentVersion
        self.name = name
    }
}

struct StartImageBuilderInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let appstreamAgentVersion: Swift.String?
}

extension StartImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
    }
}

extension StartImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImageBuilderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImageBuilderOutputResponse(imageBuilder: \(Swift.String(describing: imageBuilder)))"}
}

extension StartImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StartImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StartImageBuilderOutputResponseBody: Swift.Equatable {
    public let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StartImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

public struct StopFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFleetOutputError>
}

extension StopFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopFleetInput(name: \(Swift.String(describing: name)))"}
}

extension StopFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFleetOutputError>
}

public struct StopFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFleetOutputError>
}

public struct StopFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFleetOutputError>
}

public struct StopFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopFleetOutputError>
}

public struct StopFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopFleetInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension StopFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopFleetOutputResponse()"}
}

extension StopFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopFleetOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopFleetOutputResponseBody: Swift.Equatable {
}

extension StopFleetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StopImageBuilderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopImageBuilderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopImageBuilderOutputError>
}

extension StopImageBuilderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopImageBuilderInput(name: \(Swift.String(describing: name)))"}
}

extension StopImageBuilderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopImageBuilderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopImageBuilderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopImageBuilderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopImageBuilderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopImageBuilderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopImageBuilderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopImageBuilderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopImageBuilderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopImageBuilderInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopImageBuilderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopImageBuilderOutputError>
}

public struct StopImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopImageBuilderInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension StopImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopImageBuilderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopImageBuilderOutputResponse(imageBuilder: \(Swift.String(describing: imageBuilder)))"}
}

extension StopImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StopImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StopImageBuilderOutputResponseBody: Swift.Equatable {
    public let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StopImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension AppStreamClientTypes.StorageConnector: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorType = "ConnectorType"
        case domains = "Domains"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domainlist0 in domains {
                try domainsContainer.encode(domainlist0)
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StorageConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension AppStreamClientTypes.StorageConnector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageConnector(connectorType: \(Swift.String(describing: connectorType)), domains: \(Swift.String(describing: domains)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension AppStreamClientTypes {
    /// Describes a connector that enables persistent storage for users.
    public struct StorageConnector: Swift.Equatable {
        /// The type of storage connector.
        /// This member is required.
        public var connectorType: AppStreamClientTypes.StorageConnectorType?
        /// The names of the domains for the account.
        public var domains: [Swift.String]?
        /// The ARN of the storage connector.
        public var resourceIdentifier: Swift.String?

        public init (
            connectorType: AppStreamClientTypes.StorageConnectorType? = nil,
            domains: [Swift.String]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.connectorType = connectorType
            self.domains = domains
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension AppStreamClientTypes {
    /// The type of storage connector.
    public enum StorageConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case googleDrive
        case homefolders
        case oneDrive
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorType] {
            return [
                .googleDrive,
                .homefolders,
                .oneDrive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .googleDrive: return "GOOGLE_DRIVE"
            case .homefolders: return "HOMEFOLDERS"
            case .oneDrive: return "ONE_DRIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageConnectorType(rawValue: rawValue) ?? StorageConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum StreamView: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app
        case desktop
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamView] {
            return [
                .app,
                .desktop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app: return "APP"
            case .desktop: return "DESKTOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamView(rawValue: rawValue) ?? StreamView.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys for the tags to disassociate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDirectoryConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDirectoryConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDirectoryConfigOutputError>
}

extension UpdateDirectoryConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDirectoryConfigInput(directoryName: \(Swift.String(describing: directoryName)), organizationalUnitDistinguishedNames: \(Swift.String(describing: organizationalUnitDistinguishedNames)), serviceAccountCredentials: \(Swift.String(describing: serviceAccountCredentials)))"}
}

extension UpdateDirectoryConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

public struct UpdateDirectoryConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDirectoryConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDirectoryConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDirectoryConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDirectoryConfigInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDirectoryConfigInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDirectoryConfigInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDirectoryConfigInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDirectoryConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDirectoryConfigOutputError>
}

public struct UpdateDirectoryConfigInput: Swift.Equatable {
    /// The name of the Directory Config object.
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init (
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct UpdateDirectoryConfigInputBody: Swift.Equatable {
    public let directoryName: Swift.String?
    public let organizationalUnitDistinguishedNames: [Swift.String]?
    public let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
}

extension UpdateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension UpdateDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidRoleException(InvalidRoleException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectoryConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDirectoryConfigOutputResponse(directoryConfig: \(Swift.String(describing: directoryConfig)))"}
}

extension UpdateDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct UpdateDirectoryConfigOutputResponse: Swift.Equatable {
    /// Information about the Directory Config object.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init (
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct UpdateDirectoryConfigOutputResponseBody: Swift.Equatable {
    public let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension UpdateDirectoryConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

public struct UpdateFleetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetOutputError>
}

extension UpdateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetInput(attributesToDelete: \(Swift.String(describing: attributesToDelete)), computeCapacity: \(Swift.String(describing: computeCapacity)), deleteVpcConfig: \(Swift.String(describing: deleteVpcConfig)), description: \(Swift.String(describing: description)), disconnectTimeoutInSeconds: \(Swift.String(describing: disconnectTimeoutInSeconds)), displayName: \(Swift.String(describing: displayName)), domainJoinInfo: \(Swift.String(describing: domainJoinInfo)), enableDefaultInternetAccess: \(Swift.String(describing: enableDefaultInternetAccess)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idleDisconnectTimeoutInSeconds: \(Swift.String(describing: idleDisconnectTimeoutInSeconds)), imageArn: \(Swift.String(describing: imageArn)), imageName: \(Swift.String(describing: imageName)), instanceType: \(Swift.String(describing: instanceType)), maxUserDurationInSeconds: \(Swift.String(describing: maxUserDurationInSeconds)), name: \(Swift.String(describing: name)), streamView: \(Swift.String(describing: streamView)), vpcConfig: \(Swift.String(describing: vpcConfig)))"}
}

extension UpdateFleetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for fleetattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(fleetattributes0.rawValue)
            }
        }
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if deleteVpcConfig != false {
            try encodeContainer.encode(deleteVpcConfig, forKey: .deleteVpcConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateFleetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFleetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFleetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFleetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFleetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFleetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFleetOutputError>
}

public struct UpdateFleetInput: Swift.Equatable {
    /// The fleet attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    /// The desired capacity for the fleet.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// Deletes the VPC association for the specified fleet.
    @available(*, deprecated)
    public var deleteVpcConfig: Swift.Bool
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    public var instanceType: Swift.String?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    public var name: Swift.String?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The VPC configuration for the fleet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        attributesToDelete: [AppStreamClientTypes.FleetAttribute]? = nil,
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        deleteVpcConfig: Swift.Bool = false,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.computeCapacity = computeCapacity
        self.deleteVpcConfig = deleteVpcConfig
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.streamView = streamView
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    public let imageName: Swift.String?
    public let imageArn: Swift.String?
    public let name: Swift.String?
    public let instanceType: Swift.String?
    public let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    public let vpcConfig: AppStreamClientTypes.VpcConfig?
    public let maxUserDurationInSeconds: Swift.Int?
    public let disconnectTimeoutInSeconds: Swift.Int?
    public let deleteVpcConfig: Swift.Bool
    public let description: Swift.String?
    public let displayName: Swift.String?
    public let enableDefaultInternetAccess: Swift.Bool?
    public let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    public let idleDisconnectTimeoutInSeconds: Swift.Int?
    public let attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    public let iamRoleArn: Swift.String?
    public let streamView: AppStreamClientTypes.StreamView?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case streamView = "StreamView"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let deleteVpcConfigDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteVpcConfig)
        deleteVpcConfig = deleteVpcConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.FleetAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.FleetAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
    }
}

extension UpdateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetOutputResponse(fleet: \(Swift.String(describing: fleet)))"}
}

extension UpdateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct UpdateFleetOutputResponse: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init (
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct UpdateFleetOutputResponseBody: Swift.Equatable {
    public let fleet: AppStreamClientTypes.Fleet?
}

extension UpdateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

public struct UpdateImagePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePermissionsOutputError>
}

extension UpdateImagePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateImagePermissionsInput(imagePermissions: \(Swift.String(describing: imagePermissions)), name: \(Swift.String(describing: name)), sharedAccountId: \(Swift.String(describing: sharedAccountId)))"}
}

extension UpdateImagePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

public struct UpdateImagePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateImagePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateImagePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePermissionsOutputError>
}

public struct UpdateImagePermissionsInput: Swift.Equatable {
    /// The permissions for the image.
    /// This member is required.
    public var imagePermissions: AppStreamClientTypes.ImagePermissions?
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which you want add or update image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateImagePermissionsInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let sharedAccountId: Swift.String?
    public let imagePermissions: AppStreamClientTypes.ImagePermissions?
}

extension UpdateImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension UpdateImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateImagePermissionsOutputResponse()"}
}

extension UpdateImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateImagePermissionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateImagePermissionsOutputResponseBody: Swift.Equatable {
}

extension UpdateImagePermissionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateStackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

extension UpdateStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStackInput(accessEndpoints: \(Swift.String(describing: accessEndpoints)), applicationSettings: \(Swift.String(describing: applicationSettings)), attributesToDelete: \(Swift.String(describing: attributesToDelete)), deleteStorageConnectors: \(Swift.String(describing: deleteStorageConnectors)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), embedHostDomains: \(Swift.String(describing: embedHostDomains)), feedbackURL: \(Swift.String(describing: feedbackURL)), name: \(Swift.String(describing: name)), redirectURL: \(Swift.String(describing: redirectURL)), storageConnectors: \(Swift.String(describing: storageConnectors)), userSettings: \(Swift.String(describing: userSettings)))"}
}

extension UpdateStackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for stackattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(stackattributes0.rawValue)
            }
        }
        if deleteStorageConnectors != false {
            try encodeContainer.encode(deleteStorageConnectors, forKey: .deleteStorageConnectors)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

public struct UpdateStackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStackInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateStackInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStackInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStackOutputError>
}

public struct UpdateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The stack attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    /// Deletes the storage connectors currently enabled for the stack.
    @available(*, deprecated)
    public var deleteStorageConnectors: Swift.Bool
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they choose the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        attributesToDelete: [AppStreamClientTypes.StackAttribute]? = nil,
        deleteStorageConnectors: Swift.Bool = false,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.attributesToDelete = attributesToDelete
        self.deleteStorageConnectors = deleteStorageConnectors
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.userSettings = userSettings
    }
}

struct UpdateStackInputBody: Swift.Equatable {
    public let displayName: Swift.String?
    public let description: Swift.String?
    public let name: Swift.String?
    public let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    public let deleteStorageConnectors: Swift.Bool
    public let redirectURL: Swift.String?
    public let feedbackURL: Swift.String?
    public let attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    public let userSettings: [AppStreamClientTypes.UserSetting]?
    public let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    public let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    public let embedHostDomains: [Swift.String]?
}

extension UpdateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let deleteStorageConnectorsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteStorageConnectors)
        deleteStorageConnectors = deleteStorageConnectorsDecoded
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.StackAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.StackAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension UpdateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStackOutputResponse(stack: \(Swift.String(describing: stack)))"}
}

extension UpdateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct UpdateStackOutputResponse: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init (
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct UpdateStackOutputResponseBody: Swift.Equatable {
    public let stack: AppStreamClientTypes.Stack?
}

extension UpdateStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

extension AppStreamClientTypes {
    public enum UsageReportExecutionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServiceError
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportExecutionErrorCode] {
            return [
                .accessDenied,
                .internalServiceError,
                .resourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportExecutionErrorCode(rawValue: rawValue) ?? UsageReportExecutionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum UsageReportSchedule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportSchedule] {
            return [
                .daily,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportSchedule(rawValue: rawValue) ?? UsageReportSchedule.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.UsageReportSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastGeneratedReportDate = "LastGeneratedReportDate"
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
        case subscriptionErrors = "SubscriptionErrors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastGeneratedReportDate = lastGeneratedReportDate {
            try encodeContainer.encode(lastGeneratedReportDate.timeIntervalSince1970, forKey: .lastGeneratedReportDate)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule.rawValue, forKey: .schedule)
        }
        if let subscriptionErrors = subscriptionErrors {
            var subscriptionErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionErrors)
            for lastreportgenerationexecutionerrors0 in subscriptionErrors {
                try subscriptionErrorsContainer.encode(lastreportgenerationexecutionerrors0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastGeneratedReportDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastGeneratedReportDate)
        lastGeneratedReportDate = lastGeneratedReportDateDecoded
        let subscriptionErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.LastReportGenerationExecutionError?].self, forKey: .subscriptionErrors)
        var subscriptionErrorsDecoded0:[AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        if let subscriptionErrorsContainer = subscriptionErrorsContainer {
            subscriptionErrorsDecoded0 = [AppStreamClientTypes.LastReportGenerationExecutionError]()
            for structure0 in subscriptionErrorsContainer {
                if let structure0 = structure0 {
                    subscriptionErrorsDecoded0?.append(structure0)
                }
            }
        }
        subscriptionErrors = subscriptionErrorsDecoded0
    }
}

extension AppStreamClientTypes.UsageReportSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UsageReportSubscription(lastGeneratedReportDate: \(Swift.String(describing: lastGeneratedReportDate)), s3BucketName: \(Swift.String(describing: s3BucketName)), schedule: \(Swift.String(describing: schedule)), subscriptionErrors: \(Swift.String(describing: subscriptionErrors)))"}
}

extension AppStreamClientTypes {
    /// Describes information about the usage report subscription.
    public struct UsageReportSubscription: Swift.Equatable {
        /// The time when the last usage report was generated.
        public var lastGeneratedReportDate: ClientRuntime.Date?
        /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
        public var s3BucketName: Swift.String?
        /// The schedule for generating usage reports.
        public var schedule: AppStreamClientTypes.UsageReportSchedule?
        /// The errors that were returned if usage reports couldn't be generated.
        public var subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]?

        public init (
            lastGeneratedReportDate: ClientRuntime.Date? = nil,
            s3BucketName: Swift.String? = nil,
            schedule: AppStreamClientTypes.UsageReportSchedule? = nil,
            subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        )
        {
            self.lastGeneratedReportDate = lastGeneratedReportDate
            self.s3BucketName = s3BucketName
            self.schedule = schedule
            self.subscriptionErrors = subscriptionErrors
        }
    }

}

extension AppStreamClientTypes.User: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case authenticationType = "AuthenticationType"
        case createdTime = "CreatedTime"
        case enabled = "Enabled"
        case firstName = "FirstName"
        case lastName = "LastName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension AppStreamClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(arn: \(Swift.String(describing: arn)), authenticationType: \(Swift.String(describing: authenticationType)), createdTime: \(Swift.String(describing: createdTime)), enabled: \(Swift.String(describing: enabled)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)), status: \(Swift.String(describing: status)), userName: \(Swift.String(describing: userName)))"}
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool.
    public struct User: Swift.Equatable {
        /// The ARN of the user.
        public var arn: Swift.String?
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// The date and time the user was created in the user pool.
        public var createdTime: ClientRuntime.Date?
        /// Specifies whether the user in the user pool is enabled.
        public var enabled: Swift.Bool
        /// The first name, or given name, of the user.
        public var firstName: Swift.String?
        /// The last name, or surname, of the user.
        public var lastName: Swift.String?
        /// The status of the user in the user pool. The status can be one of the following:
        ///
        /// * UNCONFIRMED – The user is created but not confirmed.
        ///
        /// * CONFIRMED – The user is confirmed.
        ///
        /// * ARCHIVED – The user is no longer active.
        ///
        /// * COMPROMISED – The user is disabled because of a potential security threat.
        ///
        /// * UNKNOWN – The user status is not known.
        public var status: Swift.String?
        /// The email address of the user. Users' email addresses are case-sensitive.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            enabled: Swift.Bool = false,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            status: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.authenticationType = authenticationType
            self.createdTime = createdTime
            self.enabled = enabled
            self.firstName = firstName
            self.lastName = lastName
            self.status = status
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension AppStreamClientTypes.UserSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSetting(action: \(Swift.String(describing: action)), permission: \(Swift.String(describing: permission)))"}
}

extension AppStreamClientTypes {
    /// Describes an action and whether the action is enabled or disabled for users during their streaming sessions.
    public struct UserSetting: Swift.Equatable {
        /// The action that is enabled or disabled.
        /// This member is required.
        public var action: AppStreamClientTypes.Action?
        /// Indicates whether the action is enabled or disabled.
        /// This member is required.
        public var permission: AppStreamClientTypes.Permission?

        public init (
            action: AppStreamClientTypes.Action? = nil,
            permission: AppStreamClientTypes.Permission? = nil
        )
        {
            self.action = action
            self.permission = permission
        }
    }

}

extension AppStreamClientTypes.UserStackAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case sendEmailNotification = "SendEmailNotification"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if sendEmailNotification != false {
            try encodeContainer.encode(sendEmailNotification, forKey: .sendEmailNotification)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let sendEmailNotificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendEmailNotification)
        sendEmailNotification = sendEmailNotificationDecoded
    }
}

extension AppStreamClientTypes.UserStackAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserStackAssociation(authenticationType: \(Swift.String(describing: authenticationType)), sendEmailNotification: \(Swift.String(describing: sendEmailNotification)), stackName: \(Swift.String(describing: stackName)), userName: \(Swift.String(describing: userName)))"}
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool and the associated stack.
    public struct UserStackAssociation: Swift.Equatable {
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a welcome email is sent to a user after the user is created in the user pool.
        public var sendEmailNotification: Swift.Bool
        /// The name of the stack that is associated with the user.
        /// This member is required.
        public var stackName: Swift.String?
        /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            sendEmailNotification: Swift.Bool = false,
            stackName: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.sendEmailNotification = sendEmailNotification
            self.stackName = stackName
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserStackAssociationError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userStackAssociation = "UserStackAssociation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userStackAssociation = userStackAssociation {
            try encodeContainer.encode(userStackAssociation, forKey: .userStackAssociation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociation.self, forKey: .userStackAssociation)
        userStackAssociation = userStackAssociationDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes.UserStackAssociationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserStackAssociationError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), userStackAssociation: \(Swift.String(describing: userStackAssociation)))"}
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a user can’t be associated with or disassociated from a stack.
    public struct UserStackAssociationError: Swift.Equatable {
        /// The error code for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorCode: AppStreamClientTypes.UserStackAssociationErrorCode?
        /// The error message for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorMessage: Swift.String?
        /// Information about the user and associated stack.
        public var userStackAssociation: AppStreamClientTypes.UserStackAssociation?

        public init (
            errorCode: AppStreamClientTypes.UserStackAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userStackAssociation: AppStreamClientTypes.UserStackAssociation? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userStackAssociation = userStackAssociation
        }
    }

}

extension AppStreamClientTypes {
    public enum UserStackAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directoryNotFound
        case internalError
        case stackNotFound
        case userNameNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStackAssociationErrorCode] {
            return [
                .directoryNotFound,
                .internalError,
                .stackNotFound,
                .userNameNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .stackNotFound: return "STACK_NOT_FOUND"
            case .userNameNotFound: return "USER_NAME_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStackAssociationErrorCode(rawValue: rawValue) ?? UserStackAssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum VisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [VisibilityType] {
            return [
                .private,
                .public,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VisibilityType(rawValue: rawValue) ?? VisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.VpcConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension AppStreamClientTypes.VpcConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfig(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension AppStreamClientTypes {
    /// Describes VPC configuration information for fleets and image builders.
    public struct VpcConfig: Swift.Equatable {
        /// The identifiers of the security groups for the fleet or image builder.
        public var securityGroupIds: [Swift.String]?
        /// The identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance. Fleet instances use one or more subnets. Image builder instances use one subnet.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
