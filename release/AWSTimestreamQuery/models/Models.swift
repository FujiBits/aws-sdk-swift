// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             You are not authorized to perform this action.
///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelQueryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelQueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelQueryOutputError>
}

extension CancelQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelQueryInput(queryId: \(Swift.String(describing: queryId)))"}
}

extension CancelQueryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

public struct CancelQueryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelQueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelQueryOutputError>
}

public struct CancelQueryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelQueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelQueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelQueryOutputError>
}

public struct CancelQueryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelQueryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelQueryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelQueryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelQueryOutputError>
}

public struct CancelQueryInput: Swift.Equatable {
    ///
    ///       The id of the query that needs to be cancelled. QueryID is returned as part of QueryResult.
    ///
    /// This member is required.
    public var queryId: Swift.String?

    public init (
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Swift.Equatable {
    public let queryId: Swift.String?
}

extension CancelQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension CancelQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelQueryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelQueryOutputResponse(cancellationMessage: \(Swift.String(describing: cancellationMessage)))"}
}

extension CancelQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cancellationMessage = output.cancellationMessage
        } else {
            self.cancellationMessage = nil
        }
    }
}

public struct CancelQueryOutputResponse: Swift.Equatable {
    ///
    ///         A CancellationMessage is returned when a CancelQuery request for the query specified by QueryId has already been issued.
    ///
    public var cancellationMessage: Swift.String?

    public init (
        cancellationMessage: Swift.String? = nil
    )
    {
        self.cancellationMessage = cancellationMessage
    }
}

struct CancelQueryOutputResponseBody: Swift.Equatable {
    public let cancellationMessage: Swift.String?
}

extension CancelQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancellationMessage = "CancellationMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cancellationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cancellationMessage)
        cancellationMessage = cancellationMessageDecoded
    }
}

extension TimestreamQueryClientTypes.ColumnInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.value, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Box<TimestreamQueryClientTypes.ModelType>.self, forKey: .type)
        type = typeDecoded
    }
}

extension TimestreamQueryClientTypes.ColumnInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnInfo(name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension TimestreamQueryClientTypes {
    ///
    ///             Contains the meta data for query results such as the column names, data types, and other attributes.
    ///
    public struct ColumnInfo: Swift.Equatable {
        ///
        ///             The name of the result set column. The name of the result set is available for columns of all data types except for arrays.
        ///
        public var name: Swift.String?
        ///
        ///             The data type of the result set column. The data type can be a scalar or complex. Scalar data types are integers, strings, doubles, booleans, and others. Complex data types are types such as arrays, rows, and others.
        ///
        /// This member is required.
        public var type: Box<TimestreamQueryClientTypes.ModelType>?

        public init (
            name: Swift.String? = nil,
            type: Box<TimestreamQueryClientTypes.ModelType>? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///        Unable to poll results for a cancelled query.
///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamQueryClientTypes.Datum: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayValue = "ArrayValue"
        case nullValue = "NullValue"
        case rowValue = "RowValue"
        case scalarValue = "ScalarValue"
        case timeSeriesValue = "TimeSeriesValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayValue = arrayValue {
            var arrayValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arrayValue)
            for datumlist0 in arrayValue {
                try arrayValueContainer.encode(datumlist0)
            }
        }
        if let nullValue = nullValue {
            try encodeContainer.encode(nullValue, forKey: .nullValue)
        }
        if let rowValue = rowValue {
            try encodeContainer.encode(rowValue, forKey: .rowValue)
        }
        if let scalarValue = scalarValue {
            try encodeContainer.encode(scalarValue, forKey: .scalarValue)
        }
        if let timeSeriesValue = timeSeriesValue {
            var timeSeriesValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timeSeriesValue)
            for timeseriesdatapointlist0 in timeSeriesValue {
                try timeSeriesValueContainer.encode(timeseriesdatapointlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scalarValue)
        scalarValue = scalarValueDecoded
        let timeSeriesValueContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.TimeSeriesDataPoint?].self, forKey: .timeSeriesValue)
        var timeSeriesValueDecoded0:[TimestreamQueryClientTypes.TimeSeriesDataPoint]? = nil
        if let timeSeriesValueContainer = timeSeriesValueContainer {
            timeSeriesValueDecoded0 = [TimestreamQueryClientTypes.TimeSeriesDataPoint]()
            for structure0 in timeSeriesValueContainer {
                if let structure0 = structure0 {
                    timeSeriesValueDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesValue = timeSeriesValueDecoded0
        let arrayValueContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Datum?].self, forKey: .arrayValue)
        var arrayValueDecoded0:[TimestreamQueryClientTypes.Datum]? = nil
        if let arrayValueContainer = arrayValueContainer {
            arrayValueDecoded0 = [TimestreamQueryClientTypes.Datum]()
            for structure0 in arrayValueContainer {
                if let structure0 = structure0 {
                    arrayValueDecoded0?.append(structure0)
                }
            }
        }
        arrayValue = arrayValueDecoded0
        let rowValueDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.Row.self, forKey: .rowValue)
        rowValue = rowValueDecoded
        let nullValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .nullValue)
        nullValue = nullValueDecoded
    }
}

extension TimestreamQueryClientTypes.Datum: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Datum(arrayValue: \(Swift.String(describing: arrayValue)), nullValue: \(Swift.String(describing: nullValue)), rowValue: \(Swift.String(describing: rowValue)), scalarValue: \(Swift.String(describing: scalarValue)), timeSeriesValue: \(Swift.String(describing: timeSeriesValue)))"}
}

extension TimestreamQueryClientTypes {
    ///
    ///             Datum represents a single data point in a query result.
    ///
    public struct Datum: Swift.Equatable {
        ///
        ///             Indicates if the data point is an array.
        ///
        public var arrayValue: [TimestreamQueryClientTypes.Datum]?
        ///
        ///             Indicates if the data point is null.
        ///
        public var nullValue: Swift.Bool?
        ///
        ///             Indicates if the data point is a row.
        ///
        public var rowValue: TimestreamQueryClientTypes.Row?
        ///
        ///             Indicates if the data point is a scalar value such as integer, string, double, or boolean.
        ///
        public var scalarValue: Swift.String?
        ///
        ///             Indicates if the data point is of timeseries data type.
        ///
        public var timeSeriesValue: [TimestreamQueryClientTypes.TimeSeriesDataPoint]?

        public init (
            arrayValue: [TimestreamQueryClientTypes.Datum]? = nil,
            nullValue: Swift.Bool? = nil,
            rowValue: TimestreamQueryClientTypes.Row? = nil,
            scalarValue: Swift.String? = nil,
            timeSeriesValue: [TimestreamQueryClientTypes.TimeSeriesDataPoint]? = nil
        )
        {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
            self.timeSeriesValue = timeSeriesValue
        }
    }

}

extension DescribeEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsInput()"}
}

extension DescribeEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInput: Swift.Equatable {

    public init() {}
}

struct DescribeEndpointsInputBody: Swift.Equatable {
}

extension DescribeEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsOutputResponse(endpoints: \(Swift.String(describing: endpoints)))"}
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// An Endpoints object is returned when a DescribeEndpoints request is made.
    /// This member is required.
    public var endpoints: [TimestreamQueryClientTypes.Endpoint]?

    public init (
        endpoints: [TimestreamQueryClientTypes.Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    public let endpoints: [TimestreamQueryClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[TimestreamQueryClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [TimestreamQueryClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension TimestreamQueryClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .cachePeriodInMinutes)
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension TimestreamQueryClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), cachePeriodInMinutes: \(Swift.String(describing: cachePeriodInMinutes)))"}
}

extension TimestreamQueryClientTypes {
    /// Represents an available endpoint against which to make API calls agaisnt, as well as the TTL for that endpoint.
    public struct Endpoint: Swift.Equatable {
        /// An endpoint address.
        /// This member is required.
        public var address: Swift.String?
        /// The TTL for the endpoint, in minutes.
        /// This member is required.
        public var cachePeriodInMinutes: Swift.Int

        public init (
            address: Swift.String? = nil,
            cachePeriodInMinutes: Swift.Int = 0
        )
        {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             Timestream was unable to fully process this request because of an internal server error.
///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEndpointException(message: \(Swift.String(describing: message)))"}
}

extension InvalidEndpointException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested endpoint was invalid.
public struct InvalidEndpointException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEndpointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamQueryClientTypes.ModelType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayColumnInfo = "ArrayColumnInfo"
        case rowColumnInfo = "RowColumnInfo"
        case scalarType = "ScalarType"
        case timeSeriesMeasureValueColumnInfo = "TimeSeriesMeasureValueColumnInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayColumnInfo = arrayColumnInfo {
            try encodeContainer.encode(arrayColumnInfo, forKey: .arrayColumnInfo)
        }
        if let rowColumnInfo = rowColumnInfo {
            var rowColumnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowColumnInfo)
            for columninfolist0 in rowColumnInfo {
                try rowColumnInfoContainer.encode(columninfolist0)
            }
        }
        if let scalarType = scalarType {
            try encodeContainer.encode(scalarType.rawValue, forKey: .scalarType)
        }
        if let timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo {
            try encodeContainer.encode(timeSeriesMeasureValueColumnInfo, forKey: .timeSeriesMeasureValueColumnInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scalarTypeDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScalarType.self, forKey: .scalarType)
        scalarType = scalarTypeDecoded
        let arrayColumnInfoDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ColumnInfo.self, forKey: .arrayColumnInfo)
        arrayColumnInfo = arrayColumnInfoDecoded
        let timeSeriesMeasureValueColumnInfoDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ColumnInfo.self, forKey: .timeSeriesMeasureValueColumnInfo)
        timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfoDecoded
        let rowColumnInfoContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ColumnInfo?].self, forKey: .rowColumnInfo)
        var rowColumnInfoDecoded0:[TimestreamQueryClientTypes.ColumnInfo]? = nil
        if let rowColumnInfoContainer = rowColumnInfoContainer {
            rowColumnInfoDecoded0 = [TimestreamQueryClientTypes.ColumnInfo]()
            for structure0 in rowColumnInfoContainer {
                if let structure0 = structure0 {
                    rowColumnInfoDecoded0?.append(structure0)
                }
            }
        }
        rowColumnInfo = rowColumnInfoDecoded0
    }
}

extension QueryExecutionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryExecutionException(message: \(Swift.String(describing: message)))"}
}

extension QueryExecutionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QueryExecutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///         Timestream was unable to run the query successfully.
///
public struct QueryExecutionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryExecutionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension QueryExecutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct QueryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

extension QueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryInput(clientToken: \(Swift.String(describing: clientToken)), maxRows: \(Swift.String(describing: maxRows)), nextToken: \(Swift.String(describing: nextToken)), queryString: \(Swift.String(describing: queryString)))"}
}

extension QueryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let maxRows = maxRows {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

public struct QueryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

public struct QueryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

public struct QueryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: QueryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = QueryInput
    public typealias MOutput = ClientRuntime.OperationOutput<QueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryOutputError>
}

public struct QueryInput: Swift.Equatable {
    ///
    ///        Unique, case-sensitive string of up to 64 ASCII characters that you specify when you make a Query request.
    ///        Providing a ClientToken makes the call to Query idempotent, meaning that multiple identical calls
    ///        have the same effect as one single call.
    ///
    ///
    ///          Your query request will fail in the following cases:
    ///
    ///
    ///
    ///                   If you submit a request with the same client token outside the 5-minute idepotency window.
    ///
    ///
    ///
    ///
    ///                   If you submit a request with the same client token but a change in other parameters within the 5-minute idempotency window.
    ///
    ///
    ///
    ///
    ///
    ///       After 4 hours, any request with the same client token is treated as a new request.
    ///
    public var clientToken: Swift.String?
    ///
    ///       The total number of rows to return in the output. If the total number of rows available
    ///       is more than the value specified, a NextToken is provided in the command's output.
    ///       To resume pagination, provide the NextToken value in the starting-token argument of a
    ///       subsequent command.
    ///
    public var maxRows: Swift.Int?
    ///
    ///        A pagination token passed to get a set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///             The query to be executed by Timestream.
    ///
    /// This member is required.
    public var queryString: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        maxRows: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.maxRows = maxRows
        self.nextToken = nextToken
        self.queryString = queryString
    }
}

struct QueryInputBody: Swift.Equatable {
    public let queryString: Swift.String?
    public let clientToken: Swift.String?
    public let nextToken: Swift.String?
    public let maxRows: Swift.Int?
}

extension QueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case maxRows = "MaxRows"
        case nextToken = "NextToken"
        case queryString = "QueryString"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRows)
        maxRows = maxRowsDecoded
    }
}

extension QueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryExecutionException" : self = .queryExecutionException(try QueryExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case queryExecutionException(QueryExecutionException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryOutputResponse(columnInfo: \(Swift.String(describing: columnInfo)), nextToken: \(Swift.String(describing: nextToken)), queryId: \(Swift.String(describing: queryId)), queryStatus: \(Swift.String(describing: queryStatus)), rows: \(Swift.String(describing: rows)))"}
}

extension QueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columnInfo = output.columnInfo
            self.nextToken = output.nextToken
            self.queryId = output.queryId
            self.queryStatus = output.queryStatus
            self.rows = output.rows
        } else {
            self.columnInfo = nil
            self.nextToken = nil
            self.queryId = nil
            self.queryStatus = nil
            self.rows = nil
        }
    }
}

public struct QueryOutputResponse: Swift.Equatable {
    ///
    ///             The column data types of the returned result set.
    ///
    /// This member is required.
    public var columnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
    ///
    ///        A pagination token that can be used again on a Query call to get the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///        A unique ID for the given query.
    ///
    /// This member is required.
    public var queryId: Swift.String?
    /// Information about the status of the query, including progress and bytes scannned.
    public var queryStatus: TimestreamQueryClientTypes.QueryStatus?
    ///
    ///             The result set rows returned by the query.
    ///
    /// This member is required.
    public var rows: [TimestreamQueryClientTypes.Row]?

    public init (
        columnInfo: [TimestreamQueryClientTypes.ColumnInfo]? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryStatus: TimestreamQueryClientTypes.QueryStatus? = nil,
        rows: [TimestreamQueryClientTypes.Row]? = nil
    )
    {
        self.columnInfo = columnInfo
        self.nextToken = nextToken
        self.queryId = queryId
        self.queryStatus = queryStatus
        self.rows = rows
    }
}

struct QueryOutputResponseBody: Swift.Equatable {
    public let queryId: Swift.String?
    public let nextToken: Swift.String?
    public let rows: [TimestreamQueryClientTypes.Row]?
    public let columnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
    public let queryStatus: TimestreamQueryClientTypes.QueryStatus?
}

extension QueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnInfo = "ColumnInfo"
        case nextToken = "NextToken"
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
        case rows = "Rows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rowsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[TimestreamQueryClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [TimestreamQueryClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let columnInfoContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[TimestreamQueryClientTypes.ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [TimestreamQueryClientTypes.ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
        let queryStatusDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension TimestreamQueryClientTypes.QueryStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cumulativeBytesMetered = "CumulativeBytesMetered"
        case cumulativeBytesScanned = "CumulativeBytesScanned"
        case progressPercentage = "ProgressPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cumulativeBytesMetered != 0 {
            try encodeContainer.encode(cumulativeBytesMetered, forKey: .cumulativeBytesMetered)
        }
        if cumulativeBytesScanned != 0 {
            try encodeContainer.encode(cumulativeBytesScanned, forKey: .cumulativeBytesScanned)
        }
        if progressPercentage != 0.0 {
            try encodeContainer.encode(progressPercentage, forKey: .progressPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .progressPercentage)
        progressPercentage = progressPercentageDecoded
        let cumulativeBytesScannedDecoded = try containerValues.decode(Swift.Int.self, forKey: .cumulativeBytesScanned)
        cumulativeBytesScanned = cumulativeBytesScannedDecoded
        let cumulativeBytesMeteredDecoded = try containerValues.decode(Swift.Int.self, forKey: .cumulativeBytesMetered)
        cumulativeBytesMetered = cumulativeBytesMeteredDecoded
    }
}

extension TimestreamQueryClientTypes.QueryStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStatus(cumulativeBytesMetered: \(Swift.String(describing: cumulativeBytesMetered)), cumulativeBytesScanned: \(Swift.String(describing: cumulativeBytesScanned)), progressPercentage: \(Swift.String(describing: progressPercentage)))"}
}

extension TimestreamQueryClientTypes {
    /// Information about the status of the query, including progress and bytes scannned.
    public struct QueryStatus: Swift.Equatable {
        /// The amount of data scanned by the query in bytes that you will be charged for.
        ///             This is a cumulative sum and represents the total amount of data that you will be charged
        ///             for since the query was started.
        ///             The charge is applied only once and is either applied when
        ///             the query completes execution or when the query is cancelled.
        ///
        public var cumulativeBytesMetered: Swift.Int
        /// The amount of data scanned by the query in bytes.
        ///             This is a cumulative sum and represents the total amount of bytes scanned since the query was started.
        ///
        public var cumulativeBytesScanned: Swift.Int
        /// The progress of the query, expressed as a percentage.
        public var progressPercentage: Swift.Double

        public init (
            cumulativeBytesMetered: Swift.Int = 0,
            cumulativeBytesScanned: Swift.Int = 0,
            progressPercentage: Swift.Double = 0.0
        )
        {
            self.cumulativeBytesMetered = cumulativeBytesMetered
            self.cumulativeBytesScanned = cumulativeBytesScanned
            self.progressPercentage = progressPercentage
        }
    }

}

extension TimestreamQueryClientTypes.Row: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datumlist0 in data {
                try dataContainer.encode(datumlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.Datum?].self, forKey: .data)
        var dataDecoded0:[TimestreamQueryClientTypes.Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [TimestreamQueryClientTypes.Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension TimestreamQueryClientTypes.Row: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Row(data: \(Swift.String(describing: data)))"}
}

extension TimestreamQueryClientTypes {
    /// Represents a single row in the query results.
    public struct Row: Swift.Equatable {
        /// List of data points in a single row of the result set.
        /// This member is required.
        public var data: [TimestreamQueryClientTypes.Datum]?

        public init (
            data: [TimestreamQueryClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension TimestreamQueryClientTypes {
    public enum ScalarType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case date
        case double
        case integer
        case intervalDayToSecond
        case intervalYearToMonth
        case time
        case timestamp
        case unknown
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarType] {
            return [
                .bigint,
                .boolean,
                .date,
                .double,
                .integer,
                .intervalDayToSecond,
                .intervalYearToMonth,
                .time,
                .timestamp,
                .unknown,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .date: return "DATE"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .intervalDayToSecond: return "INTERVAL_DAY_TO_SECOND"
            case .intervalYearToMonth: return "INTERVAL_YEAR_TO_MONTH"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .unknown: return "UNKNOWN"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalarType(rawValue: rawValue) ?? ScalarType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamQueryClientTypes.TimeSeriesDataPoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.Datum.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamQueryClientTypes.TimeSeriesDataPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeSeriesDataPoint(time: \(Swift.String(describing: time)), value: \(Swift.String(describing: value)))"}
}

extension TimestreamQueryClientTypes {
    /// The timeseries datatype represents the values of a measure over time. A time series is an array of rows of timestamps and measure values, with rows sorted in ascending order of time. A TimeSeriesDataPoint is a single data point in the timeseries. It represents a tuple of (time, measure value) in a timeseries.
    public struct TimeSeriesDataPoint: Swift.Equatable {
        /// The timestamp when the measure value was collected.
        /// This member is required.
        public var time: Swift.String?
        /// The measure value for the  data point.
        /// This member is required.
        public var value: TimestreamQueryClientTypes.Datum?

        public init (
            time: Swift.String? = nil,
            value: TimestreamQueryClientTypes.Datum? = nil
        )
        {
            self.time = time
            self.value = value
        }
    }

}

extension TimestreamQueryClientTypes.ModelType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelType(arrayColumnInfo: \(Swift.String(describing: arrayColumnInfo)), rowColumnInfo: \(Swift.String(describing: rowColumnInfo)), scalarType: \(Swift.String(describing: scalarType)), timeSeriesMeasureValueColumnInfo: \(Swift.String(describing: timeSeriesMeasureValueColumnInfo)))"}
}

extension TimestreamQueryClientTypes {
    /// Contains the data type of a column in a query result set. The data type can be scalar or complex. The supported scalar data types are integers, boolean, string, double, timestamp, date, time, and intervals. The supported complex data types are arrays, rows, and timeseries.
    public struct ModelType: Swift.Equatable {
        /// Indicates if the column is an array.
        public var arrayColumnInfo: TimestreamQueryClientTypes.ColumnInfo?
        /// Indicates if the column is a row.
        public var rowColumnInfo: [TimestreamQueryClientTypes.ColumnInfo]?
        /// Indicates if the column is of type string, integer, boolean, double, timestamp, date, time.
        public var scalarType: TimestreamQueryClientTypes.ScalarType?
        /// Indicates if the column is a timeseries data type.
        public var timeSeriesMeasureValueColumnInfo: TimestreamQueryClientTypes.ColumnInfo?

        public init (
            arrayColumnInfo: TimestreamQueryClientTypes.ColumnInfo? = nil,
            rowColumnInfo: [TimestreamQueryClientTypes.ColumnInfo]? = nil,
            scalarType: TimestreamQueryClientTypes.ScalarType? = nil,
            timeSeriesMeasureValueColumnInfo: TimestreamQueryClientTypes.ColumnInfo? = nil
        )
        {
            self.arrayColumnInfo = arrayColumnInfo
            self.rowColumnInfo = rowColumnInfo
            self.scalarType = scalarType
            self.timeSeriesMeasureValueColumnInfo = timeSeriesMeasureValueColumnInfo
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             Invalid or malformed request.
///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
