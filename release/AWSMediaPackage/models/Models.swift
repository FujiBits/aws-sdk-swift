// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaPackageClientTypes {
    public enum AdMarkers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daterange
        case `none`
        case passthrough
        case scte35Enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [AdMarkers] {
            return [
                .daterange,
                .none,
                .passthrough,
                .scte35Enhanced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daterange: return "DATERANGE"
            case .none: return "NONE"
            case .passthrough: return "PASSTHROUGH"
            case .scte35Enhanced: return "SCTE35_ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdMarkers(rawValue: rawValue) ?? AdMarkers.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
    /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
    /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
    /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
    /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
    /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
    /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
    /// and are always treated as ads if specified in AdTriggers.
    public enum AdsOnDeliveryRestrictions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case both
        case `none`
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [AdsOnDeliveryRestrictions] {
            return [
                .both,
                .none,
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .both: return "BOTH"
            case .none: return "NONE"
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdsOnDeliveryRestrictions(rawValue: rawValue) ?? AdsOnDeliveryRestrictions.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.Authorization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdnIdentifierSecret = "cdnIdentifierSecret"
        case secretsRoleArn = "secretsRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdnIdentifierSecret = cdnIdentifierSecret {
            try encodeContainer.encode(cdnIdentifierSecret, forKey: .cdnIdentifierSecret)
        }
        if let secretsRoleArn = secretsRoleArn {
            try encodeContainer.encode(secretsRoleArn, forKey: .secretsRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdnIdentifierSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdnIdentifierSecret)
        cdnIdentifierSecret = cdnIdentifierSecretDecoded
        let secretsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsRoleArn)
        secretsRoleArn = secretsRoleArnDecoded
    }
}

extension MediaPackageClientTypes.Authorization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Authorization(cdnIdentifierSecret: \(Swift.String(describing: cdnIdentifierSecret)), secretsRoleArn: \(Swift.String(describing: secretsRoleArn)))"}
}

extension MediaPackageClientTypes {
    /// CDN Authorization credentials
    public struct Authorization: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
        /// This member is required.
        public var cdnIdentifierSecret: Swift.String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        /// This member is required.
        public var secretsRoleArn: Swift.String?

        public init (
            cdnIdentifierSecret: Swift.String? = nil,
            secretsRoleArn: Swift.String? = nil
        )
        {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }
    }

}

extension MediaPackageClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let hlsIngest = hlsIngest {
            try encodeContainer.encode(hlsIngest, forKey: .hlsIngest)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ingressAccessLogs = ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension MediaPackageClientTypes {
    /// A Channel resource configuration.
    public struct Channel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public var arn: Swift.String?
        /// A short text description of the Channel.
        public var description: Swift.String?
        /// Configure egress access logging.
        public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
        /// An HTTP Live Streaming (HLS) ingest resource configuration.
        public var hlsIngest: MediaPackageClientTypes.HlsIngest?
        /// The ID of the Channel.
        public var id: Swift.String?
        /// Configure ingress access logging.
        public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
            hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
            id: Swift.String? = nil,
            ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.egressAccessLogs = egressAccessLogs
            self.hlsIngest = hlsIngest
            self.id = id
            self.ingressAccessLogs = ingressAccessLogs
            self.tags = tags
        }
    }

}

extension MediaPackageClientTypes.CmafEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let keyRotationIntervalSeconds = keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes.CmafEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CmafEncryption(constantInitializationVector: \(Swift.String(describing: constantInitializationVector)), keyRotationIntervalSeconds: \(Swift.String(describing: keyRotationIntervalSeconds)), spekeKeyProvider: \(Swift.String(describing: spekeKeyProvider)))"}
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) encryption configuration.
    public struct CmafEncryption: Swift.Equatable {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public var constantInitializationVector: Swift.String?
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init (
            constantInitializationVector: Swift.String? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.CmafPackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifest0)
            }
        }
        if let segmentDurationSeconds = segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageClientTypes.HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageClientTypes.HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes.CmafPackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CmafPackage(encryption: \(Swift.String(describing: encryption)), hlsManifests: \(Swift.String(describing: hlsManifests)), segmentDurationSeconds: \(Swift.String(describing: segmentDurationSeconds)), segmentPrefix: \(Swift.String(describing: segmentPrefix)), streamSelection: \(Swift.String(describing: streamSelection)))"}
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackage: Swift.Equatable {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init (
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifest]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

extension MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentPrefix = "segmentPrefix"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifestcreateorupdateparameters0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifestcreateorupdateparameters0)
            }
        }
        if let segmentDurationSeconds = segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentPrefix = segmentPrefix {
            try encodeContainer.encode(segmentPrefix, forKey: .segmentPrefix)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentPrefix)
        segmentPrefix = segmentPrefixDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CmafPackageCreateOrUpdateParameters(encryption: \(Swift.String(describing: encryption)), hlsManifests: \(Swift.String(describing: hlsManifests)), segmentDurationSeconds: \(Swift.String(describing: segmentDurationSeconds)), segmentPrefix: \(Swift.String(describing: segmentPrefix)), streamSelection: \(Swift.String(describing: streamSelection)))"}
}

extension MediaPackageClientTypes {
    /// A Common Media Application Format (CMAF) packaging configuration.
    public struct CmafPackageCreateOrUpdateParameters: Swift.Equatable {
        /// A Common Media Application Format (CMAF) encryption configuration.
        public var encryption: MediaPackageClientTypes.CmafEncryption?
        /// A list of HLS manifest configurations
        public var hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public var segmentPrefix: Swift.String?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init (
            encryption: MediaPackageClientTypes.CmafEncryption? = nil,
            hlsManifests: [MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters]? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentPrefix: Swift.String? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }
    }

}

public struct ConfigureLogsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsOutputError>
}

extension ConfigureLogsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureLogsInput(egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)))"}
}

extension ConfigureLogsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let ingressAccessLogs = ingressAccessLogs {
            try encodeContainer.encode(ingressAccessLogs, forKey: .ingressAccessLogs)
        }
    }
}

public struct ConfigureLogsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsOutputError>
}

public struct ConfigureLogsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsOutputError>
}

public struct ConfigureLogsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureLogsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ConfigureLogsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())/configure_logs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ConfigureLogsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureLogsOutputError>
}

/// the option to configure log subscription.
public struct ConfigureLogsInput: Swift.Equatable {
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// The ID of the channel to log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?

    public init (
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
    }
}

struct ConfigureLogsInputBody: Swift.Equatable {
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
}

extension ConfigureLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressAccessLogs = "egressAccessLogs"
        case ingressAccessLogs = "ingressAccessLogs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
    }
}

extension ConfigureLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureLogsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureLogsOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension ConfigureLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConfigureLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct ConfigureLogsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct ConfigureLogsOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension ConfigureLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

/// A new Channel configuration.
public struct CreateChannelInput: Swift.Equatable {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel. The ID must be unique within the region and it
    /// cannot be changed after a Channel is created.
    /// This member is required.
    public var id: Swift.String?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let id: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateHarvestJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHarvestJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHarvestJobOutputError>
}

extension CreateHarvestJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHarvestJobInput(endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), originEndpointId: \(Swift.String(describing: originEndpointId)), s3Destination: \(Swift.String(describing: s3Destination)), startTime: \(Swift.String(describing: startTime)))"}
}

extension CreateHarvestJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

public struct CreateHarvestJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHarvestJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHarvestJobOutputError>
}

public struct CreateHarvestJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHarvestJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHarvestJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHarvestJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHarvestJobOutputError>
}

public struct CreateHarvestJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHarvestJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateHarvestJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/harvest_jobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateHarvestJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHarvestJobOutputError>
}

/// Configuration parameters used to create a new HarvestJob.
public struct CreateHarvestJobInput: Swift.Equatable {
    /// The end of the time-window which will be harvested
    /// This member is required.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    /// This member is required.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    /// This member is required.
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested
    /// This member is required.
    public var startTime: Swift.String?

    public init (
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
    }
}

struct CreateHarvestJobInputBody: Swift.Equatable {
    public let endTime: Swift.String?
    public let id: Swift.String?
    public let originEndpointId: Swift.String?
    public let s3Destination: MediaPackageClientTypes.S3Destination?
    public let startTime: Swift.String?
}

extension CreateHarvestJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension CreateHarvestJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHarvestJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHarvestJobOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHarvestJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHarvestJobOutputResponse(arn: \(Swift.String(describing: arn)), channelId: \(Swift.String(describing: channelId)), createdAt: \(Swift.String(describing: createdAt)), endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), originEndpointId: \(Swift.String(describing: originEndpointId)), s3Destination: \(Swift.String(describing: s3Destination)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension CreateHarvestJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHarvestJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct CreateHarvestJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The time the HarvestJob was submitted
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init (
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct CreateHarvestJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let channelId: Swift.String?
    public let createdAt: Swift.String?
    public let endTime: Swift.String?
    public let id: Swift.String?
    public let originEndpointId: Swift.String?
    public let s3Destination: MediaPackageClientTypes.S3Destination?
    public let startTime: Swift.String?
    public let status: MediaPackageClientTypes.Status?
}

extension CreateHarvestJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateOriginEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginEndpointOutputError>
}

extension CreateOriginEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginEndpointInput(authorization: \(Swift.String(describing: authorization)), channelId: \(Swift.String(describing: channelId)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), tags: \(Swift.String(describing: tags)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension CreateOriginEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeDelaySeconds = timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }
}

public struct CreateOriginEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginEndpointOutputError>
}

public struct CreateOriginEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginEndpointOutputError>
}

public struct CreateOriginEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateOriginEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/origin_endpoints"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOriginEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginEndpointOutputError>
}

/// Configuration parameters used to create a new OriginEndpoint.
public struct CreateOriginEndpointInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel that the OriginEndpoint will be associated with.
    /// This cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.  The ID must be unique within the region
    /// and it cannot be changed after the OriginEndpoint is created.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init (
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointInputBody: Swift.Equatable {
    public let authorization: MediaPackageClientTypes.Authorization?
    public let channelId: Swift.String?
    public let cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    public let dashPackage: MediaPackageClientTypes.DashPackage?
    public let description: Swift.String?
    public let hlsPackage: MediaPackageClientTypes.HlsPackage?
    public let id: Swift.String?
    public let manifestName: Swift.String?
    public let mssPackage: MediaPackageClientTypes.MssPackage?
    public let origination: MediaPackageClientTypes.Origination?
    public let startoverWindowSeconds: Swift.Int?
    public let tags: [Swift.String:Swift.String]?
    public let timeDelaySeconds: Swift.Int?
    public let whitelist: [Swift.String]?
}

extension CreateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension CreateOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginEndpointOutputResponse(arn: \(Swift.String(describing: arn)), authorization: \(Swift.String(describing: authorization)), channelId: \(Swift.String(describing: channelId)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), tags: \(Swift.String(describing: tags)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), url: \(Swift.String(describing: url)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension CreateOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct CreateOriginEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct CreateOriginEndpointOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let authorization: MediaPackageClientTypes.Authorization?
    public let channelId: Swift.String?
    public let cmafPackage: MediaPackageClientTypes.CmafPackage?
    public let dashPackage: MediaPackageClientTypes.DashPackage?
    public let description: Swift.String?
    public let hlsPackage: MediaPackageClientTypes.HlsPackage?
    public let id: Swift.String?
    public let manifestName: Swift.String?
    public let mssPackage: MediaPackageClientTypes.MssPackage?
    public let origination: MediaPackageClientTypes.Origination?
    public let startoverWindowSeconds: Swift.Int?
    public let tags: [Swift.String:Swift.String]?
    public let timeDelaySeconds: Swift.Int?
    public let url: Swift.String?
    public let whitelist: [Swift.String]?
}

extension CreateOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension MediaPackageClientTypes.DashEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyRotationIntervalSeconds = keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes.DashEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashEncryption(keyRotationIntervalSeconds: \(Swift.String(describing: keyRotationIntervalSeconds)), spekeKeyProvider: \(Swift.String(describing: spekeKeyProvider)))"}
}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public struct DashEncryption: Swift.Equatable {
        /// Time (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init (
            keyRotationIntervalSeconds: Swift.Int? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.DashPackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case manifestLayout = "manifestLayout"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case minBufferTimeSeconds = "minBufferTimeSeconds"
        case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
        case periodTriggers = "periodTriggers"
        case profile = "profile"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentTemplateFormat = "segmentTemplateFormat"
        case streamSelection = "streamSelection"
        case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
        case utcTiming = "utcTiming"
        case utcTimingUri = "utcTimingUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let manifestLayout = manifestLayout {
            try encodeContainer.encode(manifestLayout.rawValue, forKey: .manifestLayout)
        }
        if let manifestWindowSeconds = manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let minBufferTimeSeconds = minBufferTimeSeconds {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let minUpdatePeriodSeconds = minUpdatePeriodSeconds {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if let periodTriggers = periodTriggers {
            var periodTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .periodTriggers)
            for __listof__periodtriggerselement0 in periodTriggers {
                try periodTriggersContainer.encode(__listof__periodtriggerselement0.rawValue)
            }
        }
        if let profile = profile {
            try encodeContainer.encode(profile.rawValue, forKey: .profile)
        }
        if let segmentDurationSeconds = segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentTemplateFormat = segmentTemplateFormat {
            try encodeContainer.encode(segmentTemplateFormat.rawValue, forKey: .segmentTemplateFormat)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if let suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
        if let utcTiming = utcTiming {
            try encodeContainer.encode(utcTiming.rawValue, forKey: .utcTiming)
        }
        if let utcTimingUri = utcTimingUri {
            try encodeContainer.encode(utcTimingUri, forKey: .utcTimingUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestLayoutDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.ManifestLayout.self, forKey: .manifestLayout)
        manifestLayout = manifestLayoutDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let periodTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__PeriodTriggersElement?].self, forKey: .periodTriggers)
        var periodTriggersDecoded0:[MediaPackageClientTypes.__PeriodTriggersElement]? = nil
        if let periodTriggersContainer = periodTriggersContainer {
            periodTriggersDecoded0 = [MediaPackageClientTypes.__PeriodTriggersElement]()
            for string0 in periodTriggersContainer {
                if let string0 = string0 {
                    periodTriggersDecoded0?.append(string0)
                }
            }
        }
        periodTriggers = periodTriggersDecoded0
        let profileDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentTemplateFormatDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SegmentTemplateFormat.self, forKey: .segmentTemplateFormat)
        segmentTemplateFormat = segmentTemplateFormatDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
        let utcTimingDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.UtcTiming.self, forKey: .utcTiming)
        utcTiming = utcTimingDecoded
        let utcTimingUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utcTimingUri)
        utcTimingUri = utcTimingUriDecoded
    }
}

extension MediaPackageClientTypes.DashPackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashPackage(adTriggers: \(Swift.String(describing: adTriggers)), adsOnDeliveryRestrictions: \(Swift.String(describing: adsOnDeliveryRestrictions)), encryption: \(Swift.String(describing: encryption)), manifestLayout: \(Swift.String(describing: manifestLayout)), manifestWindowSeconds: \(Swift.String(describing: manifestWindowSeconds)), minBufferTimeSeconds: \(Swift.String(describing: minBufferTimeSeconds)), minUpdatePeriodSeconds: \(Swift.String(describing: minUpdatePeriodSeconds)), periodTriggers: \(Swift.String(describing: periodTriggers)), profile: \(Swift.String(describing: profile)), segmentDurationSeconds: \(Swift.String(describing: segmentDurationSeconds)), segmentTemplateFormat: \(Swift.String(describing: segmentTemplateFormat)), streamSelection: \(Swift.String(describing: streamSelection)), suggestedPresentationDelaySeconds: \(Swift.String(describing: suggestedPresentationDelaySeconds)), utcTiming: \(Swift.String(describing: utcTiming)), utcTimingUri: \(Swift.String(describing: utcTimingUri)))"}
}

extension MediaPackageClientTypes {
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public struct DashPackage: Swift.Equatable {
        /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
        /// ad markers are output.  Specify multiple items to create ad markers for all of the included
        /// message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
        /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
        /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
        /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
        /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
        /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
        /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
        /// and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
        public var encryption: MediaPackageClientTypes.DashEncryption?
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public var manifestLayout: MediaPackageClientTypes.ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public var minUpdatePeriodSeconds: Swift.Int?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Channel source contains SCTE-35 ad markers.
        public var periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public var profile: MediaPackageClientTypes.Profile?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public var segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public var suggestedPresentationDelaySeconds: Swift.Int?
        /// Determines the type of UTCTiming included in the Media Presentation Description (MPD)
        public var utcTiming: MediaPackageClientTypes.UtcTiming?
        /// Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO or HTTP-HEAD
        public var utcTimingUri: Swift.String?

        public init (
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.DashEncryption? = nil,
            manifestLayout: MediaPackageClientTypes.ManifestLayout? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            periodTriggers: [MediaPackageClientTypes.__PeriodTriggersElement]? = nil,
            profile: MediaPackageClientTypes.Profile? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            segmentTemplateFormat: MediaPackageClientTypes.SegmentTemplateFormat? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil,
            utcTiming: MediaPackageClientTypes.UtcTiming? = nil,
            utcTimingUri: Swift.String? = nil
        )
        {
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
            self.utcTiming = utcTiming
            self.utcTimingUri = utcTimingUri
        }
    }

}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ID of the Channel to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginEndpointInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteOriginEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteOriginEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginEndpointOutputError>
}

public struct DeleteOriginEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginEndpointOutputError>
}

public struct DeleteOriginEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteOriginEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/origin_endpoints/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOriginEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginEndpointOutputError>
}

public struct DeleteOriginEndpointInput: Swift.Equatable {
    /// The ID of the OriginEndpoint to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteOriginEndpointInputBody: Swift.Equatable {
}

extension DeleteOriginEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginEndpointOutputResponse()"}
}

extension DeleteOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginEndpointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOriginEndpointOutputResponseBody: Swift.Equatable {
}

extension DeleteOriginEndpointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ID of a Channel.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeChannelOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeHarvestJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHarvestJobInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeHarvestJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeHarvestJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHarvestJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHarvestJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHarvestJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHarvestJobOutputError>
}

public struct DescribeHarvestJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHarvestJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHarvestJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHarvestJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHarvestJobOutputError>
}

public struct DescribeHarvestJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHarvestJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeHarvestJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/harvest_jobs/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeHarvestJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHarvestJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHarvestJobOutputError>
}

public struct DescribeHarvestJobInput: Swift.Equatable {
    /// The ID of the HarvestJob.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeHarvestJobInputBody: Swift.Equatable {
}

extension DescribeHarvestJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHarvestJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHarvestJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHarvestJobOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHarvestJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHarvestJobOutputResponse(arn: \(Swift.String(describing: arn)), channelId: \(Swift.String(describing: channelId)), createdAt: \(Swift.String(describing: createdAt)), endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), originEndpointId: \(Swift.String(describing: originEndpointId)), s3Destination: \(Swift.String(describing: s3Destination)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension DescribeHarvestJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHarvestJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelId = output.channelId
            self.createdAt = output.createdAt
            self.endTime = output.endTime
            self.id = output.id
            self.originEndpointId = output.originEndpointId
            self.s3Destination = output.s3Destination
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.arn = nil
            self.channelId = nil
            self.createdAt = nil
            self.endTime = nil
            self.id = nil
            self.originEndpointId = nil
            self.s3Destination = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeHarvestJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
    public var arn: Swift.String?
    /// The ID of the Channel that the HarvestJob will harvest from.
    public var channelId: Swift.String?
    /// The time the HarvestJob was submitted
    public var createdAt: Swift.String?
    /// The end of the time-window which will be harvested.
    public var endTime: Swift.String?
    /// The ID of the HarvestJob. The ID must be unique within the region
    /// and it cannot be changed after the HarvestJob is submitted.
    public var id: Swift.String?
    /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
    /// This cannot be changed after the HarvestJob is submitted.
    public var originEndpointId: Swift.String?
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public var s3Destination: MediaPackageClientTypes.S3Destination?
    /// The start of the time-window which will be harvested.
    public var startTime: Swift.String?
    /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
    /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
    /// include an explanation of why the HarvestJob failed.
    public var status: MediaPackageClientTypes.Status?

    public init (
        arn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        createdAt: Swift.String? = nil,
        endTime: Swift.String? = nil,
        id: Swift.String? = nil,
        originEndpointId: Swift.String? = nil,
        s3Destination: MediaPackageClientTypes.S3Destination? = nil,
        startTime: Swift.String? = nil,
        status: MediaPackageClientTypes.Status? = nil
    )
    {
        self.arn = arn
        self.channelId = channelId
        self.createdAt = createdAt
        self.endTime = endTime
        self.id = id
        self.originEndpointId = originEndpointId
        self.s3Destination = s3Destination
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeHarvestJobOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let channelId: Swift.String?
    public let createdAt: Swift.String?
    public let endTime: Swift.String?
    public let id: Swift.String?
    public let originEndpointId: Swift.String?
    public let s3Destination: MediaPackageClientTypes.S3Destination?
    public let startTime: Swift.String?
    public let status: MediaPackageClientTypes.Status?
}

extension DescribeHarvestJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeOriginEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOriginEndpointInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeOriginEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeOriginEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOriginEndpointOutputError>
}

public struct DescribeOriginEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOriginEndpointOutputError>
}

public struct DescribeOriginEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOriginEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeOriginEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/origin_endpoints/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOriginEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOriginEndpointOutputError>
}

public struct DescribeOriginEndpointInput: Swift.Equatable {
    /// The ID of the OriginEndpoint.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeOriginEndpointInputBody: Swift.Equatable {
}

extension DescribeOriginEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOriginEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOriginEndpointOutputResponse(arn: \(Swift.String(describing: arn)), authorization: \(Swift.String(describing: authorization)), channelId: \(Swift.String(describing: channelId)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), tags: \(Swift.String(describing: tags)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), url: \(Swift.String(describing: url)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension DescribeOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct DescribeOriginEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct DescribeOriginEndpointOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let authorization: MediaPackageClientTypes.Authorization?
    public let channelId: Swift.String?
    public let cmafPackage: MediaPackageClientTypes.CmafPackage?
    public let dashPackage: MediaPackageClientTypes.DashPackage?
    public let description: Swift.String?
    public let hlsPackage: MediaPackageClientTypes.HlsPackage?
    public let id: Swift.String?
    public let manifestName: Swift.String?
    public let mssPackage: MediaPackageClientTypes.MssPackage?
    public let origination: MediaPackageClientTypes.Origination?
    public let startoverWindowSeconds: Swift.Int?
    public let tags: [Swift.String:Swift.String]?
    public let timeDelaySeconds: Swift.Int?
    public let url: Swift.String?
    public let whitelist: [Swift.String]?
}

extension DescribeOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension MediaPackageClientTypes.EgressAccessLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension MediaPackageClientTypes.EgressAccessLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EgressAccessLogs(logGroupName: \(Swift.String(describing: logGroupName)))"}
}

extension MediaPackageClientTypes {
    /// Configure egress access logging.
    public struct EgressAccessLogs: Swift.Equatable {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init (
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension MediaPackageClientTypes.EncryptionContractConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presetSpeke20Audio = "presetSpeke20Audio"
        case presetSpeke20Video = "presetSpeke20Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presetSpeke20Audio = presetSpeke20Audio {
            try encodeContainer.encode(presetSpeke20Audio.rawValue, forKey: .presetSpeke20Audio)
        }
        if let presetSpeke20Video = presetSpeke20Video {
            try encodeContainer.encode(presetSpeke20Video.rawValue, forKey: .presetSpeke20Video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetSpeke20AudioDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PresetSpeke20Audio.self, forKey: .presetSpeke20Audio)
        presetSpeke20Audio = presetSpeke20AudioDecoded
        let presetSpeke20VideoDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PresetSpeke20Video.self, forKey: .presetSpeke20Video)
        presetSpeke20Video = presetSpeke20VideoDecoded
    }
}

extension MediaPackageClientTypes.EncryptionContractConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionContractConfiguration(presetSpeke20Audio: \(Swift.String(describing: presetSpeke20Audio)), presetSpeke20Video: \(Swift.String(describing: presetSpeke20Video)))"}
}

extension MediaPackageClientTypes {
    /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0.
    /// The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream.
    /// To configure the encryption contract, specify which audio and video encryption presets to use.
    /// Note the following considerations when using encryptionContractConfiguration:
    /// encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification.
    /// You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
    public struct EncryptionContractConfiguration: Swift.Equatable {
        /// A collection of audio encryption presets.
        /// This member is required.
        public var presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio?
        /// A collection of video encryption presets.
        /// This member is required.
        public var presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video?

        public init (
            presetSpeke20Audio: MediaPackageClientTypes.PresetSpeke20Audio? = nil,
            presetSpeke20Video: MediaPackageClientTypes.PresetSpeke20Video? = nil
        )
        {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }
    }

}

extension MediaPackageClientTypes {
    public enum EncryptionMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case sampleAes
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionMethod] {
            return [
                .aes128,
                .sampleAes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "AES_128"
            case .sampleAes: return "SAMPLE_AES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionMethod(rawValue: rawValue) ?? EncryptionMethod.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.HarvestJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case channelId = "channelId"
        case createdAt = "createdAt"
        case endTime = "endTime"
        case id = "id"
        case originEndpointId = "originEndpointId"
        case s3Destination = "s3Destination"
        case startTime = "startTime"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originEndpointId = originEndpointId {
            try encodeContainer.encode(originEndpointId, forKey: .originEndpointId)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originEndpointId)
        originEndpointId = originEndpointIdDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension MediaPackageClientTypes.HarvestJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HarvestJob(arn: \(Swift.String(describing: arn)), channelId: \(Swift.String(describing: channelId)), createdAt: \(Swift.String(describing: createdAt)), endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), originEndpointId: \(Swift.String(describing: originEndpointId)), s3Destination: \(Swift.String(describing: s3Destination)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension MediaPackageClientTypes {
    /// A HarvestJob resource configuration
    public struct HarvestJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the HarvestJob.
        public var arn: Swift.String?
        /// The ID of the Channel that the HarvestJob will harvest from.
        public var channelId: Swift.String?
        /// The time the HarvestJob was submitted
        public var createdAt: Swift.String?
        /// The end of the time-window which will be harvested.
        public var endTime: Swift.String?
        /// The ID of the HarvestJob. The ID must be unique within the region
        /// and it cannot be changed after the HarvestJob is submitted.
        public var id: Swift.String?
        /// The ID of the OriginEndpoint that the HarvestJob will harvest from.
        /// This cannot be changed after the HarvestJob is submitted.
        public var originEndpointId: Swift.String?
        /// Configuration parameters for where in an S3 bucket to place the harvested content
        public var s3Destination: MediaPackageClientTypes.S3Destination?
        /// The start of the time-window which will be harvested.
        public var startTime: Swift.String?
        /// The current status of the HarvestJob. Consider setting up a CloudWatch Event to listen for
        /// HarvestJobs as they succeed or fail. In the event of failure, the CloudWatch Event will
        /// include an explanation of why the HarvestJob failed.
        public var status: MediaPackageClientTypes.Status?

        public init (
            arn: Swift.String? = nil,
            channelId: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            endTime: Swift.String? = nil,
            id: Swift.String? = nil,
            originEndpointId: Swift.String? = nil,
            s3Destination: MediaPackageClientTypes.S3Destination? = nil,
            startTime: Swift.String? = nil,
            status: MediaPackageClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.channelId = channelId
            self.createdAt = createdAt
            self.endTime = endTime
            self.id = id
            self.originEndpointId = originEndpointId
            self.s3Destination = s3Destination
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MediaPackageClientTypes.HlsEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
        case repeatExtXKey = "repeatExtXKey"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if let keyRotationIntervalSeconds = keyRotationIntervalSeconds {
            try encodeContainer.encode(keyRotationIntervalSeconds, forKey: .keyRotationIntervalSeconds)
        }
        if let repeatExtXKey = repeatExtXKey {
            try encodeContainer.encode(repeatExtXKey, forKey: .repeatExtXKey)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let keyRotationIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyRotationIntervalSeconds)
        keyRotationIntervalSeconds = keyRotationIntervalSecondsDecoded
        let repeatExtXKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .repeatExtXKey)
        repeatExtXKey = repeatExtXKeyDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes.HlsEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsEncryption(constantInitializationVector: \(Swift.String(describing: constantInitializationVector)), encryptionMethod: \(Swift.String(describing: encryptionMethod)), keyRotationIntervalSeconds: \(Swift.String(describing: keyRotationIntervalSeconds)), repeatExtXKey: \(Swift.String(describing: repeatExtXKey)), spekeKeyProvider: \(Swift.String(describing: spekeKeyProvider)))"}
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public struct HlsEncryption: Swift.Equatable {
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public var constantInitializationVector: Swift.String?
        /// The encryption method to use.
        public var encryptionMethod: MediaPackageClientTypes.EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public var keyRotationIntervalSeconds: Swift.Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public var repeatExtXKey: Swift.Bool?
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init (
            constantInitializationVector: Swift.String? = nil,
            encryptionMethod: MediaPackageClientTypes.EncryptionMethod? = nil,
            keyRotationIntervalSeconds: Swift.Int? = nil,
            repeatExtXKey: Swift.Bool? = nil,
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.HlsIngest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestEndpoints = "ingestEndpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestEndpoints = ingestEndpoints {
            var ingestEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingestEndpoints)
            for __listofingestendpoint0 in ingestEndpoints {
                try ingestEndpointsContainer.encode(__listofingestendpoint0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.IngestEndpoint?].self, forKey: .ingestEndpoints)
        var ingestEndpointsDecoded0:[MediaPackageClientTypes.IngestEndpoint]? = nil
        if let ingestEndpointsContainer = ingestEndpointsContainer {
            ingestEndpointsDecoded0 = [MediaPackageClientTypes.IngestEndpoint]()
            for structure0 in ingestEndpointsContainer {
                if let structure0 = structure0 {
                    ingestEndpointsDecoded0?.append(structure0)
                }
            }
        }
        ingestEndpoints = ingestEndpointsDecoded0
    }
}

extension MediaPackageClientTypes.HlsIngest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsIngest(ingestEndpoints: \(Swift.String(describing: ingestEndpoints)))"}
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public struct HlsIngest: Swift.Equatable {
        /// A list of endpoints to which the source stream should be sent.
        public var ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]?

        public init (
            ingestEndpoints: [MediaPackageClientTypes.IngestEndpoint]? = nil
        )
        {
            self.ingestEndpoints = ingestEndpoints
        }
    }

}

extension MediaPackageClientTypes.HlsManifest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let includeIframeOnlyStream = includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageClientTypes.HlsManifest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsManifest(adMarkers: \(Swift.String(describing: adMarkers)), id: \(Swift.String(describing: id)), includeIframeOnlyStream: \(Swift.String(describing: includeIframeOnlyStream)), manifestName: \(Swift.String(describing: manifestName)), playlistType: \(Swift.String(describing: playlistType)), playlistWindowSeconds: \(Swift.String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(Swift.String(describing: programDateTimeIntervalSeconds)), url: \(Swift.String(describing: url)))"}
}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifest: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?

        public init (
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            url: Swift.String? = nil
        )
        {
            self.adMarkers = adMarkers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case id = "id"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let includeIframeOnlyStream = includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
    }
}

extension MediaPackageClientTypes.HlsManifestCreateOrUpdateParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsManifestCreateOrUpdateParameters(adMarkers: \(Swift.String(describing: adMarkers)), adTriggers: \(Swift.String(describing: adTriggers)), adsOnDeliveryRestrictions: \(Swift.String(describing: adsOnDeliveryRestrictions)), id: \(Swift.String(describing: id)), includeIframeOnlyStream: \(Swift.String(describing: includeIframeOnlyStream)), manifestName: \(Swift.String(describing: manifestName)), playlistType: \(Swift.String(describing: playlistType)), playlistWindowSeconds: \(Swift.String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(Swift.String(describing: programDateTimeIntervalSeconds)))"}
}

extension MediaPackageClientTypes {
    /// A HTTP Live Streaming (HLS) manifest configuration.
    public struct HlsManifestCreateOrUpdateParameters: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
        /// ad markers are output.  Specify multiple items to create ad markers for all of the included
        /// message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
        /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
        /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
        /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
        /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
        /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
        /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
        /// and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        /// This member is required.
        public var id: Swift.String?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public var manifestName: Swift.String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?

        public init (
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            id: Swift.String? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            manifestName: Swift.String? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }
    }

}

extension MediaPackageClientTypes.HlsPackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkers = "adMarkers"
        case adTriggers = "adTriggers"
        case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
        case encryption = "encryption"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case playlistType = "playlistType"
        case playlistWindowSeconds = "playlistWindowSeconds"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
        case useAudioRenditionGroup = "useAudioRenditionGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if let adTriggers = adTriggers {
            var adTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adTriggers)
            for adtriggers0 in adTriggers {
                try adTriggersContainer.encode(adtriggers0.rawValue)
            }
        }
        if let adsOnDeliveryRestrictions = adsOnDeliveryRestrictions {
            try encodeContainer.encode(adsOnDeliveryRestrictions.rawValue, forKey: .adsOnDeliveryRestrictions)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let includeIframeOnlyStream = includeIframeOnlyStream {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let playlistType = playlistType {
            try encodeContainer.encode(playlistType.rawValue, forKey: .playlistType)
        }
        if let playlistWindowSeconds = playlistWindowSeconds {
            try encodeContainer.encode(playlistWindowSeconds, forKey: .playlistWindowSeconds)
        }
        if let programDateTimeIntervalSeconds = programDateTimeIntervalSeconds {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if let segmentDurationSeconds = segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
        if let useAudioRenditionGroup = useAudioRenditionGroup {
            try encodeContainer.encode(useAudioRenditionGroup, forKey: .useAudioRenditionGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let adTriggersContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.__AdTriggersElement?].self, forKey: .adTriggers)
        var adTriggersDecoded0:[MediaPackageClientTypes.__AdTriggersElement]? = nil
        if let adTriggersContainer = adTriggersContainer {
            adTriggersDecoded0 = [MediaPackageClientTypes.__AdTriggersElement]()
            for string0 in adTriggersContainer {
                if let string0 = string0 {
                    adTriggersDecoded0?.append(string0)
                }
            }
        }
        adTriggers = adTriggersDecoded0
        let adsOnDeliveryRestrictionsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.AdsOnDeliveryRestrictions.self, forKey: .adsOnDeliveryRestrictions)
        adsOnDeliveryRestrictions = adsOnDeliveryRestrictionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let playlistTypeDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.PlaylistType.self, forKey: .playlistType)
        playlistType = playlistTypeDecoded
        let playlistWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .playlistWindowSeconds)
        playlistWindowSeconds = playlistWindowSecondsDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
        let useAudioRenditionGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAudioRenditionGroup)
        useAudioRenditionGroup = useAudioRenditionGroupDecoded
    }
}

extension MediaPackageClientTypes.HlsPackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsPackage(adMarkers: \(Swift.String(describing: adMarkers)), adTriggers: \(Swift.String(describing: adTriggers)), adsOnDeliveryRestrictions: \(Swift.String(describing: adsOnDeliveryRestrictions)), encryption: \(Swift.String(describing: encryption)), includeIframeOnlyStream: \(Swift.String(describing: includeIframeOnlyStream)), playlistType: \(Swift.String(describing: playlistType)), playlistWindowSeconds: \(Swift.String(describing: playlistWindowSeconds)), programDateTimeIntervalSeconds: \(Swift.String(describing: programDateTimeIntervalSeconds)), segmentDurationSeconds: \(Swift.String(describing: segmentDurationSeconds)), streamSelection: \(Swift.String(describing: streamSelection)), useAudioRenditionGroup: \(Swift.String(describing: useAudioRenditionGroup)))"}
}

extension MediaPackageClientTypes {
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public struct HlsPackage: Swift.Equatable {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        /// "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events
        /// in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value
        /// that is greater than 0.
        public var adMarkers: MediaPackageClientTypes.AdMarkers?
        /// A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no
        /// ad markers are output.  Specify multiple items to create ad markers for all of the included
        /// message types.
        public var adTriggers: [MediaPackageClientTypes.__AdTriggersElement]?
        /// This setting allows the delivery restriction flags on SCTE-35 segmentation descriptors to
        /// determine whether a message signals an ad.  Choosing "NONE" means no SCTE-35 messages become
        /// ads.  Choosing "RESTRICTED" means SCTE-35 messages of the types specified in AdTriggers that
        /// contain delivery restrictions will be treated as ads.  Choosing "UNRESTRICTED" means SCTE-35
        /// messages of the types specified in AdTriggers that do not contain delivery restrictions will
        /// be treated as ads.  Choosing "BOTH" means all SCTE-35 messages of the types specified in
        /// AdTriggers will be treated as ads.  Note that Splice Insert messages do not have these flags
        /// and are always treated as ads if specified in AdTriggers.
        public var adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions?
        /// An HTTP Live Streaming (HLS) encryption configuration.
        public var encryption: MediaPackageClientTypes.HlsEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public var includeIframeOnlyStream: Swift.Bool?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public var playlistType: MediaPackageClientTypes.PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public var playlistWindowSeconds: Swift.Int?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public var programDateTimeIntervalSeconds: Swift.Int?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public var useAudioRenditionGroup: Swift.Bool?

        public init (
            adMarkers: MediaPackageClientTypes.AdMarkers? = nil,
            adTriggers: [MediaPackageClientTypes.__AdTriggersElement]? = nil,
            adsOnDeliveryRestrictions: MediaPackageClientTypes.AdsOnDeliveryRestrictions? = nil,
            encryption: MediaPackageClientTypes.HlsEncryption? = nil,
            includeIframeOnlyStream: Swift.Bool? = nil,
            playlistType: MediaPackageClientTypes.PlaylistType? = nil,
            playlistWindowSeconds: Swift.Int? = nil,
            programDateTimeIntervalSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil,
            useAudioRenditionGroup: Swift.Bool? = nil
        )
        {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }
    }

}

extension MediaPackageClientTypes.IngestEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case password = "password"
        case url = "url"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MediaPackageClientTypes.IngestEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IngestEndpoint(id: \(Swift.String(describing: id)), password: \(Swift.String(describing: password)), url: \(Swift.String(describing: url)), username: \(Swift.String(describing: username)))"}
}

extension MediaPackageClientTypes {
    /// An endpoint for ingesting source content for a Channel.
    public struct IngestEndpoint: Swift.Equatable {
        /// The system generated unique identifier for the IngestEndpoint
        public var id: Swift.String?
        /// The system generated password for ingest authentication.
        public var password: Swift.String?
        /// The ingest URL to which the source stream should be sent.
        public var url: Swift.String?
        /// The system generated username for ingest authentication.
        public var username: Swift.String?

        public init (
            id: Swift.String? = nil,
            password: Swift.String? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }
    }

}

extension MediaPackageClientTypes.IngressAccessLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension MediaPackageClientTypes.IngressAccessLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IngressAccessLogs(logGroupName: \(Swift.String(describing: logGroupName)))"}
}

extension MediaPackageClientTypes {
    /// Configure ingress access logging.
    public struct IngressAccessLogs: Swift.Equatable {
        /// Customize the log group name.
        public var logGroupName: Swift.String?

        public init (
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// A list of Channel records.
    public var channels: [MediaPackageClientTypes.Channel]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init (
        channels: [MediaPackageClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let channels: [MediaPackageClientTypes.Channel]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "channels"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[MediaPackageClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [MediaPackageClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHarvestJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHarvestJobsInput(includeChannelId: \(Swift.String(describing: includeChannelId)), includeStatus: \(Swift.String(describing: includeStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHarvestJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListHarvestJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHarvestJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHarvestJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHarvestJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHarvestJobsOutputError>
}

public struct ListHarvestJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHarvestJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHarvestJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let includeChannelId = input.operationInput.includeChannelId {
            let includeChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "includeChannelId".urlPercentEncoding(), value: Swift.String(includeChannelId).urlPercentEncoding())
            input.builder.withQueryItem(includeChannelIdQueryItem)
        }
        if let includeStatus = input.operationInput.includeStatus {
            let includeStatusQueryItem = ClientRuntime.URLQueryItem(name: "includeStatus".urlPercentEncoding(), value: Swift.String(includeStatus).urlPercentEncoding())
            input.builder.withQueryItem(includeStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHarvestJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHarvestJobsOutputError>
}

public struct ListHarvestJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHarvestJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListHarvestJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/harvest_jobs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListHarvestJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListHarvestJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHarvestJobsOutputError>
}

public struct ListHarvestJobsInput: Swift.Equatable {
    /// When specified, the request will return only HarvestJobs associated with the given Channel ID.
    public var includeChannelId: Swift.String?
    /// When specified, the request will return only HarvestJobs in the given status.
    public var includeStatus: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init (
        includeChannelId: Swift.String? = nil,
        includeStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeChannelId = includeChannelId
        self.includeStatus = includeStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsInputBody: Swift.Equatable {
}

extension ListHarvestJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHarvestJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHarvestJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHarvestJobsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHarvestJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHarvestJobsOutputResponse(harvestJobs: \(Swift.String(describing: harvestJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHarvestJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHarvestJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.harvestJobs = output.harvestJobs
            self.nextToken = output.nextToken
        } else {
            self.harvestJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListHarvestJobsOutputResponse: Swift.Equatable {
    /// A list of HarvestJob records.
    public var harvestJobs: [MediaPackageClientTypes.HarvestJob]?
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?

    public init (
        harvestJobs: [MediaPackageClientTypes.HarvestJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.harvestJobs = harvestJobs
        self.nextToken = nextToken
    }
}

struct ListHarvestJobsOutputResponseBody: Swift.Equatable {
    public let harvestJobs: [MediaPackageClientTypes.HarvestJob]?
    public let nextToken: Swift.String?
}

extension ListHarvestJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case harvestJobs = "harvestJobs"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let harvestJobsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.HarvestJob?].self, forKey: .harvestJobs)
        var harvestJobsDecoded0:[MediaPackageClientTypes.HarvestJob]? = nil
        if let harvestJobsContainer = harvestJobsContainer {
            harvestJobsDecoded0 = [MediaPackageClientTypes.HarvestJob]()
            for structure0 in harvestJobsContainer {
                if let structure0 = structure0 {
                    harvestJobsDecoded0?.append(structure0)
                }
            }
        }
        harvestJobs = harvestJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOriginEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginEndpointsInput(channelId: \(Swift.String(describing: channelId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOriginEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOriginEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginEndpointsOutputError>
}

public struct ListOriginEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let channelId = input.operationInput.channelId {
            let channelIdQueryItem = ClientRuntime.URLQueryItem(name: "channelId".urlPercentEncoding(), value: Swift.String(channelId).urlPercentEncoding())
            input.builder.withQueryItem(channelIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginEndpointsOutputError>
}

public struct ListOriginEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginEndpointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListOriginEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/origin_endpoints"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOriginEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginEndpointsOutputError>
}

public struct ListOriginEndpointsInput: Swift.Equatable {
    /// When specified, the request will return only OriginEndpoints associated with the given Channel ID.
    public var channelId: Swift.String?
    /// The upper bound on the number of records to return.
    public var maxResults: Swift.Int?
    /// A token used to resume pagination from the end of a previous request.
    public var nextToken: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOriginEndpointsInputBody: Swift.Equatable {
}

extension ListOriginEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOriginEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginEndpointsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginEndpointsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), originEndpoints: \(Swift.String(describing: originEndpoints)))"}
}

extension ListOriginEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOriginEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.originEndpoints = output.originEndpoints
        } else {
            self.nextToken = nil
            self.originEndpoints = nil
        }
    }
}

public struct ListOriginEndpointsOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public var nextToken: Swift.String?
    /// A list of OriginEndpoint records.
    public var originEndpoints: [MediaPackageClientTypes.OriginEndpoint]?

    public init (
        nextToken: Swift.String? = nil,
        originEndpoints: [MediaPackageClientTypes.OriginEndpoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.originEndpoints = originEndpoints
    }
}

struct ListOriginEndpointsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let originEndpoints: [MediaPackageClientTypes.OriginEndpoint]?
}

extension ListOriginEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case originEndpoints = "originEndpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let originEndpointsContainer = try containerValues.decodeIfPresent([MediaPackageClientTypes.OriginEndpoint?].self, forKey: .originEndpoints)
        var originEndpointsDecoded0:[MediaPackageClientTypes.OriginEndpoint]? = nil
        if let originEndpointsContainer = originEndpointsContainer {
            originEndpointsDecoded0 = [MediaPackageClientTypes.OriginEndpoint]()
            for structure0 in originEndpointsContainer {
                if let structure0 = structure0 {
                    originEndpointsDecoded0?.append(structure0)
                }
            }
        }
        originEndpoints = originEndpointsDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageClientTypes {
    public enum ManifestLayout: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compact
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestLayout] {
            return [
                .compact,
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compact: return "COMPACT"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManifestLayout(rawValue: rawValue) ?? ManifestLayout.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.MssEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MediaPackageClientTypes.MssEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MssEncryption(spekeKeyProvider: \(Swift.String(describing: spekeKeyProvider)))"}
}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public struct MssEncryption: Swift.Equatable {
        /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
        /// This member is required.
        public var spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider?

        public init (
            spekeKeyProvider: MediaPackageClientTypes.SpekeKeyProvider? = nil
        )
        {
            self.spekeKeyProvider = spekeKeyProvider
        }
    }

}

extension MediaPackageClientTypes.MssPackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "encryption"
        case manifestWindowSeconds = "manifestWindowSeconds"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let manifestWindowSeconds = manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let segmentDurationSeconds = segmentDurationSeconds {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MediaPackageClientTypes.MssPackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MssPackage(encryption: \(Swift.String(describing: encryption)), manifestWindowSeconds: \(Swift.String(describing: manifestWindowSeconds)), segmentDurationSeconds: \(Swift.String(describing: segmentDurationSeconds)), streamSelection: \(Swift.String(describing: streamSelection)))"}
}

extension MediaPackageClientTypes {
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public struct MssPackage: Swift.Equatable {
        /// A Microsoft Smooth Streaming (MSS) encryption configuration.
        public var encryption: MediaPackageClientTypes.MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public var manifestWindowSeconds: Swift.Int?
        /// The duration (in seconds) of each segment.
        public var segmentDurationSeconds: Swift.Int?
        /// A StreamSelection configuration.
        public var streamSelection: MediaPackageClientTypes.StreamSelection?

        public init (
            encryption: MediaPackageClientTypes.MssEncryption? = nil,
            manifestWindowSeconds: Swift.Int? = nil,
            segmentDurationSeconds: Swift.Int? = nil,
            streamSelection: MediaPackageClientTypes.StreamSelection? = nil
        )
        {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.OriginEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let channelId = channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeDelaySeconds = timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension MediaPackageClientTypes.OriginEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginEndpoint(arn: \(Swift.String(describing: arn)), authorization: \(Swift.String(describing: authorization)), channelId: \(Swift.String(describing: channelId)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), tags: \(Swift.String(describing: tags)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), url: \(Swift.String(describing: url)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension MediaPackageClientTypes {
    /// An OriginEndpoint resource configuration.
    public struct OriginEndpoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public var arn: Swift.String?
        /// CDN Authorization credentials
        public var authorization: MediaPackageClientTypes.Authorization?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public var channelId: Swift.String?
        /// A Common Media Application Format (CMAF) packaging configuration.
        public var cmafPackage: MediaPackageClientTypes.CmafPackage?
        /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
        public var dashPackage: MediaPackageClientTypes.DashPackage?
        /// A short text description of the OriginEndpoint.
        public var description: Swift.String?
        /// An HTTP Live Streaming (HLS) packaging configuration.
        public var hlsPackage: MediaPackageClientTypes.HlsPackage?
        /// The ID of the OriginEndpoint.
        public var id: Swift.String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public var manifestName: Swift.String?
        /// A Microsoft Smooth Streaming (MSS) packaging configuration.
        public var mssPackage: MediaPackageClientTypes.MssPackage?
        /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
        /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
        /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
        public var origination: MediaPackageClientTypes.Origination?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public var startoverWindowSeconds: Swift.Int?
        /// A collection of tags associated with a resource
        public var tags: [Swift.String:Swift.String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public var timeDelaySeconds: Swift.Int?
        /// The URL of the packaged OriginEndpoint for consumption.
        public var url: Swift.String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public var whitelist: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            authorization: MediaPackageClientTypes.Authorization? = nil,
            channelId: Swift.String? = nil,
            cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
            dashPackage: MediaPackageClientTypes.DashPackage? = nil,
            description: Swift.String? = nil,
            hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
            id: Swift.String? = nil,
            manifestName: Swift.String? = nil,
            mssPackage: MediaPackageClientTypes.MssPackage? = nil,
            origination: MediaPackageClientTypes.Origination? = nil,
            startoverWindowSeconds: Swift.Int? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeDelaySeconds: Swift.Int? = nil,
            url: Swift.String? = nil,
            whitelist: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authorization = authorization
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.origination = origination
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }
    }

}

extension MediaPackageClientTypes {
    public enum Origination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Origination] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Origination(rawValue: rawValue) ?? Origination.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PlaylistType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case `none`
        case vod
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaylistType] {
            return [
                .event,
                .none,
                .vod,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .none: return "NONE"
            case .vod: return "VOD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaylistType(rawValue: rawValue) ?? PlaylistType.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PresetSpeke20Audio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetAudio1
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Audio] {
            return [
                .presetAudio1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetAudio1: return "PRESET-AUDIO-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Audio(rawValue: rawValue) ?? PresetSpeke20Audio.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum PresetSpeke20Video: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case presetVideo1
        case sdkUnknown(Swift.String)

        public static var allCases: [PresetSpeke20Video] {
            return [
                .presetVideo1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .presetVideo1: return "PRESET-VIDEO-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresetSpeke20Video(rawValue: rawValue) ?? PresetSpeke20Video.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum Profile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hbbtv15
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Profile] {
            return [
                .hbbtv15,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hbbtv15: return "HBBTV_1_5"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Profile(rawValue: rawValue) ?? Profile.sdkUnknown(rawValue)
        }
    }
}

extension RotateChannelCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateChannelCredentialsInput(id: \(Swift.String(describing: id)))"}
}

extension RotateChannelCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RotateChannelCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateChannelCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateChannelCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateChannelCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateChannelCredentialsOutputError>
}

public struct RotateChannelCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateChannelCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateChannelCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateChannelCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateChannelCredentialsOutputError>
}

public struct RotateChannelCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateChannelCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RotateChannelCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())/credentials"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RotateChannelCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RotateChannelCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateChannelCredentialsOutputError>
}

@available(*, deprecated)
public struct RotateChannelCredentialsInput: Swift.Equatable {
    /// The ID of the channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RotateChannelCredentialsInputBody: Swift.Equatable {
}

extension RotateChannelCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RotateChannelCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateChannelCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateChannelCredentialsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateChannelCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateChannelCredentialsOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension RotateChannelCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateChannelCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

@available(*, deprecated)
public struct RotateChannelCredentialsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateChannelCredentialsOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension RotateChannelCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RotateIngestEndpointCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateIngestEndpointCredentialsInput(id: \(Swift.String(describing: id)), ingestEndpointId: \(Swift.String(describing: ingestEndpointId)))"}
}

extension RotateIngestEndpointCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RotateIngestEndpointCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateIngestEndpointCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateIngestEndpointCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateIngestEndpointCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateIngestEndpointCredentialsOutputError>
}

public struct RotateIngestEndpointCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateIngestEndpointCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RotateIngestEndpointCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RotateIngestEndpointCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateIngestEndpointCredentialsOutputError>
}

public struct RotateIngestEndpointCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RotateIngestEndpointCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RotateIngestEndpointCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        guard let ingestEndpointId = input.ingestEndpointId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("ingestEndpointId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())/ingest_endpoints/\(ingestEndpointId.urlPercentEncoding())/credentials"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RotateIngestEndpointCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RotateIngestEndpointCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RotateIngestEndpointCredentialsOutputError>
}

public struct RotateIngestEndpointCredentialsInput: Swift.Equatable {
    /// The ID of the channel the IngestEndpoint is on.
    /// This member is required.
    public var id: Swift.String?
    /// The id of the IngestEndpoint whose credentials should be rotated
    /// This member is required.
    public var ingestEndpointId: Swift.String?

    public init (
        id: Swift.String? = nil,
        ingestEndpointId: Swift.String? = nil
    )
    {
        self.id = id
        self.ingestEndpointId = ingestEndpointId
    }
}

struct RotateIngestEndpointCredentialsInputBody: Swift.Equatable {
}

extension RotateIngestEndpointCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RotateIngestEndpointCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RotateIngestEndpointCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RotateIngestEndpointCredentialsOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RotateIngestEndpointCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RotateIngestEndpointCredentialsOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension RotateIngestEndpointCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RotateIngestEndpointCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct RotateIngestEndpointCredentialsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct RotateIngestEndpointCredentialsOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension RotateIngestEndpointCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaPackageClientTypes.S3Destination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case manifestKey = "manifestKey"
        case roleArn = "roleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let manifestKey = manifestKey {
            try encodeContainer.encode(manifestKey, forKey: .manifestKey)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let manifestKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestKey)
        manifestKey = manifestKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension MediaPackageClientTypes.S3Destination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Destination(bucketName: \(Swift.String(describing: bucketName)), manifestKey: \(Swift.String(describing: manifestKey)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension MediaPackageClientTypes {
    /// Configuration parameters for where in an S3 bucket to place the harvested content
    public struct S3Destination: Swift.Equatable {
        /// The name of an S3 bucket within which harvested content will be exported
        /// This member is required.
        public var bucketName: Swift.String?
        /// The key in the specified S3 bucket where the harvested top-level manifest will be placed.
        /// This member is required.
        public var manifestKey: Swift.String?
        /// The IAM role used to write to the specified S3 bucket
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            manifestKey: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.manifestKey = manifestKey
            self.roleArn = roleArn
        }
    }

}

extension MediaPackageClientTypes {
    public enum SegmentTemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case numberWithDuration
        case numberWithTimeline
        case timeWithTimeline
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentTemplateFormat] {
            return [
                .numberWithDuration,
                .numberWithTimeline,
                .timeWithTimeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .numberWithDuration: return "NUMBER_WITH_DURATION"
            case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
            case .timeWithTimeline: return "TIME_WITH_TIMELINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SegmentTemplateFormat(rawValue: rawValue) ?? SegmentTemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaPackageClientTypes.SpekeKeyProvider: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "certificateArn"
        case encryptionContractConfiguration = "encryptionContractConfiguration"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case systemIds = "systemIds"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let encryptionContractConfiguration = encryptionContractConfiguration {
            try encodeContainer.encode(encryptionContractConfiguration, forKey: .encryptionContractConfiguration)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let systemIds = systemIds {
            var systemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemIds)
            for __listof__string0 in systemIds {
                try systemIdsContainer.encode(__listof__string0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let encryptionContractConfigurationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EncryptionContractConfiguration.self, forKey: .encryptionContractConfiguration)
        encryptionContractConfiguration = encryptionContractConfigurationDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let systemIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .systemIds)
        var systemIdsDecoded0:[Swift.String]? = nil
        if let systemIdsContainer = systemIdsContainer {
            systemIdsDecoded0 = [Swift.String]()
            for string0 in systemIdsContainer {
                if let string0 = string0 {
                    systemIdsDecoded0?.append(string0)
                }
            }
        }
        systemIds = systemIdsDecoded0
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaPackageClientTypes.SpekeKeyProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpekeKeyProvider(certificateArn: \(Swift.String(describing: certificateArn)), encryptionContractConfiguration: \(Swift.String(describing: encryptionContractConfiguration)), resourceId: \(Swift.String(describing: resourceId)), roleArn: \(Swift.String(describing: roleArn)), systemIds: \(Swift.String(describing: systemIds)), url: \(Swift.String(describing: url)))"}
}

extension MediaPackageClientTypes {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public struct SpekeKeyProvider: Swift.Equatable {
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
        /// that MediaPackage will use for enforcing secure end-to-end data
        /// transfer with the key provider service.
        public var certificateArn: Swift.String?
        /// Use encryptionContractConfiguration to configure one or more content encryption keys for your endpoints that use SPEKE 2.0.
        /// The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream.
        /// To configure the encryption contract, specify which audio and video encryption presets to use.
        /// Note the following considerations when using encryptionContractConfiguration:
        /// encryptionContractConfiguration can be used for DASH or CMAF endpoints that use SPEKE 2.0. SPEKE 2.0 relies on the CPIX 2.3 specification.
        /// You must disable key rotation for this endpoint by setting keyRotationIntervalSeconds to 0.
        public var encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration?
        /// The resource ID to include in key requests.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The system IDs to include in key requests.
        /// This member is required.
        public var systemIds: [Swift.String]?
        /// The URL of the external key provider service.
        /// This member is required.
        public var url: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            encryptionContractConfiguration: MediaPackageClientTypes.EncryptionContractConfiguration? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            systemIds: [Swift.String]? = nil,
            url: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }
    }

}

extension MediaPackageClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum StreamOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case original
        case videoBitrateAscending
        case videoBitrateDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamOrder] {
            return [
                .original,
                .videoBitrateAscending,
                .videoBitrateDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
            case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamOrder(rawValue: rawValue) ?? StreamOrder.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes.StreamSelection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
        case minVideoBitsPerSecond = "minVideoBitsPerSecond"
        case streamOrder = "streamOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVideoBitsPerSecond = maxVideoBitsPerSecond {
            try encodeContainer.encode(maxVideoBitsPerSecond, forKey: .maxVideoBitsPerSecond)
        }
        if let minVideoBitsPerSecond = minVideoBitsPerSecond {
            try encodeContainer.encode(minVideoBitsPerSecond, forKey: .minVideoBitsPerSecond)
        }
        if let streamOrder = streamOrder {
            try encodeContainer.encode(streamOrder.rawValue, forKey: .streamOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVideoBitsPerSecond)
        maxVideoBitsPerSecond = maxVideoBitsPerSecondDecoded
        let minVideoBitsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minVideoBitsPerSecond)
        minVideoBitsPerSecond = minVideoBitsPerSecondDecoded
        let streamOrderDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.StreamOrder.self, forKey: .streamOrder)
        streamOrder = streamOrderDecoded
    }
}

extension MediaPackageClientTypes.StreamSelection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamSelection(maxVideoBitsPerSecond: \(Swift.String(describing: maxVideoBitsPerSecond)), minVideoBitsPerSecond: \(Swift.String(describing: minVideoBitsPerSecond)), streamOrder: \(Swift.String(describing: streamOrder)))"}
}

extension MediaPackageClientTypes {
    /// A StreamSelection configuration.
    public struct StreamSelection: Swift.Equatable {
        /// The maximum video bitrate (bps) to include in output.
        public var maxVideoBitsPerSecond: Swift.Int?
        /// The minimum video bitrate (bps) to include in output.
        public var minVideoBitsPerSecond: Swift.Int?
        /// A directive that determines the order of streams in the output.
        public var streamOrder: MediaPackageClientTypes.StreamOrder?

        public init (
            maxVideoBitsPerSecond: Swift.Int? = nil,
            minVideoBitsPerSecond: Swift.Int? = nil,
            streamOrder: MediaPackageClientTypes.StreamOrder? = nil
        )
        {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnprocessableEntityException(message: \(Swift.String(describing: message)))"}
}

extension UnprocessableEntityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key(s) of tag to be deleted
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/channels/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

/// Configuration parameters used to update the Channel.
public struct UpdateChannelInput: Swift.Equatable {
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// The ID of the Channel to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let description: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), egressAccessLogs: \(Swift.String(describing: egressAccessLogs)), hlsIngest: \(Swift.String(describing: hlsIngest)), id: \(Swift.String(describing: id)), ingressAccessLogs: \(Swift.String(describing: ingressAccessLogs)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.egressAccessLogs = output.egressAccessLogs
            self.hlsIngest = output.hlsIngest
            self.id = output.id
            self.ingressAccessLogs = output.ingressAccessLogs
            self.tags = output.tags
        } else {
            self.arn = nil
            self.description = nil
            self.egressAccessLogs = nil
            self.hlsIngest = nil
            self.id = nil
            self.ingressAccessLogs = nil
            self.tags = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the Channel.
    public var arn: Swift.String?
    /// A short text description of the Channel.
    public var description: Swift.String?
    /// Configure egress access logging.
    public var egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    /// An HTTP Live Streaming (HLS) ingest resource configuration.
    public var hlsIngest: MediaPackageClientTypes.HlsIngest?
    /// The ID of the Channel.
    public var id: Swift.String?
    /// Configure ingress access logging.
    public var ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs? = nil,
        hlsIngest: MediaPackageClientTypes.HlsIngest? = nil,
        id: Swift.String? = nil,
        ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.egressAccessLogs = egressAccessLogs
        self.hlsIngest = hlsIngest
        self.id = id
        self.ingressAccessLogs = ingressAccessLogs
        self.tags = tags
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let description: Swift.String?
    public let egressAccessLogs: MediaPackageClientTypes.EgressAccessLogs?
    public let hlsIngest: MediaPackageClientTypes.HlsIngest?
    public let id: Swift.String?
    public let ingressAccessLogs: MediaPackageClientTypes.IngressAccessLogs?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case egressAccessLogs = "egressAccessLogs"
        case hlsIngest = "hlsIngest"
        case id = "id"
        case ingressAccessLogs = "ingressAccessLogs"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let hlsIngestDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsIngest.self, forKey: .hlsIngest)
        hlsIngest = hlsIngestDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ingressAccessLogsDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.IngressAccessLogs.self, forKey: .ingressAccessLogs)
        ingressAccessLogs = ingressAccessLogsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateOriginEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginEndpointOutputError>
}

extension UpdateOriginEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginEndpointInput(authorization: \(Swift.String(describing: authorization)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension UpdateOriginEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let origination = origination {
            try encodeContainer.encode(origination.rawValue, forKey: .origination)
        }
        if let startoverWindowSeconds = startoverWindowSeconds {
            try encodeContainer.encode(startoverWindowSeconds, forKey: .startoverWindowSeconds)
        }
        if let timeDelaySeconds = timeDelaySeconds {
            try encodeContainer.encode(timeDelaySeconds, forKey: .timeDelaySeconds)
        }
        if let whitelist = whitelist {
            var whitelistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .whitelist)
            for __listof__string0 in whitelist {
                try whitelistContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateOriginEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginEndpointOutputError>
}

public struct UpdateOriginEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginEndpointOutputError>
}

public struct UpdateOriginEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateOriginEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/origin_endpoints/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateOriginEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginEndpointOutputError>
}

/// Configuration parameters used to update an existing OriginEndpoint.
public struct UpdateOriginEndpointInput: Swift.Equatable {
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint to update.
    /// This member is required.
    public var id: Swift.String?
    /// A short string that will be appended to the end of the Endpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (in seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// Amount of delay (in seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init (
        authorization: MediaPackageClientTypes.Authorization? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.authorization = authorization
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.timeDelaySeconds = timeDelaySeconds
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointInputBody: Swift.Equatable {
    public let authorization: MediaPackageClientTypes.Authorization?
    public let cmafPackage: MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters?
    public let dashPackage: MediaPackageClientTypes.DashPackage?
    public let description: Swift.String?
    public let hlsPackage: MediaPackageClientTypes.HlsPackage?
    public let manifestName: Swift.String?
    public let mssPackage: MediaPackageClientTypes.MssPackage?
    public let origination: MediaPackageClientTypes.Origination?
    public let startoverWindowSeconds: Swift.Int?
    public let timeDelaySeconds: Swift.Int?
    public let whitelist: [Swift.String]?
}

extension UpdateOriginEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization = "authorization"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case timeDelaySeconds = "timeDelaySeconds"
        case whitelist = "whitelist"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackageCreateOrUpdateParameters.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension UpdateOriginEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOriginEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginEndpointOutputResponse(arn: \(Swift.String(describing: arn)), authorization: \(Swift.String(describing: authorization)), channelId: \(Swift.String(describing: channelId)), cmafPackage: \(Swift.String(describing: cmafPackage)), dashPackage: \(Swift.String(describing: dashPackage)), description: \(Swift.String(describing: description)), hlsPackage: \(Swift.String(describing: hlsPackage)), id: \(Swift.String(describing: id)), manifestName: \(Swift.String(describing: manifestName)), mssPackage: \(Swift.String(describing: mssPackage)), origination: \(Swift.String(describing: origination)), startoverWindowSeconds: \(Swift.String(describing: startoverWindowSeconds)), tags: \(Swift.String(describing: tags)), timeDelaySeconds: \(Swift.String(describing: timeDelaySeconds)), url: \(Swift.String(describing: url)), whitelist: \(Swift.String(describing: whitelist)))"}
}

extension UpdateOriginEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateOriginEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authorization = output.authorization
            self.channelId = output.channelId
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.description = output.description
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.manifestName = output.manifestName
            self.mssPackage = output.mssPackage
            self.origination = output.origination
            self.startoverWindowSeconds = output.startoverWindowSeconds
            self.tags = output.tags
            self.timeDelaySeconds = output.timeDelaySeconds
            self.url = output.url
            self.whitelist = output.whitelist
        } else {
            self.arn = nil
            self.authorization = nil
            self.channelId = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.description = nil
            self.hlsPackage = nil
            self.id = nil
            self.manifestName = nil
            self.mssPackage = nil
            self.origination = nil
            self.startoverWindowSeconds = nil
            self.tags = nil
            self.timeDelaySeconds = nil
            self.url = nil
            self.whitelist = nil
        }
    }
}

public struct UpdateOriginEndpointOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
    public var arn: Swift.String?
    /// CDN Authorization credentials
    public var authorization: MediaPackageClientTypes.Authorization?
    /// The ID of the Channel the OriginEndpoint is associated with.
    public var channelId: Swift.String?
    /// A Common Media Application Format (CMAF) packaging configuration.
    public var cmafPackage: MediaPackageClientTypes.CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public var dashPackage: MediaPackageClientTypes.DashPackage?
    /// A short text description of the OriginEndpoint.
    public var description: Swift.String?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public var hlsPackage: MediaPackageClientTypes.HlsPackage?
    /// The ID of the OriginEndpoint.
    public var id: Swift.String?
    /// A short string appended to the end of the OriginEndpoint URL.
    public var manifestName: Swift.String?
    /// A Microsoft Smooth Streaming (MSS) packaging configuration.
    public var mssPackage: MediaPackageClientTypes.MssPackage?
    /// Control whether origination of video is allowed for this OriginEndpoint. If set to ALLOW, the OriginEndpoint
    /// may by requested, pursuant to any other form of access control. If set to DENY, the OriginEndpoint may not be
    /// requested. This can be helpful for Live to VOD harvesting, or for temporarily disabling origination
    public var origination: MediaPackageClientTypes.Origination?
    /// Maximum duration (seconds) of content to retain for startover playback.
    /// If not specified, startover playback will be disabled for the OriginEndpoint.
    public var startoverWindowSeconds: Swift.Int?
    /// A collection of tags associated with a resource
    public var tags: [Swift.String:Swift.String]?
    /// Amount of delay (seconds) to enforce on the playback of live content.
    /// If not specified, there will be no time delay in effect for the OriginEndpoint.
    public var timeDelaySeconds: Swift.Int?
    /// The URL of the packaged OriginEndpoint for consumption.
    public var url: Swift.String?
    /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
    public var whitelist: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authorization: MediaPackageClientTypes.Authorization? = nil,
        channelId: Swift.String? = nil,
        cmafPackage: MediaPackageClientTypes.CmafPackage? = nil,
        dashPackage: MediaPackageClientTypes.DashPackage? = nil,
        description: Swift.String? = nil,
        hlsPackage: MediaPackageClientTypes.HlsPackage? = nil,
        id: Swift.String? = nil,
        manifestName: Swift.String? = nil,
        mssPackage: MediaPackageClientTypes.MssPackage? = nil,
        origination: MediaPackageClientTypes.Origination? = nil,
        startoverWindowSeconds: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timeDelaySeconds: Swift.Int? = nil,
        url: Swift.String? = nil,
        whitelist: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.channelId = channelId
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.description = description
        self.hlsPackage = hlsPackage
        self.id = id
        self.manifestName = manifestName
        self.mssPackage = mssPackage
        self.origination = origination
        self.startoverWindowSeconds = startoverWindowSeconds
        self.tags = tags
        self.timeDelaySeconds = timeDelaySeconds
        self.url = url
        self.whitelist = whitelist
    }
}

struct UpdateOriginEndpointOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let authorization: MediaPackageClientTypes.Authorization?
    public let channelId: Swift.String?
    public let cmafPackage: MediaPackageClientTypes.CmafPackage?
    public let dashPackage: MediaPackageClientTypes.DashPackage?
    public let description: Swift.String?
    public let hlsPackage: MediaPackageClientTypes.HlsPackage?
    public let id: Swift.String?
    public let manifestName: Swift.String?
    public let mssPackage: MediaPackageClientTypes.MssPackage?
    public let origination: MediaPackageClientTypes.Origination?
    public let startoverWindowSeconds: Swift.Int?
    public let tags: [Swift.String:Swift.String]?
    public let timeDelaySeconds: Swift.Int?
    public let url: Swift.String?
    public let whitelist: [Swift.String]?
}

extension UpdateOriginEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case channelId = "channelId"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case description = "description"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case manifestName = "manifestName"
        case mssPackage = "mssPackage"
        case origination = "origination"
        case startoverWindowSeconds = "startoverWindowSeconds"
        case tags = "tags"
        case timeDelaySeconds = "timeDelaySeconds"
        case url = "url"
        case whitelist = "whitelist"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let originationDecoded = try containerValues.decodeIfPresent(MediaPackageClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
        let startoverWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startoverWindowSeconds)
        startoverWindowSeconds = startoverWindowSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let timeDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeDelaySeconds)
        timeDelaySeconds = timeDelaySecondsDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let whitelistContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .whitelist)
        var whitelistDecoded0:[Swift.String]? = nil
        if let whitelistContainer = whitelistContainer {
            whitelistDecoded0 = [Swift.String]()
            for string0 in whitelistContainer {
                if let string0 = string0 {
                    whitelistDecoded0?.append(string0)
                }
            }
        }
        whitelist = whitelistDecoded0
    }
}

extension MediaPackageClientTypes {
    public enum UtcTiming: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpHead
        case httpIso
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [UtcTiming] {
            return [
                .httpHead,
                .httpIso,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpHead: return "HTTP-HEAD"
            case .httpIso: return "HTTP-ISO"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UtcTiming(rawValue: rawValue) ?? UtcTiming.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum __AdTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `break`
        case distributorAdvertisement
        case distributorOverlayPlacementOpportunity
        case distributorPlacementOpportunity
        case providerAdvertisement
        case providerOverlayPlacementOpportunity
        case providerPlacementOpportunity
        case spliceInsert
        case sdkUnknown(Swift.String)

        public static var allCases: [__AdTriggersElement] {
            return [
                .break,
                .distributorAdvertisement,
                .distributorOverlayPlacementOpportunity,
                .distributorPlacementOpportunity,
                .providerAdvertisement,
                .providerOverlayPlacementOpportunity,
                .providerPlacementOpportunity,
                .spliceInsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .break: return "BREAK"
            case .distributorAdvertisement: return "DISTRIBUTOR_ADVERTISEMENT"
            case .distributorOverlayPlacementOpportunity: return "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .distributorPlacementOpportunity: return "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
            case .providerAdvertisement: return "PROVIDER_ADVERTISEMENT"
            case .providerOverlayPlacementOpportunity: return "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
            case .providerPlacementOpportunity: return "PROVIDER_PLACEMENT_OPPORTUNITY"
            case .spliceInsert: return "SPLICE_INSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = __AdTriggersElement(rawValue: rawValue) ?? __AdTriggersElement.sdkUnknown(rawValue)
        }
    }
}

extension MediaPackageClientTypes {
    public enum __PeriodTriggersElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ads
        case sdkUnknown(Swift.String)

        public static var allCases: [__PeriodTriggersElement] {
            return [
                .ads,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ADS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = __PeriodTriggersElement(rawValue: rawValue) ?? __PeriodTriggersElement.sdkUnknown(rawValue)
        }
    }
}
