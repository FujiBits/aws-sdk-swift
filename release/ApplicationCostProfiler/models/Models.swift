// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteReportDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReportDefinitionInput(reportId: \(Swift.String(describing: reportId)))"}
}

extension DeleteReportDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteReportDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportDefinitionOutputError>
}

public struct DeleteReportDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportDefinitionOutputError>
}

public struct DeleteReportDefinitionInput: Swift.Equatable {
    /// <p>Required. ID of the report to delete.</p>
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionInputBody: Swift.Equatable {
}

extension DeleteReportDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReportDefinitionOutputResponse(reportId: \(Swift.String(describing: reportId)))"}
}

extension DeleteReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct DeleteReportDefinitionOutputResponse: Swift.Equatable {
    /// <p>ID of the report that was deleted.</p>
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionOutputResponseBody: Swift.Equatable {
    public let reportId: Swift.String?
}

extension DeleteReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetReportDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReportDefinitionInput(reportId: \(Swift.String(describing: reportId)))"}
}

extension GetReportDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetReportDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReportDefinitionOutputError>
}

public struct GetReportDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReportDefinitionOutputError>
}

public struct GetReportDefinitionInput: Swift.Equatable {
    /// <p>ID of the report to retrieve.</p>
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetReportDefinitionInputBody: Swift.Equatable {
}

extension GetReportDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReportDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReportDefinitionOutputResponse(createdAt: \(Swift.String(describing: createdAt)), destinationS3Location: \(Swift.String(describing: destinationS3Location)), format: \(Swift.String(describing: format)), lastUpdated: \(Swift.String(describing: lastUpdated)), reportDescription: \(Swift.String(describing: reportDescription)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportId: \(Swift.String(describing: reportId)))"}
}

extension GetReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.destinationS3Location = output.destinationS3Location
            self.format = output.format
            self.lastUpdated = output.lastUpdated
            self.reportDescription = output.reportDescription
            self.reportFrequency = output.reportFrequency
            self.reportId = output.reportId
        } else {
            self.createdAt = nil
            self.destinationS3Location = nil
            self.format = nil
            self.lastUpdated = nil
            self.reportDescription = nil
            self.reportFrequency = nil
            self.reportId = nil
        }
    }
}

public struct GetReportDefinitionOutputResponse: Swift.Equatable {
    /// <p>Timestamp (milliseconds) when this report definition was created.</p>
    public let createdAt: ClientRuntime.Date?
    /// <p>Amazon Simple Storage Service (Amazon S3) location where the report is uploaded.</p>
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// <p>Format of the generated report.</p>
    public let format: ApplicationCostProfilerClientTypes.Format?
    /// <p>Timestamp (milliseconds) when this report definition was last updated.</p>
    public let lastUpdated: ClientRuntime.Date?
    /// <p>Description of the report.</p>
    public let reportDescription: Swift.String?
    /// <p>Cadence used to generate the report.</p>
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// <p>ID of the report retrieved.</p>
    public let reportId: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        lastUpdated: ClientRuntime.Date? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.lastUpdated = lastUpdated
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct GetReportDefinitionOutputResponseBody: Swift.Equatable {
    public let reportId: Swift.String?
    public let reportDescription: Swift.String?
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    public let format: ApplicationCostProfilerClientTypes.Format?
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    public let createdAt: ClientRuntime.Date?
    public let lastUpdated: ClientRuntime.Date?
}

extension GetReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdated
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

public struct ImportApplicationUsageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportApplicationUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportApplicationUsageOutputError>
}

extension ImportApplicationUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportApplicationUsageInput(sourceS3Location: \(Swift.String(describing: sourceS3Location)))"}
}

extension ImportApplicationUsageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3Location = sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
    }
}

public struct ImportApplicationUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportApplicationUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportApplicationUsageOutputError>
}

public struct ImportApplicationUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportApplicationUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportApplicationUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportApplicationUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportApplicationUsageOutputError>
}

public struct ImportApplicationUsageInput: Swift.Equatable {
    /// <p>Amazon S3 location to import application usage data from.</p>
    public let sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?

    public init (
        sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location? = nil
    )
    {
        self.sourceS3Location = sourceS3Location
    }
}

struct ImportApplicationUsageInputBody: Swift.Equatable {
    public let sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?
}

extension ImportApplicationUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.SourceS3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
    }
}

extension ImportApplicationUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApplicationUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApplicationUsageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApplicationUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportApplicationUsageOutputResponse(importId: \(Swift.String(describing: importId)))"}
}

extension ImportApplicationUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportApplicationUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importId = output.importId
        } else {
            self.importId = nil
        }
    }
}

public struct ImportApplicationUsageOutputResponse: Swift.Equatable {
    /// <p>ID of the import request.</p>
    public let importId: Swift.String?

    public init (
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct ImportApplicationUsageOutputResponseBody: Swift.Equatable {
    public let importId: Swift.String?
}

extension ImportApplicationUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred. Retry your request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListReportDefinitionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportDefinitionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReportDefinitionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListReportDefinitionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportDefinitionsOutputError>
}

public struct ListReportDefinitionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportDefinitionsOutputError>
}

public struct ListReportDefinitionsInput: Swift.Equatable {
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Swift.Int?
    /// <p>The token value from a previous call to access the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportDefinitionsInputBody: Swift.Equatable {
}

extension ListReportDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportDefinitionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportDefinitionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), reportDefinitions: \(Swift.String(describing: reportDefinitions)))"}
}

extension ListReportDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReportDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

public struct ListReportDefinitionsOutputResponse: Swift.Equatable {
    /// <p>The value of the next token, if it exists. Null if there are no more results.</p>
    public let nextToken: Swift.String?
    /// <p>The retrieved reports.</p>
    public let reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?

    public init (
        nextToken: Swift.String? = nil,
        reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct ListReportDefinitionsOutputResponseBody: Swift.Equatable {
    public let reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?
    public let nextToken: Swift.String?
}

extension ListReportDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportDefinitions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([ApplicationCostProfilerClientTypes.ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [ApplicationCostProfilerClientTypes.ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutReportDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReportDefinitionOutputError>
}

extension PutReportDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutReportDefinitionInput(destinationS3Location: \(Swift.String(describing: destinationS3Location)), format: \(Swift.String(describing: format)), reportDescription: \(Swift.String(describing: reportDescription)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportId: \(Swift.String(describing: reportId)))"}
}

extension PutReportDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

public struct PutReportDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReportDefinitionOutputError>
}

public struct PutReportDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReportDefinitionOutputError>
}

public struct PutReportDefinitionInput: Swift.Equatable {
    /// <p>Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the
    ///       report.</p>
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// <p>Required. The format to use for the generated report.</p>
    public let format: ApplicationCostProfilerClientTypes.Format?
    /// <p>Required. Description of the report.</p>
    public let reportDescription: Swift.String?
    /// <p>Required. The cadence to generate the report.</p>
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// <p>Required. ID of the report. You can choose any valid string matching the pattern for the
    ///       ID.</p>
    public let reportId: Swift.String?

    public init (
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct PutReportDefinitionInputBody: Swift.Equatable {
    public let reportId: Swift.String?
    public let reportDescription: Swift.String?
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    public let format: ApplicationCostProfilerClientTypes.Format?
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension PutReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension PutReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReportDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutReportDefinitionOutputResponse(reportId: \(Swift.String(describing: reportId)))"}
}

extension PutReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct PutReportDefinitionOutputResponse: Swift.Equatable {
    /// <p>ID of the report.</p>
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct PutReportDefinitionOutputResponseBody: Swift.Equatable {
    public let reportId: Swift.String?
}

extension PutReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ApplicationCostProfilerClientTypes.ReportDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdatedAt
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ApplicationCostProfilerClientTypes.ReportDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportDefinition(createdAt: \(Swift.String(describing: createdAt)), destinationS3Location: \(Swift.String(describing: destinationS3Location)), format: \(Swift.String(describing: format)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), reportDescription: \(Swift.String(describing: reportDescription)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportId: \(Swift.String(describing: reportId)))"}
}

extension ApplicationCostProfilerClientTypes {
    /// <p>The configuration of a report in AWS Application Cost Profiler.</p>
    public struct ReportDefinition: Swift.Equatable {
        /// <p>Timestamp (milliseconds) when this report definition was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The location in Amazon Simple Storage Service (Amazon S3) the reports should be saved to.</p>
        public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
        /// <p>The format used for the generated reports.</p>
        public let format: ApplicationCostProfilerClientTypes.Format?
        /// <p>Timestamp (milliseconds) when this report definition was last updated.</p>
        public let lastUpdatedAt: ClientRuntime.Date?
        /// <p>Description of the report</p>
        public let reportDescription: Swift.String?
        /// <p>The cadence at which the report is generated.</p>
        public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
        /// <p>The ID of the report.</p>
        public let reportId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
            format: ApplicationCostProfilerClientTypes.Format? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            reportDescription: Swift.String? = nil,
            reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
            reportId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.destinationS3Location = destinationS3Location
            self.format = format
            self.lastUpdatedAt = lastUpdatedAt
            self.reportDescription = reportDescription
            self.reportFrequency = reportFrequency
            self.reportId = reportId
        }
    }

}

extension ApplicationCostProfilerClientTypes {
    public enum ReportFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case daily
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequency] {
            return [
                .all,
                .daily,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFrequency(rawValue: rawValue) ?? ReportFrequency.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum S3BucketRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afSouth1
        case apEast1
        case euSouth1
        case meSouth1
        case sdkUnknown(Swift.String)

        public static var allCases: [S3BucketRegion] {
            return [
                .afSouth1,
                .apEast1,
                .euSouth1,
                .meSouth1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .euSouth1: return "eu-south-1"
            case .meSouth1: return "me-south-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3BucketRegion(rawValue: rawValue) ?? S3BucketRegion.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension ApplicationCostProfilerClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucket: \(Swift.String(describing: bucket)), prefix: \(Swift.String(describing: prefix)))"}
}

extension ApplicationCostProfilerClientTypes {
    /// <p>Represents the Amazon Simple Storage Service (Amazon S3) location where AWS Application Cost Profiler
    ///       reports are generated and then written to.</p>
    public struct S3Location: Swift.Equatable {
        /// <p>Name of the S3 bucket.</p>
        public let bucket: Swift.String?
        /// <p>Prefix for the location to write to.</p>
        public let prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.prefix = prefix
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request exceeds one or more of the service quotas.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationCostProfilerClientTypes.SourceS3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let region = region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3BucketRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension ApplicationCostProfilerClientTypes.SourceS3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceS3Location(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)), region: \(Swift.String(describing: region)))"}
}

extension ApplicationCostProfilerClientTypes {
    /// <p>Represents the Amazon Simple Storage Service (Amazon S3) location where usage data is read
    ///       from.</p>
    public struct SourceS3Location: Swift.Equatable {
        /// <p>Name of the bucket.</p>
        public let bucket: Swift.String?
        /// <p>Key of the object.</p>
        public let key: Swift.String?
        /// <p>Region of the bucket. Only required for Regions that are disabled by default.
        ///         For more infomration about Regions that are disabled by default, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable">
        ///           Enabling a Region</a> in the <i>AWS General Reference guide</i>.</p>
        public let region: ApplicationCostProfilerClientTypes.S3BucketRegion?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            region: ApplicationCostProfilerClientTypes.S3BucketRegion? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.region = region
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calls to AWS Application Cost Profiler API are throttled. The request was denied.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateReportDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportDefinitionOutputError>
}

extension UpdateReportDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReportDefinitionInput(destinationS3Location: \(Swift.String(describing: destinationS3Location)), format: \(Swift.String(describing: format)), reportDescription: \(Swift.String(describing: reportDescription)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportId: \(Swift.String(describing: reportId)))"}
}

extension UpdateReportDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
    }
}

public struct UpdateReportDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportDefinitionOutputError>
}

public struct UpdateReportDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportDefinitionOutputError>
}

public struct UpdateReportDefinitionInput: Swift.Equatable {
    /// <p>Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the
    ///       report.</p>
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// <p>Required. The format to use for the generated report.</p>
    public let format: ApplicationCostProfilerClientTypes.Format?
    /// <p>Required. Description of the report.</p>
    public let reportDescription: Swift.String?
    /// <p>Required. The cadence to generate the report.</p>
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// <p>Required. ID of the report to update.</p>
    public let reportId: Swift.String?

    public init (
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionInputBody: Swift.Equatable {
    public let reportDescription: Swift.String?
    public let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    public let format: ApplicationCostProfilerClientTypes.Format?
    public let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension UpdateReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension UpdateReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReportDefinitionOutputResponse(reportId: \(Swift.String(describing: reportId)))"}
}

extension UpdateReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct UpdateReportDefinitionOutputResponse: Swift.Equatable {
    /// <p>ID of the report.</p>
    public let reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionOutputResponseBody: Swift.Equatable {
    public let reportId: Swift.String?
}

extension UpdateReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints for the API.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
