// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddTagsToStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToStreamOutputError>
}

extension AddTagsToStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToStreamInput(streamName: \(Swift.String(describing: streamName)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AddTagsToStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToStreamOutputError>
}

public struct AddTagsToStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToStreamOutputError>
}

/// Represents the input for AddTagsToStream.
public struct AddTagsToStreamInput: Swift.Equatable {
    /// The name of the stream.
    /// This member is required.
    public let streamName: Swift.String?
    /// A set of up to 10 key-value pairs to use to create the tags.
    /// This member is required.
    public let tags: [Swift.String:Swift.String]?

    public init (
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.streamName = streamName
        self.tags = tags
    }
}

struct AddTagsToStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension AddTagsToStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToStreamOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToStreamOutputResponse()"}
}

extension AddTagsToStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToStreamOutputResponseBody: Swift.Equatable {
}

extension AddTagsToStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KinesisClientTypes.ChildShard: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashKeyRange = "HashKeyRange"
        case parentShards = "ParentShards"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyRange = hashKeyRange {
            try encodeContainer.encode(hashKeyRange, forKey: .hashKeyRange)
        }
        if let parentShards = parentShards {
            var parentShardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentShards)
            for shardidlist0 in parentShards {
                try parentShardsContainer.encode(shardidlist0)
            }
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let parentShardsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentShards)
        var parentShardsDecoded0:[Swift.String]? = nil
        if let parentShardsContainer = parentShardsContainer {
            parentShardsDecoded0 = [Swift.String]()
            for string0 in parentShardsContainer {
                if let string0 = string0 {
                    parentShardsDecoded0?.append(string0)
                }
            }
        }
        parentShards = parentShardsDecoded0
        let hashKeyRangeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.HashKeyRange.self, forKey: .hashKeyRange)
        hashKeyRange = hashKeyRangeDecoded
    }
}

extension KinesisClientTypes.ChildShard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChildShard(hashKeyRange: \(Swift.String(describing: hashKeyRange)), parentShards: \(Swift.String(describing: parentShards)), shardId: \(Swift.String(describing: shardId)))"}
}

extension KinesisClientTypes {
    public struct ChildShard: Swift.Equatable {
        /// The range of possible hash key values for the shard, which is a set of ordered
        ///             contiguous positive integers.
        /// This member is required.
        public let hashKeyRange: KinesisClientTypes.HashKeyRange?
        /// This member is required.
        public let parentShards: [Swift.String]?
        /// This member is required.
        public let shardId: Swift.String?

        public init (
            hashKeyRange: KinesisClientTypes.HashKeyRange? = nil,
            parentShards: [Swift.String]? = nil,
            shardId: Swift.String? = nil
        )
        {
            self.hashKeyRange = hashKeyRange
            self.parentShards = parentShards
            self.shardId = shardId
        }
    }

}

extension KinesisClientTypes.Consumer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerCreationTimestamp = "ConsumerCreationTimestamp"
        case consumerName = "ConsumerName"
        case consumerStatus = "ConsumerStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerCreationTimestamp = consumerCreationTimestamp {
            try encodeContainer.encode(consumerCreationTimestamp.timeIntervalSince1970, forKey: .consumerCreationTimestamp)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let consumerStatus = consumerStatus {
            try encodeContainer.encode(consumerStatus.rawValue, forKey: .consumerStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let consumerStatusDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ConsumerStatus.self, forKey: .consumerStatus)
        consumerStatus = consumerStatusDecoded
        let consumerCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .consumerCreationTimestamp)
        consumerCreationTimestamp = consumerCreationTimestampDecoded
    }
}

extension KinesisClientTypes.Consumer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Consumer(consumerARN: \(Swift.String(describing: consumerARN)), consumerCreationTimestamp: \(Swift.String(describing: consumerCreationTimestamp)), consumerName: \(Swift.String(describing: consumerName)), consumerStatus: \(Swift.String(describing: consumerStatus)))"}
}

extension KinesisClientTypes {
    /// An object that represents the details of the consumer you registered. This type of
    ///             object is returned by RegisterStreamConsumer.
    public struct Consumer: Swift.Equatable {
        /// When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
        ///             this ARN to be able to call SubscribeToShard.
        ///         If you delete a consumer and then create a new one with the same name, it won't have
        ///             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
        ///             important to keep in mind if you have IAM policies that reference consumer ARNs.
        /// This member is required.
        public let consumerARN: Swift.String?
        ///
        /// This member is required.
        public let consumerCreationTimestamp: ClientRuntime.Date?
        /// The name of the consumer is something you choose when you register the
        ///             consumer.
        /// This member is required.
        public let consumerName: Swift.String?
        /// A consumer can't read data while in the CREATING or DELETING
        ///             states.
        /// This member is required.
        public let consumerStatus: KinesisClientTypes.ConsumerStatus?

        public init (
            consumerARN: Swift.String? = nil,
            consumerCreationTimestamp: ClientRuntime.Date? = nil,
            consumerName: Swift.String? = nil,
            consumerStatus: KinesisClientTypes.ConsumerStatus? = nil
        )
        {
            self.consumerARN = consumerARN
            self.consumerCreationTimestamp = consumerCreationTimestamp
            self.consumerName = consumerName
            self.consumerStatus = consumerStatus
        }
    }

}

extension KinesisClientTypes.ConsumerDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerCreationTimestamp = "ConsumerCreationTimestamp"
        case consumerName = "ConsumerName"
        case consumerStatus = "ConsumerStatus"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerCreationTimestamp = consumerCreationTimestamp {
            try encodeContainer.encode(consumerCreationTimestamp.timeIntervalSince1970, forKey: .consumerCreationTimestamp)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let consumerStatus = consumerStatus {
            try encodeContainer.encode(consumerStatus.rawValue, forKey: .consumerStatus)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let consumerStatusDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ConsumerStatus.self, forKey: .consumerStatus)
        consumerStatus = consumerStatusDecoded
        let consumerCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .consumerCreationTimestamp)
        consumerCreationTimestamp = consumerCreationTimestampDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension KinesisClientTypes.ConsumerDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConsumerDescription(consumerARN: \(Swift.String(describing: consumerARN)), consumerCreationTimestamp: \(Swift.String(describing: consumerCreationTimestamp)), consumerName: \(Swift.String(describing: consumerName)), consumerStatus: \(Swift.String(describing: consumerStatus)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension KinesisClientTypes {
    /// An object that represents the details of a registered consumer. This type of object is
    ///             returned by DescribeStreamConsumer.
    public struct ConsumerDescription: Swift.Equatable {
        /// When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
        ///             this ARN to be able to call SubscribeToShard.
        ///         If you delete a consumer and then create a new one with the same name, it won't have
        ///             the same ARN. That's because consumer ARNs contain the creation timestamp. This is
        ///             important to keep in mind if you have IAM policies that reference consumer ARNs.
        /// This member is required.
        public let consumerARN: Swift.String?
        ///
        /// This member is required.
        public let consumerCreationTimestamp: ClientRuntime.Date?
        /// The name of the consumer is something you choose when you register the
        ///             consumer.
        /// This member is required.
        public let consumerName: Swift.String?
        /// A consumer can't read data while in the CREATING or DELETING
        ///             states.
        /// This member is required.
        public let consumerStatus: KinesisClientTypes.ConsumerStatus?
        /// The ARN of the stream with which you registered the consumer.
        /// This member is required.
        public let streamARN: Swift.String?

        public init (
            consumerARN: Swift.String? = nil,
            consumerCreationTimestamp: ClientRuntime.Date? = nil,
            consumerName: Swift.String? = nil,
            consumerStatus: KinesisClientTypes.ConsumerStatus? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.consumerARN = consumerARN
            self.consumerCreationTimestamp = consumerCreationTimestamp
            self.consumerName = consumerName
            self.consumerStatus = consumerStatus
            self.streamARN = streamARN
        }
    }

}

extension KinesisClientTypes {
    public enum ConsumerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConsumerStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConsumerStatus(rawValue: rawValue) ?? ConsumerStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamOutputError>
}

extension CreateStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamInput(shardCount: \(Swift.String(describing: shardCount)), streamName: \(Swift.String(describing: streamName)))"}
}

extension CreateStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardCount = "ShardCount"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardCount = shardCount {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct CreateStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamOutputError>
}

public struct CreateStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamOutputError>
}

/// Represents the input for CreateStream.
public struct CreateStreamInput: Swift.Equatable {
    /// The number of shards that the stream will use. The throughput of the stream is a
    ///             function of the number of shards; more shards are required for greater provisioned
    ///             throughput.
    /// This member is required.
    public let shardCount: Swift.Int?
    /// A name to identify the stream. The stream name is scoped to the AWS account used by
    ///             the application that creates the stream. It is also scoped by AWS Region. That is, two
    ///             streams in two different AWS accounts can have the same name. Two streams in the same
    ///             AWS account but in two different Regions can also have the same name.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        shardCount: Swift.Int? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.shardCount = shardCount
        self.streamName = streamName
    }
}

struct CreateStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardCount: Swift.Int?
}

extension CreateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardCount = "ShardCount"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount)
        shardCount = shardCountDecoded
    }
}

extension CreateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamOutputResponse()"}
}

extension CreateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateStreamOutputResponseBody: Swift.Equatable {
}

extension CreateStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DecreaseStreamRetentionPeriodInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseStreamRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseStreamRetentionPeriodOutputError>
}

extension DecreaseStreamRetentionPeriodInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseStreamRetentionPeriodInput(retentionPeriodHours: \(Swift.String(describing: retentionPeriodHours)), streamName: \(Swift.String(describing: streamName)))"}
}

extension DecreaseStreamRetentionPeriodInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DecreaseStreamRetentionPeriodInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseStreamRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseStreamRetentionPeriodOutputError>
}

public struct DecreaseStreamRetentionPeriodInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecreaseStreamRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecreaseStreamRetentionPeriodOutputError>
}

/// Represents the input for DecreaseStreamRetentionPeriod.
public struct DecreaseStreamRetentionPeriodInput: Swift.Equatable {
    /// The new retention period of the stream, in hours. Must be less than the current
    ///             retention period.
    /// This member is required.
    public let retentionPeriodHours: Swift.Int?
    /// The name of the stream to modify.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        retentionPeriodHours: Swift.Int? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.retentionPeriodHours = retentionPeriodHours
        self.streamName = streamName
    }
}

struct DecreaseStreamRetentionPeriodInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let retentionPeriodHours: Swift.Int?
}

extension DecreaseStreamRetentionPeriodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
    }
}

extension DecreaseStreamRetentionPeriodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseStreamRetentionPeriodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecreaseStreamRetentionPeriodOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseStreamRetentionPeriodOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecreaseStreamRetentionPeriodOutputResponse()"}
}

extension DecreaseStreamRetentionPeriodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DecreaseStreamRetentionPeriodOutputResponse: Swift.Equatable {

    public init() {}
}

struct DecreaseStreamRetentionPeriodOutputResponseBody: Swift.Equatable {
}

extension DecreaseStreamRetentionPeriodOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamOutputError>
}

extension DeleteStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamInput(enforceConsumerDeletion: \(Swift.String(describing: enforceConsumerDeletion)), streamName: \(Swift.String(describing: streamName)))"}
}

extension DeleteStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceConsumerDeletion = "EnforceConsumerDeletion"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enforceConsumerDeletion = enforceConsumerDeletion {
            try encodeContainer.encode(enforceConsumerDeletion, forKey: .enforceConsumerDeletion)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DeleteStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamOutputError>
}

/// Represents the input for DeleteStream.
public struct DeleteStreamInput: Swift.Equatable {
    /// If this parameter is unset (null) or if you set it to false,
    ///             and the stream has registered consumers, the call to DeleteStream fails
    ///             with a ResourceInUseException.
    public let enforceConsumerDeletion: Swift.Bool?
    /// The name of the stream to delete.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        enforceConsumerDeletion: Swift.Bool? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.enforceConsumerDeletion = enforceConsumerDeletion
        self.streamName = streamName
    }
}

struct DeleteStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let enforceConsumerDeletion: Swift.Bool?
}

extension DeleteStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceConsumerDeletion = "EnforceConsumerDeletion"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let enforceConsumerDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceConsumerDeletion)
        enforceConsumerDeletion = enforceConsumerDeletionDecoded
    }
}

extension DeleteStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamOutputResponse()"}
}

extension DeleteStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStreamOutputResponseBody: Swift.Equatable {
}

extension DeleteStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterStreamConsumerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterStreamConsumerOutputError>
}

extension DeregisterStreamConsumerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterStreamConsumerInput(consumerARN: \(Swift.String(describing: consumerARN)), consumerName: \(Swift.String(describing: consumerName)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension DeregisterStreamConsumerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct DeregisterStreamConsumerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterStreamConsumerOutputError>
}

public struct DeregisterStreamConsumerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterStreamConsumerOutputError>
}

public struct DeregisterStreamConsumerInput: Swift.Equatable {
    /// The ARN returned by Kinesis Data Streams when you registered the consumer. If you
    ///             don't know the ARN of the consumer that you want to deregister, you can use the
    ///             ListStreamConsumers operation to get a list of the descriptions of all the consumers
    ///             that are currently registered with a given data stream. The description of a consumer
    ///             contains its ARN.
    public let consumerARN: Swift.String?
    /// The name that you gave to the consumer.
    public let consumerName: Swift.String?
    /// The ARN of the Kinesis data stream that the consumer is registered with. For more
    ///             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces.
    public let streamARN: Swift.String?

    public init (
        consumerARN: Swift.String? = nil,
        consumerName: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct DeregisterStreamConsumerInputBody: Swift.Equatable {
    public let streamARN: Swift.String?
    public let consumerName: Swift.String?
    public let consumerARN: Swift.String?
}

extension DeregisterStreamConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
    }
}

extension DeregisterStreamConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterStreamConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterStreamConsumerOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterStreamConsumerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterStreamConsumerOutputResponse()"}
}

extension DeregisterStreamConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterStreamConsumerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterStreamConsumerOutputResponseBody: Swift.Equatable {
}

extension DeregisterStreamConsumerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLimitsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLimitsInput()"}
}

extension DescribeLimitsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeLimitsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLimitsOutputError>
}

public struct DescribeLimitsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLimitsOutputError>
}

public struct DescribeLimitsInput: Swift.Equatable {

    public init() {}
}

struct DescribeLimitsInputBody: Swift.Equatable {
}

extension DescribeLimitsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLimitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLimitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLimitsOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLimitsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLimitsOutputResponse(openShardCount: \(Swift.String(describing: openShardCount)), shardLimit: \(Swift.String(describing: shardLimit)))"}
}

extension DescribeLimitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLimitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.openShardCount = output.openShardCount
            self.shardLimit = output.shardLimit
        } else {
            self.openShardCount = nil
            self.shardLimit = nil
        }
    }
}

public struct DescribeLimitsOutputResponse: Swift.Equatable {
    /// The number of open shards.
    /// This member is required.
    public let openShardCount: Swift.Int?
    /// The maximum number of shards.
    /// This member is required.
    public let shardLimit: Swift.Int?

    public init (
        openShardCount: Swift.Int? = nil,
        shardLimit: Swift.Int? = nil
    )
    {
        self.openShardCount = openShardCount
        self.shardLimit = shardLimit
    }
}

struct DescribeLimitsOutputResponseBody: Swift.Equatable {
    public let shardLimit: Swift.Int?
    public let openShardCount: Swift.Int?
}

extension DescribeLimitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openShardCount = "OpenShardCount"
        case shardLimit = "ShardLimit"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardLimit)
        shardLimit = shardLimitDecoded
        let openShardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openShardCount)
        openShardCount = openShardCountDecoded
    }
}

public struct DescribeStreamConsumerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamConsumerOutputError>
}

extension DescribeStreamConsumerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamConsumerInput(consumerARN: \(Swift.String(describing: consumerARN)), consumerName: \(Swift.String(describing: consumerName)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension DescribeStreamConsumerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct DescribeStreamConsumerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamConsumerOutputError>
}

public struct DescribeStreamConsumerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamConsumerOutputError>
}

public struct DescribeStreamConsumerInput: Swift.Equatable {
    /// The ARN returned by Kinesis Data Streams when you registered the consumer.
    public let consumerARN: Swift.String?
    /// The name that you gave to the consumer.
    public let consumerName: Swift.String?
    /// The ARN of the Kinesis data stream that the consumer is registered with. For more
    ///             information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces.
    public let streamARN: Swift.String?

    public init (
        consumerARN: Swift.String? = nil,
        consumerName: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.consumerARN = consumerARN
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct DescribeStreamConsumerInputBody: Swift.Equatable {
    public let streamARN: Swift.String?
    public let consumerName: Swift.String?
    public let consumerARN: Swift.String?
}

extension DescribeStreamConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
        let consumerARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
    }
}

extension DescribeStreamConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamConsumerOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamConsumerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamConsumerOutputResponse(consumerDescription: \(Swift.String(describing: consumerDescription)))"}
}

extension DescribeStreamConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamConsumerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.consumerDescription = output.consumerDescription
        } else {
            self.consumerDescription = nil
        }
    }
}

public struct DescribeStreamConsumerOutputResponse: Swift.Equatable {
    /// An object that represents the details of the consumer.
    /// This member is required.
    public let consumerDescription: KinesisClientTypes.ConsumerDescription?

    public init (
        consumerDescription: KinesisClientTypes.ConsumerDescription? = nil
    )
    {
        self.consumerDescription = consumerDescription
    }
}

struct DescribeStreamConsumerOutputResponseBody: Swift.Equatable {
    public let consumerDescription: KinesisClientTypes.ConsumerDescription?
}

extension DescribeStreamConsumerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerDescription = "ConsumerDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerDescriptionDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ConsumerDescription.self, forKey: .consumerDescription)
        consumerDescription = consumerDescriptionDecoded
    }
}

public struct DescribeStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamOutputError>
}

extension DescribeStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamInput(exclusiveStartShardId: \(Swift.String(describing: exclusiveStartShardId)), limit: \(Swift.String(describing: limit)), streamName: \(Swift.String(describing: streamName)))"}
}

extension DescribeStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DescribeStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamOutputError>
}

/// Represents the input for DescribeStream.
public struct DescribeStreamInput: Swift.Equatable {
    /// The shard ID of the shard to start with.
    public let exclusiveStartShardId: Swift.String?
    /// The maximum number of shards to return in a single call. The default value is 100.
    ///             If you specify a value greater than 100, at most 100 shards are returned.
    public let limit: Swift.Int?
    /// The name of the stream to describe.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        exclusiveStartShardId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.limit = limit
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let limit: Swift.Int?
    public let exclusiveStartShardId: Swift.String?
}

extension DescribeStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
    }
}

extension DescribeStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamOutputResponse(streamDescription: \(Swift.String(describing: streamDescription)))"}
}

extension DescribeStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamDescription = output.streamDescription
        } else {
            self.streamDescription = nil
        }
    }
}

/// Represents the output for DescribeStream.
public struct DescribeStreamOutputResponse: Swift.Equatable {
    /// The current status of the stream, the stream Amazon Resource Name (ARN), an array
    ///             of shard objects that comprise the stream, and whether there are more shards
    ///             available.
    /// This member is required.
    public let streamDescription: KinesisClientTypes.StreamDescription?

    public init (
        streamDescription: KinesisClientTypes.StreamDescription? = nil
    )
    {
        self.streamDescription = streamDescription
    }
}

struct DescribeStreamOutputResponseBody: Swift.Equatable {
    public let streamDescription: KinesisClientTypes.StreamDescription?
}

extension DescribeStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamDescription = "StreamDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.StreamDescription.self, forKey: .streamDescription)
        streamDescription = streamDescriptionDecoded
    }
}

public struct DescribeStreamSummaryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamSummaryOutputError>
}

extension DescribeStreamSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamSummaryInput(streamName: \(Swift.String(describing: streamName)))"}
}

extension DescribeStreamSummaryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DescribeStreamSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamSummaryOutputError>
}

public struct DescribeStreamSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStreamSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStreamSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStreamSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStreamSummaryOutputError>
}

public struct DescribeStreamSummaryInput: Swift.Equatable {
    /// The name of the stream to describe.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        streamName: Swift.String? = nil
    )
    {
        self.streamName = streamName
    }
}

struct DescribeStreamSummaryInputBody: Swift.Equatable {
    public let streamName: Swift.String?
}

extension DescribeStreamSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension DescribeStreamSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamSummaryOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStreamSummaryOutputResponse(streamDescriptionSummary: \(Swift.String(describing: streamDescriptionSummary)))"}
}

extension DescribeStreamSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamDescriptionSummary = output.streamDescriptionSummary
        } else {
            self.streamDescriptionSummary = nil
        }
    }
}

public struct DescribeStreamSummaryOutputResponse: Swift.Equatable {
    /// A StreamDescriptionSummary containing information about the
    ///             stream.
    /// This member is required.
    public let streamDescriptionSummary: KinesisClientTypes.StreamDescriptionSummary?

    public init (
        streamDescriptionSummary: KinesisClientTypes.StreamDescriptionSummary? = nil
    )
    {
        self.streamDescriptionSummary = streamDescriptionSummary
    }
}

struct DescribeStreamSummaryOutputResponseBody: Swift.Equatable {
    public let streamDescriptionSummary: KinesisClientTypes.StreamDescriptionSummary?
}

extension DescribeStreamSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamDescriptionSummary = "StreamDescriptionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionSummaryDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.StreamDescriptionSummary.self, forKey: .streamDescriptionSummary)
        streamDescriptionSummary = streamDescriptionSummaryDecoded
    }
}

public struct DisableEnhancedMonitoringInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableEnhancedMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableEnhancedMonitoringOutputError>
}

extension DisableEnhancedMonitoringInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableEnhancedMonitoringInput(shardLevelMetrics: \(Swift.String(describing: shardLevelMetrics)), streamName: \(Swift.String(describing: streamName)))"}
}

extension DisableEnhancedMonitoringInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DisableEnhancedMonitoringInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableEnhancedMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableEnhancedMonitoringOutputError>
}

public struct DisableEnhancedMonitoringInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableEnhancedMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableEnhancedMonitoringOutputError>
}

/// Represents the input for DisableEnhancedMonitoring.
public struct DisableEnhancedMonitoringInput: Swift.Equatable {
    /// List of shard-level metrics to disable.
    ///         The following are the valid shard-level metrics. The value "ALL"
    ///             disables every metric.
    ///
    ///
    ///
    ///                     IncomingBytes
    ///
    ///
    ///
    ///
    ///                     IncomingRecords
    ///
    ///
    ///
    ///
    ///                     OutgoingBytes
    ///
    ///
    ///
    ///
    ///                     OutgoingRecords
    ///
    ///
    ///
    ///
    ///                     WriteProvisionedThroughputExceeded
    ///
    ///
    ///
    ///
    ///                     ReadProvisionedThroughputExceeded
    ///
    ///
    ///
    ///
    ///                     IteratorAgeMilliseconds
    ///
    ///
    ///
    ///
    ///                     ALL
    ///
    ///
    ///
    ///         For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    ///                 Kinesis Data Streams Service with Amazon CloudWatch in the Amazon
    ///                 Kinesis Data Streams Developer Guide.
    /// This member is required.
    public let shardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// The name of the Kinesis data stream for which to disable enhanced
    ///             monitoring.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        shardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.shardLevelMetrics = shardLevelMetrics
        self.streamName = streamName
    }
}

struct DisableEnhancedMonitoringInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardLevelMetrics: [KinesisClientTypes.MetricsName]?
}

extension DisableEnhancedMonitoringInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension DisableEnhancedMonitoringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableEnhancedMonitoringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableEnhancedMonitoringOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableEnhancedMonitoringOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableEnhancedMonitoringOutputResponse(currentShardLevelMetrics: \(Swift.String(describing: currentShardLevelMetrics)), desiredShardLevelMetrics: \(Swift.String(describing: desiredShardLevelMetrics)), streamName: \(Swift.String(describing: streamName)))"}
}

extension DisableEnhancedMonitoringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableEnhancedMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentShardLevelMetrics = output.currentShardLevelMetrics
            self.desiredShardLevelMetrics = output.desiredShardLevelMetrics
            self.streamName = output.streamName
        } else {
            self.currentShardLevelMetrics = nil
            self.desiredShardLevelMetrics = nil
            self.streamName = nil
        }
    }
}

/// Represents the output for EnableEnhancedMonitoring and DisableEnhancedMonitoring.
public struct DisableEnhancedMonitoringOutputResponse: Swift.Equatable {
    /// Represents the current state of the metrics that are in the enhanced state before
    ///             the operation.
    public let currentShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// Represents the list of all the metrics that would be in the enhanced state after
    ///             the operation.
    public let desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// The name of the Kinesis data stream.
    public let streamName: Swift.String?

    public init (
        currentShardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentShardLevelMetrics = currentShardLevelMetrics
        self.desiredShardLevelMetrics = desiredShardLevelMetrics
        self.streamName = streamName
    }
}

struct DisableEnhancedMonitoringOutputResponseBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let currentShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    public let desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]?
}

extension DisableEnhancedMonitoringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentShardLevelMetrics = "CurrentShardLevelMetrics"
        case desiredShardLevelMetrics = "DesiredShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .currentShardLevelMetrics)
        var currentShardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let currentShardLevelMetricsContainer = currentShardLevelMetricsContainer {
            currentShardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in currentShardLevelMetricsContainer {
                if let string0 = string0 {
                    currentShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        currentShardLevelMetrics = currentShardLevelMetricsDecoded0
        let desiredShardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .desiredShardLevelMetrics)
        var desiredShardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let desiredShardLevelMetricsContainer = desiredShardLevelMetricsContainer {
            desiredShardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in desiredShardLevelMetricsContainer {
                if let string0 = string0 {
                    desiredShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        desiredShardLevelMetrics = desiredShardLevelMetricsDecoded0
    }
}

public struct EnableEnhancedMonitoringInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableEnhancedMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableEnhancedMonitoringOutputError>
}

extension EnableEnhancedMonitoringInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableEnhancedMonitoringInput(shardLevelMetrics: \(Swift.String(describing: shardLevelMetrics)), streamName: \(Swift.String(describing: streamName)))"}
}

extension EnableEnhancedMonitoringInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct EnableEnhancedMonitoringInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableEnhancedMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableEnhancedMonitoringOutputError>
}

public struct EnableEnhancedMonitoringInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableEnhancedMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableEnhancedMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableEnhancedMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableEnhancedMonitoringOutputError>
}

/// Represents the input for EnableEnhancedMonitoring.
public struct EnableEnhancedMonitoringInput: Swift.Equatable {
    /// List of shard-level metrics to enable.
    ///         The following are the valid shard-level metrics. The value "ALL"
    ///             enables every metric.
    ///
    ///
    ///
    ///                     IncomingBytes
    ///
    ///
    ///
    ///
    ///                     IncomingRecords
    ///
    ///
    ///
    ///
    ///                     OutgoingBytes
    ///
    ///
    ///
    ///
    ///                     OutgoingRecords
    ///
    ///
    ///
    ///
    ///                     WriteProvisionedThroughputExceeded
    ///
    ///
    ///
    ///
    ///                     ReadProvisionedThroughputExceeded
    ///
    ///
    ///
    ///
    ///                     IteratorAgeMilliseconds
    ///
    ///
    ///
    ///
    ///                     ALL
    ///
    ///
    ///
    ///         For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    ///                 Kinesis Data Streams Service with Amazon CloudWatch in the Amazon
    ///                 Kinesis Data Streams Developer Guide.
    /// This member is required.
    public let shardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// The name of the stream for which to enable enhanced monitoring.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        shardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.shardLevelMetrics = shardLevelMetrics
        self.streamName = streamName
    }
}

struct EnableEnhancedMonitoringInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardLevelMetrics: [KinesisClientTypes.MetricsName]?
}

extension EnableEnhancedMonitoringInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension EnableEnhancedMonitoringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableEnhancedMonitoringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableEnhancedMonitoringOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableEnhancedMonitoringOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableEnhancedMonitoringOutputResponse(currentShardLevelMetrics: \(Swift.String(describing: currentShardLevelMetrics)), desiredShardLevelMetrics: \(Swift.String(describing: desiredShardLevelMetrics)), streamName: \(Swift.String(describing: streamName)))"}
}

extension EnableEnhancedMonitoringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableEnhancedMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentShardLevelMetrics = output.currentShardLevelMetrics
            self.desiredShardLevelMetrics = output.desiredShardLevelMetrics
            self.streamName = output.streamName
        } else {
            self.currentShardLevelMetrics = nil
            self.desiredShardLevelMetrics = nil
            self.streamName = nil
        }
    }
}

/// Represents the output for EnableEnhancedMonitoring and DisableEnhancedMonitoring.
public struct EnableEnhancedMonitoringOutputResponse: Swift.Equatable {
    /// Represents the current state of the metrics that are in the enhanced state before
    ///             the operation.
    public let currentShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// Represents the list of all the metrics that would be in the enhanced state after
    ///             the operation.
    public let desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    /// The name of the Kinesis data stream.
    public let streamName: Swift.String?

    public init (
        currentShardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentShardLevelMetrics = currentShardLevelMetrics
        self.desiredShardLevelMetrics = desiredShardLevelMetrics
        self.streamName = streamName
    }
}

struct EnableEnhancedMonitoringOutputResponseBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let currentShardLevelMetrics: [KinesisClientTypes.MetricsName]?
    public let desiredShardLevelMetrics: [KinesisClientTypes.MetricsName]?
}

extension EnableEnhancedMonitoringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentShardLevelMetrics = "CurrentShardLevelMetrics"
        case desiredShardLevelMetrics = "DesiredShardLevelMetrics"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .currentShardLevelMetrics)
        var currentShardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let currentShardLevelMetricsContainer = currentShardLevelMetricsContainer {
            currentShardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in currentShardLevelMetricsContainer {
                if let string0 = string0 {
                    currentShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        currentShardLevelMetrics = currentShardLevelMetricsDecoded0
        let desiredShardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .desiredShardLevelMetrics)
        var desiredShardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let desiredShardLevelMetricsContainer = desiredShardLevelMetricsContainer {
            desiredShardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in desiredShardLevelMetricsContainer {
                if let string0 = string0 {
                    desiredShardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        desiredShardLevelMetrics = desiredShardLevelMetricsDecoded0
    }
}

extension KinesisClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisClientTypes.EnhancedMetrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardLevelMetrics = "ShardLevelMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardLevelMetrics = shardLevelMetrics {
            var shardLevelMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shardLevelMetrics)
            for metricsnamelist0 in shardLevelMetrics {
                try shardLevelMetricsContainer.encode(metricsnamelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardLevelMetricsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.MetricsName?].self, forKey: .shardLevelMetrics)
        var shardLevelMetricsDecoded0:[KinesisClientTypes.MetricsName]? = nil
        if let shardLevelMetricsContainer = shardLevelMetricsContainer {
            shardLevelMetricsDecoded0 = [KinesisClientTypes.MetricsName]()
            for string0 in shardLevelMetricsContainer {
                if let string0 = string0 {
                    shardLevelMetricsDecoded0?.append(string0)
                }
            }
        }
        shardLevelMetrics = shardLevelMetricsDecoded0
    }
}

extension KinesisClientTypes.EnhancedMetrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnhancedMetrics(shardLevelMetrics: \(Swift.String(describing: shardLevelMetrics)))"}
}

extension KinesisClientTypes {
    /// Represents enhanced metrics types.
    public struct EnhancedMetrics: Swift.Equatable {
        /// List of shard-level metrics.
        ///         The following are the valid shard-level metrics. The value "ALL"
        ///             enhances every metric.
        ///
        ///
        ///
        ///                     IncomingBytes
        ///
        ///
        ///
        ///
        ///                     IncomingRecords
        ///
        ///
        ///
        ///
        ///                     OutgoingBytes
        ///
        ///
        ///
        ///
        ///                     OutgoingRecords
        ///
        ///
        ///
        ///
        ///                     WriteProvisionedThroughputExceeded
        ///
        ///
        ///
        ///
        ///                     ReadProvisionedThroughputExceeded
        ///
        ///
        ///
        ///
        ///                     IteratorAgeMilliseconds
        ///
        ///
        ///
        ///
        ///                     ALL
        ///
        ///
        ///
        ///         For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
        ///                 Kinesis Data Streams Service with Amazon CloudWatch in the Amazon
        ///                 Kinesis Data Streams Developer Guide.
        public let shardLevelMetrics: [KinesisClientTypes.MetricsName]?

        public init (
            shardLevelMetrics: [KinesisClientTypes.MetricsName]? = nil
        )
        {
            self.shardLevelMetrics = shardLevelMetrics
        }
    }

}

extension ExpiredIteratorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredIteratorException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredIteratorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredIteratorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided iterator exceeds the maximum age allowed.
public struct ExpiredIteratorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredIteratorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredIteratorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExpiredNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token passed to the operation is expired.
public struct ExpiredNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetRecordsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordsOutputError>
}

extension GetRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordsInput(limit: \(Swift.String(describing: limit)), shardIterator: \(Swift.String(describing: shardIterator)))"}
}

extension GetRecordsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let shardIterator = shardIterator {
            try encodeContainer.encode(shardIterator, forKey: .shardIterator)
        }
    }
}

public struct GetRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordsOutputError>
}

public struct GetRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordsOutputError>
}

/// Represents the input for GetRecords.
public struct GetRecordsInput: Swift.Equatable {
    /// The maximum number of records to return. Specify a value of up to 10,000. If you
    ///             specify a value that is greater than 10,000, GetRecords throws
    ///                 InvalidArgumentException. The default value is 10,000.
    public let limit: Swift.Int?
    /// The position in the shard from which you want to start sequentially reading data
    ///             records. A shard iterator specifies this position using the sequence number of a data
    ///             record in the shard.
    /// This member is required.
    public let shardIterator: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        shardIterator: Swift.String? = nil
    )
    {
        self.limit = limit
        self.shardIterator = shardIterator
    }
}

struct GetRecordsInputBody: Swift.Equatable {
    public let shardIterator: Swift.String?
    public let limit: Swift.Int?
}

extension GetRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension GetRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredIteratorException" : self = .expiredIteratorException(try ExpiredIteratorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordsOutputError: Swift.Error, Swift.Equatable {
    case expiredIteratorException(ExpiredIteratorException)
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordsOutputResponse(childShards: \(Swift.String(describing: childShards)), millisBehindLatest: \(Swift.String(describing: millisBehindLatest)), nextShardIterator: \(Swift.String(describing: nextShardIterator)), records: \(Swift.String(describing: records)))"}
}

extension GetRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.childShards = output.childShards
            self.millisBehindLatest = output.millisBehindLatest
            self.nextShardIterator = output.nextShardIterator
            self.records = output.records
        } else {
            self.childShards = nil
            self.millisBehindLatest = nil
            self.nextShardIterator = nil
            self.records = nil
        }
    }
}

/// Represents the output for GetRecords.
public struct GetRecordsOutputResponse: Swift.Equatable {
    public let childShards: [KinesisClientTypes.ChildShard]?
    /// The number of milliseconds the GetRecords response is from the
    ///             tip of the stream, indicating how far behind current time the consumer is. A value of
    ///             zero indicates that record processing is caught up, and there are no new records to
    ///             process at this moment.
    public let millisBehindLatest: Swift.Int?
    /// The next position in the shard from which to start sequentially reading data
    ///             records. If set to null, the shard has been closed and the requested
    ///             iterator does not return any more data.
    public let nextShardIterator: Swift.String?
    /// The data records retrieved from the shard.
    /// This member is required.
    public let records: [KinesisClientTypes.Record]?

    public init (
        childShards: [KinesisClientTypes.ChildShard]? = nil,
        millisBehindLatest: Swift.Int? = nil,
        nextShardIterator: Swift.String? = nil,
        records: [KinesisClientTypes.Record]? = nil
    )
    {
        self.childShards = childShards
        self.millisBehindLatest = millisBehindLatest
        self.nextShardIterator = nextShardIterator
        self.records = records
    }
}

struct GetRecordsOutputResponseBody: Swift.Equatable {
    public let records: [KinesisClientTypes.Record]?
    public let nextShardIterator: Swift.String?
    public let millisBehindLatest: Swift.Int?
    public let childShards: [KinesisClientTypes.ChildShard]?
}

extension GetRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childShards = "ChildShards"
        case millisBehindLatest = "MillisBehindLatest"
        case nextShardIterator = "NextShardIterator"
        case records = "Records"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[KinesisClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [KinesisClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextShardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextShardIterator)
        nextShardIterator = nextShardIteratorDecoded
        let millisBehindLatestDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .millisBehindLatest)
        millisBehindLatest = millisBehindLatestDecoded
        let childShardsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.ChildShard?].self, forKey: .childShards)
        var childShardsDecoded0:[KinesisClientTypes.ChildShard]? = nil
        if let childShardsContainer = childShardsContainer {
            childShardsDecoded0 = [KinesisClientTypes.ChildShard]()
            for structure0 in childShardsContainer {
                if let structure0 = structure0 {
                    childShardsDecoded0?.append(structure0)
                }
            }
        }
        childShards = childShardsDecoded0
    }
}

public struct GetShardIteratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetShardIteratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetShardIteratorOutputError>
}

extension GetShardIteratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetShardIteratorInput(shardId: \(Swift.String(describing: shardId)), shardIteratorType: \(Swift.String(describing: shardIteratorType)), startingSequenceNumber: \(Swift.String(describing: startingSequenceNumber)), streamName: \(Swift.String(describing: streamName)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension GetShardIteratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case startingSequenceNumber = "StartingSequenceNumber"
        case streamName = "StreamName"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let shardIteratorType = shardIteratorType {
            try encodeContainer.encode(shardIteratorType.rawValue, forKey: .shardIteratorType)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }
}

public struct GetShardIteratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetShardIteratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetShardIteratorOutputError>
}

public struct GetShardIteratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetShardIteratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetShardIteratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetShardIteratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetShardIteratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetShardIteratorOutputError>
}

/// Represents the input for GetShardIterator.
public struct GetShardIteratorInput: Swift.Equatable {
    /// The shard ID of the Kinesis Data Streams shard to get the iterator for.
    /// This member is required.
    public let shardId: Swift.String?
    /// Determines how the shard iterator is used to start reading data records from the
    ///             shard.
    ///         The following are the valid Amazon Kinesis shard iterator types:
    ///
    ///
    ///
    ///                 AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
    ///                     sequence number, provided in the value
    ///                     StartingSequenceNumber.
    ///
    ///
    ///
    ///                 AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
    ///                     specific sequence number, provided in the value
    ///                         StartingSequenceNumber.
    ///
    ///
    ///
    ///                 AT_TIMESTAMP - Start reading from the position denoted by a specific time
    ///                     stamp, provided in the value Timestamp.
    ///
    ///
    ///
    ///                 TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
    ///                     the system, which is the oldest data record in the shard.
    ///
    ///
    ///
    ///                 LATEST - Start reading just after the most recent record in the shard, so
    ///                     that you always read the most recent data in the shard.
    ///
    ///
    /// This member is required.
    public let shardIteratorType: KinesisClientTypes.ShardIteratorType?
    /// The sequence number of the data record in the shard from which to start reading.
    ///             Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.
    public let startingSequenceNumber: Swift.String?
    /// The name of the Amazon Kinesis data stream.
    /// This member is required.
    public let streamName: Swift.String?
    /// The time stamp of the data record from which to start reading. Used with shard
    ///             iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
    ///             milliseconds. For example, 2016-04-04T19:58:46.480-00:00 or
    ///                 1459799926.480. If a record with this exact time stamp does not exist,
    ///             the iterator returned is for the next (later) record. If the time stamp is older than
    ///             the current trim horizon, the iterator returned is for the oldest untrimmed data record
    ///             (TRIM_HORIZON).
    public let timestamp: ClientRuntime.Date?

    public init (
        shardId: Swift.String? = nil,
        shardIteratorType: KinesisClientTypes.ShardIteratorType? = nil,
        startingSequenceNumber: Swift.String? = nil,
        streamName: Swift.String? = nil,
        timestamp: ClientRuntime.Date? = nil
    )
    {
        self.shardId = shardId
        self.shardIteratorType = shardIteratorType
        self.startingSequenceNumber = startingSequenceNumber
        self.streamName = streamName
        self.timestamp = timestamp
    }
}

struct GetShardIteratorInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardId: Swift.String?
    public let shardIteratorType: KinesisClientTypes.ShardIteratorType?
    public let startingSequenceNumber: Swift.String?
    public let timestamp: ClientRuntime.Date?
}

extension GetShardIteratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case startingSequenceNumber = "StartingSequenceNumber"
        case streamName = "StreamName"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let shardIteratorTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ShardIteratorType.self, forKey: .shardIteratorType)
        shardIteratorType = shardIteratorTypeDecoded
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension GetShardIteratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetShardIteratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetShardIteratorOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetShardIteratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetShardIteratorOutputResponse(shardIterator: \(Swift.String(describing: shardIterator)))"}
}

extension GetShardIteratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetShardIteratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shardIterator = output.shardIterator
        } else {
            self.shardIterator = nil
        }
    }
}

/// Represents the output for GetShardIterator.
public struct GetShardIteratorOutputResponse: Swift.Equatable {
    /// The position in the shard from which to start reading data records sequentially. A
    ///             shard iterator specifies this position using the sequence number of a data record in a
    ///             shard.
    public let shardIterator: Swift.String?

    public init (
        shardIterator: Swift.String? = nil
    )
    {
        self.shardIterator = shardIterator
    }
}

struct GetShardIteratorOutputResponseBody: Swift.Equatable {
    public let shardIterator: Swift.String?
}

extension GetShardIteratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
    }
}

extension KinesisClientTypes.HashKeyRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endingHashKey = "EndingHashKey"
        case startingHashKey = "StartingHashKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingHashKey = endingHashKey {
            try encodeContainer.encode(endingHashKey, forKey: .endingHashKey)
        }
        if let startingHashKey = startingHashKey {
            try encodeContainer.encode(startingHashKey, forKey: .startingHashKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingHashKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startingHashKey)
        startingHashKey = startingHashKeyDecoded
        let endingHashKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endingHashKey)
        endingHashKey = endingHashKeyDecoded
    }
}

extension KinesisClientTypes.HashKeyRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HashKeyRange(endingHashKey: \(Swift.String(describing: endingHashKey)), startingHashKey: \(Swift.String(describing: startingHashKey)))"}
}

extension KinesisClientTypes {
    /// The range of possible hash key values for the shard, which is a set of ordered
    ///             contiguous positive integers.
    public struct HashKeyRange: Swift.Equatable {
        /// The ending hash key of the hash key range.
        /// This member is required.
        public let endingHashKey: Swift.String?
        /// The starting hash key of the hash key range.
        /// This member is required.
        public let startingHashKey: Swift.String?

        public init (
            endingHashKey: Swift.String? = nil,
            startingHashKey: Swift.String? = nil
        )
        {
            self.endingHashKey = endingHashKey
            self.startingHashKey = startingHashKey
        }
    }

}

public struct IncreaseStreamRetentionPeriodInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseStreamRetentionPeriodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseStreamRetentionPeriodOutputError>
}

extension IncreaseStreamRetentionPeriodInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseStreamRetentionPeriodInput(retentionPeriodHours: \(Swift.String(describing: retentionPeriodHours)), streamName: \(Swift.String(describing: streamName)))"}
}

extension IncreaseStreamRetentionPeriodInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct IncreaseStreamRetentionPeriodInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseStreamRetentionPeriodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseStreamRetentionPeriodOutputError>
}

public struct IncreaseStreamRetentionPeriodInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IncreaseStreamRetentionPeriodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IncreaseStreamRetentionPeriodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IncreaseStreamRetentionPeriodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IncreaseStreamRetentionPeriodOutputError>
}

/// Represents the input for IncreaseStreamRetentionPeriod.
public struct IncreaseStreamRetentionPeriodInput: Swift.Equatable {
    /// The new retention period of the stream, in hours. Must be more than the current
    ///             retention period.
    /// This member is required.
    public let retentionPeriodHours: Swift.Int?
    /// The name of the stream to modify.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        retentionPeriodHours: Swift.Int? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.retentionPeriodHours = retentionPeriodHours
        self.streamName = streamName
    }
}

struct IncreaseStreamRetentionPeriodInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let retentionPeriodHours: Swift.Int?
}

extension IncreaseStreamRetentionPeriodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
    }
}

extension IncreaseStreamRetentionPeriodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseStreamRetentionPeriodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IncreaseStreamRetentionPeriodOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseStreamRetentionPeriodOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncreaseStreamRetentionPeriodOutputResponse()"}
}

extension IncreaseStreamRetentionPeriodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct IncreaseStreamRetentionPeriodOutputResponse: Swift.Equatable {

    public init() {}
}

struct IncreaseStreamRetentionPeriodOutputResponseBody: Swift.Equatable {
}

extension IncreaseStreamRetentionPeriodOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InternalFailureException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

/// The processing of the request failed because of an unknown error, exception, or
///             failure.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgumentException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified parameter exceeds its restrictions, is not supported, or can't be used.
///             For more information, see the returned message.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSAccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSAccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension KMSAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ciphertext references a key that doesn't exist or that you don't have access
///             to.
public struct KMSAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSDisabledException(message: \(Swift.String(describing: message)))"}
}

extension KMSDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the specified customer master key (CMK) isn't
///             enabled.
public struct KMSDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSInvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension KMSInvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the state of the specified resource isn't valid
///             for this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
///                 Customer Master Key in the AWS Key Management Service Developer
///                 Guide.
public struct KMSInvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSInvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension KMSNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the specified entity or resource can't be
///             found.
public struct KMSNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSOptInRequired: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSOptInRequired(message: \(Swift.String(describing: message)))"}
}

extension KMSOptInRequired {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSOptInRequiredBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS access key ID needs a subscription for the service.
public struct KMSOptInRequired: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSOptInRequiredBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSOptInRequiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension KMSThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. For more information about
///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits in
///             the AWS Key Management Service Developer Guide.
public struct KMSThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource exceeds the maximum number allowed, or the number of
///             concurrent stream requests exceeds the maximum number allowed.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListShardsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShardsOutputError>
}

extension ListShardsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListShardsInput(exclusiveStartShardId: \(Swift.String(describing: exclusiveStartShardId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), shardFilter: \(Swift.String(describing: shardFilter)), streamCreationTimestamp: \(Swift.String(describing: streamCreationTimestamp)), streamName: \(Swift.String(describing: streamName)))"}
}

extension ListShardsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case shardFilter = "ShardFilter"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let shardFilter = shardFilter {
            try encodeContainer.encode(shardFilter, forKey: .shardFilter)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListShardsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShardsOutputError>
}

public struct ListShardsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListShardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListShardsOutputError>
}

public struct ListShardsInput: Swift.Equatable {
    /// Specify this parameter to indicate that you want to list the shards starting with
    ///             the shard whose ID immediately follows ExclusiveStartShardId.
    ///         If you don't specify this parameter, the default behavior is for
    ///                 ListShards to list the shards starting with the first one in the
    ///             stream.
    ///         You cannot specify this parameter if you specify NextToken.
    public let exclusiveStartShardId: Swift.String?
    /// The maximum number of shards to return in a single call to ListShards.
    ///             The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
    ///             which is also the default.
    ///         When the number of shards to be listed is greater than the value of
    ///                 MaxResults, the response contains a NextToken value that
    ///             you can use in a subsequent call to ListShards to list the next set of
    ///             shards.
    public let maxResults: Swift.Int?
    /// When the number of shards in the data stream is greater than the default value for
    ///             the MaxResults parameter, or if you explicitly specify a value for
    ///                 MaxResults that is less than the number of shards in the data stream,
    ///             the response includes a pagination token named NextToken. You can specify
    ///             this NextToken value in a subsequent call to ListShards to
    ///             list the next set of shards.
    ///         Don't specify StreamName or StreamCreationTimestamp if
    ///             you specify NextToken because the latter unambiguously identifies the
    ///             stream.
    ///         You can optionally specify a value for the MaxResults parameter when
    ///             you specify NextToken. If you specify a MaxResults value that
    ///             is less than the number of shards that the operation returns if you don't specify
    ///                 MaxResults, the response will contain a new NextToken
    ///             value. You can use the new NextToken value in a subsequent call to the
    ///                 ListShards operation.
    ///
    ///             Tokens expire after 300 seconds. When you obtain a value for
    ///                     NextToken in the response to a call to ListShards, you
    ///                 have 300 seconds to use that value. If you specify an expired token in a call to
    ///                     ListShards, you get
    ///                 ExpiredNextTokenException.
    ///
    public let nextToken: Swift.String?
    public let shardFilter: KinesisClientTypes.ShardFilter?
    /// Specify this input parameter to distinguish data streams that have the same name.
    ///             For example, if you create a data stream and then delete it, and you later create
    ///             another data stream with the same name, you can use this input parameter to specify
    ///             which of the two streams you want to list the shards for.
    ///         You cannot specify this parameter if you specify the NextToken
    ///             parameter.
    public let streamCreationTimestamp: ClientRuntime.Date?
    /// The name of the data stream whose shards you want to list.
    ///         You cannot specify this parameter if you specify the NextToken
    ///             parameter.
    public let streamName: Swift.String?

    public init (
        exclusiveStartShardId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        shardFilter: KinesisClientTypes.ShardFilter? = nil,
        streamCreationTimestamp: ClientRuntime.Date? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shardFilter = shardFilter
        self.streamCreationTimestamp = streamCreationTimestamp
        self.streamName = streamName
    }
}

struct ListShardsInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let nextToken: Swift.String?
    public let exclusiveStartShardId: Swift.String?
    public let maxResults: Swift.Int?
    public let streamCreationTimestamp: ClientRuntime.Date?
    public let shardFilter: KinesisClientTypes.ShardFilter?
}

extension ListShardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case shardFilter = "ShardFilter"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let shardFilterDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ShardFilter.self, forKey: .shardFilter)
        shardFilter = shardFilterDecoded
    }
}

extension ListShardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListShardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListShardsOutputError: Swift.Error, Swift.Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListShardsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListShardsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), shards: \(Swift.String(describing: shards)))"}
}

extension ListShardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListShardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.shards = output.shards
        } else {
            self.nextToken = nil
            self.shards = nil
        }
    }
}

public struct ListShardsOutputResponse: Swift.Equatable {
    /// When the number of shards in the data stream is greater than the default value for
    ///             the MaxResults parameter, or if you explicitly specify a value for
    ///                 MaxResults that is less than the number of shards in the data stream,
    ///             the response includes a pagination token named NextToken. You can specify
    ///             this NextToken value in a subsequent call to ListShards to
    ///             list the next set of shards. For more information about the use of this pagination token
    ///             when calling the ListShards operation, see ListShardsInput$NextToken.
    ///
    ///             Tokens expire after 300 seconds. When you obtain a value for
    ///                     NextToken in the response to a call to ListShards, you
    ///                 have 300 seconds to use that value. If you specify an expired token in a call to
    ///                     ListShards, you get
    ///                 ExpiredNextTokenException.
    ///
    public let nextToken: Swift.String?
    /// An array of JSON objects. Each object represents one shard and specifies the IDs of
    ///             the shard, the shard's parent, and the shard that's adjacent to the shard's parent. Each
    ///             object also contains the starting and ending hash keys and the starting and ending
    ///             sequence numbers for the shard.
    public let shards: [KinesisClientTypes.Shard]?

    public init (
        nextToken: Swift.String? = nil,
        shards: [KinesisClientTypes.Shard]? = nil
    )
    {
        self.nextToken = nextToken
        self.shards = shards
    }
}

struct ListShardsOutputResponseBody: Swift.Equatable {
    public let shards: [KinesisClientTypes.Shard]?
    public let nextToken: Swift.String?
}

extension ListShardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case shards = "Shards"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Shard?].self, forKey: .shards)
        var shardsDecoded0:[KinesisClientTypes.Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [KinesisClientTypes.Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamConsumersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamConsumersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamConsumersOutputError>
}

extension ListStreamConsumersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamConsumersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), streamARN: \(Swift.String(describing: streamARN)), streamCreationTimestamp: \(Swift.String(describing: streamCreationTimestamp)))"}
}

extension ListStreamConsumersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
    }
}

public struct ListStreamConsumersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamConsumersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamConsumersOutputError>
}

public struct ListStreamConsumersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamConsumersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamConsumersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamConsumersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamConsumersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamConsumersOutputError>
}

public struct ListStreamConsumersInput: Swift.Equatable {
    /// The maximum number of consumers that you want a single call of
    ///                 ListStreamConsumers to return.
    public let maxResults: Swift.Int?
    /// When the number of consumers that are registered with the data stream is greater than
    ///             the default value for the MaxResults parameter, or if you explicitly
    ///             specify a value for MaxResults that is less than the number of consumers
    ///             that are registered with the data stream, the response includes a pagination token named
    ///                 NextToken. You can specify this NextToken value in a
    ///             subsequent call to ListStreamConsumers to list the next set of registered
    ///             consumers.
    ///         Don't specify StreamName or StreamCreationTimestamp if you
    ///             specify NextToken because the latter unambiguously identifies the
    ///             stream.
    ///         You can optionally specify a value for the MaxResults parameter when you
    ///             specify NextToken. If you specify a MaxResults value that is
    ///             less than the number of consumers that the operation returns if you don't specify
    ///                 MaxResults, the response will contain a new NextToken
    ///             value. You can use the new NextToken value in a subsequent call to the
    ///                 ListStreamConsumers operation to list the next set of consumers.
    ///
    ///             Tokens expire after 300 seconds. When you obtain a value for
    ///                     NextToken in the response to a call to
    ///                     ListStreamConsumers, you have 300 seconds to use that value. If you
    ///                 specify an expired token in a call to ListStreamConsumers, you get
    ///                     ExpiredNextTokenException.
    ///
    public let nextToken: Swift.String?
    /// The ARN of the Kinesis data stream for which you want to list the registered
    ///             consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces.
    /// This member is required.
    public let streamARN: Swift.String?
    /// Specify this input parameter to distinguish data streams that have the same name. For
    ///             example, if you create a data stream and then delete it, and you later create another
    ///             data stream with the same name, you can use this input parameter to specify which of the
    ///             two streams you want to list the consumers for.
    ///         You can't specify this parameter if you specify the NextToken parameter.
    public let streamCreationTimestamp: ClientRuntime.Date?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamCreationTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamCreationTimestamp = streamCreationTimestamp
    }
}

struct ListStreamConsumersInputBody: Swift.Equatable {
    public let streamARN: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let streamCreationTimestamp: ClientRuntime.Date?
}

extension ListStreamConsumersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
    }
}

extension ListStreamConsumersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamConsumersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamConsumersOutputError: Swift.Error, Swift.Equatable {
    case expiredNextTokenException(ExpiredNextTokenException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamConsumersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamConsumersOutputResponse(consumers: \(Swift.String(describing: consumers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListStreamConsumersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamConsumersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.consumers = output.consumers
            self.nextToken = output.nextToken
        } else {
            self.consumers = nil
            self.nextToken = nil
        }
    }
}

public struct ListStreamConsumersOutputResponse: Swift.Equatable {
    /// An array of JSON objects. Each object represents one registered consumer.
    public let consumers: [KinesisClientTypes.Consumer]?
    /// When the number of consumers that are registered with the data stream is greater than
    ///             the default value for the MaxResults parameter, or if you explicitly
    ///             specify a value for MaxResults that is less than the number of registered
    ///             consumers, the response includes a pagination token named NextToken. You
    ///             can specify this NextToken value in a subsequent call to
    ///                 ListStreamConsumers to list the next set of registered consumers. For
    ///             more information about the use of this pagination token when calling the
    ///                 ListStreamConsumers operation, see ListStreamConsumersInput$NextToken.
    ///
    ///             Tokens expire after 300 seconds. When you obtain a value for
    ///                     NextToken in the response to a call to
    ///                     ListStreamConsumers, you have 300 seconds to use that value. If you
    ///                 specify an expired token in a call to ListStreamConsumers, you get
    ///                     ExpiredNextTokenException.
    ///
    public let nextToken: Swift.String?

    public init (
        consumers: [KinesisClientTypes.Consumer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumers = consumers
        self.nextToken = nextToken
    }
}

struct ListStreamConsumersOutputResponseBody: Swift.Equatable {
    public let consumers: [KinesisClientTypes.Consumer]?
    public let nextToken: Swift.String?
}

extension ListStreamConsumersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumers = "Consumers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumersContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Consumer?].self, forKey: .consumers)
        var consumersDecoded0:[KinesisClientTypes.Consumer]? = nil
        if let consumersContainer = consumersContainer {
            consumersDecoded0 = [KinesisClientTypes.Consumer]()
            for structure0 in consumersContainer {
                if let structure0 = structure0 {
                    consumersDecoded0?.append(structure0)
                }
            }
        }
        consumers = consumersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamsInput(exclusiveStartStreamName: \(Swift.String(describing: exclusiveStartStreamName)), limit: \(Swift.String(describing: limit)))"}
}

extension ListStreamsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartStreamName = "ExclusiveStartStreamName"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartStreamName = exclusiveStartStreamName {
            try encodeContainer.encode(exclusiveStartStreamName, forKey: .exclusiveStartStreamName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

/// Represents the input for ListStreams.
public struct ListStreamsInput: Swift.Equatable {
    /// The name of the stream to start the list with.
    public let exclusiveStartStreamName: Swift.String?
    /// The maximum number of streams to list.
    public let limit: Swift.Int?

    public init (
        exclusiveStartStreamName: Swift.String? = nil,
        limit: Swift.Int? = nil
    )
    {
        self.exclusiveStartStreamName = exclusiveStartStreamName
        self.limit = limit
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    public let limit: Swift.Int?
    public let exclusiveStartStreamName: Swift.String?
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartStreamName = "ExclusiveStartStreamName"
        case limit = "Limit"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartStreamName)
        exclusiveStartStreamName = exclusiveStartStreamNameDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamsOutputResponse(hasMoreStreams: \(Swift.String(describing: hasMoreStreams)), streamNames: \(Swift.String(describing: streamNames)))"}
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hasMoreStreams = output.hasMoreStreams
            self.streamNames = output.streamNames
        } else {
            self.hasMoreStreams = nil
            self.streamNames = nil
        }
    }
}

/// Represents the output for ListStreams.
public struct ListStreamsOutputResponse: Swift.Equatable {
    /// If set to true, there are more streams available to list.
    /// This member is required.
    public let hasMoreStreams: Swift.Bool?
    /// The names of the streams that are associated with the AWS account making the
    ///                 ListStreams request.
    /// This member is required.
    public let streamNames: [Swift.String]?

    public init (
        hasMoreStreams: Swift.Bool? = nil,
        streamNames: [Swift.String]? = nil
    )
    {
        self.hasMoreStreams = hasMoreStreams
        self.streamNames = streamNames
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    public let streamNames: [Swift.String]?
    public let hasMoreStreams: Swift.Bool?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreStreams = "HasMoreStreams"
        case streamNames = "StreamNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamNames)
        var streamNamesDecoded0:[Swift.String]? = nil
        if let streamNamesContainer = streamNamesContainer {
            streamNamesDecoded0 = [Swift.String]()
            for string0 in streamNamesContainer {
                if let string0 = string0 {
                    streamNamesDecoded0?.append(string0)
                }
            }
        }
        streamNames = streamNamesDecoded0
        let hasMoreStreamsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreStreams)
        hasMoreStreams = hasMoreStreamsDecoded
    }
}

public struct ListTagsForStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForStreamOutputError>
}

extension ListTagsForStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForStreamInput(exclusiveStartTagKey: \(Swift.String(describing: exclusiveStartTagKey)), limit: \(Swift.String(describing: limit)), streamName: \(Swift.String(describing: streamName)))"}
}

extension ListTagsForStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartTagKey = "ExclusiveStartTagKey"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartTagKey = exclusiveStartTagKey {
            try encodeContainer.encode(exclusiveStartTagKey, forKey: .exclusiveStartTagKey)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListTagsForStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForStreamOutputError>
}

public struct ListTagsForStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForStreamOutputError>
}

/// Represents the input for ListTagsForStream.
public struct ListTagsForStreamInput: Swift.Equatable {
    /// The key to use as the starting point for the list of tags. If this parameter is
    ///             set, ListTagsForStream gets all tags that occur after
    ///                 ExclusiveStartTagKey.
    public let exclusiveStartTagKey: Swift.String?
    /// The number of tags to return. If this number is less than the total number of tags
    ///             associated with the stream, HasMoreTags is set to true. To
    ///             list additional tags, set ExclusiveStartTagKey to the last key in the
    ///             response.
    public let limit: Swift.Int?
    /// The name of the stream.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        exclusiveStartTagKey: Swift.String? = nil,
        limit: Swift.Int? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.exclusiveStartTagKey = exclusiveStartTagKey
        self.limit = limit
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let exclusiveStartTagKey: Swift.String?
    public let limit: Swift.Int?
}

extension ListTagsForStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartTagKey = "ExclusiveStartTagKey"
        case limit = "Limit"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let exclusiveStartTagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartTagKey)
        exclusiveStartTagKey = exclusiveStartTagKeyDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTagsForStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForStreamOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForStreamOutputResponse(hasMoreTags: \(Swift.String(describing: hasMoreTags)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hasMoreTags = output.hasMoreTags
            self.tags = output.tags
        } else {
            self.hasMoreTags = nil
            self.tags = nil
        }
    }
}

/// Represents the output for ListTagsForStream.
public struct ListTagsForStreamOutputResponse: Swift.Equatable {
    /// If set to true, more tags are available. To request additional tags,
    ///             set ExclusiveStartTagKey to the key of the last tag returned.
    /// This member is required.
    public let hasMoreTags: Swift.Bool?
    /// A list of tags associated with StreamName, starting with the first tag
    ///             after ExclusiveStartTagKey and up to the specified Limit.
    ///
    /// This member is required.
    public let tags: [KinesisClientTypes.Tag]?

    public init (
        hasMoreTags: Swift.Bool? = nil,
        tags: [KinesisClientTypes.Tag]? = nil
    )
    {
        self.hasMoreTags = hasMoreTags
        self.tags = tags
    }
}

struct ListTagsForStreamOutputResponseBody: Swift.Equatable {
    public let tags: [KinesisClientTypes.Tag]?
    public let hasMoreTags: Swift.Bool?
}

extension ListTagsForStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreTags = "HasMoreTags"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let hasMoreTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreTags)
        hasMoreTags = hasMoreTagsDecoded
    }
}

public struct MergeShardsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeShardsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeShardsOutputError>
}

extension MergeShardsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MergeShardsInput(adjacentShardToMerge: \(Swift.String(describing: adjacentShardToMerge)), shardToMerge: \(Swift.String(describing: shardToMerge)), streamName: \(Swift.String(describing: streamName)))"}
}

extension MergeShardsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjacentShardToMerge = "AdjacentShardToMerge"
        case shardToMerge = "ShardToMerge"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjacentShardToMerge = adjacentShardToMerge {
            try encodeContainer.encode(adjacentShardToMerge, forKey: .adjacentShardToMerge)
        }
        if let shardToMerge = shardToMerge {
            try encodeContainer.encode(shardToMerge, forKey: .shardToMerge)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct MergeShardsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeShardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeShardsOutputError>
}

public struct MergeShardsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "MergeShardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<MergeShardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<MergeShardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<MergeShardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<MergeShardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<MergeShardsOutputError>
}

/// Represents the input for MergeShards.
public struct MergeShardsInput: Swift.Equatable {
    /// The shard ID of the adjacent shard for the merge.
    /// This member is required.
    public let adjacentShardToMerge: Swift.String?
    /// The shard ID of the shard to combine with the adjacent shard for the
    ///             merge.
    /// This member is required.
    public let shardToMerge: Swift.String?
    /// The name of the stream for the merge.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        adjacentShardToMerge: Swift.String? = nil,
        shardToMerge: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.adjacentShardToMerge = adjacentShardToMerge
        self.shardToMerge = shardToMerge
        self.streamName = streamName
    }
}

struct MergeShardsInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardToMerge: Swift.String?
    public let adjacentShardToMerge: Swift.String?
}

extension MergeShardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjacentShardToMerge = "AdjacentShardToMerge"
        case shardToMerge = "ShardToMerge"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardToMergeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardToMerge)
        shardToMerge = shardToMergeDecoded
        let adjacentShardToMergeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adjacentShardToMerge)
        adjacentShardToMerge = adjacentShardToMergeDecoded
    }
}

extension MergeShardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeShardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeShardsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeShardsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MergeShardsOutputResponse()"}
}

extension MergeShardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct MergeShardsOutputResponse: Swift.Equatable {

    public init() {}
}

struct MergeShardsOutputResponseBody: Swift.Equatable {
}

extension MergeShardsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KinesisClientTypes {
    public enum MetricsName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case incomingBytes
        case incomingRecords
        case iteratorAgeMilliseconds
        case outgoingBytes
        case outgoingRecords
        case readProvisionedThroughputExceeded
        case writeProvisionedThroughputExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricsName] {
            return [
                .all,
                .incomingBytes,
                .incomingRecords,
                .iteratorAgeMilliseconds,
                .outgoingBytes,
                .outgoingRecords,
                .readProvisionedThroughputExceeded,
                .writeProvisionedThroughputExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .incomingBytes: return "IncomingBytes"
            case .incomingRecords: return "IncomingRecords"
            case .iteratorAgeMilliseconds: return "IteratorAgeMilliseconds"
            case .outgoingBytes: return "OutgoingBytes"
            case .outgoingRecords: return "OutgoingRecords"
            case .readProvisionedThroughputExceeded: return "ReadProvisionedThroughputExceeded"
            case .writeProvisionedThroughputExceeded: return "WriteProvisionedThroughputExceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricsName(rawValue: rawValue) ?? MetricsName.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionedThroughputExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedThroughputExceededException(message: \(Swift.String(describing: message)))"}
}

extension ProvisionedThroughputExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request rate for the stream is too high, or the requested data is too large for
///             the available throughput. Reduce the frequency or size of your requests. For more
///             information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits in the
///                 Amazon Kinesis Data Streams Developer Guide, and <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">Error Retries and
///                 Exponential Backoff in AWS in the AWS General
///             Reference.
public struct ProvisionedThroughputExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedThroughputExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProvisionedThroughputExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRecordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

extension PutRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordInput(data: \(Swift.String(describing: data)), explicitHashKey: \(Swift.String(describing: explicitHashKey)), partitionKey: \(Swift.String(describing: partitionKey)), sequenceNumberForOrdering: \(Swift.String(describing: sequenceNumberForOrdering)), streamName: \(Swift.String(describing: streamName)))"}
}

extension PutRecordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
        case sequenceNumberForOrdering = "SequenceNumberForOrdering"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let explicitHashKey = explicitHashKey {
            try encodeContainer.encode(explicitHashKey, forKey: .explicitHashKey)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let sequenceNumberForOrdering = sequenceNumberForOrdering {
            try encodeContainer.encode(sequenceNumberForOrdering, forKey: .sequenceNumberForOrdering)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct PutRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

/// Represents the input for PutRecord.
public struct PutRecordInput: Swift.Equatable {
    /// The data blob to put into the record, which is base64-encoded when the blob is
    ///             serialized. When the data blob (the payload before base64-encoding) is added to the
    ///             partition key size, the total size must not exceed the maximum record size (1
    ///             MiB).
    /// This member is required.
    public let data: ClientRuntime.Data?
    /// The hash value used to explicitly determine the shard the data record is assigned
    ///             to by overriding the partition key hash.
    public let explicitHashKey: Swift.String?
    /// Determines which shard in the stream the data record is assigned to. Partition keys
    ///             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    ///             Kinesis Data Streams uses the partition key as input to a hash function that maps the
    ///             partition key and associated data to a specific shard. Specifically, an MD5 hash
    ///             function is used to map partition keys to 128-bit integer values and to map associated
    ///             data records to shards. As a result of this hashing mechanism, all data records with the
    ///             same partition key map to the same shard within the stream.
    /// This member is required.
    public let partitionKey: Swift.String?
    /// Guarantees strictly increasing sequence numbers, for puts from the same client and
    ///             to the same partition key. Usage: set the SequenceNumberForOrdering of
    ///             record n to the sequence number of record n-1
    ///             (as returned in the result when putting record n-1). If this
    ///             parameter is not set, records are coarsely ordered based on arrival time.
    public let sequenceNumberForOrdering: Swift.String?
    /// The name of the stream to put the data record into.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        data: ClientRuntime.Data? = nil,
        explicitHashKey: Swift.String? = nil,
        partitionKey: Swift.String? = nil,
        sequenceNumberForOrdering: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.data = data
        self.explicitHashKey = explicitHashKey
        self.partitionKey = partitionKey
        self.sequenceNumberForOrdering = sequenceNumberForOrdering
        self.streamName = streamName
    }
}

struct PutRecordInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let data: ClientRuntime.Data?
    public let partitionKey: Swift.String?
    public let explicitHashKey: Swift.String?
    public let sequenceNumberForOrdering: Swift.String?
}

extension PutRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
        case sequenceNumberForOrdering = "SequenceNumberForOrdering"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
        let explicitHashKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explicitHashKey)
        explicitHashKey = explicitHashKeyDecoded
        let sequenceNumberForOrderingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumberForOrdering)
        sequenceNumberForOrdering = sequenceNumberForOrderingDecoded
    }
}

extension PutRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordOutputResponse(encryptionType: \(Swift.String(describing: encryptionType)), sequenceNumber: \(Swift.String(describing: sequenceNumber)), shardId: \(Swift.String(describing: shardId)))"}
}

extension PutRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.encryptionType = output.encryptionType
            self.sequenceNumber = output.sequenceNumber
            self.shardId = output.shardId
        } else {
            self.encryptionType = nil
            self.sequenceNumber = nil
            self.shardId = nil
        }
    }
}

/// Represents the output for PutRecord.
public struct PutRecordOutputResponse: Swift.Equatable {
    /// The encryption type to use on the record. This parameter can be one of the
    ///             following values:
    ///
    ///
    ///
    ///                   NONE: Do not encrypt the records in the stream.
    ///
    ///
    ///
    ///                   KMS: Use server-side encryption on the records in the stream
    ///                     using a customer-managed AWS KMS key.
    ///
    ///
    public let encryptionType: KinesisClientTypes.EncryptionType?
    /// The sequence number identifier that was assigned to the put data record. The
    ///             sequence number for the record is unique across all records in the stream. A sequence
    ///             number is the identifier associated with every record put into the stream.
    /// This member is required.
    public let sequenceNumber: Swift.String?
    /// The shard ID of the shard where the data record was placed.
    /// This member is required.
    public let shardId: Swift.String?

    public init (
        encryptionType: KinesisClientTypes.EncryptionType? = nil,
        sequenceNumber: Swift.String? = nil,
        shardId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
    }
}

struct PutRecordOutputResponseBody: Swift.Equatable {
    public let shardId: Swift.String?
    public let sequenceNumber: Swift.String?
    public let encryptionType: KinesisClientTypes.EncryptionType?
}

extension PutRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

public struct PutRecordsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordsOutputError>
}

extension PutRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordsInput(records: \(Swift.String(describing: records)), streamName: \(Swift.String(describing: streamName)))"}
}

extension PutRecordsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records = "Records"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for putrecordsrequestentrylist0 in records {
                try recordsContainer.encode(putrecordsrequestentrylist0)
            }
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct PutRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordsOutputError>
}

public struct PutRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordsOutputError>
}

/// A PutRecords request.
public struct PutRecordsInput: Swift.Equatable {
    /// The records associated with the request.
    /// This member is required.
    public let records: [KinesisClientTypes.PutRecordsRequestEntry]?
    /// The stream name associated with the request.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        records: [KinesisClientTypes.PutRecordsRequestEntry]? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.records = records
        self.streamName = streamName
    }
}

struct PutRecordsInputBody: Swift.Equatable {
    public let records: [KinesisClientTypes.PutRecordsRequestEntry]?
    public let streamName: Swift.String?
}

extension PutRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records = "Records"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.PutRecordsRequestEntry?].self, forKey: .records)
        var recordsDecoded0:[KinesisClientTypes.PutRecordsRequestEntry]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [KinesisClientTypes.PutRecordsRequestEntry]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension PutRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedThroughputExceededException" : self = .provisionedThroughputExceededException(try ProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case provisionedThroughputExceededException(ProvisionedThroughputExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordsOutputResponse(encryptionType: \(Swift.String(describing: encryptionType)), failedRecordCount: \(Swift.String(describing: failedRecordCount)), records: \(Swift.String(describing: records)))"}
}

extension PutRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.encryptionType = output.encryptionType
            self.failedRecordCount = output.failedRecordCount
            self.records = output.records
        } else {
            self.encryptionType = nil
            self.failedRecordCount = nil
            self.records = nil
        }
    }
}

///
///             PutRecords results.
public struct PutRecordsOutputResponse: Swift.Equatable {
    /// The encryption type used on the records. This parameter can be one of the following
    ///             values:
    ///
    ///
    ///
    ///                   NONE: Do not encrypt the records.
    ///
    ///
    ///
    ///                   KMS: Use server-side encryption on the records using a
    ///                     customer-managed AWS KMS key.
    ///
    ///
    public let encryptionType: KinesisClientTypes.EncryptionType?
    /// The number of unsuccessfully processed records in a PutRecords
    ///             request.
    public let failedRecordCount: Swift.Int?
    /// An array of successfully and unsuccessfully processed record results, correlated
    ///             with the request by natural ordering. A record that is successfully added to a stream
    ///             includes SequenceNumber and ShardId in the result. A record
    ///             that fails to be added to a stream includes ErrorCode and
    ///                 ErrorMessage in the result.
    /// This member is required.
    public let records: [KinesisClientTypes.PutRecordsResultEntry]?

    public init (
        encryptionType: KinesisClientTypes.EncryptionType? = nil,
        failedRecordCount: Swift.Int? = nil,
        records: [KinesisClientTypes.PutRecordsResultEntry]? = nil
    )
    {
        self.encryptionType = encryptionType
        self.failedRecordCount = failedRecordCount
        self.records = records
    }
}

struct PutRecordsOutputResponseBody: Swift.Equatable {
    public let failedRecordCount: Swift.Int?
    public let records: [KinesisClientTypes.PutRecordsResultEntry]?
    public let encryptionType: KinesisClientTypes.EncryptionType?
}

extension PutRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case failedRecordCount = "FailedRecordCount"
        case records = "Records"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRecordCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedRecordCount)
        failedRecordCount = failedRecordCountDecoded
        let recordsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.PutRecordsResultEntry?].self, forKey: .records)
        var recordsDecoded0:[KinesisClientTypes.PutRecordsResultEntry]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [KinesisClientTypes.PutRecordsResultEntry]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension KinesisClientTypes.PutRecordsRequestEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
        case explicitHashKey = "ExplicitHashKey"
        case partitionKey = "PartitionKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let explicitHashKey = explicitHashKey {
            try encodeContainer.encode(explicitHashKey, forKey: .explicitHashKey)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let explicitHashKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explicitHashKey)
        explicitHashKey = explicitHashKeyDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
    }
}

extension KinesisClientTypes.PutRecordsRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordsRequestEntry(data: \(Swift.String(describing: data)), explicitHashKey: \(Swift.String(describing: explicitHashKey)), partitionKey: \(Swift.String(describing: partitionKey)))"}
}

extension KinesisClientTypes {
    /// Represents the output for PutRecords.
    public struct PutRecordsRequestEntry: Swift.Equatable {
        /// The data blob to put into the record, which is base64-encoded when the blob is
        ///             serialized. When the data blob (the payload before base64-encoding) is added to the
        ///             partition key size, the total size must not exceed the maximum record size (1
        ///             MiB).
        /// This member is required.
        public let data: ClientRuntime.Data?
        /// The hash value used to determine explicitly the shard that the data record is
        ///             assigned to by overriding the partition key hash.
        public let explicitHashKey: Swift.String?
        /// Determines which shard in the stream the data record is assigned to. Partition keys
        ///             are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
        ///             Kinesis Data Streams uses the partition key as input to a hash function that maps the
        ///             partition key and associated data to a specific shard. Specifically, an MD5 hash
        ///             function is used to map partition keys to 128-bit integer values and to map associated
        ///             data records to shards. As a result of this hashing mechanism, all data records with the
        ///             same partition key map to the same shard within the stream.
        /// This member is required.
        public let partitionKey: Swift.String?

        public init (
            data: ClientRuntime.Data? = nil,
            explicitHashKey: Swift.String? = nil,
            partitionKey: Swift.String? = nil
        )
        {
            self.data = data
            self.explicitHashKey = explicitHashKey
            self.partitionKey = partitionKey
        }
    }

}

extension KinesisClientTypes.PutRecordsResultEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension KinesisClientTypes.PutRecordsResultEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordsResultEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), sequenceNumber: \(Swift.String(describing: sequenceNumber)), shardId: \(Swift.String(describing: shardId)))"}
}

extension KinesisClientTypes {
    /// Represents the result of an individual record from a PutRecords
    ///             request. A record that is successfully added to a stream includes
    ///                 SequenceNumber and ShardId in the result. A record that
    ///             fails to be added to the stream includes ErrorCode and
    ///                 ErrorMessage in the result.
    public struct PutRecordsResultEntry: Swift.Equatable {
        /// The error code for an individual record result. ErrorCodes can be
        ///             either ProvisionedThroughputExceededException or
        ///                 InternalFailure.
        public let errorCode: Swift.String?
        /// The error message for an individual record result. An ErrorCode value
        ///             of ProvisionedThroughputExceededException has an error message that
        ///             includes the account ID, stream name, and shard ID. An ErrorCode value of
        ///                 InternalFailure has the error message "Internal Service
        ///                 Failure".
        public let errorMessage: Swift.String?
        /// The sequence number for an individual record result.
        public let sequenceNumber: Swift.String?
        /// The shard ID for an individual record result.
        public let shardId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            sequenceNumber: Swift.String? = nil,
            shardId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.sequenceNumber = sequenceNumber
            self.shardId = shardId
        }
    }

}

extension KinesisClientTypes.Record: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateArrivalTimestamp = "ApproximateArrivalTimestamp"
        case data = "Data"
        case encryptionType = "EncryptionType"
        case partitionKey = "PartitionKey"
        case sequenceNumber = "SequenceNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateArrivalTimestamp = approximateArrivalTimestamp {
            try encodeContainer.encode(approximateArrivalTimestamp.timeIntervalSince1970, forKey: .approximateArrivalTimestamp)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let partitionKey = partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let approximateArrivalTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approximateArrivalTimestamp)
        approximateArrivalTimestamp = approximateArrivalTimestampDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension KinesisClientTypes.Record: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Record(approximateArrivalTimestamp: \(Swift.String(describing: approximateArrivalTimestamp)), data: \(Swift.String(describing: data)), encryptionType: \(Swift.String(describing: encryptionType)), partitionKey: \(Swift.String(describing: partitionKey)), sequenceNumber: \(Swift.String(describing: sequenceNumber)))"}
}

extension KinesisClientTypes {
    /// The unit of data of the Kinesis data stream, which is composed of a sequence
    ///             number, a partition key, and a data blob.
    public struct Record: Swift.Equatable {
        /// The approximate time that the record was inserted into the stream.
        public let approximateArrivalTimestamp: ClientRuntime.Date?
        /// The data blob. The data in the blob is both opaque and immutable to Kinesis Data
        ///             Streams, which does not inspect, interpret, or change the data in the blob in any way.
        ///             When the data blob (the payload before base64-encoding) is added to the partition key
        ///             size, the total size must not exceed the maximum record size (1 MiB).
        /// This member is required.
        public let data: ClientRuntime.Data?
        /// The encryption type used on the record. This parameter can be one of the following
        ///             values:
        ///
        ///
        ///
        ///                   NONE: Do not encrypt the records in the stream.
        ///
        ///
        ///
        ///                   KMS: Use server-side encryption on the records in the stream
        ///                     using a customer-managed AWS KMS key.
        ///
        ///
        public let encryptionType: KinesisClientTypes.EncryptionType?
        /// Identifies which shard in the stream the data record is assigned to.
        /// This member is required.
        public let partitionKey: Swift.String?
        /// The unique identifier of the record within its shard.
        /// This member is required.
        public let sequenceNumber: Swift.String?

        public init (
            approximateArrivalTimestamp: ClientRuntime.Date? = nil,
            data: ClientRuntime.Data? = nil,
            encryptionType: KinesisClientTypes.EncryptionType? = nil,
            partitionKey: Swift.String? = nil,
            sequenceNumber: Swift.String? = nil
        )
        {
            self.approximateArrivalTimestamp = approximateArrivalTimestamp
            self.data = data
            self.encryptionType = encryptionType
            self.partitionKey = partitionKey
            self.sequenceNumber = sequenceNumber
        }
    }

}

public struct RegisterStreamConsumerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterStreamConsumerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterStreamConsumerOutputError>
}

extension RegisterStreamConsumerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterStreamConsumerInput(consumerName: \(Swift.String(describing: consumerName)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension RegisterStreamConsumerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerName = consumerName {
            try encodeContainer.encode(consumerName, forKey: .consumerName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct RegisterStreamConsumerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterStreamConsumerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterStreamConsumerOutputError>
}

public struct RegisterStreamConsumerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterStreamConsumerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterStreamConsumerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterStreamConsumerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterStreamConsumerOutputError>
}

public struct RegisterStreamConsumerInput: Swift.Equatable {
    /// For a given Kinesis data stream, each consumer must have a unique name. However,
    ///             consumer names don't have to be unique across data streams.
    /// This member is required.
    public let consumerName: Swift.String?
    /// The ARN of the Kinesis data stream that you want to register the consumer with. For
    ///             more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces.
    /// This member is required.
    public let streamARN: Swift.String?

    public init (
        consumerName: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.consumerName = consumerName
        self.streamARN = streamARN
    }
}

struct RegisterStreamConsumerInputBody: Swift.Equatable {
    public let streamARN: Swift.String?
    public let consumerName: Swift.String?
}

extension RegisterStreamConsumerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerName = "ConsumerName"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let consumerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerName)
        consumerName = consumerNameDecoded
    }
}

extension RegisterStreamConsumerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterStreamConsumerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterStreamConsumerOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterStreamConsumerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterStreamConsumerOutputResponse(consumer: \(Swift.String(describing: consumer)))"}
}

extension RegisterStreamConsumerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterStreamConsumerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.consumer = output.consumer
        } else {
            self.consumer = nil
        }
    }
}

public struct RegisterStreamConsumerOutputResponse: Swift.Equatable {
    /// An object that represents the details of the consumer you registered. When you
    ///             register a consumer, it gets an ARN that is generated by Kinesis Data Streams.
    /// This member is required.
    public let consumer: KinesisClientTypes.Consumer?

    public init (
        consumer: KinesisClientTypes.Consumer? = nil
    )
    {
        self.consumer = consumer
    }
}

struct RegisterStreamConsumerOutputResponseBody: Swift.Equatable {
    public let consumer: KinesisClientTypes.Consumer?
}

extension RegisterStreamConsumerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumer = "Consumer"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.Consumer.self, forKey: .consumer)
        consumer = consumerDecoded
    }
}

public struct RemoveTagsFromStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromStreamOutputError>
}

extension RemoveTagsFromStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromStreamInput(streamName: \(Swift.String(describing: streamName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromStreamOutputError>
}

public struct RemoveTagsFromStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromStreamOutputError>
}

/// Represents the input for RemoveTagsFromStream.
public struct RemoveTagsFromStreamInput: Swift.Equatable {
    /// The name of the stream.
    /// This member is required.
    public let streamName: Swift.String?
    /// A list of tag keys. Each corresponding tag is removed from the stream.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        streamName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.streamName = streamName
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromStreamInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension RemoveTagsFromStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName = "StreamName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromStreamOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromStreamOutputResponse()"}
}

extension RemoveTagsFromStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromStreamOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceInUseException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is not available for this operation. For successful operation, the
///             resource must be in the ACTIVE state.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource could not be found. The stream might not be specified
///             correctly.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisClientTypes {
    public enum ScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case uniformScaling
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalingType] {
            return [
                .uniformScaling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .uniformScaling: return "UNIFORM_SCALING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisClientTypes.SequenceNumberRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endingSequenceNumber = "EndingSequenceNumber"
        case startingSequenceNumber = "StartingSequenceNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingSequenceNumber = endingSequenceNumber {
            try encodeContainer.encode(endingSequenceNumber, forKey: .endingSequenceNumber)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let endingSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endingSequenceNumber)
        endingSequenceNumber = endingSequenceNumberDecoded
    }
}

extension KinesisClientTypes.SequenceNumberRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SequenceNumberRange(endingSequenceNumber: \(Swift.String(describing: endingSequenceNumber)), startingSequenceNumber: \(Swift.String(describing: startingSequenceNumber)))"}
}

extension KinesisClientTypes {
    /// The range of possible sequence numbers for the shard.
    public struct SequenceNumberRange: Swift.Equatable {
        /// The ending sequence number for the range. Shards that are in the OPEN state have an
        ///             ending sequence number of null.
        public let endingSequenceNumber: Swift.String?
        /// The starting sequence number for the range.
        /// This member is required.
        public let startingSequenceNumber: Swift.String?

        public init (
            endingSequenceNumber: Swift.String? = nil,
            startingSequenceNumber: Swift.String? = nil
        )
        {
            self.endingSequenceNumber = endingSequenceNumber
            self.startingSequenceNumber = startingSequenceNumber
        }
    }

}

extension KinesisClientTypes.Shard: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjacentParentShardId = "AdjacentParentShardId"
        case hashKeyRange = "HashKeyRange"
        case parentShardId = "ParentShardId"
        case sequenceNumberRange = "SequenceNumberRange"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjacentParentShardId = adjacentParentShardId {
            try encodeContainer.encode(adjacentParentShardId, forKey: .adjacentParentShardId)
        }
        if let hashKeyRange = hashKeyRange {
            try encodeContainer.encode(hashKeyRange, forKey: .hashKeyRange)
        }
        if let parentShardId = parentShardId {
            try encodeContainer.encode(parentShardId, forKey: .parentShardId)
        }
        if let sequenceNumberRange = sequenceNumberRange {
            try encodeContainer.encode(sequenceNumberRange, forKey: .sequenceNumberRange)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let parentShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentShardId)
        parentShardId = parentShardIdDecoded
        let adjacentParentShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adjacentParentShardId)
        adjacentParentShardId = adjacentParentShardIdDecoded
        let hashKeyRangeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.HashKeyRange.self, forKey: .hashKeyRange)
        hashKeyRange = hashKeyRangeDecoded
        let sequenceNumberRangeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.SequenceNumberRange.self, forKey: .sequenceNumberRange)
        sequenceNumberRange = sequenceNumberRangeDecoded
    }
}

extension KinesisClientTypes.Shard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Shard(adjacentParentShardId: \(Swift.String(describing: adjacentParentShardId)), hashKeyRange: \(Swift.String(describing: hashKeyRange)), parentShardId: \(Swift.String(describing: parentShardId)), sequenceNumberRange: \(Swift.String(describing: sequenceNumberRange)), shardId: \(Swift.String(describing: shardId)))"}
}

extension KinesisClientTypes {
    /// A uniquely identified group of data records in a Kinesis data stream.
    public struct Shard: Swift.Equatable {
        /// The shard ID of the shard adjacent to the shard's parent.
        public let adjacentParentShardId: Swift.String?
        /// The range of possible hash key values for the shard, which is a set of ordered
        ///             contiguous positive integers.
        /// This member is required.
        public let hashKeyRange: KinesisClientTypes.HashKeyRange?
        /// The shard ID of the shard's parent.
        public let parentShardId: Swift.String?
        /// The range of possible sequence numbers for the shard.
        /// This member is required.
        public let sequenceNumberRange: KinesisClientTypes.SequenceNumberRange?
        /// The unique identifier of the shard within the stream.
        /// This member is required.
        public let shardId: Swift.String?

        public init (
            adjacentParentShardId: Swift.String? = nil,
            hashKeyRange: KinesisClientTypes.HashKeyRange? = nil,
            parentShardId: Swift.String? = nil,
            sequenceNumberRange: KinesisClientTypes.SequenceNumberRange? = nil,
            shardId: Swift.String? = nil
        )
        {
            self.adjacentParentShardId = adjacentParentShardId
            self.hashKeyRange = hashKeyRange
            self.parentShardId = parentShardId
            self.sequenceNumberRange = sequenceNumberRange
            self.shardId = shardId
        }
    }

}

extension KinesisClientTypes.ShardFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardId = "ShardId"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ShardFilterType.self, forKey: .type)
        type = typeDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension KinesisClientTypes.ShardFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShardFilter(shardId: \(Swift.String(describing: shardId)), timestamp: \(Swift.String(describing: timestamp)), type: \(Swift.String(describing: type)))"}
}

extension KinesisClientTypes {
    public struct ShardFilter: Swift.Equatable {
        public let shardId: Swift.String?
        public let timestamp: ClientRuntime.Date?
        /// This member is required.
        public let type: KinesisClientTypes.ShardFilterType?

        public init (
            shardId: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: KinesisClientTypes.ShardFilterType? = nil
        )
        {
            self.shardId = shardId
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension KinesisClientTypes {
    public enum ShardFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterShardId
        case atLatest
        case atTimestamp
        case atTrimHorizon
        case fromTimestamp
        case fromTrimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [ShardFilterType] {
            return [
                .afterShardId,
                .atLatest,
                .atTimestamp,
                .atTrimHorizon,
                .fromTimestamp,
                .fromTrimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterShardId: return "AFTER_SHARD_ID"
            case .atLatest: return "AT_LATEST"
            case .atTimestamp: return "AT_TIMESTAMP"
            case .atTrimHorizon: return "AT_TRIM_HORIZON"
            case .fromTimestamp: return "FROM_TIMESTAMP"
            case .fromTrimHorizon: return "FROM_TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShardFilterType(rawValue: rawValue) ?? ShardFilterType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisClientTypes {
    public enum ShardIteratorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterSequenceNumber
        case atSequenceNumber
        case atTimestamp
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [ShardIteratorType] {
            return [
                .afterSequenceNumber,
                .atSequenceNumber,
                .atTimestamp,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
            case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
            case .atTimestamp: return "AT_TIMESTAMP"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShardIteratorType(rawValue: rawValue) ?? ShardIteratorType.sdkUnknown(rawValue)
        }
    }
}

public struct SplitShardInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SplitShardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SplitShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SplitShardOutputError>
}

extension SplitShardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SplitShardInput(newStartingHashKey: \(Swift.String(describing: newStartingHashKey)), shardToSplit: \(Swift.String(describing: shardToSplit)), streamName: \(Swift.String(describing: streamName)))"}
}

extension SplitShardInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newStartingHashKey = "NewStartingHashKey"
        case shardToSplit = "ShardToSplit"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newStartingHashKey = newStartingHashKey {
            try encodeContainer.encode(newStartingHashKey, forKey: .newStartingHashKey)
        }
        if let shardToSplit = shardToSplit {
            try encodeContainer.encode(shardToSplit, forKey: .shardToSplit)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct SplitShardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SplitShardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SplitShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SplitShardOutputError>
}

public struct SplitShardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SplitShardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SplitShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SplitShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SplitShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SplitShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SplitShardOutputError>
}

/// Represents the input for SplitShard.
public struct SplitShardInput: Swift.Equatable {
    /// A hash key value for the starting hash key of one of the child shards created by
    ///             the split. The hash key range for a given shard constitutes a set of ordered contiguous
    ///             positive integers. The value for NewStartingHashKey must be in the range of
    ///             hash keys being mapped into the shard. The NewStartingHashKey hash key
    ///             value and all higher hash key values in hash key range are distributed to one of the
    ///             child shards. All the lower hash key values in the range are distributed to the other
    ///             child shard.
    /// This member is required.
    public let newStartingHashKey: Swift.String?
    /// The shard ID of the shard to split.
    /// This member is required.
    public let shardToSplit: Swift.String?
    /// The name of the stream for the shard split.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        newStartingHashKey: Swift.String? = nil,
        shardToSplit: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.newStartingHashKey = newStartingHashKey
        self.shardToSplit = shardToSplit
        self.streamName = streamName
    }
}

struct SplitShardInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let shardToSplit: Swift.String?
    public let newStartingHashKey: Swift.String?
}

extension SplitShardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newStartingHashKey = "NewStartingHashKey"
        case shardToSplit = "ShardToSplit"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let shardToSplitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardToSplit)
        shardToSplit = shardToSplitDecoded
        let newStartingHashKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newStartingHashKey)
        newStartingHashKey = newStartingHashKeyDecoded
    }
}

extension SplitShardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SplitShardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SplitShardOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SplitShardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SplitShardOutputResponse()"}
}

extension SplitShardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SplitShardOutputResponse: Swift.Equatable {

    public init() {}
}

struct SplitShardOutputResponseBody: Swift.Equatable {
}

extension SplitShardOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct StartStreamEncryptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamEncryptionOutputError>
}

extension StartStreamEncryptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamEncryptionInput(encryptionType: \(Swift.String(describing: encryptionType)), keyId: \(Swift.String(describing: keyId)), streamName: \(Swift.String(describing: streamName)))"}
}

extension StartStreamEncryptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct StartStreamEncryptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamEncryptionOutputError>
}

public struct StartStreamEncryptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStreamEncryptionOutputError>
}

public struct StartStreamEncryptionInput: Swift.Equatable {
    /// The encryption type to use. The only valid value is KMS.
    /// This member is required.
    public let encryptionType: KinesisClientTypes.EncryptionType?
    /// The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    ///             an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    ///             owned by Kinesis Data Streams by specifying the alias
    ///             aws/kinesis.
    ///
    ///
    ///                 Key ARN example:
    ///                         arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    ///
    ///
    ///                 Alias ARN example:
    ///                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
    ///
    ///
    ///
    ///                 Globally unique key ID example:
    ///                         12345678-1234-1234-1234-123456789012
    ///
    ///
    ///
    ///                 Alias name example: alias/MyAliasName
    ///
    ///
    ///
    ///                 Master key owned by Kinesis Data Streams:
    ///                     alias/aws/kinesis
    ///
    ///
    ///
    /// This member is required.
    public let keyId: Swift.String?
    /// The name of the stream for which to start encrypting records.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        encryptionType: KinesisClientTypes.EncryptionType? = nil,
        keyId: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.keyId = keyId
        self.streamName = streamName
    }
}

struct StartStreamEncryptionInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let encryptionType: KinesisClientTypes.EncryptionType?
    public let keyId: Swift.String?
}

extension StartStreamEncryptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension StartStreamEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStreamEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSOptInRequired" : self = .kMSOptInRequired(try KMSOptInRequired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingException" : self = .kMSThrottlingException(try KMSThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStreamEncryptionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case kMSOptInRequired(KMSOptInRequired)
    case kMSThrottlingException(KMSThrottlingException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStreamEncryptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamEncryptionOutputResponse()"}
}

extension StartStreamEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartStreamEncryptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartStreamEncryptionOutputResponseBody: Swift.Equatable {
}

extension StartStreamEncryptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KinesisClientTypes.StartingPosition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sequenceNumber = "SequenceNumber"
        case timestamp = "Timestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ShardIteratorType.self, forKey: .type)
        type = typeDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension KinesisClientTypes.StartingPosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartingPosition(sequenceNumber: \(Swift.String(describing: sequenceNumber)), timestamp: \(Swift.String(describing: timestamp)), type: \(Swift.String(describing: type)))"}
}

extension KinesisClientTypes {
    ///
    public struct StartingPosition: Swift.Equatable {
        /// The sequence number of the data record in the shard from which to start streaming. To
        ///             specify a sequence number, set StartingPosition to
        ///                 AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER.
        public let sequenceNumber: Swift.String?
        /// The time stamp of the data record from which to start reading. To specify a time
        ///             stamp, set StartingPosition to Type AT_TIMESTAMP. A time stamp
        ///             is the Unix epoch date with precision in milliseconds. For example,
        ///                 2016-04-04T19:58:46.480-00:00 or 1459799926.480. If a
        ///             record with this exact time stamp does not exist, records will be streamed from the next
        ///             (later) record. If the time stamp is older than the current trim horizon, records will
        ///             be streamed from the oldest untrimmed data record (TRIM_HORIZON).
        public let timestamp: ClientRuntime.Date?
        /// You can set the starting position to one of the following values:
        ///
        ///             AT_SEQUENCE_NUMBER: Start streaming from the position denoted by the
        ///             sequence number specified in the SequenceNumber field.
        ///
        ///             AFTER_SEQUENCE_NUMBER: Start streaming right after the position denoted
        ///             by the sequence number specified in the SequenceNumber field.
        ///
        ///             AT_TIMESTAMP: Start streaming from the position denoted by the time stamp
        ///             specified in the Timestamp field.
        ///
        ///             TRIM_HORIZON: Start streaming at the last untrimmed record in the shard,
        ///             which is the oldest data record in the shard.
        ///
        ///             LATEST: Start streaming just after the most recent record in the shard,
        ///             so that you always read the most recent data in the shard.
        /// This member is required.
        public let type: KinesisClientTypes.ShardIteratorType?

        public init (
            sequenceNumber: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            type: KinesisClientTypes.ShardIteratorType? = nil
        )
        {
            self.sequenceNumber = sequenceNumber
            self.timestamp = timestamp
            self.type = type
        }
    }

}

public struct StopStreamEncryptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamEncryptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamEncryptionOutputError>
}

extension StopStreamEncryptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStreamEncryptionInput(encryptionType: \(Swift.String(describing: encryptionType)), keyId: \(Swift.String(describing: keyId)), streamName: \(Swift.String(describing: streamName)))"}
}

extension StopStreamEncryptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct StopStreamEncryptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamEncryptionOutputError>
}

public struct StopStreamEncryptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamEncryptionOutputError>
}

public struct StopStreamEncryptionInput: Swift.Equatable {
    /// The encryption type. The only valid value is KMS.
    /// This member is required.
    public let encryptionType: KinesisClientTypes.EncryptionType?
    /// The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    ///             be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    ///             an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    ///             owned by Kinesis Data Streams by specifying the alias
    ///             aws/kinesis.
    ///
    ///
    ///                 Key ARN example:
    ///                         arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    ///
    ///
    ///                 Alias ARN example:
    ///                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
    ///
    ///
    ///
    ///                 Globally unique key ID example:
    ///                         12345678-1234-1234-1234-123456789012
    ///
    ///
    ///
    ///                 Alias name example: alias/MyAliasName
    ///
    ///
    ///
    ///                 Master key owned by Kinesis Data Streams:
    ///                     alias/aws/kinesis
    ///
    ///
    ///
    /// This member is required.
    public let keyId: Swift.String?
    /// The name of the stream on which to stop encrypting records.
    /// This member is required.
    public let streamName: Swift.String?

    public init (
        encryptionType: KinesisClientTypes.EncryptionType? = nil,
        keyId: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.keyId = keyId
        self.streamName = streamName
    }
}

struct StopStreamEncryptionInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let encryptionType: KinesisClientTypes.EncryptionType?
    public let keyId: Swift.String?
}

extension StopStreamEncryptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension StopStreamEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStreamEncryptionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamEncryptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStreamEncryptionOutputResponse()"}
}

extension StopStreamEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopStreamEncryptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopStreamEncryptionOutputResponseBody: Swift.Equatable {
}

extension StopStreamEncryptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KinesisClientTypes.StreamDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case enhancedMonitoring = "EnhancedMonitoring"
        case hasMoreShards = "HasMoreShards"
        case keyId = "KeyId"
        case retentionPeriodHours = "RetentionPeriodHours"
        case shards = "Shards"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
        case streamStatus = "StreamStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            var enhancedMonitoringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enhancedMonitoring)
            for enhancedmonitoringlist0 in enhancedMonitoring {
                try enhancedMonitoringContainer.encode(enhancedmonitoringlist0)
            }
        }
        if let hasMoreShards = hasMoreShards {
            try encodeContainer.encode(hasMoreShards, forKey: .hasMoreShards)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for shardlist0 in shards {
                try shardsContainer.encode(shardlist0)
            }
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let shardsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Shard?].self, forKey: .shards)
        var shardsDecoded0:[KinesisClientTypes.Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [KinesisClientTypes.Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let hasMoreShardsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreShards)
        hasMoreShards = hasMoreShardsDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let enhancedMonitoringContainer = try containerValues.decodeIfPresent([KinesisClientTypes.EnhancedMetrics?].self, forKey: .enhancedMonitoring)
        var enhancedMonitoringDecoded0:[KinesisClientTypes.EnhancedMetrics]? = nil
        if let enhancedMonitoringContainer = enhancedMonitoringContainer {
            enhancedMonitoringDecoded0 = [KinesisClientTypes.EnhancedMetrics]()
            for structure0 in enhancedMonitoringContainer {
                if let structure0 = structure0 {
                    enhancedMonitoringDecoded0?.append(structure0)
                }
            }
        }
        enhancedMonitoring = enhancedMonitoringDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension KinesisClientTypes.StreamDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamDescription(encryptionType: \(Swift.String(describing: encryptionType)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), hasMoreShards: \(Swift.String(describing: hasMoreShards)), keyId: \(Swift.String(describing: keyId)), retentionPeriodHours: \(Swift.String(describing: retentionPeriodHours)), shards: \(Swift.String(describing: shards)), streamARN: \(Swift.String(describing: streamARN)), streamCreationTimestamp: \(Swift.String(describing: streamCreationTimestamp)), streamName: \(Swift.String(describing: streamName)), streamStatus: \(Swift.String(describing: streamStatus)))"}
}

extension KinesisClientTypes {
    /// Represents the output for DescribeStream.
    public struct StreamDescription: Swift.Equatable {
        /// The server-side encryption type used on the stream. This parameter can be one of
        ///             the following values:
        ///
        ///
        ///
        ///                   NONE: Do not encrypt the records in the stream.
        ///
        ///
        ///
        ///                   KMS: Use server-side encryption on the records in the stream
        ///                     using a customer-managed AWS KMS key.
        ///
        ///
        public let encryptionType: KinesisClientTypes.EncryptionType?
        /// Represents the current enhanced monitoring settings of the stream.
        /// This member is required.
        public let enhancedMonitoring: [KinesisClientTypes.EnhancedMetrics]?
        /// If set to true, more shards in the stream are available to
        ///             describe.
        /// This member is required.
        public let hasMoreShards: Swift.Bool?
        /// The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        ///             be a globally unique identifier, a fully specified ARN to either an alias or a key, or
        ///             an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
        ///             Streams by specifying the alias aws/kinesis.
        ///
        ///
        ///                 Key ARN example:
        ///                         arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
        ///
        ///
        ///
        ///                 Alias ARN example:
        ///                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
        ///
        ///
        ///
        ///                 Globally unique key ID example:
        ///                         12345678-1234-1234-1234-123456789012
        ///
        ///
        ///
        ///                 Alias name example: alias/MyAliasName
        ///
        ///
        ///
        ///                 Master key owned by Kinesis Data Streams:
        ///                     alias/aws/kinesis
        ///
        ///
        ///
        public let keyId: Swift.String?
        /// The current retention period, in hours. Minimum value of 24. Maximum value of
        ///             168.
        /// This member is required.
        public let retentionPeriodHours: Swift.Int?
        /// The shards that comprise the stream.
        /// This member is required.
        public let shards: [KinesisClientTypes.Shard]?
        /// The Amazon Resource Name (ARN) for the stream being described.
        /// This member is required.
        public let streamARN: Swift.String?
        /// The approximate time that the stream was created.
        /// This member is required.
        public let streamCreationTimestamp: ClientRuntime.Date?
        /// The name of the stream being described.
        /// This member is required.
        public let streamName: Swift.String?
        /// The current status of the stream being described. The stream status is one of the
        ///             following states:
        ///
        ///
        ///
        ///                     CREATING - The stream is being created. Kinesis Data Streams
        ///                     immediately returns and sets StreamStatus to
        ///                     CREATING.
        ///
        ///
        ///
        ///                     DELETING - The stream is being deleted. The specified stream is in
        ///                     the DELETING state until Kinesis Data Streams completes the
        ///                     deletion.
        ///
        ///
        ///
        ///                     ACTIVE - The stream exists and is ready for read and write
        ///                     operations or deletion. You should perform read and write operations only on an
        ///                         ACTIVE stream.
        ///
        ///
        ///
        ///                     UPDATING - Shards in the stream are being merged or split. Read and
        ///                     write operations continue to work while the stream is in the
        ///                         UPDATING state.
        ///
        ///
        /// This member is required.
        public let streamStatus: KinesisClientTypes.StreamStatus?

        public init (
            encryptionType: KinesisClientTypes.EncryptionType? = nil,
            enhancedMonitoring: [KinesisClientTypes.EnhancedMetrics]? = nil,
            hasMoreShards: Swift.Bool? = nil,
            keyId: Swift.String? = nil,
            retentionPeriodHours: Swift.Int? = nil,
            shards: [KinesisClientTypes.Shard]? = nil,
            streamARN: Swift.String? = nil,
            streamCreationTimestamp: ClientRuntime.Date? = nil,
            streamName: Swift.String? = nil,
            streamStatus: KinesisClientTypes.StreamStatus? = nil
        )
        {
            self.encryptionType = encryptionType
            self.enhancedMonitoring = enhancedMonitoring
            self.hasMoreShards = hasMoreShards
            self.keyId = keyId
            self.retentionPeriodHours = retentionPeriodHours
            self.shards = shards
            self.streamARN = streamARN
            self.streamCreationTimestamp = streamCreationTimestamp
            self.streamName = streamName
            self.streamStatus = streamStatus
        }
    }

}

extension KinesisClientTypes.StreamDescriptionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerCount = "ConsumerCount"
        case encryptionType = "EncryptionType"
        case enhancedMonitoring = "EnhancedMonitoring"
        case keyId = "KeyId"
        case openShardCount = "OpenShardCount"
        case retentionPeriodHours = "RetentionPeriodHours"
        case streamARN = "StreamARN"
        case streamCreationTimestamp = "StreamCreationTimestamp"
        case streamName = "StreamName"
        case streamStatus = "StreamStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerCount = consumerCount {
            try encodeContainer.encode(consumerCount, forKey: .consumerCount)
        }
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            var enhancedMonitoringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enhancedMonitoring)
            for enhancedmonitoringlist0 in enhancedMonitoring {
                try enhancedMonitoringContainer.encode(enhancedmonitoringlist0)
            }
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let openShardCount = openShardCount {
            try encodeContainer.encode(openShardCount, forKey: .openShardCount)
        }
        if let retentionPeriodHours = retentionPeriodHours {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamCreationTimestamp = streamCreationTimestamp {
            try encodeContainer.encode(streamCreationTimestamp.timeIntervalSince1970, forKey: .streamCreationTimestamp)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours)
        retentionPeriodHours = retentionPeriodHoursDecoded
        let streamCreationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .streamCreationTimestamp)
        streamCreationTimestamp = streamCreationTimestampDecoded
        let enhancedMonitoringContainer = try containerValues.decodeIfPresent([KinesisClientTypes.EnhancedMetrics?].self, forKey: .enhancedMonitoring)
        var enhancedMonitoringDecoded0:[KinesisClientTypes.EnhancedMetrics]? = nil
        if let enhancedMonitoringContainer = enhancedMonitoringContainer {
            enhancedMonitoringDecoded0 = [KinesisClientTypes.EnhancedMetrics]()
            for structure0 in enhancedMonitoringContainer {
                if let structure0 = structure0 {
                    enhancedMonitoringDecoded0?.append(structure0)
                }
            }
        }
        enhancedMonitoring = enhancedMonitoringDecoded0
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let openShardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openShardCount)
        openShardCount = openShardCountDecoded
        let consumerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumerCount)
        consumerCount = consumerCountDecoded
    }
}

extension KinesisClientTypes.StreamDescriptionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamDescriptionSummary(consumerCount: \(Swift.String(describing: consumerCount)), encryptionType: \(Swift.String(describing: encryptionType)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), keyId: \(Swift.String(describing: keyId)), openShardCount: \(Swift.String(describing: openShardCount)), retentionPeriodHours: \(Swift.String(describing: retentionPeriodHours)), streamARN: \(Swift.String(describing: streamARN)), streamCreationTimestamp: \(Swift.String(describing: streamCreationTimestamp)), streamName: \(Swift.String(describing: streamName)), streamStatus: \(Swift.String(describing: streamStatus)))"}
}

extension KinesisClientTypes {
    /// Represents the output for DescribeStreamSummary
    ///
    public struct StreamDescriptionSummary: Swift.Equatable {
        /// The number of enhanced fan-out consumers registered with the stream.
        public let consumerCount: Swift.Int?
        /// The encryption type used. This value is one of the following:
        ///
        ///
        ///
        ///                   KMS
        ///
        ///
        ///
        ///
        ///                   NONE
        ///
        ///
        ///
        public let encryptionType: KinesisClientTypes.EncryptionType?
        /// Represents the current enhanced monitoring settings of the stream.
        /// This member is required.
        public let enhancedMonitoring: [KinesisClientTypes.EnhancedMetrics]?
        /// The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        ///             be a globally unique identifier, a fully specified ARN to either an alias or a key, or
        ///             an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
        ///             Streams by specifying the alias aws/kinesis.
        ///
        ///
        ///                 Key ARN example:
        ///                         arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
        ///
        ///
        ///
        ///                 Alias ARN example:
        ///                         arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
        ///
        ///
        ///
        ///                 Globally unique key ID example:
        ///                         12345678-1234-1234-1234-123456789012
        ///
        ///
        ///
        ///                 Alias name example: alias/MyAliasName
        ///
        ///
        ///
        ///                 Master key owned by Kinesis Data Streams:
        ///                     alias/aws/kinesis
        ///
        ///
        ///
        public let keyId: Swift.String?
        /// The number of open shards in the stream.
        /// This member is required.
        public let openShardCount: Swift.Int?
        /// The current retention period, in hours.
        /// This member is required.
        public let retentionPeriodHours: Swift.Int?
        /// The Amazon Resource Name (ARN) for the stream being described.
        /// This member is required.
        public let streamARN: Swift.String?
        /// The approximate time that the stream was created.
        /// This member is required.
        public let streamCreationTimestamp: ClientRuntime.Date?
        /// The name of the stream being described.
        /// This member is required.
        public let streamName: Swift.String?
        /// The current status of the stream being described. The stream status is one of the
        ///             following states:
        ///
        ///
        ///
        ///                     CREATING - The stream is being created. Kinesis Data Streams
        ///                     immediately returns and sets StreamStatus to
        ///                     CREATING.
        ///
        ///
        ///
        ///                     DELETING - The stream is being deleted. The specified stream is in
        ///                     the DELETING state until Kinesis Data Streams completes the
        ///                     deletion.
        ///
        ///
        ///
        ///                     ACTIVE - The stream exists and is ready for read and write
        ///                     operations or deletion. You should perform read and write operations only on an
        ///                         ACTIVE stream.
        ///
        ///
        ///
        ///                     UPDATING - Shards in the stream are being merged or split. Read and
        ///                     write operations continue to work while the stream is in the
        ///                         UPDATING state.
        ///
        ///
        /// This member is required.
        public let streamStatus: KinesisClientTypes.StreamStatus?

        public init (
            consumerCount: Swift.Int? = nil,
            encryptionType: KinesisClientTypes.EncryptionType? = nil,
            enhancedMonitoring: [KinesisClientTypes.EnhancedMetrics]? = nil,
            keyId: Swift.String? = nil,
            openShardCount: Swift.Int? = nil,
            retentionPeriodHours: Swift.Int? = nil,
            streamARN: Swift.String? = nil,
            streamCreationTimestamp: ClientRuntime.Date? = nil,
            streamName: Swift.String? = nil,
            streamStatus: KinesisClientTypes.StreamStatus? = nil
        )
        {
            self.consumerCount = consumerCount
            self.encryptionType = encryptionType
            self.enhancedMonitoring = enhancedMonitoring
            self.keyId = keyId
            self.openShardCount = openShardCount
            self.retentionPeriodHours = retentionPeriodHours
            self.streamARN = streamARN
            self.streamCreationTimestamp = streamCreationTimestamp
            self.streamName = streamName
            self.streamStatus = streamStatus
        }
    }

}

extension KinesisClientTypes {
    public enum StreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisClientTypes.SubscribeToShardEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childShards = "ChildShards"
        case continuationSequenceNumber = "ContinuationSequenceNumber"
        case millisBehindLatest = "MillisBehindLatest"
        case records = "Records"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childShards = childShards {
            var childShardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .childShards)
            for childshardlist0 in childShards {
                try childShardsContainer.encode(childshardlist0)
            }
        }
        if let continuationSequenceNumber = continuationSequenceNumber {
            try encodeContainer.encode(continuationSequenceNumber, forKey: .continuationSequenceNumber)
        }
        if let millisBehindLatest = millisBehindLatest {
            try encodeContainer.encode(millisBehindLatest, forKey: .millisBehindLatest)
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for recordlist0 in records {
                try recordsContainer.encode(recordlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[KinesisClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [KinesisClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let continuationSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationSequenceNumber)
        continuationSequenceNumber = continuationSequenceNumberDecoded
        let millisBehindLatestDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .millisBehindLatest)
        millisBehindLatest = millisBehindLatestDecoded
        let childShardsContainer = try containerValues.decodeIfPresent([KinesisClientTypes.ChildShard?].self, forKey: .childShards)
        var childShardsDecoded0:[KinesisClientTypes.ChildShard]? = nil
        if let childShardsContainer = childShardsContainer {
            childShardsDecoded0 = [KinesisClientTypes.ChildShard]()
            for structure0 in childShardsContainer {
                if let structure0 = structure0 {
                    childShardsDecoded0?.append(structure0)
                }
            }
        }
        childShards = childShardsDecoded0
    }
}

extension KinesisClientTypes.SubscribeToShardEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToShardEvent(childShards: \(Swift.String(describing: childShards)), continuationSequenceNumber: \(Swift.String(describing: continuationSequenceNumber)), millisBehindLatest: \(Swift.String(describing: millisBehindLatest)), records: \(Swift.String(describing: records)))"}
}

extension KinesisClientTypes {
    /// After you call SubscribeToShard, Kinesis Data Streams sends events
    ///             of this type over an HTTP/2 connection to your consumer.
    public struct SubscribeToShardEvent: Swift.Equatable {
        public let childShards: [KinesisClientTypes.ChildShard]?
        /// Use this as SequenceNumber in the next call to SubscribeToShard, with StartingPosition set to
        ///                 AT_SEQUENCE_NUMBER or AFTER_SEQUENCE_NUMBER. Use
        ///                 ContinuationSequenceNumber for checkpointing because it captures your
        ///             shard progress even when no data is written to the shard.
        /// This member is required.
        public let continuationSequenceNumber: Swift.String?
        /// The number of milliseconds the read records are from the tip of the stream, indicating
        ///             how far behind current time the consumer is. A value of zero indicates that record
        ///             processing is caught up, and there are no new records to process at this moment.
        /// This member is required.
        public let millisBehindLatest: Swift.Int?
        ///
        /// This member is required.
        public let records: [KinesisClientTypes.Record]?

        public init (
            childShards: [KinesisClientTypes.ChildShard]? = nil,
            continuationSequenceNumber: Swift.String? = nil,
            millisBehindLatest: Swift.Int? = nil,
            records: [KinesisClientTypes.Record]? = nil
        )
        {
            self.childShards = childShards
            self.continuationSequenceNumber = continuationSequenceNumber
            self.millisBehindLatest = millisBehindLatest
            self.records = records
        }
    }

}

extension KinesisClientTypes.SubscribeToShardEventStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case internalfailureexception = "InternalFailureException"
        case kmsaccessdeniedexception = "KMSAccessDeniedException"
        case kmsdisabledexception = "KMSDisabledException"
        case kmsinvalidstateexception = "KMSInvalidStateException"
        case kmsnotfoundexception = "KMSNotFoundException"
        case kmsoptinrequired = "KMSOptInRequired"
        case kmsthrottlingexception = "KMSThrottlingException"
        case resourceinuseexception = "ResourceInUseException"
        case resourcenotfoundexception = "ResourceNotFoundException"
        case subscribetoshardevent = "SubscribeToShardEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internalfailureexception(internalfailureexception):
                try container.encode(internalfailureexception, forKey: .internalfailureexception)
            case let .kmsaccessdeniedexception(kmsaccessdeniedexception):
                try container.encode(kmsaccessdeniedexception, forKey: .kmsaccessdeniedexception)
            case let .kmsdisabledexception(kmsdisabledexception):
                try container.encode(kmsdisabledexception, forKey: .kmsdisabledexception)
            case let .kmsinvalidstateexception(kmsinvalidstateexception):
                try container.encode(kmsinvalidstateexception, forKey: .kmsinvalidstateexception)
            case let .kmsnotfoundexception(kmsnotfoundexception):
                try container.encode(kmsnotfoundexception, forKey: .kmsnotfoundexception)
            case let .kmsoptinrequired(kmsoptinrequired):
                try container.encode(kmsoptinrequired, forKey: .kmsoptinrequired)
            case let .kmsthrottlingexception(kmsthrottlingexception):
                try container.encode(kmsthrottlingexception, forKey: .kmsthrottlingexception)
            case let .resourceinuseexception(resourceinuseexception):
                try container.encode(resourceinuseexception, forKey: .resourceinuseexception)
            case let .resourcenotfoundexception(resourcenotfoundexception):
                try container.encode(resourcenotfoundexception, forKey: .resourcenotfoundexception)
            case let .subscribetoshardevent(subscribetoshardevent):
                try container.encode(subscribetoshardevent, forKey: .subscribetoshardevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let subscribetoshardeventDecoded = try values.decodeIfPresent(KinesisClientTypes.SubscribeToShardEvent.self, forKey: .subscribetoshardevent)
        if let subscribetoshardevent = subscribetoshardeventDecoded {
            self = .subscribetoshardevent(subscribetoshardevent)
            return
        }
        let resourcenotfoundexceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourcenotfoundexception)
        if let resourcenotfoundexception = resourcenotfoundexceptionDecoded {
            self = .resourcenotfoundexception(resourcenotfoundexception)
            return
        }
        let resourceinuseexceptionDecoded = try values.decodeIfPresent(ResourceInUseException.self, forKey: .resourceinuseexception)
        if let resourceinuseexception = resourceinuseexceptionDecoded {
            self = .resourceinuseexception(resourceinuseexception)
            return
        }
        let kmsdisabledexceptionDecoded = try values.decodeIfPresent(KMSDisabledException.self, forKey: .kmsdisabledexception)
        if let kmsdisabledexception = kmsdisabledexceptionDecoded {
            self = .kmsdisabledexception(kmsdisabledexception)
            return
        }
        let kmsinvalidstateexceptionDecoded = try values.decodeIfPresent(KMSInvalidStateException.self, forKey: .kmsinvalidstateexception)
        if let kmsinvalidstateexception = kmsinvalidstateexceptionDecoded {
            self = .kmsinvalidstateexception(kmsinvalidstateexception)
            return
        }
        let kmsaccessdeniedexceptionDecoded = try values.decodeIfPresent(KMSAccessDeniedException.self, forKey: .kmsaccessdeniedexception)
        if let kmsaccessdeniedexception = kmsaccessdeniedexceptionDecoded {
            self = .kmsaccessdeniedexception(kmsaccessdeniedexception)
            return
        }
        let kmsnotfoundexceptionDecoded = try values.decodeIfPresent(KMSNotFoundException.self, forKey: .kmsnotfoundexception)
        if let kmsnotfoundexception = kmsnotfoundexceptionDecoded {
            self = .kmsnotfoundexception(kmsnotfoundexception)
            return
        }
        let kmsoptinrequiredDecoded = try values.decodeIfPresent(KMSOptInRequired.self, forKey: .kmsoptinrequired)
        if let kmsoptinrequired = kmsoptinrequiredDecoded {
            self = .kmsoptinrequired(kmsoptinrequired)
            return
        }
        let kmsthrottlingexceptionDecoded = try values.decodeIfPresent(KMSThrottlingException.self, forKey: .kmsthrottlingexception)
        if let kmsthrottlingexception = kmsthrottlingexceptionDecoded {
            self = .kmsthrottlingexception(kmsthrottlingexception)
            return
        }
        let internalfailureexceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalfailureexception)
        if let internalfailureexception = internalfailureexceptionDecoded {
            self = .internalfailureexception(internalfailureexception)
            return
        }
        self = .sdkUnknown("")
    }
}

extension KinesisClientTypes {
    /// This is a tagged union for all of the types of events an enhanced fan-out consumer can
    ///             receive over HTTP/2 after a call to SubscribeToShard.
    public enum SubscribeToShardEventStream: Swift.Equatable {
        /// After you call SubscribeToShard, Kinesis Data Streams sends events
        ///             of this type to your consumer. For an example of how to handle these events, see <a href="/streams/latest/dev/building-enhanced-consumers-api.html">Enhanced Fan-Out
        ///                 Using the Kinesis Data Streams API.
        case subscribetoshardevent(KinesisClientTypes.SubscribeToShardEvent)
        /// The requested resource could not be found. The stream might not be specified
        ///             correctly.
        case resourcenotfoundexception(ResourceNotFoundException)
        /// The resource is not available for this operation. For successful operation, the
        ///             resource must be in the ACTIVE state.
        case resourceinuseexception(ResourceInUseException)
        /// The request was rejected because the specified customer master key (CMK) isn't
        ///             enabled.
        case kmsdisabledexception(KMSDisabledException)
        /// The request was rejected because the state of the specified resource isn't valid
        ///             for this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
        ///                 Customer Master Key in the AWS Key Management Service Developer
        ///                 Guide.
        case kmsinvalidstateexception(KMSInvalidStateException)
        /// The ciphertext references a key that doesn't exist or that you don't have access
        ///             to.
        case kmsaccessdeniedexception(KMSAccessDeniedException)
        /// The request was rejected because the specified entity or resource can't be
        ///             found.
        case kmsnotfoundexception(KMSNotFoundException)
        /// The AWS access key ID needs a subscription for the service.
        case kmsoptinrequired(KMSOptInRequired)
        /// The request was denied due to request throttling. For more information about
        ///             throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits in
        ///             the AWS Key Management Service Developer Guide.
        case kmsthrottlingexception(KMSThrottlingException)
        /// The processing of the request failed because of an unknown error, exception, or
        ///             failure.
        case internalfailureexception(InternalFailureException)
        case sdkUnknown(Swift.String)
    }

}

public struct SubscribeToShardInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToShardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToShardOutputError>
}

extension SubscribeToShardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToShardInput(consumerARN: \(Swift.String(describing: consumerARN)), shardId: \(Swift.String(describing: shardId)), startingPosition: \(Swift.String(describing: startingPosition)))"}
}

extension SubscribeToShardInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case shardId = "ShardId"
        case startingPosition = "StartingPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumerARN = consumerARN {
            try encodeContainer.encode(consumerARN, forKey: .consumerARN)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition, forKey: .startingPosition)
        }
    }
}

public struct SubscribeToShardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToShardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToShardOutputError>
}

public struct SubscribeToShardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToShardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToShardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToShardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToShardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToShardOutputError>
}

public struct SubscribeToShardInput: Swift.Equatable {
    /// For this parameter, use the value you obtained when you called RegisterStreamConsumer.
    /// This member is required.
    public let consumerARN: Swift.String?
    /// The ID of the shard you want to subscribe to. To see a list of all the shards for a
    ///             given stream, use ListShards.
    /// This member is required.
    public let shardId: Swift.String?
    ///
    /// This member is required.
    public let startingPosition: KinesisClientTypes.StartingPosition?

    public init (
        consumerARN: Swift.String? = nil,
        shardId: Swift.String? = nil,
        startingPosition: KinesisClientTypes.StartingPosition? = nil
    )
    {
        self.consumerARN = consumerARN
        self.shardId = shardId
        self.startingPosition = startingPosition
    }
}

struct SubscribeToShardInputBody: Swift.Equatable {
    public let consumerARN: Swift.String?
    public let shardId: Swift.String?
    public let startingPosition: KinesisClientTypes.StartingPosition?
}

extension SubscribeToShardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumerARN = "ConsumerARN"
        case shardId = "ShardId"
        case startingPosition = "StartingPosition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumerARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumerARN)
        consumerARN = consumerARNDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.StartingPosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
    }
}

extension SubscribeToShardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToShardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToShardOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToShardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToShardOutputResponse(eventStream: \(Swift.String(describing: eventStream)))"}
}

extension SubscribeToShardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SubscribeToShardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventStream = output.eventStream
        } else {
            self.eventStream = nil
        }
    }
}

public struct SubscribeToShardOutputResponse: Swift.Equatable {
    /// The event stream that your consumer can use to read records from the shard.
    /// This member is required.
    public let eventStream: KinesisClientTypes.SubscribeToShardEventStream?

    public init (
        eventStream: KinesisClientTypes.SubscribeToShardEventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

struct SubscribeToShardOutputResponseBody: Swift.Equatable {
    public let eventStream: KinesisClientTypes.SubscribeToShardEventStream?
}

extension SubscribeToShardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventStream = "EventStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.SubscribeToShardEventStream.self, forKey: .eventStream)
        eventStream = eventStreamDecoded
    }
}

extension KinesisClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension KinesisClientTypes {
    /// Metadata assigned to the stream, consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// A unique identifier for the tag. Maximum length: 128 characters. Valid characters:
        ///             Unicode letters, digits, white space, _ . / = + - % @
        /// This member is required.
        public let key: Swift.String?
        /// An optional string, typically used to describe or define the tag. Maximum length:
        ///             256 characters. Valid characters: Unicode letters, digits, white space, _ . / = + - %
        ///             @
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct UpdateShardCountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShardCountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShardCountOutputError>
}

extension UpdateShardCountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateShardCountInput(scalingType: \(Swift.String(describing: scalingType)), streamName: \(Swift.String(describing: streamName)), targetShardCount: \(Swift.String(describing: targetShardCount)))"}
}

extension UpdateShardCountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingType = "ScalingType"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let targetShardCount = targetShardCount {
            try encodeContainer.encode(targetShardCount, forKey: .targetShardCount)
        }
    }
}

public struct UpdateShardCountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShardCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShardCountOutputError>
}

public struct UpdateShardCountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateShardCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateShardCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateShardCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateShardCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateShardCountOutputError>
}

public struct UpdateShardCountInput: Swift.Equatable {
    /// The scaling type. Uniform scaling creates shards of equal size.
    /// This member is required.
    public let scalingType: KinesisClientTypes.ScalingType?
    /// The name of the stream.
    /// This member is required.
    public let streamName: Swift.String?
    /// The new number of shards. This value has the following default limits. By default,
    ///             you cannot do the following:
    ///
    ///
    ///                 Set this value to more than double your current shard count for a
    ///                     stream.
    ///
    ///
    ///                 Set this value below half your current shard count for a stream.
    ///
    ///
    ///                 Set this value to more than 500 shards in a stream (the default limit for
    ///                     shard count per stream is 500 per account per region), unless you request a
    ///                     limit increase.
    ///
    ///
    ///                 Scale a stream with more than 500 shards down unless you set this value to
    ///                     less than 500 shards.
    ///
    ///
    /// This member is required.
    public let targetShardCount: Swift.Int?

    public init (
        scalingType: KinesisClientTypes.ScalingType? = nil,
        streamName: Swift.String? = nil,
        targetShardCount: Swift.Int? = nil
    )
    {
        self.scalingType = scalingType
        self.streamName = streamName
        self.targetShardCount = targetShardCount
    }
}

struct UpdateShardCountInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let targetShardCount: Swift.Int?
    public let scalingType: KinesisClientTypes.ScalingType?
}

extension UpdateShardCountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scalingType = "ScalingType"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let targetShardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetShardCount)
        targetShardCount = targetShardCountDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(KinesisClientTypes.ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension UpdateShardCountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateShardCountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateShardCountOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateShardCountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateShardCountOutputResponse(currentShardCount: \(Swift.String(describing: currentShardCount)), streamName: \(Swift.String(describing: streamName)), targetShardCount: \(Swift.String(describing: targetShardCount)))"}
}

extension UpdateShardCountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateShardCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentShardCount = output.currentShardCount
            self.streamName = output.streamName
            self.targetShardCount = output.targetShardCount
        } else {
            self.currentShardCount = nil
            self.streamName = nil
            self.targetShardCount = nil
        }
    }
}

public struct UpdateShardCountOutputResponse: Swift.Equatable {
    /// The current number of shards.
    public let currentShardCount: Swift.Int?
    /// The name of the stream.
    public let streamName: Swift.String?
    /// The updated number of shards.
    public let targetShardCount: Swift.Int?

    public init (
        currentShardCount: Swift.Int? = nil,
        streamName: Swift.String? = nil,
        targetShardCount: Swift.Int? = nil
    )
    {
        self.currentShardCount = currentShardCount
        self.streamName = streamName
        self.targetShardCount = targetShardCount
    }
}

struct UpdateShardCountOutputResponseBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let currentShardCount: Swift.Int?
    public let targetShardCount: Swift.Int?
}

extension UpdateShardCountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentShardCount = "CurrentShardCount"
        case streamName = "StreamName"
        case targetShardCount = "TargetShardCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let currentShardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentShardCount)
        currentShardCount = currentShardCountDecoded
        let targetShardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetShardCount)
        targetShardCount = targetShardCountDecoded
    }
}
