// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RdsDataClientTypes.ArrayValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case booleanvalues = "booleanValues"
        case doublevalues = "doubleValues"
        case longvalues = "longValues"
        case sdkUnknown
        case stringvalues = "stringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for arrayofarray0 in arrayvalues {
                    try arrayvaluesContainer.encode(arrayofarray0)
                }
            case let .booleanvalues(booleanvalues):
                var booleanvaluesContainer = container.nestedUnkeyedContainer(forKey: .booleanvalues)
                for booleanarray0 in booleanvalues {
                    try booleanvaluesContainer.encode(booleanarray0)
                }
            case let .doublevalues(doublevalues):
                var doublevaluesContainer = container.nestedUnkeyedContainer(forKey: .doublevalues)
                for doublearray0 in doublevalues {
                    try doublevaluesContainer.encode(doublearray0)
                }
            case let .longvalues(longvalues):
                var longvaluesContainer = container.nestedUnkeyedContainer(forKey: .longvalues)
                for longarray0 in longvalues {
                    try longvaluesContainer.encode(longarray0)
                }
            case let .stringvalues(stringvalues):
                var stringvaluesContainer = container.nestedUnkeyedContainer(forKey: .stringvalues)
                for stringarray0 in stringvalues {
                    try stringvaluesContainer.encode(stringarray0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let booleanvaluesContainer = try values.decodeIfPresent([Swift.Bool?].self, forKey: .booleanvalues)
        var booleanvaluesDecoded0:[Swift.Bool]? = nil
        if let booleanvaluesContainer = booleanvaluesContainer {
            booleanvaluesDecoded0 = [Swift.Bool]()
            for boolean0 in booleanvaluesContainer {
                if let boolean0 = boolean0 {
                    booleanvaluesDecoded0?.append(boolean0)
                }
            }
        }
        if let booleanvalues = booleanvaluesDecoded0 {
            self = .booleanvalues(booleanvalues)
            return
        }
        let longvaluesContainer = try values.decodeIfPresent([Swift.Int?].self, forKey: .longvalues)
        var longvaluesDecoded0:[Swift.Int]? = nil
        if let longvaluesContainer = longvaluesContainer {
            longvaluesDecoded0 = [Swift.Int]()
            for long0 in longvaluesContainer {
                if let long0 = long0 {
                    longvaluesDecoded0?.append(long0)
                }
            }
        }
        if let longvalues = longvaluesDecoded0 {
            self = .longvalues(longvalues)
            return
        }
        let doublevaluesContainer = try values.decodeIfPresent([Swift.Double?].self, forKey: .doublevalues)
        var doublevaluesDecoded0:[Swift.Double]? = nil
        if let doublevaluesContainer = doublevaluesContainer {
            doublevaluesDecoded0 = [Swift.Double]()
            for double0 in doublevaluesContainer {
                if let double0 = double0 {
                    doublevaluesDecoded0?.append(double0)
                }
            }
        }
        if let doublevalues = doublevaluesDecoded0 {
            self = .doublevalues(doublevalues)
            return
        }
        let stringvaluesContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringvalues)
        var stringvaluesDecoded0:[Swift.String]? = nil
        if let stringvaluesContainer = stringvaluesContainer {
            stringvaluesDecoded0 = [Swift.String]()
            for string0 in stringvaluesContainer {
                if let string0 = string0 {
                    stringvaluesDecoded0?.append(string0)
                }
            }
        }
        if let stringvalues = stringvaluesDecoded0 {
            self = .stringvalues(stringvalues)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RdsDataClientTypes.ArrayValue?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RdsDataClientTypes.ArrayValue]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RdsDataClientTypes.ArrayValue]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// <p>Contains an array.</p>
    public enum ArrayValue: Swift.Equatable {
        /// <p>An array of Boolean values.</p>
        case booleanvalues([Swift.Bool])
        /// <p>An array of floating point numbers.</p>
        case longvalues([Swift.Int])
        /// <p>An array of integers.</p>
        case doublevalues([Swift.Double])
        /// <p>An array of strings.</p>
        case stringvalues([Swift.String])
        /// <p>An array of arrays.</p>
        case arrayvalues([RdsDataClientTypes.ArrayValue])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is an error in the call or in a SQL statement.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message returned by this <code>BadRequestException</code> error.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchExecuteStatementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchExecuteStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchExecuteStatementOutputError>
}

extension BatchExecuteStatementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchExecuteStatementInput(database: \(Swift.String(describing: database)), parameterSets: \(Swift.String(describing: parameterSets)), resourceArn: \(Swift.String(describing: resourceArn)), schema: \(Swift.String(describing: schema)), secretArn: \(Swift.String(describing: secretArn)), sql: \(Swift.String(describing: sql)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension BatchExecuteStatementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let parameterSets = parameterSets {
            var parameterSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterSets)
            for sqlparametersets0 in parameterSets {
                var sqlparametersets0Container = parameterSetsContainer.nestedUnkeyedContainer()
                for sqlparameterslist1 in sqlparametersets0 {
                    try sqlparametersets0Container.encode(sqlparameterslist1)
                }
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct BatchExecuteStatementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchExecuteStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchExecuteStatementOutputError>
}

public struct BatchExecuteStatementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchExecuteStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchExecuteStatementOutputError>
}

/// <p>The request parameters represent the input of a SQL statement over an array of
///             data.</p>
public struct BatchExecuteStatementInput: Swift.Equatable {
    /// <p>The name of the database.</p>
    public let database: Swift.String?
    /// <p>The parameter set for the batch operation.</p>
    ///         <p>The SQL statement is executed as many times as the number of parameter sets provided.
    ///           To execute a SQL statement with no parameters, use one of the following options:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Specify one or more empty parameter sets.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Use the <code>ExecuteStatement</code> operation instead of the <code>BatchExecuteStatement</code> operation.</p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>Array parameters are not supported.</p>
    ///         </note>
    public let parameterSets: [[RdsDataClientTypes.SqlParameter]]?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: Swift.String?
    /// <p>The name of the database schema.</p>
    public let schema: Swift.String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: Swift.String?
    /// <p>The SQL statement to run.</p>
    public let sql: Swift.String?
    /// <p>The identifier of a transaction that was started by using the
    ///                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
    ///             transaction that you want to include the SQL statement in.</p>
    ///         <p>If the SQL statement is not part of a transaction, don't set this
    ///             parameter.</p>
    public let transactionId: Swift.String?

    public init (
        database: Swift.String? = nil,
        parameterSets: [[RdsDataClientTypes.SqlParameter]]? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.database = database
        self.parameterSets = parameterSets
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct BatchExecuteStatementInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let secretArn: Swift.String?
    public let sql: Swift.String?
    public let database: Swift.String?
    public let schema: Swift.String?
    public let parameterSets: [[RdsDataClientTypes.SqlParameter]]?
    public let transactionId: Swift.String?
}

extension BatchExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parameterSetsContainer = try containerValues.decodeIfPresent([[RdsDataClientTypes.SqlParameter?]?].self, forKey: .parameterSets)
        var parameterSetsDecoded0:[[RdsDataClientTypes.SqlParameter]]? = nil
        if let parameterSetsContainer = parameterSetsContainer {
            parameterSetsDecoded0 = [[RdsDataClientTypes.SqlParameter]]()
            for list0 in parameterSetsContainer {
                var list0Decoded0: [RdsDataClientTypes.SqlParameter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RdsDataClientTypes.SqlParameter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parameterSetsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parameterSets = parameterSetsDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension BatchExecuteStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchExecuteStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchExecuteStatementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchExecuteStatementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchExecuteStatementOutputResponse(updateResults: \(Swift.String(describing: updateResults)))"}
}

extension BatchExecuteStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateResults = output.updateResults
        } else {
            self.updateResults = nil
        }
    }
}

/// <p>The response elements represent the output of a SQL statement over an array of
///             data.</p>
public struct BatchExecuteStatementOutputResponse: Swift.Equatable {
    /// <p>The execution results of each batch entry.</p>
    public let updateResults: [RdsDataClientTypes.UpdateResult]?

    public init (
        updateResults: [RdsDataClientTypes.UpdateResult]? = nil
    )
    {
        self.updateResults = updateResults
    }
}

struct BatchExecuteStatementOutputResponseBody: Swift.Equatable {
    public let updateResults: [RdsDataClientTypes.UpdateResult]?
}

extension BatchExecuteStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateResultsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.UpdateResult?].self, forKey: .updateResults)
        var updateResultsDecoded0:[RdsDataClientTypes.UpdateResult]? = nil
        if let updateResultsContainer = updateResultsContainer {
            updateResultsDecoded0 = [RdsDataClientTypes.UpdateResult]()
            for structure0 in updateResultsContainer {
                if let structure0 = structure0 {
                    updateResultsDecoded0?.append(structure0)
                }
            }
        }
        updateResults = updateResultsDecoded0
    }
}

public struct BeginTransactionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BeginTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BeginTransactionOutputError>
}

extension BeginTransactionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BeginTransactionInput(database: \(Swift.String(describing: database)), resourceArn: \(Swift.String(describing: resourceArn)), schema: \(Swift.String(describing: schema)), secretArn: \(Swift.String(describing: secretArn)))"}
}

extension BeginTransactionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

public struct BeginTransactionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BeginTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BeginTransactionOutputError>
}

public struct BeginTransactionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BeginTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BeginTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BeginTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BeginTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BeginTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BeginTransactionOutputError>
}

/// <p>The request parameters represent the input of a request to start a SQL
///             transaction.</p>
public struct BeginTransactionInput: Swift.Equatable {
    /// <p>The name of the database.</p>
    public let database: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: Swift.String?
    /// <p>The name of the database schema.</p>
    public let schema: Swift.String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: Swift.String?

    public init (
        database: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil
    )
    {
        self.database = database
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
    }
}

struct BeginTransactionInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let secretArn: Swift.String?
    public let database: Swift.String?
    public let schema: Swift.String?
}

extension BeginTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension BeginTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BeginTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BeginTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BeginTransactionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BeginTransactionOutputResponse(transactionId: \(Swift.String(describing: transactionId)))"}
}

extension BeginTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BeginTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

/// <p>The response elements represent the output of a request to start a SQL
///             transaction.</p>
public struct BeginTransactionOutputResponse: Swift.Equatable {
    /// <p>The transaction ID of the transaction started by the call.</p>
    public let transactionId: Swift.String?

    public init (
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct BeginTransactionOutputResponseBody: Swift.Equatable {
    public let transactionId: Swift.String?
}

extension BeginTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RdsDataClientTypes.ColumnMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayBaseColumnType
        case isAutoIncrement
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case type
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if arrayBaseColumnType != 0 {
            try encodeContainer.encode(arrayBaseColumnType, forKey: .arrayBaseColumnType)
        }
        if isAutoIncrement != false {
            try encodeContainer.encode(isAutoIncrement, forKey: .isAutoIncrement)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decode(Swift.Int.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let isAutoIncrementDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isAutoIncrement)
        isAutoIncrement = isAutoIncrementDecoded
        let isSignedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSigned)
        isSigned = isSignedDecoded
        let isCurrencyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCurrency)
        isCurrency = isCurrencyDecoded
        let isCaseSensitiveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCaseSensitive)
        isCaseSensitive = isCaseSensitiveDecoded
        let nullableDecoded = try containerValues.decode(Swift.Int.self, forKey: .nullable)
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Swift.Int.self, forKey: .scale)
        scale = scaleDecoded
        let arrayBaseColumnTypeDecoded = try containerValues.decode(Swift.Int.self, forKey: .arrayBaseColumnType)
        arrayBaseColumnType = arrayBaseColumnTypeDecoded
    }
}

extension RdsDataClientTypes.ColumnMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnMetadata(arrayBaseColumnType: \(Swift.String(describing: arrayBaseColumnType)), isAutoIncrement: \(Swift.String(describing: isAutoIncrement)), isCaseSensitive: \(Swift.String(describing: isCaseSensitive)), isCurrency: \(Swift.String(describing: isCurrency)), isSigned: \(Swift.String(describing: isSigned)), label: \(Swift.String(describing: label)), name: \(Swift.String(describing: name)), nullable: \(Swift.String(describing: nullable)), precision: \(Swift.String(describing: precision)), scale: \(Swift.String(describing: scale)), schemaName: \(Swift.String(describing: schemaName)), tableName: \(Swift.String(describing: tableName)), type: \(Swift.String(describing: type)), typeName: \(Swift.String(describing: typeName)))"}
}

extension RdsDataClientTypes {
    /// <p>Contains the metadata for a column.</p>
    public struct ColumnMetadata: Swift.Equatable {
        /// <p>The type of the column.</p>
        public let arrayBaseColumnType: Swift.Int
        /// <p>A value that indicates whether the column increments automatically.</p>
        public let isAutoIncrement: Swift.Bool
        /// <p>A value that indicates whether the column is case-sensitive.</p>
        public let isCaseSensitive: Swift.Bool
        /// <p>A value that indicates whether the column contains currency values.</p>
        public let isCurrency: Swift.Bool
        /// <p>A value that indicates whether an integer column is signed.</p>
        public let isSigned: Swift.Bool
        /// <p>The label for the column.</p>
        public let label: Swift.String?
        /// <p>The name of the column.</p>
        public let name: Swift.String?
        /// <p>A value that indicates whether the column is nullable.</p>
        public let nullable: Swift.Int
        /// <p>The precision value of a decimal number column.</p>
        public let precision: Swift.Int
        /// <p>The scale value of a decimal number column.</p>
        public let scale: Swift.Int
        /// <p>The name of the schema that owns the table that includes the column.</p>
        public let schemaName: Swift.String?
        /// <p>The name of the table that includes the column.</p>
        public let tableName: Swift.String?
        /// <p>The type of the column.</p>
        public let type: Swift.Int
        /// <p>The database-specific data type of the column.</p>
        public let typeName: Swift.String?

        public init (
            arrayBaseColumnType: Swift.Int = 0,
            isAutoIncrement: Swift.Bool = false,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.Int = 0,
            typeName: Swift.String? = nil
        )
        {
            self.arrayBaseColumnType = arrayBaseColumnType
            self.isAutoIncrement = isAutoIncrement
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
            self.typeName = typeName
        }
    }

}

public struct CommitTransactionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CommitTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CommitTransactionOutputError>
}

extension CommitTransactionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommitTransactionInput(resourceArn: \(Swift.String(describing: resourceArn)), secretArn: \(Swift.String(describing: secretArn)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension CommitTransactionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct CommitTransactionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CommitTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CommitTransactionOutputError>
}

public struct CommitTransactionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CommitTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CommitTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CommitTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CommitTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CommitTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CommitTransactionOutputError>
}

/// <p>The request parameters represent the input of a commit transaction request.</p>
public struct CommitTransactionInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: Swift.String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: Swift.String?
    /// <p>The identifier of the transaction to end and commit.</p>
    public let transactionId: Swift.String?

    public init (
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct CommitTransactionInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let secretArn: Swift.String?
    public let transactionId: Swift.String?
}

extension CommitTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CommitTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CommitTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CommitTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CommitTransactionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommitTransactionOutputResponse(transactionStatus: \(Swift.String(describing: transactionStatus)))"}
}

extension CommitTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CommitTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// <p>The response elements represent the output of a commit transaction request.</p>
public struct CommitTransactionOutputResponse: Swift.Equatable {
    /// <p>The status of the commit operation.</p>
    public let transactionStatus: Swift.String?

    public init (
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct CommitTransactionOutputResponseBody: Swift.Equatable {
    public let transactionStatus: Swift.String?
}

extension CommitTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

extension RdsDataClientTypes {
    public enum DecimalReturnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleOrLong
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DecimalReturnType] {
            return [
                .doubleOrLong,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleOrLong: return "DOUBLE_OR_LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DecimalReturnType(rawValue: rawValue) ?? DecimalReturnType.sdkUnknown(rawValue)
        }
    }
}

public struct ExecuteSqlInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteSqlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteSqlOutputError>
}

extension ExecuteSqlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteSqlInput(awsSecretStoreArn: \(Swift.String(describing: awsSecretStoreArn)), database: \(Swift.String(describing: database)), dbClusterOrInstanceArn: \(Swift.String(describing: dbClusterOrInstanceArn)), schema: \(Swift.String(describing: schema)), sqlStatements: \(Swift.String(describing: sqlStatements)))"}
}

extension ExecuteSqlInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbClusterOrInstanceArn = dbClusterOrInstanceArn {
            try encodeContainer.encode(dbClusterOrInstanceArn, forKey: .dbClusterOrInstanceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let sqlStatements = sqlStatements {
            try encodeContainer.encode(sqlStatements, forKey: .sqlStatements)
        }
    }
}

public struct ExecuteSqlInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteSqlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteSqlOutputError>
}

public struct ExecuteSqlInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteSqlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteSqlInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteSqlInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteSqlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteSqlOutputError>
}

/// <p>The request parameters represent the input of a request to run one or more SQL
///             statements.</p>
public struct ExecuteSqlInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster.</p>
    public let awsSecretStoreArn: Swift.String?
    /// <p>The name of the database.</p>
    public let database: Swift.String?
    /// <p>The ARN of the Aurora Serverless DB cluster.</p>
    public let dbClusterOrInstanceArn: Swift.String?
    /// <p>The name of the database schema.</p>
    public let schema: Swift.String?
    /// <p>One or more SQL statements to run on the DB cluster.</p>
    ///         <p>You can separate SQL statements from each other with a semicolon (;). Any valid SQL
    ///             statement is permitted, including data definition, data manipulation, and commit
    ///             statements. </p>
    public let sqlStatements: Swift.String?

    public init (
        awsSecretStoreArn: Swift.String? = nil,
        database: Swift.String? = nil,
        dbClusterOrInstanceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        sqlStatements: Swift.String? = nil
    )
    {
        self.awsSecretStoreArn = awsSecretStoreArn
        self.database = database
        self.dbClusterOrInstanceArn = dbClusterOrInstanceArn
        self.schema = schema
        self.sqlStatements = sqlStatements
    }
}

struct ExecuteSqlInputBody: Swift.Equatable {
    public let dbClusterOrInstanceArn: Swift.String?
    public let awsSecretStoreArn: Swift.String?
    public let sqlStatements: Swift.String?
    public let database: Swift.String?
    public let schema: Swift.String?
}

extension ExecuteSqlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOrInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterOrInstanceArn)
        dbClusterOrInstanceArn = dbClusterOrInstanceArnDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
        let sqlStatementsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlStatements)
        sqlStatements = sqlStatementsDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ExecuteSqlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteSqlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteSqlOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteSqlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteSqlOutputResponse(sqlStatementResults: \(Swift.String(describing: sqlStatementResults)))"}
}

extension ExecuteSqlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteSqlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sqlStatementResults = output.sqlStatementResults
        } else {
            self.sqlStatementResults = nil
        }
    }
}

/// <p>The response elements represent the output of a request to run one or more SQL
///             statements.</p>
public struct ExecuteSqlOutputResponse: Swift.Equatable {
    /// <p>The results of the SQL statement or statements.</p>
    public let sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]?

    public init (
        sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]? = nil
    )
    {
        self.sqlStatementResults = sqlStatementResults
    }
}

struct ExecuteSqlOutputResponseBody: Swift.Equatable {
    public let sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]?
}

extension ExecuteSqlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sqlStatementResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlStatementResultsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.SqlStatementResult?].self, forKey: .sqlStatementResults)
        var sqlStatementResultsDecoded0:[RdsDataClientTypes.SqlStatementResult]? = nil
        if let sqlStatementResultsContainer = sqlStatementResultsContainer {
            sqlStatementResultsDecoded0 = [RdsDataClientTypes.SqlStatementResult]()
            for structure0 in sqlStatementResultsContainer {
                if let structure0 = structure0 {
                    sqlStatementResultsDecoded0?.append(structure0)
                }
            }
        }
        sqlStatementResults = sqlStatementResultsDecoded0
    }
}

public struct ExecuteStatementInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteStatementOutputError>
}

extension ExecuteStatementInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteStatementInput(continueAfterTimeout: \(Swift.String(describing: continueAfterTimeout)), database: \(Swift.String(describing: database)), includeResultMetadata: \(Swift.String(describing: includeResultMetadata)), parameters: \(Swift.String(describing: parameters)), resourceArn: \(Swift.String(describing: resourceArn)), resultSetOptions: \(Swift.String(describing: resultSetOptions)), schema: \(Swift.String(describing: schema)), secretArn: \(Swift.String(describing: secretArn)), sql: \(Swift.String(describing: sql)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension ExecuteStatementInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if continueAfterTimeout != false {
            try encodeContainer.encode(continueAfterTimeout, forKey: .continueAfterTimeout)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if includeResultMetadata != false {
            try encodeContainer.encode(includeResultMetadata, forKey: .includeResultMetadata)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for sqlparameterslist0 in parameters {
                try parametersContainer.encode(sqlparameterslist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resultSetOptions = resultSetOptions {
            try encodeContainer.encode(resultSetOptions, forKey: .resultSetOptions)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct ExecuteStatementInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteStatementOutputError>
}

public struct ExecuteStatementInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteStatementInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteStatementInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteStatementOutputError>
}

/// <p>The request parameters represent the input of a request to run a SQL statement against
///             a database.</p>
public struct ExecuteStatementInput: Swift.Equatable {
    /// <p>A value that indicates whether to continue running the statement after
    ///             the call times out. By default, the statement stops running when the call
    ///             times out.</p>
    ///         <important>
    ///             <p>For DDL statements, we recommend continuing to run the statement after
    ///                the call times out. When a DDL statement terminates before it is finished
    ///                running, it can result in errors and possibly corrupted data structures.</p>
    ///         </important>
    public let continueAfterTimeout: Swift.Bool
    /// <p>The name of the database.</p>
    public let database: Swift.String?
    /// <p>A value that indicates whether to include metadata in the results.</p>
    public let includeResultMetadata: Swift.Bool
    /// <p>The parameters for the SQL statement.</p>
    ///         <note>
    ///             <p>Array parameters are not supported.</p>
    ///         </note>
    public let parameters: [RdsDataClientTypes.SqlParameter]?
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: Swift.String?
    /// <p>Options that control how the result set is returned.</p>
    public let resultSetOptions: RdsDataClientTypes.ResultSetOptions?
    /// <p>The name of the database schema.</p>
    ///         <note>
    ///             <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    ///         </note>
    public let schema: Swift.String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: Swift.String?
    /// <p>The SQL statement to run.</p>
    public let sql: Swift.String?
    /// <p>The identifier of a transaction that was started by using the
    ///                 <code>BeginTransaction</code> operation. Specify the transaction ID of the
    ///             transaction that you want to include the SQL statement in.</p>
    ///         <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    public let transactionId: Swift.String?

    public init (
        continueAfterTimeout: Swift.Bool = false,
        database: Swift.String? = nil,
        includeResultMetadata: Swift.Bool = false,
        parameters: [RdsDataClientTypes.SqlParameter]? = nil,
        resourceArn: Swift.String? = nil,
        resultSetOptions: RdsDataClientTypes.ResultSetOptions? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.continueAfterTimeout = continueAfterTimeout
        self.database = database
        self.includeResultMetadata = includeResultMetadata
        self.parameters = parameters
        self.resourceArn = resourceArn
        self.resultSetOptions = resultSetOptions
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct ExecuteStatementInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let secretArn: Swift.String?
    public let sql: Swift.String?
    public let database: Swift.String?
    public let schema: Swift.String?
    public let parameters: [RdsDataClientTypes.SqlParameter]?
    public let transactionId: Swift.String?
    public let includeResultMetadata: Swift.Bool
    public let continueAfterTimeout: Swift.Bool
    public let resultSetOptions: RdsDataClientTypes.ResultSetOptions?
}

extension ExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parametersContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.SqlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[RdsDataClientTypes.SqlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [RdsDataClientTypes.SqlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let includeResultMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeResultMetadata)
        includeResultMetadata = includeResultMetadataDecoded
        let continueAfterTimeoutDecoded = try containerValues.decode(Swift.Bool.self, forKey: .continueAfterTimeout)
        continueAfterTimeout = continueAfterTimeoutDecoded
        let resultSetOptionsDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultSetOptions.self, forKey: .resultSetOptions)
        resultSetOptions = resultSetOptionsDecoded
    }
}

extension ExecuteStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteStatementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteStatementOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteStatementOutputResponse(columnMetadata: \(Swift.String(describing: columnMetadata)), generatedFields: \(Swift.String(describing: generatedFields)), numberOfRecordsUpdated: \(Swift.String(describing: numberOfRecordsUpdated)), records: \(Swift.String(describing: records)))"}
}

extension ExecuteStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columnMetadata = output.columnMetadata
            self.generatedFields = output.generatedFields
            self.numberOfRecordsUpdated = output.numberOfRecordsUpdated
            self.records = output.records
        } else {
            self.columnMetadata = nil
            self.generatedFields = nil
            self.numberOfRecordsUpdated = 0
            self.records = nil
        }
    }
}

/// <p>The response elements represent the output of a request to run a SQL statement against
///             a database.</p>
public struct ExecuteStatementOutputResponse: Swift.Equatable {
    /// <p>Metadata for the columns included in the results.</p>
    public let columnMetadata: [RdsDataClientTypes.ColumnMetadata]?
    /// <p>Values for fields generated during the request.</p>
    ///
    ///         <note>
    ///             <p>The <code>generatedFields</code> data isn't supported by Aurora PostgreSQL.
    ///                 To get the values of generated fields, use the <code>RETURNING</code> clause. For
    ///                 more information, see <a href="https://www.postgresql.org/docs/10/dml-returning.html">Returning Data From
    ///                     Modified Rows</a> in the PostgreSQL documentation.</p>
    ///         </note>
    public let generatedFields: [RdsDataClientTypes.Field]?
    /// <p>The number of records updated by the request.</p>
    public let numberOfRecordsUpdated: Swift.Int
    /// <p>The records returned by the SQL statement.</p>
    public let records: [[RdsDataClientTypes.Field]]?

    public init (
        columnMetadata: [RdsDataClientTypes.ColumnMetadata]? = nil,
        generatedFields: [RdsDataClientTypes.Field]? = nil,
        numberOfRecordsUpdated: Swift.Int = 0,
        records: [[RdsDataClientTypes.Field]]? = nil
    )
    {
        self.columnMetadata = columnMetadata
        self.generatedFields = generatedFields
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.records = records
    }
}

struct ExecuteStatementOutputResponseBody: Swift.Equatable {
    public let records: [[RdsDataClientTypes.Field]]?
    public let columnMetadata: [RdsDataClientTypes.ColumnMetadata]?
    public let numberOfRecordsUpdated: Swift.Int
    public let generatedFields: [RdsDataClientTypes.Field]?
}

extension ExecuteStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnMetadata
        case generatedFields
        case numberOfRecordsUpdated
        case records
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[RdsDataClientTypes.Field?]?].self, forKey: .records)
        var recordsDecoded0:[[RdsDataClientTypes.Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[RdsDataClientTypes.Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [RdsDataClientTypes.Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RdsDataClientTypes.Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RdsDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RdsDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RdsDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RdsDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension RdsDataClientTypes.Field: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalue = "arrayValue"
        case blobvalue = "blobValue"
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case isnull = "isNull"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalue(arrayvalue):
                try container.encode(arrayvalue, forKey: .arrayvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvalueDecoded = try values.decodeIfPresent(RdsDataClientTypes.ArrayValue.self, forKey: .arrayvalue)
        if let arrayvalue = arrayvalueDecoded {
            self = .arrayvalue(arrayvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// <p>Contains a value.</p>
    public enum Field: Swift.Equatable {
        /// <p>A NULL value.</p>
        case isnull(Swift.Bool)
        /// <p>A value of Boolean data type.</p>
        case booleanvalue(Swift.Bool)
        /// <p>A value of long data type.</p>
        case longvalue(Swift.Int)
        /// <p>A value of double data type.</p>
        case doublevalue(Swift.Double)
        /// <p>A value of string data type.</p>
        case stringvalue(Swift.String)
        /// <p>A value of BLOB data type.</p>
        case blobvalue(ClientRuntime.Data)
        /// <p>An array of values.</p>
        case arrayvalue(RdsDataClientTypes.ArrayValue)
        case sdkUnknown(Swift.String)
    }

}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are insufficient privileges to make the call.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message returned by this <code>ForbiddenException</code> error.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException()"}
}

extension InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server

    public init() {}
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>resourceArn</code>, <code>secretArn</code>, or <code>transactionId</code> value can't be found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The error message returned by this <code>NotFoundException</code> error.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsDataClientTypes.Record: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for row0 in values {
                try valuesContainer.encode(row0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .values)
        var valuesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in valuesContainer {
                if let union0 = union0 {
                    valuesDecoded0?.append(union0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RdsDataClientTypes.Record: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Record(values: \(Swift.String(describing: values)))"}
}

extension RdsDataClientTypes {
    /// <p>A record returned by a call.</p>
    public struct Record: Swift.Equatable {
        /// <p>The values returned in the record.</p>
        public let values: [RdsDataClientTypes.Value]?

        public init (
            values: [RdsDataClientTypes.Value]? = nil
        )
        {
            self.values = values
        }
    }

}

extension RdsDataClientTypes.ResultFrame: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records
        case resultSetMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
        if let resultSetMetadata = resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
        let recordsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[RdsDataClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [RdsDataClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension RdsDataClientTypes.ResultFrame: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResultFrame(records: \(Swift.String(describing: records)), resultSetMetadata: \(Swift.String(describing: resultSetMetadata)))"}
}

extension RdsDataClientTypes {
    /// <p>The result set returned by a SQL statement.</p>
    public struct ResultFrame: Swift.Equatable {
        /// <p>The records in the result set.</p>
        public let records: [RdsDataClientTypes.Record]?
        /// <p>The result-set metadata in the result set.</p>
        public let resultSetMetadata: RdsDataClientTypes.ResultSetMetadata?

        public init (
            records: [RdsDataClientTypes.Record]? = nil,
            resultSetMetadata: RdsDataClientTypes.ResultSetMetadata? = nil
        )
        {
            self.records = records
            self.resultSetMetadata = resultSetMetadata
        }
    }

}

extension RdsDataClientTypes.ResultSetMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnCount
        case columnMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnCount != 0 {
            try encodeContainer.encode(columnCount, forKey: .columnCount)
        }
        if let columnMetadata = columnMetadata {
            var columnMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnMetadata)
            for metadata0 in columnMetadata {
                try columnMetadataContainer.encode(metadata0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .columnCount)
        columnCount = columnCountDecoded
        let columnMetadataContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RdsDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RdsDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
    }
}

extension RdsDataClientTypes.ResultSetMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResultSetMetadata(columnCount: \(Swift.String(describing: columnCount)), columnMetadata: \(Swift.String(describing: columnMetadata)))"}
}

extension RdsDataClientTypes {
    /// <p>The metadata of the result set returned by a SQL statement.</p>
    public struct ResultSetMetadata: Swift.Equatable {
        /// <p>The number of columns in the result set.</p>
        public let columnCount: Swift.Int
        /// <p>The metadata of the columns in the result set.</p>
        public let columnMetadata: [RdsDataClientTypes.ColumnMetadata]?

        public init (
            columnCount: Swift.Int = 0,
            columnMetadata: [RdsDataClientTypes.ColumnMetadata]? = nil
        )
        {
            self.columnCount = columnCount
            self.columnMetadata = columnMetadata
        }
    }

}

extension RdsDataClientTypes.ResultSetOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalReturnType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalReturnType = decimalReturnType {
            try encodeContainer.encode(decimalReturnType.rawValue, forKey: .decimalReturnType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalReturnTypeDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.DecimalReturnType.self, forKey: .decimalReturnType)
        decimalReturnType = decimalReturnTypeDecoded
    }
}

extension RdsDataClientTypes.ResultSetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResultSetOptions(decimalReturnType: \(Swift.String(describing: decimalReturnType)))"}
}

extension RdsDataClientTypes {
    /// <p>Options that control how the result set is returned.</p>
    public struct ResultSetOptions: Swift.Equatable {
        /// <p>A value that indicates how a field of <code>DECIMAL</code> type is represented
        ///             in the response. The value of <code>STRING</code>, the default, specifies that
        ///             it is converted to a String value. The value of <code>DOUBLE_OR_LONG</code>
        ///             specifies that it is converted to a Long value if its scale is 0, or to a Double
        ///             value otherwise.</p>
        ///         <important>
        ///             <p>Conversion to Double or Long can result in roundoff errors due to precision loss.
        ///                 We recommend converting to String, especially when working with currency values.</p>
        ///         </important>
        public let decimalReturnType: RdsDataClientTypes.DecimalReturnType?

        public init (
            decimalReturnType: RdsDataClientTypes.DecimalReturnType? = nil
        )
        {
            self.decimalReturnType = decimalReturnType
        }
    }

}

public struct RollbackTransactionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RollbackTransactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RollbackTransactionOutputError>
}

extension RollbackTransactionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollbackTransactionInput(resourceArn: \(Swift.String(describing: resourceArn)), secretArn: \(Swift.String(describing: secretArn)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension RollbackTransactionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

public struct RollbackTransactionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RollbackTransactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RollbackTransactionOutputError>
}

public struct RollbackTransactionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RollbackTransactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RollbackTransactionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RollbackTransactionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RollbackTransactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RollbackTransactionOutputError>
}

/// <p>The request parameters represent the input of a request to perform a rollback of a
///             transaction.</p>
public struct RollbackTransactionInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    public let resourceArn: Swift.String?
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    public let secretArn: Swift.String?
    /// <p>The identifier of the transaction to roll back.</p>
    public let transactionId: Swift.String?

    public init (
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct RollbackTransactionInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let secretArn: Swift.String?
    public let transactionId: Swift.String?
}

extension RollbackTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RollbackTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RollbackTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RollbackTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RollbackTransactionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollbackTransactionOutputResponse(transactionStatus: \(Swift.String(describing: transactionStatus)))"}
}

extension RollbackTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RollbackTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// <p>The response elements represent the output of a request to perform a rollback of a
///             transaction.</p>
public struct RollbackTransactionOutputResponse: Swift.Equatable {
    /// <p>The status of the rollback operation.</p>
    public let transactionStatus: Swift.String?

    public init (
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct RollbackTransactionOutputResponseBody: Swift.Equatable {
    public let transactionStatus: Swift.String?
}

extension RollbackTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

extension ServiceUnavailableError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableError()"}
}

extension ServiceUnavailableError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service specified by the <code>resourceArn</code> parameter is not
///             available.</p>
public struct ServiceUnavailableError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server

    public init() {}
}

extension RdsDataClientTypes.SqlParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case typeHint
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let typeHint = typeHint {
            try encodeContainer.encode(typeHint.rawValue, forKey: .typeHint)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.Field.self, forKey: .value)
        value = valueDecoded
        let typeHintDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.TypeHint.self, forKey: .typeHint)
        typeHint = typeHintDecoded
    }
}

extension RdsDataClientTypes.SqlParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqlParameter(name: \(Swift.String(describing: name)), typeHint: \(Swift.String(describing: typeHint)), value: \(Swift.String(describing: value)))"}
}

extension RdsDataClientTypes {
    /// <p>A parameter used in a SQL statement.</p>
    public struct SqlParameter: Swift.Equatable {
        /// <p>The name of the parameter.</p>
        public let name: Swift.String?
        /// <p>A hint that specifies the correct object type for data type mapping. Possible values
        ///             are as follows:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>DATE</code> - The corresponding <code>String</code> parameter value is sent as an object
        ///               of <code>DATE</code> type to the database. The accepted format is <code>YYYY-MM-DD</code>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>DECIMAL</code> - The corresponding <code>String</code> parameter value is sent as an object
        ///                     of <code>DECIMAL</code> type to the database.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>JSON</code> - The corresponding <code>String</code> parameter value is sent as an
        ///            object of <code>JSON</code> type to the database.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>TIME</code> - The corresponding <code>String</code> parameter value is sent as an object
        ///                     of <code>TIME</code> type to the database. The accepted format is <code>HH:MM:SS[.FFF]</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>TIMESTAMP</code> - The corresponding <code>String</code> parameter value is sent as an object
        ///               of <code>TIMESTAMP</code> type to the database. The accepted format is <code>YYYY-MM-DD HH:MM:SS[.FFF]</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>UUID</code> - The corresponding <code>String</code> parameter value is sent as an object of
        ///              <code>UUID</code> type to the database.
        ///           </p>
        ///             </li>
        ///          </ul>
        public let typeHint: RdsDataClientTypes.TypeHint?
        /// <p>The value of the parameter.</p>
        public let value: RdsDataClientTypes.Field?

        public init (
            name: Swift.String? = nil,
            typeHint: RdsDataClientTypes.TypeHint? = nil,
            value: RdsDataClientTypes.Field? = nil
        )
        {
            self.name = name
            self.typeHint = typeHint
            self.value = value
        }
    }

}

extension RdsDataClientTypes.SqlStatementResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfRecordsUpdated
        case resultFrame
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRecordsUpdated != 0 {
            try encodeContainer.encode(numberOfRecordsUpdated, forKey: .numberOfRecordsUpdated)
        }
        if let resultFrame = resultFrame {
            try encodeContainer.encode(resultFrame, forKey: .resultFrame)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFrameDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultFrame.self, forKey: .resultFrame)
        resultFrame = resultFrameDecoded
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
    }
}

extension RdsDataClientTypes.SqlStatementResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqlStatementResult(numberOfRecordsUpdated: \(Swift.String(describing: numberOfRecordsUpdated)), resultFrame: \(Swift.String(describing: resultFrame)))"}
}

extension RdsDataClientTypes {
    /// <p>The result of a SQL statement.</p>
    ///
    ///         <important>
    ///             <p>This data type is deprecated.</p>
    ///         </important>
    public struct SqlStatementResult: Swift.Equatable {
        /// <p>The number of records updated by a SQL statement.</p>
        public let numberOfRecordsUpdated: Swift.Int
        /// <p>The result set of the SQL statement.</p>
        public let resultFrame: RdsDataClientTypes.ResultFrame?

        public init (
            numberOfRecordsUpdated: Swift.Int = 0,
            resultFrame: RdsDataClientTypes.ResultFrame? = nil
        )
        {
            self.numberOfRecordsUpdated = numberOfRecordsUpdated
            self.resultFrame = resultFrame
        }
    }

}

extension StatementTimeoutException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatementTimeoutException(dbConnectionId: \(Swift.String(describing: dbConnectionId)), message: \(Swift.String(describing: message)))"}
}

extension StatementTimeoutException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StatementTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.dbConnectionId = output.dbConnectionId
            self.message = output.message
        } else {
            self.dbConnectionId = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The execution of the SQL statement timed out.</p>
public struct StatementTimeoutException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The database connection ID that executed the SQL statement.</p>
    public var dbConnectionId: Swift.Int
    /// <p>The error message returned by this <code>StatementTimeoutException</code> error.</p>
    public var message: Swift.String?

    public init (
        dbConnectionId: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.dbConnectionId = dbConnectionId
        self.message = message
    }
}

struct StatementTimeoutExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let dbConnectionId: Swift.Int
}

extension StatementTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbConnectionId
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dbConnectionIdDecoded = try containerValues.decode(Swift.Int.self, forKey: .dbConnectionId)
        dbConnectionId = dbConnectionIdDecoded
    }
}

extension RdsDataClientTypes.StructValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for arrayvaluelist0 in attributes {
                try attributesContainer.encode(arrayvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .attributes)
        var attributesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in attributesContainer {
                if let union0 = union0 {
                    attributesDecoded0?.append(union0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RdsDataClientTypes.StructValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StructValue(attributes: \(Swift.String(describing: attributes)))"}
}

extension RdsDataClientTypes {
    /// <p>A structure value returned by a call.</p>
    public struct StructValue: Swift.Equatable {
        /// <p>The attributes returned in the record.</p>
        public let attributes: [RdsDataClientTypes.Value]?

        public init (
            attributes: [RdsDataClientTypes.Value]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension RdsDataClientTypes {
    public enum TypeHint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case decimal
        case json
        case time
        case timestamp
        case uuid
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeHint] {
            return [
                .date,
                .decimal,
                .json,
                .time,
                .timestamp,
                .uuid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .json: return "JSON"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .uuid: return "UUID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeHint(rawValue: rawValue) ?? TypeHint.sdkUnknown(rawValue)
        }
    }
}

extension RdsDataClientTypes.UpdateResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFields = generatedFields {
            var generatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedFields)
            for fieldlist0 in generatedFields {
                try generatedFieldsContainer.encode(fieldlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RdsDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RdsDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension RdsDataClientTypes.UpdateResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResult(generatedFields: \(Swift.String(describing: generatedFields)))"}
}

extension RdsDataClientTypes {
    /// <p>The response elements represent the results of an update.</p>
    public struct UpdateResult: Swift.Equatable {
        /// <p>Values for fields generated during the request.</p>
        public let generatedFields: [RdsDataClientTypes.Field]?

        public init (
            generatedFields: [RdsDataClientTypes.Field]? = nil
        )
        {
            self.generatedFields = generatedFields
        }
    }

}

extension RdsDataClientTypes.Value: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case bigintvalue = "bigIntValue"
        case bitvalue = "bitValue"
        case blobvalue = "blobValue"
        case doublevalue = "doubleValue"
        case intvalue = "intValue"
        case isnull = "isNull"
        case realvalue = "realValue"
        case sdkUnknown
        case stringvalue = "stringValue"
        case structvalue = "structValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for arrayvaluelist0 in arrayvalues {
                    try arrayvaluesContainer.encode(arrayvaluelist0)
                }
            case let .bigintvalue(bigintvalue):
                try container.encode(bigintvalue, forKey: .bigintvalue)
            case let .bitvalue(bitvalue):
                try container.encode(bitvalue, forKey: .bitvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .intvalue(intvalue):
                try container.encode(intvalue, forKey: .intvalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .realvalue(realvalue):
                try container.encode(realvalue, forKey: .realvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .structvalue(structvalue):
                try container.encode(structvalue, forKey: .structvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let bitvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .bitvalue)
        if let bitvalue = bitvalueDecoded {
            self = .bitvalue(bitvalue)
            return
        }
        let bigintvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .bigintvalue)
        if let bigintvalue = bigintvalueDecoded {
            self = .bigintvalue(bigintvalue)
            return
        }
        let intvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .intvalue)
        if let intvalue = intvalueDecoded {
            self = .intvalue(intvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let realvalueDecoded = try values.decodeIfPresent(Swift.Float.self, forKey: .realvalue)
        if let realvalue = realvalueDecoded {
            self = .realvalue(realvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        let structvalueDecoded = try values.decodeIfPresent(RdsDataClientTypes.StructValue.self, forKey: .structvalue)
        if let structvalue = structvalueDecoded {
            self = .structvalue(structvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// <p>Contains the value of a column.</p>
    ///
    ///         <important>
    ///             <p>This data type is deprecated.</p>
    ///         </important>
    public enum Value: Swift.Equatable {
        /// <p>A NULL value.</p>
        case isnull(Swift.Bool)
        /// <p>A value for a column of BIT data type.</p>
        case bitvalue(Swift.Bool)
        /// <p>A value for a column of big integer data type.</p>
        case bigintvalue(Swift.Int)
        /// <p>A value for a column of integer data type.</p>
        case intvalue(Swift.Int)
        /// <p>A value for a column of double data type.</p>
        case doublevalue(Swift.Double)
        /// <p>A value for a column of real data type.</p>
        case realvalue(Swift.Float)
        /// <p>A value for a column of string data type.</p>
        case stringvalue(Swift.String)
        /// <p>A value for a column of BLOB data type.</p>
        case blobvalue(ClientRuntime.Data)
        /// <p>An array of column values.</p>
        case arrayvalues([RdsDataClientTypes.Value])
        /// <p>A value for a column of STRUCT data type.</p>
        case structvalue(RdsDataClientTypes.StructValue)
        case sdkUnknown(Swift.String)
    }

}
