// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Timestream was unable to process this request because it contains resource that already exists.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDatabaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatabaseOutputError>
}

extension CreateDatabaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatabaseInput(databaseName: \(Swift.String(describing: databaseName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDatabaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDatabaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>The KMS key for the database. If the KMS key is not specified, the database will be encrypted with a Timestream
    ///          managed KMS key located in your account. Refer to <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">AWS managed KMS keys</a> for more info.</p>
    public let kmsKeyId: Swift.String?
    /// <p>
    ///       A list of key-value pairs to label the table.
    ///    </p>
    public let tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
        self.tags = tags
    }
}

struct CreateDatabaseInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [TimestreamWriteClientTypes.Tag]?
}

extension CreateDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatabaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatabaseOutputResponse(database: \(Swift.String(describing: database)))"}
}

extension CreateDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct CreateDatabaseOutputResponse: Swift.Equatable {
    /// <p>The newly created Timestream database.</p>
    public let database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct CreateDatabaseOutputResponseBody: Swift.Equatable {
    public let database: TimestreamWriteClientTypes.Database?
}

extension CreateDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct CreateTableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTableOutputError>
}

extension CreateTableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTableInput(databaseName: \(Swift.String(describing: databaseName)), retentionProperties: \(Swift.String(describing: retentionProperties)), tableName: \(Swift.String(describing: tableName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateTableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTableOutputError>
}

public struct CreateTableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTableOutputError>
}

public struct CreateTableInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>The duration for which your time series data must be stored in the memory store and the magnetic store.</p>
    public let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// <p>The name of the Timestream table.</p>
    public let tableName: Swift.String?
    /// <p>
    ///       A list of key-value pairs to label the table.
    ///    </p>
    public let tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        databaseName: Swift.String? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        tableName: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.retentionProperties = retentionProperties
        self.tableName = tableName
        self.tags = tags
    }
}

struct CreateTableInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let tableName: Swift.String?
    public let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    public let tags: [TimestreamWriteClientTypes.Tag]?
}

extension CreateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTableOutputResponse(table: \(Swift.String(describing: table)))"}
}

extension CreateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct CreateTableOutputResponse: Swift.Equatable {
    /// <p>The newly created Timestream table.</p>
    public let table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct CreateTableOutputResponseBody: Swift.Equatable {
    public let table: TimestreamWriteClientTypes.Table?
}

extension CreateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension TimestreamWriteClientTypes.Database: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case lastUpdatedTime = "LastUpdatedTime"
        case tableCount = "TableCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if tableCount != 0 {
            try encodeContainer.encode(tableCount, forKey: .tableCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .tableCount)
        tableCount = tableCountDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension TimestreamWriteClientTypes.Database: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Database(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), databaseName: \(Swift.String(describing: databaseName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), tableCount: \(Swift.String(describing: tableCount)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>A top level container for a table. Databases and tables are the
    ///       fundamental management concepts in Amazon Timestream. All tables in a
    ///       database are encrypted with the same KMS key.</p>
    public struct Database: Swift.Equatable {
        /// <p>The Amazon Resource Name that uniquely identifies this database.</p>
        public let arn: Swift.String?
        /// <p>The time when the database was created, calculated from the Unix epoch time.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the Timestream database.</p>
        public let databaseName: Swift.String?
        /// <p>The identifier of the KMS key used to encrypt the data stored in the database.</p>
        public let kmsKeyId: Swift.String?
        /// <p>
        ///    The last time that this database was updated.
        ///    </p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The total number of tables found within a Timestream database. </p>
        public let tableCount: Swift.Int

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            tableCount: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.kmsKeyId = kmsKeyId
            self.lastUpdatedTime = lastUpdatedTime
            self.tableCount = tableCount
        }
    }

}

public struct DeleteDatabaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatabaseOutputError>
}

extension DeleteDatabaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatabaseInput(databaseName: \(Swift.String(describing: databaseName)))"}
}

extension DeleteDatabaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

public struct DeleteDatabaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInput: Swift.Equatable {
    /// <p>The name of the Timestream database to be deleted.</p>
    public let databaseName: Swift.String?

    public init (
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DeleteDatabaseInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
}

extension DeleteDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DeleteDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatabaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatabaseOutputResponse()"}
}

extension DeleteDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatabaseOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatabaseOutputResponseBody: Swift.Equatable {
}

extension DeleteDatabaseOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTableOutputError>
}

extension DeleteTableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTableInput(databaseName: \(Swift.String(describing: databaseName)), tableName: \(Swift.String(describing: tableName)))"}
}

extension DeleteTableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeleteTableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTableOutputError>
}

public struct DeleteTableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTableOutputError>
}

public struct DeleteTableInput: Swift.Equatable {
    /// <p>The name of the database where the Timestream database is to be deleted.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the Timestream table to be deleted.</p>
    public let tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DeleteTableInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let tableName: Swift.String?
}

extension DeleteTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DeleteTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTableOutputResponse()"}
}

extension DeleteTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTableOutputResponseBody: Swift.Equatable {
}

extension DeleteTableOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeDatabaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatabaseOutputError>
}

extension DescribeDatabaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatabaseInput(databaseName: \(Swift.String(describing: databaseName)))"}
}

extension DescribeDatabaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

public struct DescribeDatabaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatabaseOutputError>
}

public struct DescribeDatabaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatabaseOutputError>
}

public struct DescribeDatabaseInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?

    public init (
        databaseName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DescribeDatabaseInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
}

extension DescribeDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DescribeDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatabaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatabaseOutputResponse(database: \(Swift.String(describing: database)))"}
}

extension DescribeDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct DescribeDatabaseOutputResponse: Swift.Equatable {
    /// <p>The name of the Timestream table.</p>
    public let database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct DescribeDatabaseOutputResponseBody: Swift.Equatable {
    public let database: TimestreamWriteClientTypes.Database?
}

extension DescribeDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension DescribeEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsInput()"}
}

extension DescribeEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInput: Swift.Equatable {

    public init() {}
}

struct DescribeEndpointsInputBody: Swift.Equatable {
}

extension DescribeEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEndpointsOutputResponse(endpoints: \(Swift.String(describing: endpoints)))"}
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// <p>An <code>Endpoints</code> object is returned when a <code>DescribeEndpoints</code> request is made.</p>
    public let endpoints: [TimestreamWriteClientTypes.Endpoint]?

    public init (
        endpoints: [TimestreamWriteClientTypes.Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    public let endpoints: [TimestreamWriteClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[TimestreamWriteClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [TimestreamWriteClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

public struct DescribeTableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableOutputError>
}

extension DescribeTableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableInput(databaseName: \(Swift.String(describing: databaseName)), tableName: \(Swift.String(describing: tableName)))"}
}

extension DescribeTableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DescribeTableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableOutputError>
}

public struct DescribeTableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTableOutputError>
}

public struct DescribeTableInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>The name of the Timestream table.</p>
    public let tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DescribeTableInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let tableName: Swift.String?
}

extension DescribeTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DescribeTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTableOutputResponse(table: \(Swift.String(describing: table)))"}
}

extension DescribeTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct DescribeTableOutputResponse: Swift.Equatable {
    /// <p>The Timestream table.</p>
    public let table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct DescribeTableOutputResponseBody: Swift.Equatable {
    public let table: TimestreamWriteClientTypes.Table?
}

extension DescribeTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension TimestreamWriteClientTypes.Dimension: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueType = "DimensionValueType"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionValueType = dimensionValueType {
            try encodeContainer.encode(dimensionValueType.rawValue, forKey: .dimensionValueType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let dimensionValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.DimensionValueType.self, forKey: .dimensionValueType)
        dimensionValueType = dimensionValueTypeDecoded
    }
}

extension TimestreamWriteClientTypes.Dimension: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Dimension(dimensionValueType: \(Swift.String(describing: dimensionValueType)), name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>Dimension represents the meta data attributes of the time series. For example, the name and availability zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions. </p>
    public struct Dimension: Swift.Equatable {
        /// <p>The data type of the dimension for the time series data point.</p>
        public let dimensionValueType: TimestreamWriteClientTypes.DimensionValueType?
        /// <p>
        ///          Dimension represents the meta data attributes of the time series.
        ///          For example, the name and availability zone of an EC2 instance or
        ///          the name of the manufacturer of a wind turbine are dimensions.
        ///
        ///       </p>
        ///          <p>For constraints on Dimension names,
        ///          see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming">Naming Constraints</a>.</p>
        public let name: Swift.String?
        /// <p>The value of the dimension.</p>
        public let value: Swift.String?

        public init (
            dimensionValueType: TimestreamWriteClientTypes.DimensionValueType? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.dimensionValueType = dimensionValueType
            self.name = name
            self.value = value
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum DimensionValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueType] {
            return [
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionValueType(rawValue: rawValue) ?? DimensionValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .cachePeriodInMinutes)
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension TimestreamWriteClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), cachePeriodInMinutes: \(Swift.String(describing: cachePeriodInMinutes)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>Represents an available endpoint against which to make API calls agaisnt, as well as the TTL for that endpoint.</p>
    public struct Endpoint: Swift.Equatable {
        /// <p>An endpoint address.</p>
        public let address: Swift.String?
        /// <p>The TTL for the endpoint, in minutes.</p>
        public let cachePeriodInMinutes: Swift.Int

        public init (
            address: Swift.String? = nil,
            cachePeriodInMinutes: Swift.Int = 0
        )
        {
            self.address = address
            self.cachePeriodInMinutes = cachePeriodInMinutes
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Timestream was unable to fully process this request because of an internal server error.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEndpointException(message: \(Swift.String(describing: message)))"}
}

extension InvalidEndpointException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested endpoint was invalid.</p>
public struct InvalidEndpointException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEndpointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDatabasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatabasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatabasesOutputError>
}

extension ListDatabasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatabasesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatabasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatabasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatabasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatabasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInput: Swift.Equatable {
    /// <p>The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let maxResults: Swift.Int?
    /// <p>The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatabasesOutputResponse(databases: \(Swift.String(describing: databases)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Swift.Equatable {
    /// <p>A list of database names.</p>
    public let databases: [TimestreamWriteClientTypes.Database]?
    /// <p>The pagination token. This parameter is returned when the response is truncated.</p>
    public let nextToken: Swift.String?

    public init (
        databases: [TimestreamWriteClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Swift.Equatable {
    public let databases: [TimestreamWriteClientTypes.Database]?
    public let nextToken: Swift.String?
}

extension ListDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Database?].self, forKey: .databases)
        var databasesDecoded0:[TimestreamWriteClientTypes.Database]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [TimestreamWriteClientTypes.Database]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTablesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTablesOutputError>
}

extension ListTablesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTablesInput(databaseName: \(Swift.String(describing: databaseName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTablesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTablesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTablesOutputError>
}

public struct ListTablesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTablesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTablesOutputError>
}

public struct ListTablesInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let maxResults: Swift.Int?
    /// <p>The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let nextToken: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTablesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTablesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tables: \(Swift.String(describing: tables)))"}
}

extension ListTablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutputResponse: Swift.Equatable {
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously truncated response.</p>
    public let nextToken: Swift.String?
    /// <p>A list of tables.</p>
    public let tables: [TimestreamWriteClientTypes.Table]?

    public init (
        nextToken: Swift.String? = nil,
        tables: [TimestreamWriteClientTypes.Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputResponseBody: Swift.Equatable {
    public let tables: [TimestreamWriteClientTypes.Table]?
    public let nextToken: Swift.String?
}

extension ListTablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Table?].self, forKey: .tables)
        var tablesDecoded0:[TimestreamWriteClientTypes.Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [TimestreamWriteClientTypes.Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>
    /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>
    /// The tags currently associated with the Timestream resource.
    /// </p>
    public let tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [TimestreamWriteClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TimestreamWriteClientTypes {
    public enum MeasureValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case double
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasureValueType] {
            return [
                .bigint,
                .boolean,
                .double,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeasureValueType(rawValue: rawValue) ?? MeasureValueType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.Record: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case measureName = "MeasureName"
        case measureValue = "MeasureValue"
        case measureValueType = "MeasureValueType"
        case time = "Time"
        case timeUnit = "TimeUnit"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensions0 in dimensions {
                try dimensionsContainer.encode(dimensions0)
            }
        }
        if let measureName = measureName {
            try encodeContainer.encode(measureName, forKey: .measureName)
        }
        if let measureValue = measureValue {
            try encodeContainer.encode(measureValue, forKey: .measureValue)
        }
        if let measureValueType = measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let time = time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[TimestreamWriteClientTypes.Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [TimestreamWriteClientTypes.Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let measureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureName)
        measureName = measureNameDecoded
        let measureValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureValue)
        measureValue = measureValueDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.MeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let versionDecoded = try containerValues.decode(Swift.Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension TimestreamWriteClientTypes.Record: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Record(dimensions: \(Swift.String(describing: dimensions)), measureName: \(Swift.String(describing: measureName)), measureValue: \(Swift.String(describing: measureValue)), measureValueType: \(Swift.String(describing: measureValueType)), time: \(Swift.String(describing: time)), timeUnit: \(Swift.String(describing: timeUnit)), version: \(Swift.String(describing: version)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>Record represents a time series data point being written into
    ///        Timestream. Each record contains an array of dimensions. Dimensions
    ///        represent the meta data attributes of a time series data point such as
    ///        the instance name or availability zone of an EC2 instance. A record also
    ///        contains the measure name which is the name of the measure being collected
    ///        for example the CPU utilization of an EC2 instance. A record also contains
    ///        the measure value and the value type which is the data type of the measure value.
    ///        In addition, the record contains the timestamp when the measure was collected that
    ///        the timestamp unit which represents the granularity of the timestamp.
    ///        </p>
    public struct Record: Swift.Equatable {
        /// <p>Contains the list of dimensions for time series data points.</p>
        public let dimensions: [TimestreamWriteClientTypes.Dimension]?
        /// <p>Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures. </p>
        public let measureName: Swift.String?
        /// <p>
        /// Contains the measure value for the time series data point.
        /// </p>
        public let measureValue: Swift.String?
        /// <p>
        /// Contains the data type of the measure value for the time series data point.
        /// </p>
        public let measureValueType: TimestreamWriteClientTypes.MeasureValueType?
        /// <p>
        /// Contains the time at which the measure value for the data point was collected.
        /// The time value plus the unit provides the time elapsed since the epoch.
        /// For example, if the time value is <code>12345</code> and the unit is <code>ms</code>,
        ///    then <code>12345 ms</code> have elapsed since the epoch.
        /// </p>
        public let time: Swift.String?
        /// <p>
        /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds or other supported values.
        /// </p>
        public let timeUnit: TimestreamWriteClientTypes.TimeUnit?
        /// <p>64-bit attribute used for record updates.
        ///          Write requests for duplicate data with a higher version number will update the existing measure value and version.
        ///          In cases where the measure value is the same, <code>Version</code> will still be updated . Default value is to 1.</p>
        public let version: Swift.Int

        public init (
            dimensions: [TimestreamWriteClientTypes.Dimension]? = nil,
            measureName: Swift.String? = nil,
            measureValue: Swift.String? = nil,
            measureValueType: TimestreamWriteClientTypes.MeasureValueType? = nil,
            time: Swift.String? = nil,
            timeUnit: TimestreamWriteClientTypes.TimeUnit? = nil,
            version: Swift.Int = 0
        )
        {
            self.dimensions = dimensions
            self.measureName = measureName
            self.measureValue = measureValue
            self.measureValueType = measureValueType
            self.time = time
            self.timeUnit = timeUnit
            self.version = version
        }
    }

}

extension TimestreamWriteClientTypes.RejectedRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingVersion = "ExistingVersion"
        case reason = "Reason"
        case recordIndex = "RecordIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if existingVersion != 0 {
            try encodeContainer.encode(existingVersion, forKey: .existingVersion)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIndexDecoded = try containerValues.decode(Swift.Int.self, forKey: .recordIndex)
        recordIndex = recordIndexDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let existingVersionDecoded = try containerValues.decode(Swift.Int.self, forKey: .existingVersion)
        existingVersion = existingVersionDecoded
    }
}

extension TimestreamWriteClientTypes.RejectedRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectedRecord(existingVersion: \(Swift.String(describing: existingVersion)), reason: \(Swift.String(describing: reason)), recordIndex: \(Swift.String(describing: recordIndex)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>
    /// Records that were not successfully inserted into Timestream due to data validation issues
    /// that must be resolved prior to reinserting time series data into the system.
    /// </p>
    public struct RejectedRecord: Swift.Equatable {
        /// <p>The existing version of the record.
        ///          This value is populated in scenarios where an identical record exists with a higher version than the version in the write request.</p>
        public let existingVersion: Swift.Int
        /// <p>
        ///          The reason why a record was not successfully inserted into Timestream. Possible causes of failure include:
        ///       </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                  Records with duplicate data where there are multiple records with the same dimensions,
        ///          timestamps, and measure names but different measure values.
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                  Records with timestamps that lie outside the retention duration of the memory store
        ///                </p>
        ///                <note>
        ///                   <p>When the retention window is updated, you will receive a <code>RejectedRecords</code> exception
        ///                   if you immediately try to ingest data within the new window.
        ///                   To avoid a <code>RejectedRecords</code> exception,
        ///                   wait until the duration of the new window to ingest new data.
        ///                   For further information,
        ///                   see
        ///                   <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/best-practices.html#configuration">
        ///                      Best Practices for Configuring Timestream</a>
        ///                   and
        ///                   <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html">the explanation of how storage works in Timestream</a>.</p>
        ///                </note>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                  Records with dimensions or measures that exceed the Timestream defined limits.
        ///                </p>
        ///             </li>
        ///          </ul>
        ///          <p>
        ///             For more information, see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html">Access Management</a> in the Timestream Developer Guide.
        ///          </p>
        public let reason: Swift.String?
        /// <p>
        /// The index of the record in the input request for WriteRecords. Indexes begin with 0.
        /// </p>
        public let recordIndex: Swift.Int

        public init (
            existingVersion: Swift.Int = 0,
            reason: Swift.String? = nil,
            recordIndex: Swift.Int = 0
        )
        {
            self.existingVersion = existingVersion
            self.reason = reason
            self.recordIndex = recordIndex
        }
    }

}

extension RejectedRecordsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectedRecordsException(message: \(Swift.String(describing: message)), rejectedRecords: \(Swift.String(describing: rejectedRecords)))"}
}

extension RejectedRecordsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectedRecordsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.rejectedRecords = output.rejectedRecords
        } else {
            self.message = nil
            self.rejectedRecords = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///          WriteRecords would throw this exception in the following cases:
///       </p>
///          <ul>
///             <li>
///                <p>
///                  Records with duplicate data where there are multiple records with the same dimensions,
///          timestamps, and measure names but different measure values.
///                </p>
///             </li>
///             <li>
///                <p>
///                  Records with timestamps that lie outside the retention duration of the memory store
///                </p>
///             </li>
///             <li>
///                <p>
///                  Records with dimensions or measures that exceed the Timestream defined limits.
///                </p>
///             </li>
///          </ul>
///          <p>
///          For more information, see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html">Access Management</a> in the Timestream Developer Guide.
///          </p>
public struct RejectedRecordsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]?

    public init (
        message: Swift.String? = nil,
        rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]? = nil
    )
    {
        self.message = message
        self.rejectedRecords = rejectedRecords
    }
}

struct RejectedRecordsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let rejectedRecords: [TimestreamWriteClientTypes.RejectedRecord]?
}

extension RejectedRecordsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case rejectedRecords = "RejectedRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let rejectedRecordsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.RejectedRecord?].self, forKey: .rejectedRecords)
        var rejectedRecordsDecoded0:[TimestreamWriteClientTypes.RejectedRecord]? = nil
        if let rejectedRecordsContainer = rejectedRecordsContainer {
            rejectedRecordsDecoded0 = [TimestreamWriteClientTypes.RejectedRecord]()
            for structure0 in rejectedRecordsContainer {
                if let structure0 = structure0 {
                    rejectedRecordsDecoded0?.append(structure0)
                }
            }
        }
        rejectedRecords = rejectedRecordsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes.RetentionProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case magneticStoreRetentionPeriodInDays = "MagneticStoreRetentionPeriodInDays"
        case memoryStoreRetentionPeriodInHours = "MemoryStoreRetentionPeriodInHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if magneticStoreRetentionPeriodInDays != 0 {
            try encodeContainer.encode(magneticStoreRetentionPeriodInDays, forKey: .magneticStoreRetentionPeriodInDays)
        }
        if memoryStoreRetentionPeriodInHours != 0 {
            try encodeContainer.encode(memoryStoreRetentionPeriodInHours, forKey: .memoryStoreRetentionPeriodInHours)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memoryStoreRetentionPeriodInHoursDecoded = try containerValues.decode(Swift.Int.self, forKey: .memoryStoreRetentionPeriodInHours)
        memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHoursDecoded
        let magneticStoreRetentionPeriodInDaysDecoded = try containerValues.decode(Swift.Int.self, forKey: .magneticStoreRetentionPeriodInDays)
        magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDaysDecoded
    }
}

extension TimestreamWriteClientTypes.RetentionProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetentionProperties(magneticStoreRetentionPeriodInDays: \(Swift.String(describing: magneticStoreRetentionPeriodInDays)), memoryStoreRetentionPeriodInHours: \(Swift.String(describing: memoryStoreRetentionPeriodInHours)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>Retention properties contain the duration for which your time series data must be stored in the magnetic store and the memory store.
    ///       </p>
    public struct RetentionProperties: Swift.Equatable {
        /// <p>The duration for which data must be stored in the magnetic store. </p>
        public let magneticStoreRetentionPeriodInDays: Swift.Int
        /// <p>The duration for which data must be stored in the memory store. </p>
        public let memoryStoreRetentionPeriodInHours: Swift.Int

        public init (
            magneticStoreRetentionPeriodInDays: Swift.Int = 0,
            memoryStoreRetentionPeriodInHours: Swift.Int = 0
        )
        {
            self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
            self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Instance quota of resource exceeded for this account.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes.Table: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case lastUpdatedTime = "LastUpdatedTime"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableStatus = tableStatus {
            try encodeContainer.encode(tableStatus.rawValue, forKey: .tableStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableStatusDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.TableStatus.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension TimestreamWriteClientTypes.Table: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Table(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), databaseName: \(Swift.String(describing: databaseName)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), retentionProperties: \(Swift.String(describing: retentionProperties)), tableName: \(Swift.String(describing: tableName)), tableStatus: \(Swift.String(describing: tableStatus)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>Table represents a database table in Timestream. Tables contain one or more related time series. You can modify the retention duration of the memory store and the magnetic store for a table.
    ///       </p>
    public struct Table: Swift.Equatable {
        /// <p>The Amazon Resource Name that uniquely identifies this table.</p>
        public let arn: Swift.String?
        /// <p>The time when the Timestream table was created. </p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the Timestream database that contains this table.</p>
        public let databaseName: Swift.String?
        /// <p>The time when the Timestream table was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The retention duration for the memory store and magnetic store.</p>
        public let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
        /// <p>The name of the Timestream table.</p>
        public let tableName: Swift.String?
        /// <p>The current state of the table:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>DELETING</code> - The table is being deleted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ACTIVE</code> - The table is ready for use.</p>
        ///             </li>
        ///          </ul>
        public let tableStatus: TimestreamWriteClientTypes.TableStatus?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            databaseName: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
            tableName: Swift.String? = nil,
            tableStatus: TimestreamWriteClientTypes.TableStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastUpdatedTime = lastUpdatedTime
            self.retentionProperties = retentionProperties
            self.tableName = tableName
            self.tableStatus = tableStatus
        }
    }

}

extension TimestreamWriteClientTypes {
    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableStatus(rawValue: rawValue) ?? TableStatus.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamWriteClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestreamWriteClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension TimestreamWriteClientTypes {
    /// <p>
    /// A tag is a label that you assign to a Timestream database and/or table. Each tag consists
    /// of a key and an optional value, both of which you define. Tags enable you to
    /// categorize databases and/or tables, for example, by purpose, owner, or environment.
    /// </p>
    public struct Tag: Swift.Equatable {
        /// <p>
        /// The key of the tag. Tag keys are case sensitive.
        /// </p>
        public let key: Swift.String?
        /// <p>
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// </p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>
    ///     Identifies the Timestream resource to which tags should be added. This value is an
    ///     Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: Swift.String?
    /// <p>
    /// The tags to be assigned to the Timestream resource.
    /// </p>
    public let tags: [TimestreamWriteClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [TimestreamWriteClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [TimestreamWriteClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TimestreamWriteClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TimestreamWriteClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Too many requests were made by a user exceeding service quotas. The request was throttled.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamWriteClientTypes {
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case microseconds
        case milliseconds
        case nanoseconds
        case seconds
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .microseconds,
                .milliseconds,
                .nanoseconds,
                .seconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .microseconds: return "MICROSECONDS"
            case .milliseconds: return "MILLISECONDS"
            case .nanoseconds: return "NANOSECONDS"
            case .seconds: return "SECONDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>
    ///     The Timestream resource that the tags will be removed from. This value
    ///     is an Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: Swift.String?
    /// <p>
    ///     A list of tags keys. Existing tags of the resource whose keys are members of this
    ///     list will be removed from the Timestream resource.
    /// </p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDatabaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatabaseOutputError>
}

extension UpdateDatabaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatabaseInput(databaseName: \(Swift.String(describing: databaseName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension UpdateDatabaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

public struct UpdateDatabaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInput: Swift.Equatable {
    /// <p>
    ///      The name of the database.
    ///    </p>
    public let databaseName: Swift.String?
    /// <p>
    ///       The identifier of the new KMS key (<code>KmsKeyId</code>) to be used to encrypt the data stored in the database.
    ///       If the <code>KmsKeyId</code> currently registered with the database is the same as the <code>KmsKeyId</code> in the
    ///       request, there will not be any update.
    ///    </p>
    ///          <p>You can specify the <code>KmsKeyId</code> using any of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
    }
}

struct UpdateDatabaseInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let kmsKeyId: Swift.String?
}

extension UpdateDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateDatabaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatabaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatabaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatabaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatabaseOutputResponse(database: \(Swift.String(describing: database)))"}
}

extension UpdateDatabaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct UpdateDatabaseOutputResponse: Swift.Equatable {
    /// <p>A top level container for a table. Databases and tables are the
    ///       fundamental management concepts in Amazon Timestream. All tables in a
    ///       database are encrypted with the same KMS key.</p>
    public let database: TimestreamWriteClientTypes.Database?

    public init (
        database: TimestreamWriteClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct UpdateDatabaseOutputResponseBody: Swift.Equatable {
    public let database: TimestreamWriteClientTypes.Database?
}

extension UpdateDatabaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct UpdateTableInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTableOutputError>
}

extension UpdateTableInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTableInput(databaseName: \(Swift.String(describing: databaseName)), retentionProperties: \(Swift.String(describing: retentionProperties)), tableName: \(Swift.String(describing: tableName)))"}
}

extension UpdateTableInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct UpdateTableInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTableOutputError>
}

public struct UpdateTableInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTableInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTableOutputError>
}

public struct UpdateTableInput: Swift.Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>The retention duration of the memory store and the magnetic store.</p>
    public let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
    /// <p>The name of the Timesream table.</p>
    public let tableName: Swift.String?

    public init (
        databaseName: Swift.String? = nil,
        retentionProperties: TimestreamWriteClientTypes.RetentionProperties? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.retentionProperties = retentionProperties
        self.tableName = tableName
    }
}

struct UpdateTableInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let tableName: Swift.String?
    public let retentionProperties: TimestreamWriteClientTypes.RetentionProperties?
}

extension UpdateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
    }
}

extension UpdateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTableOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTableOutputResponse(table: \(Swift.String(describing: table)))"}
}

extension UpdateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct UpdateTableOutputResponse: Swift.Equatable {
    /// <p>The updated Timestream table.</p>
    public let table: TimestreamWriteClientTypes.Table?

    public init (
        table: TimestreamWriteClientTypes.Table? = nil
    )
    {
        self.table = table
    }
}

struct UpdateTableOutputResponseBody: Swift.Equatable {
    public let table: TimestreamWriteClientTypes.Table?
}

extension UpdateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case table = "Table"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Invalid or malformed request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct WriteRecordsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WriteRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WriteRecordsOutputError>
}

extension WriteRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WriteRecordsInput(commonAttributes: \(Swift.String(describing: commonAttributes)), databaseName: \(Swift.String(describing: databaseName)), records: \(Swift.String(describing: records)), tableName: \(Swift.String(describing: tableName)))"}
}

extension WriteRecordsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonAttributes = commonAttributes {
            try encodeContainer.encode(commonAttributes, forKey: .commonAttributes)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct WriteRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WriteRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WriteRecordsOutputError>
}

public struct WriteRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "WriteRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<WriteRecordsOutputError>
}

public struct WriteRecordsInput: Swift.Equatable {
    /// <p>A record containing the common measure and dimension attributes
    ///        shared across all the records in the request. The measure and dimension
    ///        attributes specified in here will be merged with the measure and dimension
    ///        attributes in the records object when the data is written into Timestream.
    ///        </p>
    public let commonAttributes: TimestreamWriteClientTypes.Record?
    /// <p>The name of the Timestream database.</p>
    public let databaseName: Swift.String?
    /// <p>An array of records containing the unique dimension and measure
    ///        attributes for each time series data point.
    ///        </p>
    public let records: [TimestreamWriteClientTypes.Record]?
    /// <p>The name of the Timesream table.</p>
    public let tableName: Swift.String?

    public init (
        commonAttributes: TimestreamWriteClientTypes.Record? = nil,
        databaseName: Swift.String? = nil,
        records: [TimestreamWriteClientTypes.Record]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.commonAttributes = commonAttributes
        self.databaseName = databaseName
        self.records = records
        self.tableName = tableName
    }
}

struct WriteRecordsInputBody: Swift.Equatable {
    public let databaseName: Swift.String?
    public let tableName: Swift.String?
    public let commonAttributes: TimestreamWriteClientTypes.Record?
    public let records: [TimestreamWriteClientTypes.Record]?
}

extension WriteRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let commonAttributesDecoded = try containerValues.decodeIfPresent(TimestreamWriteClientTypes.Record.self, forKey: .commonAttributes)
        commonAttributes = commonAttributesDecoded
        let recordsContainer = try containerValues.decodeIfPresent([TimestreamWriteClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[TimestreamWriteClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [TimestreamWriteClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension WriteRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WriteRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RejectedRecordsException" : self = .rejectedRecordsException(try RejectedRecordsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum WriteRecordsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case rejectedRecordsException(RejectedRecordsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WriteRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WriteRecordsOutputResponse()"}
}

extension WriteRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct WriteRecordsOutputResponse: Swift.Equatable {

    public init() {}
}

struct WriteRecordsOutputResponseBody: Swift.Equatable {
}

extension WriteRecordsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
