// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssumeRoleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

extension AssumeRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleInput(durationSeconds: \(Swift.String(describing: durationSeconds)), externalId: \(Swift.String(describing: externalId)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), roleArn: \(Swift.String(describing: roleArn)), roleSessionName: \(Swift.String(describing: roleSessionName)), serialNumber: \(Swift.String(describing: serialNumber)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), tags: \(Swift.String(describing: tags)), tokenCode: \(Swift.String(describing: tokenCode)), transitiveTagKeys: \(Swift.String(describing: transitiveTagKeys)))"}
}

extension AssumeRoleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let externalId = externalId {
            try container.encode(externalId, forKey: ClientRuntime.Key("ExternalId"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: ClientRuntime.Key("RoleSessionName"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let sourceIdentity = sourceIdentity {
            try container.encode(sourceIdentity, forKey: ClientRuntime.Key("SourceIdentity"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: ClientRuntime.Key("TokenCode"))
        }
        if let transitiveTagKeys = transitiveTagKeys {
            var transitiveTagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TransitiveTagKeys"))
            for (index0, tagkeytype0) in transitiveTagKeys.enumerated() {
                try transitiveTagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AssumeRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInput: Swift.Equatable {
    /// The duration, in seconds, of the role session. The value specified can can range from
    ///          900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
    ///          maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
    ///          value higher than this setting or the administrator setting (whichever is lower), the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role in the
    ///             IAM User Guide.
    ///          By default, the value is set to 3600 seconds.
    ///
    ///             The DurationSeconds parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a SessionDuration
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the Management Console in the
    ///                IAM User Guide.
    ///
    public let durationSeconds: Swift.Int?
    /// A unique identifier that might be required when you assume a role in another account. If
    ///          the administrator of the account to which the role belongs provided you with an external
    ///          ID, then provide that value in the ExternalId parameter. This value can be any
    ///          string, such as a passphrase or account number. A cross-account role is usually set up to
    ///          trust everyone in an account. Therefore, the administrator of the trusting account might
    ///          send an external ID to the administrator of the trusted account. That way, only someone
    ///          with the ID can assume the role, rather than everyone in the account. For more information
    ///          about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
    ///             When Granting Access to Your Amazon Web Services Resources to a Third Party in the
    ///             IAM User Guide.
    ///          The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-
    public let externalId: Swift.String?
    /// An IAM policy in JSON format that you want to use as an inline session policy.
    ///          This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    ///          The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    public let policy: Swift.String?
    /// The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.
    ///          This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
    ///             Service Namespaces in the Amazon Web Services General Reference.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    ///
    ///          Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// The Amazon Resource Name (ARN) of the role to assume.
    /// This member is required.
    public let roleArn: Swift.String?
    /// An identifier for the assumed role session.
    ///          Use the role session name to uniquely identify a session when the same role is assumed
    ///          by different principals or for different reasons. In cross-account scenarios, the role
    ///          session name is visible to, and can be logged by the account that owns the role. The role
    ///          session name is also used in the ARN of the assumed role principal. This means that
    ///          subsequent cross-account API requests that use the temporary security credentials will
    ///          expose the role session name to the external account in their CloudTrail logs.
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    /// This member is required.
    public let roleSessionName: Swift.String?
    /// The identification number of the MFA device that is associated with the user who is
    ///          making the AssumeRole call. Specify this value if the trust policy of the role
    ///          being assumed includes a condition that requires MFA authentication. The value is either
    ///          the serial number for a hardware device (such as GAHT12345678) or an Amazon
    ///          Resource Name (ARN) for a virtual device (such as
    ///             arn:aws:iam::123456789012:mfa/user).
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    public let serialNumber: Swift.String?
    /// The source identity specified by the principal that is calling the
    ///             AssumeRole operation.
    ///          You can require users to specify a source identity when they assume a role. You do this
    ///          by using the sts:SourceIdentity condition key in a role trust policy. You can
    ///          use source identity information in CloudTrail logs to determine who took actions with a role.
    ///          You can use the aws:SourceIdentity condition key to further control access to
    ///          Amazon Web Services resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles in the
    ///          IAM User Guide.
    ///          The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-. You cannot use a value that begins with the text
    ///          aws:. This prefix is reserved for Amazon Web Services internal
    ///          use.
    public let sourceIdentity: Swift.String?
    /// A list of session tags that you want to pass. Each session tag consists of a key name
    ///          and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging STS
    ///             Sessions in the IAM User Guide.
    ///          This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters, and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits in the IAM User Guide.
    ///
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    ///          You can pass a session tag with the same key as a tag that is already
    ///          attached to the role. When you do, session tags override a role tag with the same key.
    ///          Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate Department and department tag keys. Assume
    ///          that the role has the Department=Marketing tag and you pass the
    ///             department=engineering session tag. Department
    ///          and department are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.
    ///          Additionally, if you used temporary credentials to perform this operation, the new
    ///          session inherits any transitive session tags from the calling session. If you pass a
    ///          session tag with the same key as an inherited tag, the operation fails. To view the
    ///          inherited tags for a session, see the CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail in the
    ///          IAM User Guide.
    public let tags: [StsClientTypes.Tag]?
    /// The value provided by the MFA device, if the trust policy of the role being assumed
    ///          requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
    ///          the role being assumed requires MFA and if the TokenCode value is missing or
    ///          expired, the AssumeRole call returns an "access denied" error.
    ///          The format for this parameter, as described by its regex pattern, is a sequence of six
    ///          numeric digits.
    public let tokenCode: Swift.String?
    /// A list of keys for session tags that you want to set as transitive. If you set a tag key
    ///          as transitive, the corresponding key and value passes to subsequent sessions in a role
    ///          chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
    ///             with Session Tags in the IAM User Guide.
    ///          This parameter is optional. When you set session tags as transitive, the session policy
    ///          and session tags packed binary limit is not affected.
    ///          If you choose not to specify a transitive tag key, then no tags are passed from this
    ///          session to any subsequent sessions.
    public let transitiveTagKeys: [Swift.String]?

    public init (
        durationSeconds: Swift.Int? = nil,
        externalId: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        roleArn: Swift.String? = nil,
        roleSessionName: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        sourceIdentity: Swift.String? = nil,
        tags: [StsClientTypes.Tag]? = nil,
        tokenCode: Swift.String? = nil,
        transitiveTagKeys: [Swift.String]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.externalId = externalId
        self.policy = policy
        self.policyArns = policyArns
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.serialNumber = serialNumber
        self.sourceIdentity = sourceIdentity
        self.tags = tags
        self.tokenCode = tokenCode
        self.transitiveTagKeys = transitiveTagKeys
    }
}

extension AssumeRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLarge" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), credentials: \(Swift.String(describing: credentials)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), sourceIdentity: \(Swift.String(describing: sourceIdentity)))"}
}

extension AssumeRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
        } else {
            self.assumedRoleUser = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
        }
    }
}

/// Contains the response to a successful AssumeRole request, including
///       temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests.
public struct AssumeRoleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the RoleSessionName that you specified
    ///          when you called AssumeRole.
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    /// The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.
    ///
    ///             The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.
    ///
    public let credentials: StsClientTypes.Credentials?
    /// A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.
    public let packedPolicySize: Swift.Int?
    /// The source identity specified by the principal that is calling the
    ///             AssumeRole operation.
    ///          You can require users to specify a source identity when they assume a role. You do this
    ///          by using the sts:SourceIdentity condition key in a role trust policy. You can
    ///          use source identity information in CloudTrail logs to determine who took actions with a role.
    ///          You can use the aws:SourceIdentity condition key to further control access to
    ///          Amazon Web Services resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles in the
    ///          IAM User Guide.
    ///          The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-
    public let sourceIdentity: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        packedPolicySize: Swift.Int? = nil,
        sourceIdentity: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
    }
}

struct AssumeRoleOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithSAMLInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

extension AssumeRoleWithSAMLInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithSAMLInput(durationSeconds: \(Swift.String(describing: durationSeconds)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), principalArn: \(Swift.String(describing: principalArn)), roleArn: \(Swift.String(describing: roleArn)), sAMLAssertion: \(Swift.String(describing: sAMLAssertion)))"}
}

extension AssumeRoleWithSAMLInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let principalArn = principalArn {
            try container.encode(principalArn, forKey: ClientRuntime.Key("PrincipalArn"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let sAMLAssertion = sAMLAssertion {
            try container.encode(sAMLAssertion, forKey: ClientRuntime.Key("SAMLAssertion"))
        }
        try container.encode("AssumeRoleWithSAML", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleWithSAMLInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInput: Swift.Equatable {
    /// The duration, in seconds, of the role session. Your role session lasts for the duration
    ///          that you specify for the DurationSeconds parameter, or until the time
    ///          specified in the SAML authentication response's SessionNotOnOrAfter value,
    ///          whichever is shorter. You can provide a DurationSeconds value from 900 seconds
    ///          (15 minutes) up to the maximum session duration setting for the role. This setting can have
    ///          a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role in the
    ///             IAM User Guide.
    ///          By default, the value is set to 3600 seconds.
    ///
    ///             The DurationSeconds parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a SessionDuration
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the Management Console in the
    ///                IAM User Guide.
    ///
    public let durationSeconds: Swift.Int?
    /// An IAM policy in JSON format that you want to use as an inline session policy.
    ///          This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    ///          The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    public let policy: Swift.String?
    /// The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.
    ///          This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
    ///             Service Namespaces in the Amazon Web Services General Reference.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    ///
    ///          Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
    ///          IdP.
    /// This member is required.
    public let principalArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the role that the caller is assuming.
    /// This member is required.
    public let roleArn: Swift.String?
    /// The base64 encoded SAML authentication response provided by the IdP.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
    ///             Adding Claims in the IAM User Guide.
    /// This member is required.
    public let sAMLAssertion: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        principalArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sAMLAssertion: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.principalArn = principalArn
        self.roleArn = roleArn
        self.sAMLAssertion = sAMLAssertion
    }
}

extension AssumeRoleWithSAMLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithSAMLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaim" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityToken" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLarge" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithSAMLOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithSAMLOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithSAMLOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), audience: \(Swift.String(describing: audience)), credentials: \(Swift.String(describing: credentials)), issuer: \(Swift.String(describing: issuer)), nameQualifier: \(Swift.String(describing: nameQualifier)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), subject: \(Swift.String(describing: subject)), subjectType: \(Swift.String(describing: subjectType)))"}
}

extension AssumeRoleWithSAMLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleWithSAMLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.issuer = output.issuer
            self.nameQualifier = output.nameQualifier
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
            self.subject = output.subject
            self.subjectType = output.subjectType
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.issuer = nil
            self.nameQualifier = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
            self.subject = nil
            self.subjectType = nil
        }
    }
}

/// Contains the response to a successful AssumeRoleWithSAML request,
///       including temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests.
public struct AssumeRoleWithSAMLOutputResponse: Swift.Equatable {
    /// The identifiers for the temporary security credentials that the operation
    ///          returns.
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    ///  The value of the Recipient attribute of the
    ///             SubjectConfirmationData element of the SAML assertion.
    public let audience: Swift.String?
    /// The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.
    ///
    ///             The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.
    ///
    public let credentials: StsClientTypes.Credentials?
    /// The value of the Issuer element of the SAML assertion.
    public let issuer: Swift.String?
    /// A hash value based on the concatenation of the following:
    ///
    ///
    ///                The Issuer response value.
    ///
    ///
    ///                The Amazon Web Services account ID.
    ///
    ///
    ///                The friendly name (the last part of the ARN) of the SAML provider in IAM.
    ///
    ///
    ///          The combination of NameQualifier and Subject can be used to
    ///          uniquely identify a federated user.
    ///          The following pseudocode shows how the hash value is calculated:
    ///
    ///             BASE64 ( SHA1 ( "https://example.com/saml" + "123456789012" + "/MySAMLIdP" ) )
    ///
    public let nameQualifier: Swift.String?
    /// A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.
    public let packedPolicySize: Swift.Int?
    /// The value in the SourceIdentity attribute in the SAML assertion.
    ///          You can require users to set a source identity value when they assume a role. You do
    ///          this by using the sts:SourceIdentity condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role sessions. You can configure your SAML identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             AssumeRoleWithSAML. You do this by adding an attribute to the SAML
    ///          assertion. For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles in the
    ///          IAM User Guide.
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    public let sourceIdentity: Swift.String?
    /// The value of the NameID element in the Subject element of the
    ///          SAML assertion.
    public let subject: Swift.String?
    ///  The format of the name ID, as defined by the Format attribute in the
    ///             NameID element of the SAML assertion. Typical examples of the format are
    ///             transient or persistent.
    ///           If the format includes the prefix
    ///             urn:oasis:names:tc:SAML:2.0:nameid-format, that prefix is removed. For
    ///          example, urn:oasis:names:tc:SAML:2.0:nameid-format:transient is returned as
    ///             transient. If the format includes any other prefix, the format is returned
    ///          with no modifications.
    public let subjectType: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        audience: Swift.String? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        issuer: Swift.String? = nil,
        nameQualifier: Swift.String? = nil,
        packedPolicySize: Swift.Int? = nil,
        sourceIdentity: Swift.String? = nil,
        subject: Swift.String? = nil,
        subjectType: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.issuer = issuer
        self.nameQualifier = nameQualifier
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
        self.subject = subject
        self.subjectType = subjectType
    }
}

struct AssumeRoleWithSAMLOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let subject: Swift.String?
    public let subjectType: Swift.String?
    public let issuer: Swift.String?
    public let audience: Swift.String?
    public let nameQualifier: Swift.String?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleWithSAMLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case issuer = "Issuer"
        case nameQualifier = "NameQualifier"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
        case subject = "Subject"
        case subjectType = "SubjectType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleWithSAMLResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectType)
        subjectType = subjectTypeDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audience)
        audience = audienceDecoded
        let nameQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameQualifier)
        nameQualifier = nameQualifierDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithWebIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

extension AssumeRoleWithWebIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithWebIdentityInput(durationSeconds: \(Swift.String(describing: durationSeconds)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), providerId: \(Swift.String(describing: providerId)), roleArn: \(Swift.String(describing: roleArn)), roleSessionName: \(Swift.String(describing: roleSessionName)), webIdentityToken: \(Swift.String(describing: webIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: ClientRuntime.Key("RoleSessionName"))
        }
        if let webIdentityToken = webIdentityToken {
            try container.encode(webIdentityToken, forKey: ClientRuntime.Key("WebIdentityToken"))
        }
        try container.encode("AssumeRoleWithWebIdentity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleWithWebIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInput: Swift.Equatable {
    /// The duration, in seconds, of the role session. The value can range from 900 seconds (15
    ///          minutes) up to the maximum session duration setting for the role. This setting can have a
    ///          value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role in the
    ///             IAM User Guide.
    ///          By default, the value is set to 3600 seconds.
    ///
    ///             The DurationSeconds parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a SessionDuration
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the Management Console in the
    ///                IAM User Guide.
    ///
    public let durationSeconds: Swift.Int?
    /// An IAM policy in JSON format that you want to use as an inline session policy.
    ///          This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    ///          The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    public let policy: Swift.String?
    /// The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.
    ///          This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
    ///             Service Namespaces in the Amazon Web Services General Reference.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    ///
    ///          Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies in the IAM User Guide.
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// The fully qualified host component of the domain name of the identity provider.
    ///          Specify this value only for OAuth 2.0 access tokens. Currently
    ///             www.amazon.com and graph.facebook.com are the only supported
    ///          identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
    ///          numbers.
    ///          Do not specify this value for OpenID Connect ID tokens.
    public let providerId: Swift.String?
    /// The Amazon Resource Name (ARN) of the role that the caller is assuming.
    /// This member is required.
    public let roleArn: Swift.String?
    /// An identifier for the assumed role session. Typically, you pass the name or identifier
    ///          that is associated with the user who is using your application. That way, the temporary
    ///          security credentials that your application will use are associated with that user. This
    ///          session name is included as part of the ARN and assumed role ID in the
    ///             AssumedRoleUser response element.
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    /// This member is required.
    public let roleSessionName: Swift.String?
    /// The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
    ///          provider. Your application must get this token by authenticating the user who is using your
    ///          application with a web identity provider before the application makes an
    ///             AssumeRoleWithWebIdentity call.
    /// This member is required.
    public let webIdentityToken: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        providerId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        roleSessionName: Swift.String? = nil,
        webIdentityToken: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.providerId = providerId
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.webIdentityToken = webIdentityToken
    }
}

extension AssumeRoleWithWebIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithWebIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPCommunicationError" : self = .iDPCommunicationErrorException(try IDPCommunicationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaim" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityToken" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLarge" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithWebIdentityOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPCommunicationErrorException(IDPCommunicationErrorException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithWebIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithWebIdentityOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), audience: \(Swift.String(describing: audience)), credentials: \(Swift.String(describing: credentials)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), provider: \(Swift.String(describing: provider)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), subjectFromWebIdentityToken: \(Swift.String(describing: subjectFromWebIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleWithWebIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.provider = output.provider
            self.sourceIdentity = output.sourceIdentity
            self.subjectFromWebIdentityToken = output.subjectFromWebIdentityToken
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.provider = nil
            self.sourceIdentity = nil
            self.subjectFromWebIdentityToken = nil
        }
    }
}

/// Contains the response to a successful AssumeRoleWithWebIdentity
///       request, including temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests.
public struct AssumeRoleWithWebIdentityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the RoleSessionName that you specified
    ///          when you called AssumeRole.
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    /// The intended audience (also known as client ID) of the web identity token. This is
    ///          traditionally the client identifier issued to the application that requested the web
    ///          identity token.
    public let audience: Swift.String?
    /// The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security token.
    ///
    ///             The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.
    ///
    public let credentials: StsClientTypes.Credentials?
    /// A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.
    public let packedPolicySize: Swift.Int?
    ///  The issuing authority of the web identity token presented. For OpenID Connect ID
    ///          tokens, this contains the value of the iss field. For OAuth 2.0 access tokens,
    ///          this contains the value of the ProviderId parameter that was passed in the
    ///             AssumeRoleWithWebIdentity request.
    public let provider: Swift.String?
    /// The value of the source identity that is returned in the JSON web token (JWT) from the
    ///          identity provider.
    ///          You can require users to set a source identity value when they assume a role. You do
    ///          this by using the sts:SourceIdentity condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role sessions. You can configure your identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             AssumeRoleWithWebIdentity. You do this by adding a claim to the JSON web
    ///          token. To learn more about OIDC tokens and claims, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html">Using Tokens with User Pools in the Amazon Cognito Developer Guide.
    ///          For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles in the
    ///          IAM User Guide.
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    public let sourceIdentity: Swift.String?
    /// The unique user identifier that is returned by the identity provider. This identifier is
    ///          associated with the WebIdentityToken that was submitted with the
    ///             AssumeRoleWithWebIdentity call. The identifier is typically unique to the
    ///          user and the application that acquired the WebIdentityToken (pairwise
    ///          identifier). For OpenID Connect ID tokens, this field contains the value returned by the
    ///          identity provider as the token's sub (Subject) claim.
    public let subjectFromWebIdentityToken: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        audience: Swift.String? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        packedPolicySize: Swift.Int? = nil,
        provider: Swift.String? = nil,
        sourceIdentity: Swift.String? = nil,
        subjectFromWebIdentityToken: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.provider = provider
        self.sourceIdentity = sourceIdentity
        self.subjectFromWebIdentityToken = subjectFromWebIdentityToken
    }
}

struct AssumeRoleWithWebIdentityOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let subjectFromWebIdentityToken: Swift.String?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let provider: Swift.String?
    public let audience: Swift.String?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleWithWebIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case provider = "Provider"
        case sourceIdentity = "SourceIdentity"
        case subjectFromWebIdentityToken = "SubjectFromWebIdentityToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleWithWebIdentityResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let subjectFromWebIdentityTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectFromWebIdentityToken)
        subjectFromWebIdentityToken = subjectFromWebIdentityTokenDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audience)
        audience = audienceDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

extension StsClientTypes.AssumedRoleUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumedRoleId = "AssumedRoleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumedRoleId = assumedRoleId {
            try container.encode(assumedRoleId, forKey: ClientRuntime.Key("AssumedRoleId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumedRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumedRoleId)
        assumedRoleId = assumedRoleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.AssumedRoleUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumedRoleUser(arn: \(Swift.String(describing: arn)), assumedRoleId: \(Swift.String(describing: assumedRoleId)))"}
}

extension StsClientTypes {
    /// The identifiers for the temporary security credentials that the operation
    ///          returns.
    public struct AssumedRoleUser: Swift.Equatable {
        /// The ARN of the temporary security credentials that are returned from the AssumeRole action. For more information about ARNs and how to use them in
        ///          policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM Identifiers in the
        ///             IAM User Guide.
        /// This member is required.
        public let arn: Swift.String?
        /// A unique identifier that contains the role ID and the role session name of the role that
        ///          is being assumed. The role ID is generated by Amazon Web Services when the role is created.
        /// This member is required.
        public let assumedRoleId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            assumedRoleId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.assumedRoleId = assumedRoleId
        }
    }

}

extension StsClientTypes.Credentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let expiration = expiration {
            try container.encode(ClientRuntime.TimestampWrapper(expiration, format: .dateTime), forKey: ClientRuntime.Key("expiration"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: ClientRuntime.Key("SecretAccessKey"))
        }
        if let sessionToken = sessionToken {
            try container.encode(sessionToken, forKey: ClientRuntime.Key("SessionToken"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        var expirationBuffer:ClientRuntime.Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

extension StsClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessKeyId: \(Swift.String(describing: accessKeyId)), expiration: \(Swift.String(describing: expiration)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), sessionToken: \(Swift.String(describing: sessionToken)))"}
}

extension StsClientTypes {
    /// Amazon Web Services credentials for API authentication.
    public struct Credentials: Swift.Equatable {
        /// The access key ID that identifies the temporary security credentials.
        /// This member is required.
        public let accessKeyId: Swift.String?
        /// The date on which the current credentials expire.
        /// This member is required.
        public let expiration: ClientRuntime.Date?
        /// The secret access key that can be used to sign requests.
        /// This member is required.
        public let secretAccessKey: Swift.String?
        /// The token that users must pass to the service API to use the temporary
        ///          credentials.
        /// This member is required.
        public let sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

public struct DecodeAuthorizationMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

extension DecodeAuthorizationMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecodeAuthorizationMessageInput(encodedMessage: \(Swift.String(describing: encodedMessage)))"}
}

extension DecodeAuthorizationMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let encodedMessage = encodedMessage {
            try container.encode(encodedMessage, forKey: ClientRuntime.Key("EncodedMessage"))
        }
        try container.encode("DecodeAuthorizationMessage", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DecodeAuthorizationMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInput: Swift.Equatable {
    /// The encoded message that was returned with the response.
    /// This member is required.
    public let encodedMessage: Swift.String?

    public init (
        encodedMessage: Swift.String? = nil
    )
    {
        self.encodedMessage = encodedMessage
    }
}

extension DecodeAuthorizationMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DecodeAuthorizationMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAuthorizationMessageException" : self = .invalidAuthorizationMessageException(try InvalidAuthorizationMessageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecodeAuthorizationMessageOutputError: Swift.Error, Swift.Equatable {
    case invalidAuthorizationMessageException(InvalidAuthorizationMessageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecodeAuthorizationMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecodeAuthorizationMessageOutputResponse(decodedMessage: \(Swift.String(describing: decodedMessage)))"}
}

extension DecodeAuthorizationMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecodeAuthorizationMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.decodedMessage = output.decodedMessage
        } else {
            self.decodedMessage = nil
        }
    }
}

/// A document that contains additional information about the authorization status of a
///       request from an encoded message that is returned in response to an Amazon Web Services request.
public struct DecodeAuthorizationMessageOutputResponse: Swift.Equatable {
    /// An XML document that contains the decoded message.
    public let decodedMessage: Swift.String?

    public init (
        decodedMessage: Swift.String? = nil
    )
    {
        self.decodedMessage = decodedMessage
    }
}

struct DecodeAuthorizationMessageOutputResponseBody: Swift.Equatable {
    public let decodedMessage: Swift.String?
}

extension DecodeAuthorizationMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodedMessage = "DecodedMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DecodeAuthorizationMessageResult"))
        let decodedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decodedMessage)
        decodedMessage = decodedMessageDecoded
    }
}

extension ExpiredTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredTokenException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ExpiredTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The web identity token that was passed is expired or is not valid. Get a new identity
///             token from the identity provider and then retry the request.
public struct ExpiredTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.FederatedUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case federatedUserId = "FederatedUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let federatedUserId = federatedUserId {
            try container.encode(federatedUserId, forKey: ClientRuntime.Key("FederatedUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let federatedUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federatedUserId)
        federatedUserId = federatedUserIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.FederatedUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FederatedUser(arn: \(Swift.String(describing: arn)), federatedUserId: \(Swift.String(describing: federatedUserId)))"}
}

extension StsClientTypes {
    /// Identifiers for the federated user that is associated with the credentials.
    public struct FederatedUser: Swift.Equatable {
        /// The ARN that specifies the federated user that is associated with the credentials. For
        ///          more information about ARNs and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
        ///             Identifiers in the IAM User Guide.
        /// This member is required.
        public let arn: Swift.String?
        /// The string that identifies the federated user associated with the credentials, similar
        ///          to the unique ID of an IAM user.
        /// This member is required.
        public let federatedUserId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            federatedUserId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.federatedUserId = federatedUserId
        }
    }

}

public struct GetAccessKeyInfoInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

extension GetAccessKeyInfoInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessKeyInfoInput(accessKeyId: \(Swift.String(describing: accessKeyId)))"}
}

extension GetAccessKeyInfoInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyInfo", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetAccessKeyInfoInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInput: Swift.Equatable {
    /// The identifier of an access key.
    ///         This parameter allows (through its regex pattern) a string of characters that can
    ///             consist of any upper- or lowercase letter or digit.
    /// This member is required.
    public let accessKeyId: Swift.String?

    public init (
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

extension GetAccessKeyInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessKeyInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessKeyInfoOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessKeyInfoOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessKeyInfoOutputResponse(account: \(Swift.String(describing: account)))"}
}

extension GetAccessKeyInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccessKeyInfoOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct GetAccessKeyInfoOutputResponse: Swift.Equatable {
    /// The number used to identify the Amazon Web Services account.
    public let account: Swift.String?

    public init (
        account: Swift.String? = nil
    )
    {
        self.account = account
    }
}

struct GetAccessKeyInfoOutputResponseBody: Swift.Equatable {
    public let account: Swift.String?
}

extension GetAccessKeyInfoOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccessKeyInfoResult"))
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

public struct GetCallerIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

extension GetCallerIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCallerIdentityInput()"}
}

extension GetCallerIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetCallerIdentity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetCallerIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

extension GetCallerIdentityInput {
    public func presign(config: AWSClientRuntime.AWSClientConfiguration, sigv4Config: AWSClientRuntime.SigV4Config? = nil) -> ClientRuntime.SdkHttpRequest? {
        let serviceName = "STS"
        let input = self
        let encoder = ClientRuntime.FormURLEncoder()
        let decoder = ClientRuntime.XMLDecoder()
        let urlPath = "/"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCallerIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "sts")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetCallerIdentityInput, GetCallerIdentityOutputResponse, GetCallerIdentityOutputError>(id: "getCallerIdentity")
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetCallerIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetCallerIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetCallerIdentityInput, GetCallerIdentityOutputResponse, GetCallerIdentityOutputError>(contentType: "application/x-www-form-urlencoded"))
        operation.serializeStep.intercept(position: .after, middleware: GetCallerIdentityInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = sigv4Config ?? AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let presignedRequestBuilder = operation.presignedRequest(context: context.build(), input: input, next: ClientRuntime.NoopHandler())
        guard let builtRequest = presignedRequestBuilder?.build() else {
            return nil
        }
        return builtRequest
    }
}

public struct GetCallerIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

public struct GetCallerIdentityInput: Swift.Equatable {

    public init() {}
}

extension GetCallerIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCallerIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCallerIdentityOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCallerIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCallerIdentityOutputResponse(account: \(Swift.String(describing: account)), arn: \(Swift.String(describing: arn)), userId: \(Swift.String(describing: userId)))"}
}

extension GetCallerIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCallerIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
            self.arn = output.arn
            self.userId = output.userId
        } else {
            self.account = nil
            self.arn = nil
            self.userId = nil
        }
    }
}

/// Contains the response to a successful GetCallerIdentity request,
///          including information about the entity making the request.
public struct GetCallerIdentityOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID number of the account that owns or contains the calling
    ///          entity.
    public let account: Swift.String?
    /// The Amazon Web Services ARN associated with the calling entity.
    public let arn: Swift.String?
    /// The unique identifier of the calling entity. The exact value depends on the type of
    ///          entity that is making the call. The values returned are those listed in the aws:userid column in the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable">Principal
    ///             table found on the Policy Variables reference
    ///          page in the IAM User Guide.
    public let userId: Swift.String?

    public init (
        account: Swift.String? = nil,
        arn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.account = account
        self.arn = arn
        self.userId = userId
    }
}

struct GetCallerIdentityOutputResponseBody: Swift.Equatable {
    public let userId: Swift.String?
    public let account: Swift.String?
    public let arn: Swift.String?
}

extension GetCallerIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case arn = "Arn"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetCallerIdentityResult"))
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetFederationTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

extension GetFederationTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFederationTokenInput(durationSeconds: \(Swift.String(describing: durationSeconds)), name: \(Swift.String(describing: name)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), tags: \(Swift.String(describing: tags)))"}
}

extension GetFederationTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetFederationToken", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetFederationTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInput: Swift.Equatable {
    /// The duration, in seconds, that the session should last. Acceptable durations for
    ///          federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
    ///          43,200 seconds (12 hours) as the default. Sessions obtained using Amazon Web Services account root user
    ///          credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
    ///          duration is longer than one hour, the session obtained by using root user credentials
    ///          defaults to one hour.
    public let durationSeconds: Swift.Int?
    /// The name of the federated user. The name is used as an identifier for the temporary
    ///          security credentials (such as Bob). For example, you can reference the
    ///          federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.
    ///          The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-
    /// This member is required.
    public let name: Swift.String?
    /// An IAM policy in JSON format that you want to use as an inline session policy.
    ///          You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session
    ///          policies.
    ///          This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.
    ///          When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies in
    ///          the IAM User Guide.
    ///          The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             Principal element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.
    ///          The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    public let policy: Swift.String?
    /// The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as a
    ///          managed session policy. The policies must exist in the same account as the IAM user that
    ///          is requesting federated access.
    ///          You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session policies.
    ///          The plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. You can provide up to 10 managed policy ARNs. For more information about ARNs,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///             Resource Names (ARNs) and Amazon Web Services Service Namespaces in the Amazon Web Services General Reference.
    ///          This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.
    ///          When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies in
    ///          the IAM User Guide.
    ///          The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             Principal element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// A list of session tags. Each session tag consists of a key name and an associated value.
    ///          For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS in the
    ///             IAM User Guide.
    ///          This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits in the IAM User Guide.
    ///
    ///
    ///             An Amazon Web Services conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The PackedPolicySize
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///
    ///
    ///          You can pass a session tag with the same key as a tag that is already
    ///          attached to the user you are federating. When you do, session tags override a user tag with
    ///          the same key.
    ///          Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate Department and department tag keys. Assume
    ///          that the role has the Department=Marketing tag and you pass the
    ///             department=engineering session tag. Department
    ///          and department are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.
    public let tags: [StsClientTypes.Tag]?

    public init (
        durationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        tags: [StsClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.name = name
        self.policy = policy
        self.policyArns = policyArns
        self.tags = tags
    }
}

extension GetFederationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFederationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "MalformedPolicyDocument" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLarge" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFederationTokenOutputError: Swift.Error, Swift.Equatable {
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFederationTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFederationTokenOutputResponse(credentials: \(Swift.String(describing: credentials)), federatedUser: \(Swift.String(describing: federatedUser)), packedPolicySize: \(Swift.String(describing: packedPolicySize)))"}
}

extension GetFederationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFederationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.federatedUser = output.federatedUser
            self.packedPolicySize = output.packedPolicySize
        } else {
            self.credentials = nil
            self.federatedUser = nil
            self.packedPolicySize = nil
        }
    }
}

/// Contains the response to a successful GetFederationToken request,
///       including temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests.
public struct GetFederationTokenOutputResponse: Swift.Equatable {
    /// The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.
    ///
    ///             The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.
    ///
    public let credentials: StsClientTypes.Credentials?
    /// Identifiers for the federated user associated with the credentials (such as
    ///             arn:aws:sts::123456789012:federated-user/Bob or
    ///             123456789012:Bob). You can use the federated user's ARN in your
    ///          resource-based policies, such as an Amazon S3 bucket policy.
    public let federatedUser: StsClientTypes.FederatedUser?
    /// A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.
    public let packedPolicySize: Swift.Int?

    public init (
        credentials: StsClientTypes.Credentials? = nil,
        federatedUser: StsClientTypes.FederatedUser? = nil,
        packedPolicySize: Swift.Int? = nil
    )
    {
        self.credentials = credentials
        self.federatedUser = federatedUser
        self.packedPolicySize = packedPolicySize
    }
}

struct GetFederationTokenOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let federatedUser: StsClientTypes.FederatedUser?
    public let packedPolicySize: Swift.Int?
}

extension GetFederationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case federatedUser = "FederatedUser"
        case packedPolicySize = "PackedPolicySize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetFederationTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let federatedUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.FederatedUser.self, forKey: .federatedUser)
        federatedUser = federatedUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
    }
}

public struct GetSessionTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

extension GetSessionTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionTokenInput(durationSeconds: \(Swift.String(describing: durationSeconds)), serialNumber: \(Swift.String(describing: serialNumber)), tokenCode: \(Swift.String(describing: tokenCode)))"}
}

extension GetSessionTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: ClientRuntime.Key("TokenCode"))
        }
        try container.encode("GetSessionToken", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetSessionTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInput: Swift.Equatable {
    /// The duration, in seconds, that the credentials should remain valid. Acceptable
    ///             durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
    ///             (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for Amazon Web Services account
    ///             owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
    ///             longer than one hour, the session for Amazon Web Services account owners defaults to one hour.
    public let durationSeconds: Swift.Int?
    /// The identification number of the MFA device that is associated with the IAM user who
    ///             is making the GetSessionToken call. Specify this value if the IAM user
    ///             has a policy that requires MFA authentication. The value is either the serial number for
    ///             a hardware device (such as GAHT12345678) or an Amazon Resource Name (ARN)
    ///             for a virtual device (such as arn:aws:iam::123456789012:mfa/user). You can
    ///             find the device for an IAM user by going to the Management Console and viewing the user's
    ///             security credentials.
    ///         The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-
    public let serialNumber: Swift.String?
    /// The value provided by the MFA device, if MFA is required. If any policy requires the
    ///             IAM user to submit an MFA code, specify this value. If MFA authentication is required,
    ///             the user must provide a code when requesting a set of temporary security credentials. A
    ///             user who fails to provide the code receives an "access denied" response when requesting
    ///             resources that require MFA authentication.
    ///         The format for this parameter, as described by its regex pattern, is a sequence of six
    ///             numeric digits.
    public let tokenCode: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        serialNumber: Swift.String? = nil,
        tokenCode: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.serialNumber = serialNumber
        self.tokenCode = tokenCode
    }
}

extension GetSessionTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSessionTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionTokenOutputError: Swift.Error, Swift.Equatable {
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionTokenOutputResponse(credentials: \(Swift.String(describing: credentials)))"}
}

extension GetSessionTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSessionTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

/// Contains the response to a successful GetSessionToken request,
///       including temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests.
public struct GetSessionTokenOutputResponse: Swift.Equatable {
    /// The temporary security credentials, which include an access key ID, a secret access
    ///             key, and a security (or session) token.
    ///
    ///
    ///             The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.
    ///
    public let credentials: StsClientTypes.Credentials?

    public init (
        credentials: StsClientTypes.Credentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct GetSessionTokenOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
}

extension GetSessionTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSessionTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

extension IDPCommunicationErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IDPCommunicationErrorException(message: \(Swift.String(describing: message)))"}
}

extension IDPCommunicationErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IDPCommunicationErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be fulfilled because the identity provider (IDP) that
///             was asked to verify the incoming identity token could not be reached. This is often a
///             transient error caused by network conditions. Retry the request a limited number of
///             times so that you don't exceed the request rate. If the error persists, the
///             identity provider might be down or not responding.
public struct IDPCommunicationErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IDPCommunicationErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IDPCommunicationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IDPRejectedClaimException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IDPRejectedClaimException(message: \(Swift.String(describing: message)))"}
}

extension IDPRejectedClaimException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IDPRejectedClaimExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The identity provider (IdP) reported that authentication failed. This might be because
///             the claim is invalid.
///         If this error is returned for the AssumeRoleWithWebIdentity operation, it
///             can also mean that the claim has expired or has been explicitly revoked.
public struct IDPRejectedClaimException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IDPRejectedClaimExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IDPRejectedClaimExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorizationMessageException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAuthorizationMessageException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAuthorizationMessageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidAuthorizationMessageExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The error returned if the message passed to DecodeAuthorizationMessage
///             was invalid. This can happen if the token contains invalid characters, such as
///             linebreaks.
public struct InvalidAuthorizationMessageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorizationMessageExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAuthorizationMessageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidIdentityTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidIdentityTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidIdentityTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The web identity token that was passed could not be validated by Amazon Web Services. Get a new
///             identity token from the identity provider and then retry the request.
public struct InvalidIdentityTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidIdentityTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedPolicyDocumentException(message: \(Swift.String(describing: message)))"}
}

extension MalformedPolicyDocumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the policy document was malformed. The error message
///             describes the specific error.
public struct MalformedPolicyDocumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PackedPolicyTooLargeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackedPolicyTooLargeException(message: \(Swift.String(describing: message)))"}
}

extension PackedPolicyTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PackedPolicyTooLargeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because the total packed size of the session policies and
///             session tags combined was too large. An Amazon Web Services conversion compresses the session policy
///             document, session policy ARNs, and session tags into a packed binary format that has a
///             separate limit. The error message indicates by percentage how close the policies and
///             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS in
///             the IAM User Guide.
///         You could receive this error even though you meet other defined session policy and
///             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">IAM and STS Entity
///                 Character Limits in the IAM User Guide.
public struct PackedPolicyTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PackedPolicyTooLargeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PackedPolicyTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.PolicyDescriptorType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("arn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.PolicyDescriptorType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyDescriptorType(arn: \(Swift.String(describing: arn)))"}
}

extension StsClientTypes {
    /// A reference to the IAM managed policy that is passed as a session policy for a role
    ///          session or a federated user session.
    public struct PolicyDescriptorType: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM managed policy to use as a session policy
        ///          for the role. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
        ///             Service Namespaces in the Amazon Web Services General Reference.
        public let arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension RegionDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegionDisabledException(message: \(Swift.String(describing: message)))"}
}

extension RegionDisabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<RegionDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// STS is not activated in the requested region for the account that is being asked to
///             generate credentials. The account administrator must use the IAM console to activate STS
///             in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
///                 Deactivating Amazon Web Services STS in an Amazon Web Services Region in the IAM User
///                     Guide.
public struct RegionDisabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RegionDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RegionDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension StsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension StsClientTypes {
    /// You can pass custom key-value pair attributes when you assume a role or federate a user.
    ///          These are called session tags. You can then use the session tags to control access to
    ///          resources. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging STS Sessions in the
    ///             IAM User Guide.
    public struct Tag: Swift.Equatable {
        /// The key for a session tag.
        ///          You can pass up to 50 session tags. The plain text session tag keys can’t exceed 128
        ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        ///             and STS Character Limits in the IAM User Guide.
        /// This member is required.
        public let key: Swift.String?
        /// The value for a session tag.
        ///          You can pass up to 50 session tags. The plain text session tag values can’t exceed 256
        ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        ///             and STS Character Limits in the IAM User Guide.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}
