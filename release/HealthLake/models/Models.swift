// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access is denied. Your account is not authorized to perform this operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Data Store is in a transition state and the user requested action can not be performed.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

extension CreateFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFHIRDatastoreInput(clientToken: \(Swift.String(describing: clientToken)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreTypeVersion: \(Swift.String(describing: datastoreTypeVersion)), preloadDataConfig: \(Swift.String(describing: preloadDataConfig)))"}
}

extension CreateFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
    }
}

public struct CreateFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInput: Swift.Equatable {
    /// <p>Optional user provided token used for ensuring idempotency.</p>
    public var clientToken: Swift.String?
    /// <p>The user generated name for the Data Store.</p>
    public let datastoreName: Swift.String?
    /// <p>The FHIR version of the Data Store. The only supported version is R4.</p>
    public let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// <p>Optional parameter to preload data upon creation of the Data Store. Currently, the only
    ///          supported preloaded data is synthetic data generated from Synthea.</p>
    public let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.preloadDataConfig = preloadDataConfig
    }
}

struct CreateFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreName: Swift.String?
    public let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    public let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    public let clientToken: Swift.String?
}

extension CreateFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFHIRDatastoreOutputResponse(datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension CreateFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateFHIRDatastoreOutputResponse: Swift.Equatable {
    /// <p>The datastore ARN is generated during the creation of the Data Store and can be found in
    ///          the output from the initial Data Store creation call.</p>
    public let datastoreArn: Swift.String?
    /// <p>The AWS endpoint for the created Data Store. For preview, only US-east-1 endpoints are
    ///          supported.</p>
    public let datastoreEndpoint: Swift.String?
    /// <p>The AWS-generated Data Store id. This id is in the output from the initial Data Store
    ///          creation call.</p>
    public let datastoreId: Swift.String?
    /// <p>The status of the FHIR Data Store. Possible statuses are ‘CREATING’, ‘ACTIVE’, ‘DELETING’,
    ///          ‘DELETED’.</p>
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let datastoreArn: Swift.String?
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    public let datastoreEndpoint: Swift.String?
}

extension CreateFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = createdAfter {
            try encodeContainer.encode(createdAfter.timeIntervalSince1970, forKey: .createdAfter)
        }
        if let createdBefore = createdBefore {
            try encodeContainer.encode(createdBefore.timeIntervalSince1970, forKey: .createdBefore)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreFilter(createdAfter: \(Swift.String(describing: createdAfter)), createdBefore: \(Swift.String(describing: createdBefore)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension HealthLakeClientTypes {
    /// <p>The filters applied to Data Store query.</p>
    public struct DatastoreFilter: Swift.Equatable {
        /// <p>A filter that allows the user to set cutoff dates for records. All Data Stores created
        ///          after the specified date will be included in the results.</p>
        public let createdAfter: ClientRuntime.Date?
        /// <p>A filter that allows the user to set cutoff dates for records. All Data Stores created
        ///          before the specified date will be included in the results. </p>
        public let createdBefore: ClientRuntime.Date?
        /// <p>Allows the user to filter Data Store results by name.</p>
        public let datastoreName: Swift.String?
        /// <p>Allows the user to filter Data Store results by status.</p>
        public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }

}

extension HealthLakeClientTypes.DatastoreProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datastoreArn = datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreEndpoint = datastoreEndpoint {
            try encodeContainer.encode(datastoreEndpoint, forKey: .datastoreEndpoint)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
    }
}

extension HealthLakeClientTypes.DatastoreProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreProperties(createdAt: \(Swift.String(describing: createdAt)), datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreStatus: \(Swift.String(describing: datastoreStatus)), datastoreTypeVersion: \(Swift.String(describing: datastoreTypeVersion)), preloadDataConfig: \(Swift.String(describing: preloadDataConfig)))"}
}

extension HealthLakeClientTypes {
    /// <p>Displays the properties of the Data Store, including the ID, Arn, name, and the status of the Data Store.</p>
    public struct DatastoreProperties: Swift.Equatable {
        /// <p>The time that a Data Store was created. </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The Amazon Resource Name used in the creation of the Data Store.</p>
        public let datastoreArn: Swift.String?
        /// <p>The AWS endpoint for the Data Store. Each Data Store will have it's own endpoint with Data Store ID in the endpoint URL.</p>
        public let datastoreEndpoint: Swift.String?
        /// <p>The AWS-generated ID number for the Data Store.</p>
        public let datastoreId: Swift.String?
        /// <p>The user-generated name for the Data Store.</p>
        public let datastoreName: Swift.String?
        /// <p>The status of the Data Store. Possible statuses are 'CREATING', 'ACTIVE', 'DELETING', or 'DELETED'.</p>
        public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// <p>The FHIR version. Only R4 version data is supported.</p>
        public let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// <p>The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.</p>
        public let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.preloadDataConfig = preloadDataConfig
        }
    }

}

extension HealthLakeClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

extension DeleteFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFHIRDatastoreInput(datastoreId: \(Swift.String(describing: datastoreId)))"}
}

extension DeleteFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DeleteFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInput: Swift.Equatable {
    /// <p> The AWS-generated ID for the Data Store to be deleted.</p>
    public let datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
}

extension DeleteFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DeleteFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFHIRDatastoreOutputResponse(datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension DeleteFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteFHIRDatastoreOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.</p>
    public let datastoreArn: Swift.String?
    /// <p>The AWS endpoint for the Data Store the user has requested to be deleted.</p>
    public let datastoreEndpoint: Swift.String?
    /// <p>The AWS-generated ID for the Data Store to be deleted.</p>
    public let datastoreId: Swift.String?
    /// <p>The status of the Data Store that the user has requested to be deleted.
    ///       </p>
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let datastoreArn: Swift.String?
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    public let datastoreEndpoint: Swift.String?
}

extension DeleteFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

public struct DescribeFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

extension DescribeFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRDatastoreInput(datastoreId: \(Swift.String(describing: datastoreId)))"}
}

extension DescribeFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DescribeFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInput: Swift.Equatable {
    /// <p>The AWS-generated Data Store id. This is part of the ‘CreateFHIRDatastore’ output.</p>
    public let datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DescribeFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
}

extension DescribeFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DescribeFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRDatastoreOutputResponse(datastoreProperties: \(Swift.String(describing: datastoreProperties)))"}
}

extension DescribeFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct DescribeFHIRDatastoreOutputResponse: Swift.Equatable {
    /// <p>All properties associated with a Data Store, including the Data Store ID, Data Store ARN,
    ///          Data Store name, Data Store status, created at, Data Store type version, and Data Store
    ///          endpoint.</p>
    public let datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init (
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct DescribeFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreProperties: HealthLakeClientTypes.DatastoreProperties?
}

extension DescribeFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreProperties = "DatastoreProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

public struct DescribeFHIRExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

extension DescribeFHIRExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRExportJobInput(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeFHIRExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInput: Swift.Equatable {
    /// <p>The AWS generated ID for the Data Store from which files are being exported from for an export job.</p>
    public let datastoreId: Swift.String?
    /// <p>The AWS generated ID for an export job.</p>
    public let jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRExportJobInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let jobId: Swift.String?
}

extension DescribeFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRExportJobOutputResponse(exportJobProperties: \(Swift.String(describing: exportJobProperties)))"}
}

extension DescribeFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobProperties = output.exportJobProperties
        } else {
            self.exportJobProperties = nil
        }
    }
}

public struct DescribeFHIRExportJobOutputResponse: Swift.Equatable {
    /// <p>Displays the properties of the export job, including the ID, Arn, Name, and the status of the job. </p>
    public let exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init (
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

struct DescribeFHIRExportJobOutputResponseBody: Swift.Equatable {
    public let exportJobProperties: HealthLakeClientTypes.ExportJobProperties?
}

extension DescribeFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobProperties = "ExportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ExportJobProperties.self, forKey: .exportJobProperties)
        exportJobProperties = exportJobPropertiesDecoded
    }
}

public struct DescribeFHIRImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

extension DescribeFHIRImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRImportJobInput(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeFHIRImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInput: Swift.Equatable {
    /// <p>The AWS-generated ID of the Data Store.</p>
    public let datastoreId: Swift.String?
    /// <p>The AWS-generated job ID.</p>
    public let jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRImportJobInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let jobId: Swift.String?
}

extension DescribeFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRImportJobOutputResponse(importJobProperties: \(Swift.String(describing: importJobProperties)))"}
}

extension DescribeFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobProperties = output.importJobProperties
        } else {
            self.importJobProperties = nil
        }
    }
}

public struct DescribeFHIRImportJobOutputResponse: Swift.Equatable {
    /// <p>The properties of the Import job request, including the ID, ARN, name, and the status of the job.</p>
    public let importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init (
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

struct DescribeFHIRImportJobOutputResponseBody: Swift.Equatable {
    public let importJobProperties: HealthLakeClientTypes.ImportJobProperties?
}

extension DescribeFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobProperties = "ImportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ImportJobProperties.self, forKey: .importJobProperties)
        importJobProperties = importJobPropertiesDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), endTime: \(Swift.String(describing: endTime)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), message: \(Swift.String(describing: message)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), submitTime: \(Swift.String(describing: submitTime)))"}
}

extension HealthLakeClientTypes {
    /// <p>The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.</p>
    public struct ExportJobProperties: Swift.Equatable {
        /// <p>The Amazon Resource Name used during the initiation of the job.</p>
        public let dataAccessRoleArn: Swift.String?
        /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
        public let datastoreId: Swift.String?
        /// <p>The time an export job completed.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>The AWS generated ID for an export job.</p>
        public let jobId: Swift.String?
        /// <p>The user generated name for an export job.</p>
        public let jobName: Swift.String?
        /// <p>The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.</p>
        public let jobStatus: HealthLakeClientTypes.JobStatus?
        /// <p>An explanation of any errors that may have occurred during the export job.</p>
        public let message: Swift.String?
        /// <p>The output data configuration that was supplied when the export job was created.</p>
        public let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// <p>The time an export job was initiated.</p>
        public let submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes {
    public enum FHIRVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FHIRVersion(rawValue: rawValue) ?? FHIRVersion.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.ImportJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.ImportJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), message: \(Swift.String(describing: message)), submitTime: \(Swift.String(describing: submitTime)))"}
}

extension HealthLakeClientTypes {
    /// <p>Displays the properties of the import job, including the ID, Arn, Name, and the status of the Data Store.</p>
    public struct ImportJobProperties: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access to your input data.</p>
        public let dataAccessRoleArn: Swift.String?
        /// <p>The datastore id used when the Import job was created. </p>
        public let datastoreId: Swift.String?
        /// <p>The time that the Import job was completed.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>The input data configuration that was supplied when  the Import job was created.</p>
        public let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// <p>The AWS-generated id number for the Import job.</p>
        public let jobId: Swift.String?
        /// <p>The user-generated name for an Import job.</p>
        public let jobName: Swift.String?
        /// <p>The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, FAILED.</p>
        public let jobStatus: HealthLakeClientTypes.JobStatus?
        /// <p>An explanation of any errors that may have occurred during the FHIR import job. </p>
        public let message: Swift.String?
        /// <p>The time that the Import job was submitted for processing.</p>
        public let submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// <p> The input properties for an import job.</p>
    public enum InputDataConfig: Swift.Equatable, Swift.Hashable {
        /// <p>The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake. </p>
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unknown error occurs in the service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

public struct ListFHIRDatastoresInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

extension ListFHIRDatastoresInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRDatastoresInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRDatastoresInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFHIRDatastoresInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInput: Swift.Equatable {
    /// <p>Lists all filters associated with a FHIR Data Store request.</p>
    public let filter: HealthLakeClientTypes.DatastoreFilter?
    /// <p>The maximum number of Data Stores returned in a single page of a
    ///          ListFHIRDatastoresRequest call.</p>
    public let maxResults: Swift.Int?
    /// <p>Fetches the next page of Data Stores when results are paginated.</p>
    public let nextToken: Swift.String?

    public init (
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresInputBody: Swift.Equatable {
    public let filter: HealthLakeClientTypes.DatastoreFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFHIRDatastoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFHIRDatastoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRDatastoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFHIRDatastoresOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRDatastoresOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRDatastoresOutputResponse(datastorePropertiesList: \(Swift.String(describing: datastorePropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRDatastoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFHIRDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastorePropertiesList = output.datastorePropertiesList
            self.nextToken = output.nextToken
        } else {
            self.datastorePropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRDatastoresOutputResponse: Swift.Equatable {
    /// <p>All properties associated with the listed Data Stores.</p>
    public let datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// <p>Pagination token that can be used to retrieve the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresOutputResponseBody: Swift.Equatable {
    public let datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    public let nextToken: Swift.String?
}

extension ListFHIRDatastoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastorePropertiesList = "DatastorePropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.DatastoreProperties?].self, forKey: .datastorePropertiesList)
        var datastorePropertiesListDecoded0:[HealthLakeClientTypes.DatastoreProperties]? = nil
        if let datastorePropertiesListContainer = datastorePropertiesListContainer {
            datastorePropertiesListDecoded0 = [HealthLakeClientTypes.DatastoreProperties]()
            for structure0 in datastorePropertiesListContainer {
                if let structure0 = structure0 {
                    datastorePropertiesListDecoded0?.append(structure0)
                }
            }
        }
        datastorePropertiesList = datastorePropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension HealthLakeClientTypes.OutputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// <p>The output data configuration that was supplied when the export job was created.</p>
    public enum OutputDataConfig: Swift.Equatable, Swift.Hashable {
        /// <p>The S3Uri is the user specified S3 location to which data will be exported from a FHIR Data Store.</p>
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preloadDataType = "PreloadDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preloadDataType = preloadDataType {
            try encodeContainer.encode(preloadDataType.rawValue, forKey: .preloadDataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preloadDataTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataType.self, forKey: .preloadDataType)
        preloadDataType = preloadDataTypeDecoded
    }
}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreloadDataConfig(preloadDataType: \(Swift.String(describing: preloadDataType)))"}
}

extension HealthLakeClientTypes {
    /// <p> The input properties for the preloaded Data Store. Only data preloaded from Synthea is supported.</p>
    public struct PreloadDataConfig: Swift.Equatable {
        /// <p>The type of preloaded data. Only Synthea preloaded data is supported.</p>
        public let preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init (
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        )
        {
            self.preloadDataType = preloadDataType
        }
    }

}

extension HealthLakeClientTypes {
    public enum PreloadDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreloadDataType(rawValue: rawValue) ?? PreloadDataType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The requested Data Store was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartFHIRExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

extension StartFHIRExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRExportJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), jobName: \(Swift.String(describing: jobName)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartFHIRExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartFHIRExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInput: Swift.Equatable {
    /// <p>An optional user provided token used for ensuring idempotency.</p>
    public var clientToken: Swift.String?
    /// <p>The Amazon Resource Name used during the initiation of the job.</p>
    public let dataAccessRoleArn: Swift.String?
    /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
    public let datastoreId: Swift.String?
    /// <p>The user generated name for an export job.</p>
    public let jobName: Swift.String?
    /// <p>The output data configuration that was supplied when the export job was created.</p>
    public let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartFHIRExportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    public let datastoreId: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let clientToken: Swift.String?
}

extension StartFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRExportJobOutputResponse(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StartFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRExportJobOutputResponse: Swift.Equatable {
    /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
    public let datastoreId: Swift.String?
    /// <p>The AWS generated ID for an export job.</p>
    public let jobId: Swift.String?
    /// <p>The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.</p>
    public let jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRExportJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let datastoreId: Swift.String?
}

extension StartFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

public struct StartFHIRImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

extension StartFHIRImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRImportJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)))"}
}

extension StartFHIRImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
    }
}

public struct StartFHIRImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInput: Swift.Equatable {
    /// <p>Optional user provided token used for ensuring idempotency.</p>
    public var clientToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.</p>
    public let dataAccessRoleArn: Swift.String?
    /// <p>The AWS-generated Data Store ID.</p>
    public let datastoreId: Swift.String?
    /// <p>The input properties of the FHIR Import job in the StartFHIRImport job request.</p>
    public let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// <p>The name of the FHIR Import job in the StartFHIRImport job request.</p>
    public let jobName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
    }
}

struct StartFHIRImportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    public let datastoreId: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let clientToken: Swift.String?
}

extension StartFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRImportJobOutputResponse(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StartFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRImportJobOutputResponse: Swift.Equatable {
    /// <p>The AWS-generated Data Store ID.</p>
    public let datastoreId: Swift.String?
    /// <p>The AWS-generated job ID.</p>
    public let jobId: Swift.String?
    /// <p>The status of an import job.</p>
    public let jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRImportJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let datastoreId: Swift.String?
}

extension StartFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user has exceeded their maximum number of allowed calls to the given API. </p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user input parameter was invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
