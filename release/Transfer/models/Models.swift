// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the <code>UpdatServer</code> is called for a file transfer
///       protocol-enabled server that has VPC as the endpoint type and the server's
///         <code>VpcEndpointID</code> is not in the available state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessOutputError>
}

extension CreateAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessInput(externalId: \(Swift.String(describing: externalId)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)), serverId: \(Swift.String(describing: serverId)))"}
}

extension CreateAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct CreateAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessOutputError>
}

public struct CreateAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessOutputError>
}

public struct CreateAccessInput: Swift.Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: Swift.String?
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    ///          <p>A <code>HomeDirectory</code> example is <code>/directory_name/home/mydirectory</code>.</p>
    public let homeDirectory: Swift.String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    ///       be visible to your user and how you want to make them visible. You must specify the
    ///         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    ///       only specify a target, it will be displayed as is. You also must ensure that your AWS Identity
    ///       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    ///       can only be set when <code>HomeDirectoryType</code> is set to
    ///       <i>LOGICAL</i>.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
    ///         <code>HomeDirectory</code> parameter value.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or Amazon EFS, the
    ///         entry will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create
    ///         0-byte objects as place holders for your directory. If using the AWS CLI, use the
    ///           <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code> or
    ///           <code>efs</code> so you can use the <code>put-object</code> operation. For example, you
    ///         can use the following.</p>
    ///             <p>
    ///                <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>
    ///             </p>
    ///             <p>The end of the key name must end in a <code>/</code> for it to be considered a
    ///         folder.</p>
    ///          </note>
    ///          <p>Required: No</p>
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple
    ///       users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables
    ///       that you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>This only applies when domain of <code>ServerId</code> is S3. Amazon EFS does not use scope
    ///         down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
    ///           scope-down policy</a>.</p>
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS Security Token Service API
    ///           Reference</i>.</p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: TransferClientTypes.PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    ///       file system. The policies attached to this role determine the level of access that you want to
    ///       provide your users when transferring files into and out of your Amazon S3 bucket or EFS file
    ///       system. The IAM role should also contain a trust relationship that allows the server to access
    ///       your resources when servicing your users' transfer requests.</p>
    public let role: Swift.String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct CreateAccessInputBody: Swift.Equatable {
    public let homeDirectory: Swift.String?
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    public let policy: Swift.String?
    public let posixProfile: TransferClientTypes.PosixProfile?
    public let role: Swift.String?
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension CreateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessOutputResponse(externalId: \(Swift.String(describing: externalId)), serverId: \(Swift.String(describing: serverId)))"}
}

extension CreateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct CreateAccessOutputResponse: Swift.Equatable {
    /// <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family.</p>
    public let externalId: Swift.String?
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct CreateAccessOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension CreateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

public struct CreateServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(certificate: \(Swift.String(describing: certificate)), domain: \(Swift.String(describing: domain)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), hostKey: \(Swift.String(describing: hostKey)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), protocols: \(Swift.String(describing: protocols)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

public struct CreateServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

public struct CreateServerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. Required
    ///       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    ///
    ///          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
    ///         private certificate</a> in the <i> AWS Certificate Manager User
    ///       Guide</i>.</p>
    ///
    ///          <p>Certificates with the following cryptographic algorithms and key sizes are
    ///       supported:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>2048-bit RSA (RSA_2048)</p>
    ///             </li>
    ///             <li>
    ///                <p>4096-bit RSA (RSA_4096)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
    ///         address specified and information about the issuer.</p>
    ///          </note>
    public let certificate: Swift.String?
    /// <p>The domain of the storage system that is used for file transfers. There are two domains
    ///       available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
    ///       default value is S3.</p>
    ///
    ///          <note>
    ///             <p>After the server is created, the domain cannot be changed.</p>
    ///          </note>
    public let domain: TransferClientTypes.Domain?
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
    ///       When you host your endpoint within your VPC, you can make it accessible only to resources
    ///       within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
    ///       the internet. Your VPC's default security groups are automatically assigned to your
    ///       endpoint.</p>
    public let endpointDetails: TransferClientTypes.EndpointDetails?
    /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
    ///       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
    ///       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
    ///          <note>
    ///             <p> After March 31, 2021, you won't be able to create a server using
    ///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
    ///       done so before March 31, 2021. If you have already created servers with
    ///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
    ///         you will not be affected. After this date, use
    ///         <code>EndpointType</code>=<code>VPC</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
    ///         this endpoint type, you have the option to directly associate up to three Elastic IPv4
    ///         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
    ///         restrict traffic by the client's public IP address. This is not possible with
    ///           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
    ///          </note>
    public let endpointType: TransferClientTypes.EndpointType?
    /// <p>The RSA private key as generated by the <code>ssh-keygen -N "" -m PEM -f
    ///         my-new-server-key</code> command.</p>
    ///
    ///          <important>
    ///             <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
    ///         server to a new server, don't update the host key. Accidentally changing a
    ///         server's host key can be disruptive.</p>
    ///          </important>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>AWS Transfer
    ///         Family User Guide</i>.</p>
    public let hostKey: Swift.String?
    /// <p>Required when <code>IdentityProviderType</code> is set to
    ///         <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
    ///       all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
    ///       invoke a customer-supplied authentication API, including the API Gateway URL. Not required
    ///       when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
    public let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// <p>Specifies the mode of authentication for a server. The default value is
    ///         <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
    ///       the AWS Transfer Family service. Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
    ///       Active Directory groups in AWS Managed Active Directory or Microsoft Active Directory in your
    ///       on-premises environment or in AWS using AD Connectors. This option also requires you to
    ///       provide a Directory ID using the <code>IdentityProviderDetails</code> parameter. Use the
    ///         <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
    ///         <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
    ///       for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
    public let identityProviderType: TransferClientTypes.IdentityProviderType?
    /// <p>Allows the service to write your users' activity to your Amazon CloudWatch logs for
    ///       monitoring and auditing purposes.</p>
    public let loggingRole: Swift.String?
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    ///       client can connect to your server's endpoint. The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
    ///           SSH</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
    ///           encryption</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>If you select <code>FTPS</code>, you must choose a certificate stored in AWS Certificate
    ///         Manager (ACM) which will be used to identify your server when clients connect to it over
    ///         FTPS.</p>
    ///
    ///             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
    ///           <code>EndpointType</code> must be <code>VPC</code> and the
    ///           <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
    ///
    ///             <p>If <code>Protocol</code> includes <code>FTP</code>, then
    ///           <code>AddressAllocationIds</code> cannot be associated.</p>
    ///
    ///             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
    ///         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
    ///           <code>SERVICE_MANAGED</code>.</p>
    ///          </note>
    public let protocols: [TransferClientTypes.ModelProtocol]?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: Swift.String?
    /// <p>Key-value pairs that can be used to group and search for servers.</p>
    public let tags: [TransferClientTypes.Tag]?

    public init (
        certificate: Swift.String? = nil,
        domain: TransferClientTypes.Domain? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
        loggingRole: Swift.String? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.tags = tags
    }
}

struct CreateServerInputBody: Swift.Equatable {
    public let certificate: Swift.String?
    public let domain: TransferClientTypes.Domain?
    public let endpointDetails: TransferClientTypes.EndpointDetails?
    public let endpointType: TransferClientTypes.EndpointType?
    public let hostKey: Swift.String?
    public let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    public let identityProviderType: TransferClientTypes.IdentityProviderType?
    public let loggingRole: Swift.String?
    public let protocols: [TransferClientTypes.ModelProtocol]?
    public let securityPolicyName: Swift.String?
    public let tags: [TransferClientTypes.Tag]?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerOutputResponse(serverId: \(Swift.String(describing: serverId)))"}
}

extension CreateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct CreateServerOutputResponse: Swift.Equatable {
    /// <p>The service-assigned ID of the server that is created.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct CreateServerOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension CreateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

public struct CreateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)), serverId: \(Swift.String(describing: serverId)), sshPublicKeyBody: \(Swift.String(describing: sshPublicKeyBody)), tags: \(Swift.String(describing: tags)), userName: \(Swift.String(describing: userName)))"}
}

extension CreateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Swift.Equatable {
    /// <p>The landing directory (folder) for a user when they log in to the server using the
    ///       client.</p>
    ///
    ///          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    public let homeDirectory: Swift.String?
    /// <p>Logical directory mappings that specify what Amazon S3 or EFS paths and keys should be visible to
    ///       your user and how you want to make them visible. You will need to specify the
    ///         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or EFS path. If you only specify a
    ///       target, it will be displayed as is. You will need to also make sure that your IAM role
    ///       provides access to paths in <code>Target</code>. This value can only be set when
    ///         <code>HomeDirectoryType</code> is set to <code>LOGICAL</code>.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target":
    ///         "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock your user
    ///       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for
    ///         <code>chroot</code>.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry will
    ///         be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
    ///         holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
    ///         <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
    ///         following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
    ///         sure that the end of the key name ends in a <code>/</code> for it to be considered a
    ///         folder.</p>
    ///          </note>
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) you want your users' home directory to be when
    ///       they log into the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 paths visible to your
    ///       users.</p>
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// <p>A scope-down policy for your user so you can use the same IAM role across multiple users.
    ///       This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you
    ///       can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///
    ///          <note>
    ///             <p>This only applies when domain of ServerId is S3. EFS does not use scope down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead
    ///         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
    ///         it in the <code>Policy</code> argument.</p>
    ///
    ///
    ///
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example scope-down
    ///         policy</a>.</p>
    ///
    ///
    ///
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS
    ///           Security Token Service API Reference</i>.</p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in Amazon EFS determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: TransferClientTypes.PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies
    ///       attached to this role will determine the level of access you want to provide your users when
    ///       transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also
    ///
    ///       contain a trust relationship that allows the server to access your resources when servicing
    ///       your users' transfer requests.</p>
    public let role: Swift.String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server
    ///       that you added your user to.</p>
    public let serverId: Swift.String?
    /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
    ///       server.</p>
    public let sshPublicKeyBody: Swift.String?
    /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
    ///       to users for any purpose.</p>
    public let tags: [TransferClientTypes.Tag]?
    /// <p>A unique string that identifies a user and is associated with a as specified by the
    ///         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
    ///       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
    ///       '-', period '.', and at sign '@'. The user name can't start
    ///       with a hyphen, period, or at sign.</p>
    public let userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    public let homeDirectory: Swift.String?
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    public let policy: Swift.String?
    public let posixProfile: TransferClientTypes.PosixProfile?
    public let role: Swift.String?
    public let serverId: Swift.String?
    public let sshPublicKeyBody: Swift.String?
    public let tags: [TransferClientTypes.Tag]?
    public let userName: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserOutputResponse(serverId: \(Swift.String(describing: serverId)), userName: \(Swift.String(describing: userName)))"}
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: Swift.String?
    /// <p>A unique string that identifies a user account associated with a server.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let userName: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

public struct DeleteAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessOutputError>
}

extension DeleteAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessInput(externalId: \(Swift.String(describing: externalId)), serverId: \(Swift.String(describing: serverId)))"}
}

extension DeleteAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DeleteAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessOutputError>
}

public struct DeleteAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessOutputError>
}

public struct DeleteAccessInput: Swift.Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: Swift.String?
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DeleteAccessInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension DeleteAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DeleteAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessOutputResponse()"}
}

extension DeleteAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAccessOutputResponseBody: Swift.Equatable {
}

extension DeleteAccessOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

extension DeleteServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServerInput(serverId: \(Swift.String(describing: serverId)))"}
}

extension DeleteServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DeleteServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

public struct DeleteServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

public struct DeleteServerInput: Swift.Equatable {
    /// <p>A unique system-assigned identifier for a server instance.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServerOutputResponse()"}
}

extension DeleteServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServerOutputResponseBody: Swift.Equatable {
}

extension DeleteServerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSshPublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSshPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSshPublicKeyOutputError>
}

extension DeleteSshPublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSshPublicKeyInput(serverId: \(Swift.String(describing: serverId)), sshPublicKeyId: \(Swift.String(describing: sshPublicKeyId)), userName: \(Swift.String(describing: userName)))"}
}

extension DeleteSshPublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteSshPublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSshPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSshPublicKeyOutputError>
}

public struct DeleteSshPublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSshPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSshPublicKeyOutputError>
}

public struct DeleteSshPublicKeyInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
    ///       that has the user assigned to it.</p>
    public let serverId: Swift.String?
    /// <p>A unique identifier used to reference your user's specific SSH key.</p>
    public let sshPublicKeyId: Swift.String?
    /// <p>A unique string that identifies a user whose public key is being deleted.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSshPublicKeyInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let sshPublicKeyId: Swift.String?
    public let userName: Swift.String?
}

extension DeleteSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSshPublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSshPublicKeyOutputResponse()"}
}

extension DeleteSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSshPublicKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSshPublicKeyOutputResponseBody: Swift.Equatable {
}

extension DeleteSshPublicKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(serverId: \(Swift.String(describing: serverId)), userName: \(Swift.String(describing: userName)))"}
}

extension DeleteUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server instance that has the user assigned to
    ///       it.</p>
    public let serverId: Swift.String?
    /// <p>A unique string that identifies a user that is being deleted from a server.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let userName: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
}

extension DeleteUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessOutputError>
}

extension DescribeAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessInput(externalId: \(Swift.String(describing: externalId)), serverId: \(Swift.String(describing: serverId)))"}
}

extension DescribeAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DescribeAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessOutputError>
}

public struct DescribeAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessOutputError>
}

public struct DescribeAccessInput: Swift.Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group you associate have access to your Amazon S3 or Amazon EFS resources
    ///       over the enabled protocols using AWS Transfer Family. If you know the group name, you can view
    ///       the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: Swift.String?
    /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DescribeAccessInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension DescribeAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribeAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessOutputResponse(access: \(Swift.String(describing: access)), serverId: \(Swift.String(describing: serverId)))"}
}

extension DescribeAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.access = output.access
            self.serverId = output.serverId
        } else {
            self.access = nil
            self.serverId = nil
        }
    }
}

public struct DescribeAccessOutputResponse: Swift.Equatable {
    /// <p>The external ID of the server that the access is attached to.</p>
    public let access: TransferClientTypes.DescribedAccess?
    /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
    public let serverId: Swift.String?

    public init (
        access: TransferClientTypes.DescribedAccess? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

struct DescribeAccessOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let access: TransferClientTypes.DescribedAccess?
}

extension DescribeAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedAccess.self, forKey: .access)
        access = accessDecoded
    }
}

public struct DescribeSecurityPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecurityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecurityPolicyOutputError>
}

extension DescribeSecurityPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecurityPolicyInput(securityPolicyName: \(Swift.String(describing: securityPolicyName)))"}
}

extension DescribeSecurityPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
    }
}

public struct DescribeSecurityPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecurityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecurityPolicyOutputError>
}

public struct DescribeSecurityPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSecurityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSecurityPolicyOutputError>
}

public struct DescribeSecurityPolicyInput: Swift.Equatable {
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: Swift.String?

    public init (
        securityPolicyName: Swift.String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

struct DescribeSecurityPolicyInputBody: Swift.Equatable {
    public let securityPolicyName: Swift.String?
}

extension DescribeSecurityPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension DescribeSecurityPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecurityPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSecurityPolicyOutputResponse(securityPolicy: \(Swift.String(describing: securityPolicy)))"}
}

extension DescribeSecurityPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityPolicy = output.securityPolicy
        } else {
            self.securityPolicy = nil
        }
    }
}

public struct DescribeSecurityPolicyOutputResponse: Swift.Equatable {
    /// <p>An array containing the properties of the security policy.</p>
    public let securityPolicy: TransferClientTypes.DescribedSecurityPolicy?

    public init (
        securityPolicy: TransferClientTypes.DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

struct DescribeSecurityPolicyOutputResponseBody: Swift.Equatable {
    public let securityPolicy: TransferClientTypes.DescribedSecurityPolicy?
}

extension DescribeSecurityPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicy = "SecurityPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedSecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

public struct DescribeServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServerOutputError>
}

extension DescribeServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServerInput(serverId: \(Swift.String(describing: serverId)))"}
}

extension DescribeServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DescribeServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServerOutputError>
}

public struct DescribeServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServerOutputError>
}

public struct DescribeServerInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DescribeServerInputBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension DescribeServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServerOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension DescribeServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct DescribeServerOutputResponse: Swift.Equatable {
    /// <p>An array containing the properties of a server with the <code>ServerID</code> you
    ///       specified.</p>
    public let server: TransferClientTypes.DescribedServer?

    public init (
        server: TransferClientTypes.DescribedServer? = nil
    )
    {
        self.server = server
    }
}

struct DescribeServerOutputResponseBody: Swift.Equatable {
    public let server: TransferClientTypes.DescribedServer?
}

extension DescribeServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedServer.self, forKey: .server)
        server = serverDecoded
    }
}

public struct DescribeUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

extension DescribeUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserInput(serverId: \(Swift.String(describing: serverId)), userName: \(Swift.String(describing: userName)))"}
}

extension DescribeUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DescribeUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: Swift.String?
    /// <p>The name of the user assigned to one or more servers. User names are part of the sign-in
    ///       credentials to use the AWS Transfer Family service and perform file transfer tasks.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let userName: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutputResponse(serverId: \(Swift.String(describing: serverId)), user: \(Swift.String(describing: user)))"}
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.user = output.user
        } else {
            self.serverId = nil
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: Swift.String?
    /// <p>An array containing the properties of the user account for the <code>ServerID</code> value
    ///       that you specified.</p>
    public let user: TransferClientTypes.DescribedUser?

    public init (
        serverId: Swift.String? = nil,
        user: TransferClientTypes.DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let user: TransferClientTypes.DescribedUser?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(TransferClientTypes.DescribedUser.self, forKey: .user)
        user = userDecoded
    }
}

extension TransferClientTypes.DescribedAccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes.DescribedAccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedAccess(externalId: \(Swift.String(describing: externalId)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)))"}
}

extension TransferClientTypes {
    /// <p>Describes the properties of the access that was specified.</p>
    public struct DescribedAccess: Swift.Equatable {
        /// <p>A unique identifier that might be required when you assume a role in another account.
        ///       Think of the <code>ExternalID</code> as a group membership mechanism that uses a unique
        ///       identifier (often a SID, but could be a group name or something else) as a basis. If the
        ///       administrator of the account to which the role belongs provided you with an external ID, then
        ///       provide that value in the <code>ExternalId</code> parameter. A cross-account role is usually
        ///       set up to trust everyone in an account. Therefore, the administrator of the trusting account
        ///       might send an external ID to the administrator of the trusted account. That way, only someone
        ///       with the ID can assume the role, rather than everyone in the account.</p>
        ///          <p>The regex used to validate this parameter is a string of characters consisting of
        ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
        ///       underscores or any of the following characters: =,.@:/-</p>
        public let externalId: Swift.String?
        /// <p>Specifies the landing directory (or folder), which is the location that files are written
        ///       to or read from in an Amazon S3 bucket, for the described access.</p>
        public let homeDirectory: Swift.String?
        /// <p>Specifies the logical directory mappings that specify what Amazon S3 or Amazon EFS paths
        ///       and keys should be visible to the associated access and how you want to make them visible. You
        ///       must specify the "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code>
        ///       shows how the path is made visible and <code>Target</code> is the actual Amazon S3 or EFS
        ///       path. If you only specify a target, it will be displayed as is. You also must ensure that your
        ///       AWS Identity and Access Management (IAM) role provides access to paths in
        ///       <code>Target</code>.</p>
        ///
        ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down the
        ///       associated access to the designated home directory ("<code>chroot</code>"). To do this, you
        ///       can set <code>Entry</code> to '/' and set <code>Target</code> to the
        ///         <code>HomeDirectory</code> parameter value.</p>
        public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// <p>The type of landing directory (folder) that you want your users' home directory to be when
        ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
        ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it to
        ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
        ///       for how you want to make Amazon S3 paths visible to your users.</p>
        public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// <p>A scope-down policy for your user so that you can use the same AWS Identity and Access
        ///       Management (IAM) role across multiple users. This policy scopes down user access to portions
        ///       of their Amazon S3 bucket. Variables that you can use inside this policy include
        ///         <code>${Transfer:UserName}</code>, <code>${Transfer:HomeDirectory}</code>, and
        ///         <code>${Transfer:HomeBucket}</code>.</p>
        public let policy: Swift.String?
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        ///       files and directories in your file system determine the level of access your users get when
        ///       transferring files into and out of your Amazon EFS file systems.</p>
        public let posixProfile: TransferClientTypes.PosixProfile?
        /// <p>The IAM role that controls access to your Amazon S3 bucket from the specified associated
        ///       access. The policies attached to this role will determine the level of access that you want to
        ///       provide the associated access when transferring files into and out of your Amazon S3 bucket or
        ///       buckets. The IAM role should also contain a trust relationship that allows a server to access
        ///       your resources when servicing transfer requests for the associated access.</p>
        public let role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
        }
    }

}

extension TransferClientTypes.DescribedSecurityPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fips = "Fips"
        case securityPolicyName = "SecurityPolicyName"
        case sshCiphers = "SshCiphers"
        case sshKexs = "SshKexs"
        case sshMacs = "SshMacs"
        case tlsCiphers = "TlsCiphers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fips = fips {
            try encodeContainer.encode(fips, forKey: .fips)
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sshCiphers = sshCiphers {
            var sshCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshCiphers)
            for securitypolicyoptions0 in sshCiphers {
                try sshCiphersContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshKexs = sshKexs {
            var sshKexsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshKexs)
            for securitypolicyoptions0 in sshKexs {
                try sshKexsContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshMacs = sshMacs {
            var sshMacsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshMacs)
            for securitypolicyoptions0 in sshMacs {
                try sshMacsContainer.encode(securitypolicyoptions0)
            }
        }
        if let tlsCiphers = tlsCiphers {
            var tlsCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tlsCiphers)
            for securitypolicyoptions0 in tlsCiphers {
                try tlsCiphersContainer.encode(securitypolicyoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fipsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fips)
        fips = fipsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let sshCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshCiphers)
        var sshCiphersDecoded0:[Swift.String]? = nil
        if let sshCiphersContainer = sshCiphersContainer {
            sshCiphersDecoded0 = [Swift.String]()
            for string0 in sshCiphersContainer {
                if let string0 = string0 {
                    sshCiphersDecoded0?.append(string0)
                }
            }
        }
        sshCiphers = sshCiphersDecoded0
        let sshKexsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshKexs)
        var sshKexsDecoded0:[Swift.String]? = nil
        if let sshKexsContainer = sshKexsContainer {
            sshKexsDecoded0 = [Swift.String]()
            for string0 in sshKexsContainer {
                if let string0 = string0 {
                    sshKexsDecoded0?.append(string0)
                }
            }
        }
        sshKexs = sshKexsDecoded0
        let sshMacsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sshMacs)
        var sshMacsDecoded0:[Swift.String]? = nil
        if let sshMacsContainer = sshMacsContainer {
            sshMacsDecoded0 = [Swift.String]()
            for string0 in sshMacsContainer {
                if let string0 = string0 {
                    sshMacsDecoded0?.append(string0)
                }
            }
        }
        sshMacs = sshMacsDecoded0
        let tlsCiphersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tlsCiphers)
        var tlsCiphersDecoded0:[Swift.String]? = nil
        if let tlsCiphersContainer = tlsCiphersContainer {
            tlsCiphersDecoded0 = [Swift.String]()
            for string0 in tlsCiphersContainer {
                if let string0 = string0 {
                    tlsCiphersDecoded0?.append(string0)
                }
            }
        }
        tlsCiphers = tlsCiphersDecoded0
    }
}

extension TransferClientTypes.DescribedSecurityPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedSecurityPolicy(fips: \(Swift.String(describing: fips)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), sshCiphers: \(Swift.String(describing: sshCiphers)), sshKexs: \(Swift.String(describing: sshKexs)), sshMacs: \(Swift.String(describing: sshMacs)), tlsCiphers: \(Swift.String(describing: tlsCiphers)))"}
}

extension TransferClientTypes {
    /// <p>Describes the properties of a security policy that was specified. For more information
    ///       about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
    ///         policies</a>.</p>
    public struct DescribedSecurityPolicy: Swift.Equatable {
        /// <p>Specifies whether this policy enables Federal Information Processing Standards
        ///       (FIPS).</p>
        public let fips: Swift.Bool?
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        public let securityPolicyName: Swift.String?
        /// <p>Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security
        ///       policy that is attached to the server.</p>
        public let sshCiphers: [Swift.String]?
        /// <p>Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy
        ///       that is attached to the server.</p>
        public let sshKexs: [Swift.String]?
        /// <p>Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the
        ///       security policy that is attached to the server.</p>
        public let sshMacs: [Swift.String]?
        /// <p>Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the
        ///       security policy that is attached to the server.</p>
        public let tlsCiphers: [Swift.String]?

        public init (
            fips: Swift.Bool? = nil,
            securityPolicyName: Swift.String? = nil,
            sshCiphers: [Swift.String]? = nil,
            sshKexs: [Swift.String]? = nil,
            sshMacs: [Swift.String]? = nil,
            tlsCiphers: [Swift.String]? = nil
        )
        {
            self.fips = fips
            self.securityPolicyName = securityPolicyName
            self.sshCiphers = sshCiphers
            self.sshKexs = sshKexs
            self.sshMacs = sshMacs
            self.tlsCiphers = tlsCiphers
        }
    }

}

extension TransferClientTypes.DescribedServer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case state = "State"
        case tags = "Tags"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKeyFingerprint = hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension TransferClientTypes.DescribedServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedServer(arn: \(Swift.String(describing: arn)), certificate: \(Swift.String(describing: certificate)), domain: \(Swift.String(describing: domain)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), hostKeyFingerprint: \(Swift.String(describing: hostKeyFingerprint)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), protocols: \(Swift.String(describing: protocols)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), serverId: \(Swift.String(describing: serverId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), userCount: \(Swift.String(describing: userCount)))"}
}

extension TransferClientTypes {
    /// <p>Describes the properties of a file transfer protocol-enabled server that was
    ///       specified.</p>
    public struct DescribedServer: Swift.Equatable {
        /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
        public let arn: Swift.String?
        /// <p>Specifies the ARN of the AWS Certificate Manager (ACM) certificate. Required when
        ///         <code>Protocols</code> is set to <code>FTPS</code>.</p>
        public let certificate: Swift.String?
        /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
        public let domain: TransferClientTypes.Domain?
        /// <p>Specifies the virtual private cloud (VPC) endpoint settings that you configured for your
        ///       server.</p>
        public let endpointDetails: TransferClientTypes.EndpointDetails?
        /// <p>Defines the type of endpoint that your server is connected to. If your server is connected
        ///       to a VPC endpoint, your server isn't accessible over the public internet.</p>
        public let endpointType: TransferClientTypes.EndpointType?
        /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value
        ///       is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code>
        ///       command.</p>
        public let hostKeyFingerprint: Swift.String?
        /// <p>Specifies information to call a customer-supplied authentication API. This field is not
        ///       populated when the <code>IdentityProviderType</code> of a server is
        ///       <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
        public let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
        /// <p>Specifies the mode of authentication method enabled for this service. A value of
        ///         <code>AWS_DIRECTORY_SERVICE</code> means that you are providing access to Active Directory
        ///       groups in AWS Managed Active Directory or Microsoft Active Directory in your on-premises
        ///       environment or in AWS using AD Connectors. A value of <code>SERVICE_MANAGED</code> means that
        ///       you are using this server to store and access user credentials within the service. A value of
        ///         <code>API_GATEWAY</code> indicates that you have integrated an API Gateway endpoint that
        ///       will be invoked for authenticating your user into the service.</p>
        public let identityProviderType: TransferClientTypes.IdentityProviderType?
        /// <p>Specifies the AWS Identity and Access Management (IAM) role that allows a server to turn
        ///       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        ///       your CloudWatch logs.</p>
        public let loggingRole: Swift.String?
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        ///       client can connect to your server's endpoint. The available protocols are:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
        ///           SSH</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
        ///           encryption</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
        ///             </li>
        ///          </ul>
        public let protocols: [TransferClientTypes.ModelProtocol]?
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        public let securityPolicyName: Swift.String?
        /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
        public let serverId: Swift.String?
        /// <p>Specifies the condition of a server for the server that was described. A value of
        ///         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
        ///         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
        ///       transfer operations.</p>
        ///
        ///          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
        ///       in an intermediate state, either not fully able to respond, or not fully offline. The values
        ///       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
        ///       condition.</p>
        public let state: TransferClientTypes.State?
        /// <p>Specifies the key-value pairs that you can use to search for and group servers that were
        ///       assigned to the server that was described.</p>
        public let tags: [TransferClientTypes.Tag]?
        /// <p>Specifies the number of users that are assigned to a server you specified with the
        ///         <code>ServerId</code>.</p>
        public let userCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointDetails: TransferClientTypes.EndpointDetails? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            hostKeyFingerprint: Swift.String? = nil,
            identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            protocols: [TransferClientTypes.ModelProtocol]? = nil,
            securityPolicyName: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.certificate = certificate
            self.domain = domain
            self.endpointDetails = endpointDetails
            self.endpointType = endpointType
            self.hostKeyFingerprint = hostKeyFingerprint
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.protocols = protocols
            self.securityPolicyName = securityPolicyName
            self.serverId = serverId
            self.state = state
            self.tags = tags
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes.DescribedUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case sshPublicKeys = "SshPublicKeys"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeys = sshPublicKeys {
            var sshPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshPublicKeys)
            for sshpublickeys0 in sshPublicKeys {
                try sshPublicKeysContainer.encode(sshpublickeys0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeysContainer = try containerValues.decodeIfPresent([TransferClientTypes.SshPublicKey?].self, forKey: .sshPublicKeys)
        var sshPublicKeysDecoded0:[TransferClientTypes.SshPublicKey]? = nil
        if let sshPublicKeysContainer = sshPublicKeysContainer {
            sshPublicKeysDecoded0 = [TransferClientTypes.SshPublicKey]()
            for structure0 in sshPublicKeysContainer {
                if let structure0 = structure0 {
                    sshPublicKeysDecoded0?.append(structure0)
                }
            }
        }
        sshPublicKeys = sshPublicKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.DescribedUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribedUser(arn: \(Swift.String(describing: arn)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)), sshPublicKeys: \(Swift.String(describing: sshPublicKeys)), tags: \(Swift.String(describing: tags)), userName: \(Swift.String(describing: userName)))"}
}

extension TransferClientTypes {
    /// <p>Describes the properties of a user that was specified.</p>
    public struct DescribedUser: Swift.Equatable {
        /// <p>Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be
        ///       described.</p>
        public let arn: Swift.String?
        /// <p>Specifies the landing directory (or folder), which is the location that files are written
        ///       to or read from in an Amazon S3 bucket, for the described user. An example is
        ///           <i>
        ///                <code>your-Amazon-S3-bucket-name>/home/username</code>
        ///             </i>.</p>
        public let homeDirectory: Swift.String?
        /// <p>Specifies the logical directory mappings that specify what Amazon S3 or EFS paths and keys should
        ///       be visible to your user and how you want to make them visible. You will need to specify the
        ///         "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code> shows how the
        ///       path is made visible and <code>Target</code> is the actual Amazon S3 or EFS path. If you only specify
        ///       a target, it will be displayed as is. You will need to also make sure that your AWS Identity
        ///       and Access Management (IAM) role provides access to paths in <code>Target</code>.</p>
        ///
        ///          <p>In most cases, you can use this value instead of the scope-down policy to lock your user
        ///       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
        ///         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
        ///       parameter value.</p>
        public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
        /// <p>Specifies the type of landing directory (folder) you mapped for your users to see when
        ///       they log into the file transfer protocol-enabled server. If you set it to <code>PATH</code>,
        ///       the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
        ///       clients. If you set it <code>LOGICAL</code>, you will need to provide mappings in the
        ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or EFS paths visible to your
        ///       users.</p>
        public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// <p>Specifies the name of the policy in use for the described user.</p>
        public let policy: Swift.String?
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        ///       your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX
        ///       permissions that are set on files and directories in your file system determine the level of
        ///       access your users get when transferring files into and out of your Amazon EFS file
        ///       systems.</p>
        public let posixProfile: TransferClientTypes.PosixProfile?
        /// <p>The IAM role that controls your users' access to your Amazon S3 bucket. The
        ///       policies attached to this role will determine the level of access you want to provide your
        ///       users when transferring files into and out of your Amazon S3 bucket or buckets. The IAM role
        ///       should also contain a trust relationship that allows a server to access your resources when
        ///       servicing your users' transfer requests.</p>
        public let role: Swift.String?
        /// <p>Specifies the public key portion of the Secure Shell (SSH) keys stored for the described
        ///       user.</p>
        public let sshPublicKeys: [TransferClientTypes.SshPublicKey]?
        /// <p>Specifies the key-value pairs for the user requested. Tag can be used to search for and
        ///       group users for a variety of purposes.</p>
        public let tags: [TransferClientTypes.Tag]?
        /// <p>Specifies the name of the user that was requested to be described. User names are used for
        ///       authentication purposes. This is the string that will be used by your user when they log in to
        ///       your server.</p>
        public let userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            policy: Swift.String? = nil,
            posixProfile: TransferClientTypes.PosixProfile? = nil,
            role: Swift.String? = nil,
            sshPublicKeys: [TransferClientTypes.SshPublicKey]? = nil,
            tags: [TransferClientTypes.Tag]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryMappings = homeDirectoryMappings
            self.homeDirectoryType = homeDirectoryType
            self.policy = policy
            self.posixProfile = posixProfile
            self.role = role
            self.sshPublicKeys = sshPublicKeys
            self.tags = tags
            self.userName = userName
        }
    }

}

extension TransferClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efs
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .efs,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efs: return "EFS"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.EndpointDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressAllocationIds = "AddressAllocationIds"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressAllocationIds = addressAllocationIds {
            var addressAllocationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addressAllocationIds)
            for addressallocationids0 in addressAllocationIds {
                try addressAllocationIdsContainer.encode(addressallocationids0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressAllocationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addressAllocationIds)
        var addressAllocationIdsDecoded0:[Swift.String]? = nil
        if let addressAllocationIdsContainer = addressAllocationIdsContainer {
            addressAllocationIdsDecoded0 = [Swift.String]()
            for string0 in addressAllocationIdsContainer {
                if let string0 = string0 {
                    addressAllocationIdsDecoded0?.append(string0)
                }
            }
        }
        addressAllocationIds = addressAllocationIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension TransferClientTypes.EndpointDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointDetails(addressAllocationIds: \(Swift.String(describing: addressAllocationIds)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcEndpointId: \(Swift.String(describing: vpcEndpointId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension TransferClientTypes {
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your file
    ///       transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server
    ///       and resources only within your VPC. To control incoming internet traffic, invoke the
    ///         <code>UpdateServer</code> API and attach an Elastic IP address to your server's
    ///       endpoint.</p>
    ///          <note>
    ///             <p> After March 31, 2021, you won't be able to create a server using
    ///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
    ///       done so before March 31, 2021. If you have already created servers with
    ///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
    ///         you will not be affected. After this date, use
    ///         <code>EndpointType</code>=<code>VPC</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///          </note>
    public struct EndpointDetails: Swift.Equatable {
        /// <p>A list of address allocation IDs that are required to attach an Elastic IP address to your
        ///       server's endpoint.</p>
        ///
        ///          <note>
        ///
        ///             <p>This property can only be set when <code>EndpointType</code> is set to <code>VPC</code>
        ///         and it is only valid in the <code>UpdateServer</code> API.</p>
        ///          </note>
        public let addressAllocationIds: [Swift.String]?
        /// <p>A list of security groups IDs that are available to attach to your server's
        ///       endpoint.</p>
        ///
        ///          <note>
        ///             <p>This property can only be set when <code>EndpointType</code> is set to
        ///         <code>VPC</code>.</p>
        ///
        ///             <p>You can edit the <code>SecurityGroupIds</code> property in the <a href="https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html">UpdateServer</a> API only if you are changing the <code>EndpointType</code> from
        ///           <code>PUBLIC</code> or <code>VPC_ENDPOINT</code> to <code>VPC</code>. To change security
        ///         groups associated with your server's VPC endpoint after creation, use the Amazon EC2
        ///           <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html">ModifyVpcEndpoint</a> API.</p>
        ///          </note>
        public let securityGroupIds: [Swift.String]?
        /// <p>A list of subnet IDs that are required to host your server endpoint in your VPC.</p>
        ///
        ///          <note>
        ///             <p>This property can only be set when <code>EndpointType</code> is set to
        ///         <code>VPC</code>.</p>
        ///          </note>
        public let subnetIds: [Swift.String]?
        /// <p>The ID of the VPC endpoint.</p>
        ///
        ///          <note>
        ///             <p>This property can only be set when <code>EndpointType</code> is set to
        ///           <code>VPC_ENDPOINT</code>.</p>
        ///
        ///             <p>For more information, see
        ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        ///          </note>
        public let vpcEndpointId: Swift.String?
        /// <p>The VPC ID of the VPC in which a server's endpoint will be hosted.</p>
        ///
        ///          <note>
        ///             <p>This property can only be set when <code>EndpointType</code> is set to
        ///         <code>VPC</code>.</p>
        ///          </note>
        public let vpcId: Swift.String?

        public init (
            addressAllocationIds: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.addressAllocationIds = addressAllocationIds
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension TransferClientTypes {
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `public`
        case vpc
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .public,
                .vpc,
                .vpcEndpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .public: return "PUBLIC"
            case .vpc: return "VPC"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.HomeDirectoryMapEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry = "Entry"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entry)
        entry = entryDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension TransferClientTypes.HomeDirectoryMapEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HomeDirectoryMapEntry(entry: \(Swift.String(describing: entry)), target: \(Swift.String(describing: target)))"}
}

extension TransferClientTypes {
    /// <p>Represents an object that contains entries and targets for
    ///         <code>HomeDirectoryMappings</code>.</p>
    public struct HomeDirectoryMapEntry: Swift.Equatable {
        /// <p>Represents an entry and a target for <code>HomeDirectoryMappings</code>.</p>
        public let entry: Swift.String?
        /// <p>Represents the map target that is used in a <code>HomeDirectorymapEntry</code>.</p>
        public let target: Swift.String?

        public init (
            entry: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.entry = entry
            self.target = target
        }
    }

}

extension TransferClientTypes {
    public enum HomeDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case logical
        case path
        case sdkUnknown(Swift.String)

        public static var allCases: [HomeDirectoryType] {
            return [
                .logical,
                .path,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .logical: return "LOGICAL"
            case .path: return "PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomeDirectoryType(rawValue: rawValue) ?? HomeDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension TransferClientTypes.IdentityProviderDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case invocationRole = "InvocationRole"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let invocationRole = invocationRole {
            try encodeContainer.encode(invocationRole, forKey: .invocationRole)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let invocationRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationRole)
        invocationRole = invocationRoleDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension TransferClientTypes.IdentityProviderDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderDetails(directoryId: \(Swift.String(describing: directoryId)), invocationRole: \(Swift.String(describing: invocationRole)), url: \(Swift.String(describing: url)))"}
}

extension TransferClientTypes {
    /// <p>Returns information related to the type of user authentication that is in use for a file
    ///       transfer protocol-enabled server's users. A server can have only one method of
    ///       authentication.</p>
    public struct IdentityProviderDetails: Swift.Equatable {
        /// <p>The identifier of the AWS Directory Service directory that you want to stop sharing.</p>
        public let directoryId: Swift.String?
        /// <p>Provides the type of <code>InvocationRole</code> used to authenticate the user
        ///       account.</p>
        public let invocationRole: Swift.String?
        /// <p>Provides the location of the service endpoint used to authenticate users.</p>
        public let url: Swift.String?

        public init (
            directoryId: Swift.String? = nil,
            invocationRole: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.invocationRole = invocationRole
            self.url = url
        }
    }

}

extension TransferClientTypes {
    /// <p>Returns information related to the type of user authentication that is in use for a file
    ///       transfer protocol-enabled server's users. For <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>
    ///       authentication, the Secure Shell (SSH) public keys are stored with a user on the server
    ///       instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is
    ///       implemented by using an API call. The server can have only one method of
    ///       authentication.</p>
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case awsDirectoryService
        case serviceManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .apiGateway,
                .awsDirectoryService,
                .serviceManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .serviceManaged: return "SERVICE_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

public struct ImportSshPublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportSshPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportSshPublicKeyOutputError>
}

extension ImportSshPublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportSshPublicKeyInput(serverId: \(Swift.String(describing: serverId)), sshPublicKeyBody: \(Swift.String(describing: sshPublicKeyBody)), userName: \(Swift.String(describing: userName)))"}
}

extension ImportSshPublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct ImportSshPublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportSshPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportSshPublicKeyOutputError>
}

public struct ImportSshPublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportSshPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportSshPublicKeyOutputError>
}

public struct ImportSshPublicKeyInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: Swift.String?
    /// <p>The public key portion of an SSH key pair.</p>
    public let sshPublicKeyBody: Swift.String?
    /// <p>The name of the user account that is assigned to one or more servers.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyBody: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct ImportSshPublicKeyInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let sshPublicKeyBody: Swift.String?
    public let userName: Swift.String?
}

extension ImportSshPublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ImportSshPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSshPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportSshPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSshPublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportSshPublicKeyOutputResponse(serverId: \(Swift.String(describing: serverId)), sshPublicKeyId: \(Swift.String(describing: sshPublicKeyId)), userName: \(Swift.String(describing: userName)))"}
}

extension ImportSshPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportSshPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.sshPublicKeyId = output.sshPublicKeyId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.sshPublicKeyId = nil
            self.userName = nil
        }
    }
}

/// <p>Identifies the user, the server they belong to, and the identifier of the SSH public key
///       associated with that user. A user can have more than one key on each server that they are
///       associated with.</p>
public struct ImportSshPublicKeyOutputResponse: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: Swift.String?
    /// <p>The name given to a public key by the system that was imported.</p>
    public let sshPublicKeyId: Swift.String?
    /// <p>A user name assigned to the <code>ServerID</code> value that you specified.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        sshPublicKeyId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct ImportSshPublicKeyOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let sshPublicKeyId: Swift.String?
    public let userName: Swift.String?
}

extension ImportSshPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension InternalServiceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceError(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when an error occurs in the AWS Transfer Family service.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> parameter that was passed is invalid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the client submits a malformed request.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccessesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessesOutputError>
}

extension ListAccessesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serverId: \(Swift.String(describing: serverId)))"}
}

extension ListAccessesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct ListAccessesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessesOutputError>
}

public struct ListAccessesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessesOutputError>
}

public struct ListAccessesInput: Swift.Equatable {
    /// <p>Specifies the maximum number of access SIDs to return.</p>
    public let maxResults: Swift.Int?
    /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       accesses.</p>
    public let nextToken: Swift.String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let serverId: Swift.String?
}

extension ListAccessesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAccessesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessesOutputResponse(accesses: \(Swift.String(describing: accesses)), nextToken: \(Swift.String(describing: nextToken)), serverId: \(Swift.String(describing: serverId)))"}
}

extension ListAccessesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accesses = output.accesses
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.accesses = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListAccessesOutputResponse: Swift.Equatable {
    /// <p>Returns the accesses and their properties for the <code>ServerId</code> value that you
    ///       specify.</p>
    public let accesses: [TransferClientTypes.ListedAccess]?
    /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       accesses.</p>
    public let nextToken: Swift.String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: Swift.String?

    public init (
        accesses: [TransferClientTypes.ListedAccess]? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let serverId: Swift.String?
    public let accesses: [TransferClientTypes.ListedAccess]?
}

extension ListAccessesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accesses = "Accesses"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessesContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedAccess?].self, forKey: .accesses)
        var accessesDecoded0:[TransferClientTypes.ListedAccess]? = nil
        if let accessesContainer = accessesContainer {
            accessesDecoded0 = [TransferClientTypes.ListedAccess]()
            for structure0 in accessesContainer {
                if let structure0 = structure0 {
                    accessesDecoded0?.append(structure0)
                }
            }
        }
        accesses = accessesDecoded0
    }
}

public struct ListSecurityPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecurityPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecurityPoliciesOutputError>
}

extension ListSecurityPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecurityPoliciesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSecurityPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSecurityPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecurityPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecurityPoliciesOutputError>
}

public struct ListSecurityPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSecurityPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSecurityPoliciesOutputError>
}

public struct ListSecurityPoliciesInput: Swift.Equatable {
    /// <p>Specifies the number of security policies to return as a response to the
    ///         <code>ListSecurityPolicies</code> query.</p>
    public let maxResults: Swift.Int?
    /// <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass the
    ///         <code>NextToken</code> parameter in a subsequent command to continue listing additional
    ///       security policies.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityPoliciesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListSecurityPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSecurityPoliciesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), securityPolicyNames: \(Swift.String(describing: securityPolicyNames)))"}
}

extension ListSecurityPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSecurityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityPolicyNames = output.securityPolicyNames
        } else {
            self.nextToken = nil
            self.securityPolicyNames = nil
        }
    }
}

public struct ListSecurityPoliciesOutputResponse: Swift.Equatable {
    /// <p>When you can get additional results from the <code>ListSecurityPolicies</code> operation,
    ///       a <code>NextToken</code> parameter is returned in the output. In a following command, you can
    ///       pass in the <code>NextToken</code> parameter to continue listing security policies.</p>
    public let nextToken: Swift.String?
    /// <p>An array of security policies that were listed.</p>
    public let securityPolicyNames: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        securityPolicyNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

struct ListSecurityPoliciesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let securityPolicyNames: [Swift.String]?
}

extension ListSecurityPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case securityPolicyNames = "SecurityPolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let securityPolicyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityPolicyNames)
        var securityPolicyNamesDecoded0:[Swift.String]? = nil
        if let securityPolicyNamesContainer = securityPolicyNamesContainer {
            securityPolicyNamesDecoded0 = [Swift.String]()
            for string0 in securityPolicyNamesContainer {
                if let string0 = string0 {
                    securityPolicyNamesDecoded0?.append(string0)
                }
            }
        }
        securityPolicyNames = securityPolicyNamesDecoded0
    }
}

public struct ListServersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServersOutputError>
}

extension ListServersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServersOutputError>
}

public struct ListServersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServersOutputError>
}

public struct ListServersInput: Swift.Equatable {
    /// <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
    ///       query.</p>
    public let maxResults: Swift.Int?
    /// <p>When additional results are obtained from the <code>ListServers</code> command, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass the
    ///         <code>NextToken</code> parameter in a subsequent command to continue listing additional
    ///       servers.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), servers: \(Swift.String(describing: servers)))"}
}

extension ListServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct ListServersOutputResponse: Swift.Equatable {
    /// <p>When you can get additional results from the <code>ListServers</code> operation, a
    ///         <code>NextToken</code> parameter is returned in the output. In a following command, you can
    ///       pass in the <code>NextToken</code> parameter to continue listing additional servers.</p>
    public let nextToken: Swift.String?
    /// <p>An array of servers that were listed.</p>
    public let servers: [TransferClientTypes.ListedServer]?

    public init (
        nextToken: Swift.String? = nil,
        servers: [TransferClientTypes.ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct ListServersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let servers: [TransferClientTypes.ListedServer]?
}

extension ListServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serversContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedServer?].self, forKey: .servers)
        var serversDecoded0:[TransferClientTypes.ListedServer]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [TransferClientTypes.ListedServer]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(arn: \(Swift.String(describing: arn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
    ///       identifier for a specific AWS resource, such as a server, user, or role.</p>
    public let arn: Swift.String?
    /// <p>Specifies the number of tags to return as a response to the
    ///         <code>ListTagsForResource</code> request.</p>
    public let maxResults: Swift.Int?
    /// <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
    ///         <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
    ///       command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
    public let nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(arn: \(Swift.String(describing: arn)), nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.arn = nil
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>The ARN you specified to list the tags of.</p>
    public let arn: Swift.String?
    /// <p>When you can get additional results from the <code>ListTagsForResource</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       tags.</p>
    public let nextToken: Swift.String?
    /// <p>Key-value pairs that are assigned to a resource, usually for the purpose of grouping and
    ///       searching for items. Tags are metadata that you define.</p>
    public let tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let nextToken: Swift.String?
    public let tags: [TransferClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListUsersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serverId: \(Swift.String(describing: serverId)))"}
}

extension ListUsersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Swift.Equatable {
    /// <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
    ///       request.</p>
    public let maxResults: Swift.Int?
    /// <p>When you can get additional results from the <code>ListUsers</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       users.</p>
    public let nextToken: Swift.String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let serverId: Swift.String?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serverId: \(Swift.String(describing: serverId)), users: \(Swift.String(describing: users)))"}
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverId = output.serverId
            self.users = output.users
        } else {
            self.nextToken = nil
            self.serverId = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// <p>When you can get additional results from the <code>ListUsers</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       users.</p>
    public let nextToken: Swift.String?
    /// <p>A system-assigned unique identifier for a server that the users are assigned to.</p>
    public let serverId: Swift.String?
    /// <p>Returns the user accounts and their properties for the <code>ServerId</code> value that
    ///       you specify.</p>
    public let users: [TransferClientTypes.ListedUser]?

    public init (
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil,
        users: [TransferClientTypes.ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let serverId: Swift.String?
    public let users: [TransferClientTypes.ListedUser]?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverId = "ServerId"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([TransferClientTypes.ListedUser?].self, forKey: .users)
        var usersDecoded0:[TransferClientTypes.ListedUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TransferClientTypes.ListedUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension TransferClientTypes.ListedAccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension TransferClientTypes.ListedAccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListedAccess(externalId: \(Swift.String(describing: externalId)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), role: \(Swift.String(describing: role)))"}
}

extension TransferClientTypes {
    /// <p>Lists the properties for one or more specified associated accesses.</p>
    public struct ListedAccess: Swift.Equatable {
        /// <p>A unique identifier that might be required when you assume a role in another account. Think
        ///       of the <code>ExternalID</code> as a group membership mechanism that uses a unique identifier
        ///       (often a SID, but could be a group name or something else) as a basis. If the administrator of
        ///       the account to which the role belongs provided you with an external ID, then provide that
        ///       value in the <code>ExternalId</code> parameter. A cross-account role is usually set up to
        ///       trust everyone in an account. Therefore, the administrator of the trusting account might send
        ///       an external ID to the administrator of the trusted account. That way, only someone with the ID
        ///       can assume the role, rather than everyone in the account.</p>
        ///          <p>The regex used to validate this parameter is a string of characters consisting of
        ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
        ///       underscores or any of the following characters: =,.@:/-</p>
        public let externalId: Swift.String?
        /// <p>Specifies the landing directory (or folder), which is the location that files are written
        ///       to or read from in an Amazon S3 bucket, for the described access.</p>
        public let homeDirectory: Swift.String?
        /// <p>The type of landing directory (folder) that you want your users' home directory to be when
        ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
        ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it to
        ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
        ///       for how you want to make Amazon S3 paths visible to your users.</p>
        public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// <p>The AWS Identity and Access Management (IAM) role that controls access to your Amazon S3
        ///       bucket from the specified associated access. The policies attached to this role will determine
        ///       the level of access that you want to provide the associated access when transferring files
        ///       into and out of your Amazon S3 bucket or buckets. The IAM role should also contain a trust
        ///       relationship that allows a server to access your resources when servicing transfer requests
        ///       for the associated access.</p>
        public let role: Swift.String?

        public init (
            externalId: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
        }
    }

}

extension TransferClientTypes.ListedServer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case domain = "Domain"
        case endpointType = "EndpointType"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case serverId = "ServerId"
        case state = "State"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(TransferClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransferClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension TransferClientTypes.ListedServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListedServer(arn: \(Swift.String(describing: arn)), domain: \(Swift.String(describing: domain)), endpointType: \(Swift.String(describing: endpointType)), identityProviderType: \(Swift.String(describing: identityProviderType)), loggingRole: \(Swift.String(describing: loggingRole)), serverId: \(Swift.String(describing: serverId)), state: \(Swift.String(describing: state)), userCount: \(Swift.String(describing: userCount)))"}
}

extension TransferClientTypes {
    /// <p>Returns properties of a file transfer protocol-enabled server that was specified.</p>
    public struct ListedServer: Swift.Equatable {
        /// <p>Specifies the unique Amazon Resource Name (ARN) for a server to be listed.</p>
        public let arn: Swift.String?
        /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
        public let domain: TransferClientTypes.Domain?
        /// <p>Specifies the type of VPC endpoint that your server is connected to. If your server is
        ///       connected to a VPC endpoint, your server isn't accessible over the public
        ///       internet.</p>
        public let endpointType: TransferClientTypes.EndpointType?
        /// <p>Specifies the authentication method used to validate a user for a server that was
        ///       specified. This can include Secure Shell (SSH), Active Directory groups, user name and
        ///       password combinations, or your own custom authentication method. </p>
        public let identityProviderType: TransferClientTypes.IdentityProviderType?
        /// <p>Specifies the AWS Identity and Access Management (IAM) role that allows a server to turn
        ///       on Amazon CloudWatch logging.</p>
        public let loggingRole: Swift.String?
        /// <p>Specifies the unique system assigned identifier for the servers that were listed.</p>
        public let serverId: Swift.String?
        /// <p>Specifies the condition of a server for the server that was described. A value of
        ///         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
        ///         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
        ///       transfer operations.</p>
        ///
        ///          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
        ///       in an intermediate state, either not fully able to respond, or not fully offline. The values
        ///       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
        ///       condition.</p>
        public let state: TransferClientTypes.State?
        /// <p>Specifies the number of users that are assigned to a server you specified with the
        ///         <code>ServerId</code>.</p>
        public let userCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            domain: TransferClientTypes.Domain? = nil,
            endpointType: TransferClientTypes.EndpointType? = nil,
            identityProviderType: TransferClientTypes.IdentityProviderType? = nil,
            loggingRole: Swift.String? = nil,
            serverId: Swift.String? = nil,
            state: TransferClientTypes.State? = nil,
            userCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.domain = domain
            self.endpointType = endpointType
            self.identityProviderType = identityProviderType
            self.loggingRole = loggingRole
            self.serverId = serverId
            self.state = state
            self.userCount = userCount
        }
    }

}

extension TransferClientTypes.ListedUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
        case sshPublicKeyCount = "SshPublicKeyCount"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeyCount = sshPublicKeyCount {
            try encodeContainer.encode(sshPublicKeyCount, forKey: .sshPublicKeyCount)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sshPublicKeyCount)
        sshPublicKeyCount = sshPublicKeyCountDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension TransferClientTypes.ListedUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListedUser(arn: \(Swift.String(describing: arn)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), role: \(Swift.String(describing: role)), sshPublicKeyCount: \(Swift.String(describing: sshPublicKeyCount)), userName: \(Swift.String(describing: userName)))"}
}

extension TransferClientTypes {
    /// <p>Returns properties of the user that you specify.</p>
    public struct ListedUser: Swift.Equatable {
        /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn
        ///       about.</p>
        public let arn: Swift.String?
        /// <p>Specifies the location that files are written to or read from an Amazon S3 bucket for the
        ///       user you specify by their ARN.</p>
        public let homeDirectory: Swift.String?
        /// <p>Specifies the type of landing directory (folder) you mapped for your users' home
        ///       directory. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket
        ///       paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you
        ///       will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to
        ///       make Amazon S3 paths visible to your users.</p>
        public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
        /// <p>Specifies the role that is in use by this user. A <i>role</i> is an AWS
        ///       Identity and Access Management (IAM) entity that, in this case, allows a file transfer
        ///       protocol-enabled server to act on a user's behalf. It allows the server to inherit the
        ///       trust relationship that enables that user to perform file operations to their Amazon S3
        ///       bucket.</p>
        ///          <note>
        ///
        ///             <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>.
        ///         </p>
        ///             <p>The policies attached to this role determine the level of access you want to provide your users when
        ///         transferring files into and out of your S3 buckets or EFS file systems.</p>
        ///
        ///          </note>
        public let role: Swift.String?
        /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
        public let sshPublicKeyCount: Swift.Int?
        /// <p>Specifies the name of the user whose ARN was specified. User names are used for
        ///       authentication purposes.</p>
        public let userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            homeDirectory: Swift.String? = nil,
            homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
            role: Swift.String? = nil,
            sshPublicKeyCount: Swift.Int? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.homeDirectory = homeDirectory
            self.homeDirectoryType = homeDirectoryType
            self.role = role
            self.sshPublicKeyCount = sshPublicKeyCount
            self.userName = userName
        }
    }

}

extension TransferClientTypes.PosixProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for secondarygids0 in secondaryGids {
                try secondaryGidsContainer.encode(secondarygids0)
            }
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension TransferClientTypes.PosixProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PosixProfile(gid: \(Swift.String(describing: gid)), secondaryGids: \(Swift.String(describing: secondaryGids)), uid: \(Swift.String(describing: uid)))"}
}

extension TransferClientTypes {
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public struct PosixProfile: Swift.Equatable {
        /// <p>The POSIX group ID used for all EFS operations by this user.</p>
        public let gid: Swift.Int?
        /// <p>The secondary POSIX group IDs used for all EFS operations by this user.</p>
        public let secondaryGids: [Swift.Int]?
        /// <p>The POSIX user ID used for all EFS operations by this user.</p>
        public let uid: Swift.Int?

        public init (
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension TransferClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ftp
        case ftps
        case sftp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .ftp,
                .ftps,
                .sftp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ftp: return "FTP"
            case .ftps: return "FTPS"
            case .sftp: return "SFTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ResourceExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceExistsException(message: \(Swift.String(describing: message)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist.</p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resource: Swift.String?
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resource: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a resource is not found by the AWS Transfer Family
///       service.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resource: Swift.String?
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resource: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed because the AWS Transfer Family service is not available.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferClientTypes.SshPublicKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateImported = "DateImported"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case sshPublicKeyId = "SshPublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateImported = dateImported {
            try encodeContainer.encode(dateImported.timeIntervalSince1970, forKey: .dateImported)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateImportedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension TransferClientTypes.SshPublicKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SshPublicKey(dateImported: \(Swift.String(describing: dateImported)), sshPublicKeyBody: \(Swift.String(describing: sshPublicKeyBody)), sshPublicKeyId: \(Swift.String(describing: sshPublicKeyId)))"}
}

extension TransferClientTypes {
    /// <p>Provides information about the public Secure Shell (SSH) key that is associated with a
    ///       user account for the specific file transfer protocol-enabled server (as identified by
    ///         <code>ServerId</code>). The information returned includes the date the key was imported, the
    ///       public key contents, and the public key ID. A user can store more than one SSH public key
    ///       associated with their user name on a specific server.</p>
    public struct SshPublicKey: Swift.Equatable {
        /// <p>Specifies the date that the public key was added to the user account.</p>
        public let dateImported: ClientRuntime.Date?
        /// <p>Specifies the content of the SSH public key as specified by the
        ///       <code>PublicKeyId</code>.</p>
        public let sshPublicKeyBody: Swift.String?
        /// <p>Specifies the <code>SshPublicKeyId</code> parameter contains the identifier of the public
        ///       key.</p>
        public let sshPublicKeyId: Swift.String?

        public init (
            dateImported: ClientRuntime.Date? = nil,
            sshPublicKeyBody: Swift.String? = nil,
            sshPublicKeyId: Swift.String? = nil
        )
        {
            self.dateImported = dateImported
            self.sshPublicKeyBody = sshPublicKeyBody
            self.sshPublicKeyId = sshPublicKeyId
        }
    }

}

public struct StartServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartServerOutputError>
}

extension StartServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartServerInput(serverId: \(Swift.String(describing: serverId)))"}
}

extension StartServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct StartServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartServerOutputError>
}

public struct StartServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartServerOutputError>
}

public struct StartServerInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server that you start.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StartServerInputBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension StartServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StartServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartServerOutputResponse()"}
}

extension StartServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartServerOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartServerOutputResponseBody: Swift.Equatable {
}

extension StartServerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TransferClientTypes {
    /// <p>Describes the condition of a file transfer protocol-enabled server with respect to its
    ///       ability to perform file operations. There are six possible states: <code>OFFLINE</code>,
    ///         <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>,
    ///       <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p>
    ///
    ///          <p>
    ///             <code>OFFLINE</code> indicates that the server exists, but that it is not available for
    ///       file operations. <code>ONLINE</code> indicates that the server is available to perform file
    ///       operations. <code>STARTING</code> indicates that the server's was instantiated, but the
    ///       server is not yet available to perform file operations. Under normal conditions, it can take a
    ///       couple of minutes for the server to be completely operational. Both <code>START_FAILED</code>
    ///       and <code>STOP_FAILED</code> are error conditions.</p>
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case starting
        case startFailed
        case stopping
        case stopFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .offline,
                .online,
                .starting,
                .startFailed,
                .stopping,
                .stopFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .starting: return "STARTING"
            case .startFailed: return "START_FAILED"
            case .stopping: return "STOPPING"
            case .stopFailed: return "STOP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

public struct StopServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopServerOutputError>
}

extension StopServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopServerInput(serverId: \(Swift.String(describing: serverId)))"}
}

extension StopServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct StopServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopServerOutputError>
}

public struct StopServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopServerOutputError>
}

public struct StopServerInput: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server that you stopped.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StopServerInputBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension StopServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StopServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopServerOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopServerOutputResponse()"}
}

extension StopServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopServerOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopServerOutputResponseBody: Swift.Equatable {
}

extension StopServerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TransferClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TransferClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension TransferClientTypes {
    /// <p>Creates a key-value pair for a specific resource. Tags are metadata that you can use to
    ///       search for and group a resource for various purposes. You can apply tags to servers, users,
    ///       and roles. A tag key can take more than one value. For example, to group servers for
    ///       accounting purposes, you might create a tag called <code>Group</code> and assign the values
    ///         <code>Research</code> and <code>Accounting</code> to that group.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The name assigned to the tag that you create.</p>
        public let key: Swift.String?
        /// <p>Contains one or more values that you assigned to the key name you create.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(arn: \(Swift.String(describing: arn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>An Amazon Resource Name (ARN) for a specific AWS resource, such as a server, user, or
    ///       role.</p>
    public let arn: Swift.String?
    /// <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
    ///       type. You can attach this metadata to user accounts for any purpose.</p>
    public let tags: [TransferClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        tags: [TransferClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let tags: [TransferClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TransferClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[TransferClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TransferClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TestIdentityProviderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestIdentityProviderOutputError>
}

extension TestIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestIdentityProviderInput(serverId: \(Swift.String(describing: serverId)), serverProtocol: \(Swift.String(describing: serverProtocol)), sourceIp: \(Swift.String(describing: sourceIp)), userName: \(Swift.String(describing: userName)), userPassword: \(Swift.String(describing: userPassword)))"}
}

extension TestIdentityProviderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverProtocol = serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let sourceIp = sourceIp {
            try encodeContainer.encode(sourceIp, forKey: .sourceIp)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPassword = userPassword {
            try encodeContainer.encode(userPassword, forKey: .userPassword)
        }
    }
}

public struct TestIdentityProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestIdentityProviderOutputError>
}

public struct TestIdentityProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestIdentityProviderOutputError>
}

public struct TestIdentityProviderInput: Swift.Equatable {
    /// <p>A system-assigned identifier for a specific server. That server's user authentication
    ///       method is tested with a user name and password.</p>
    public let serverId: Swift.String?
    /// <p>The type of file transfer protocol to be tested.</p>
    ///
    ///          <p>The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol Secure (FTPS)</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol (FTP)</p>
    ///             </li>
    ///          </ul>
    public let serverProtocol: TransferClientTypes.ModelProtocol?
    /// <p>The source IP address of the user account to be tested.</p>
    public let sourceIp: Swift.String?
    /// <p>The name of the user account to be tested.</p>
    public let userName: Swift.String?
    /// <p>The password of the user account to be tested.</p>
    public let userPassword: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        serverProtocol: TransferClientTypes.ModelProtocol? = nil,
        sourceIp: Swift.String? = nil,
        userName: Swift.String? = nil,
        userPassword: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

struct TestIdentityProviderInputBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let serverProtocol: TransferClientTypes.ModelProtocol?
    public let sourceIp: Swift.String?
    public let userName: Swift.String?
    public let userPassword: Swift.String?
}

extension TestIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(TransferClientTypes.ModelProtocol.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let sourceIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIp)
        sourceIp = sourceIpDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPassword)
        userPassword = userPasswordDecoded
    }
}

extension TestIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestIdentityProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestIdentityProviderOutputResponse(message: \(Swift.String(describing: message)), response: \(Swift.String(describing: response)), statusCode: \(Swift.String(describing: statusCode)), url: \(Swift.String(describing: url)))"}
}

extension TestIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.response = output.response
            self.statusCode = output.statusCode
            self.url = output.url
        } else {
            self.message = nil
            self.response = nil
            self.statusCode = 0
            self.url = nil
        }
    }
}

public struct TestIdentityProviderOutputResponse: Swift.Equatable {
    /// <p>A message that indicates whether the test was successful or not.</p>
    public let message: Swift.String?
    /// <p>The response that is returned from your API Gateway.</p>
    public let response: Swift.String?
    /// <p>The HTTP status code that is the response from your API Gateway.</p>
    public let statusCode: Swift.Int
    /// <p>The endpoint of the service used to authenticate a user.</p>
    public let url: Swift.String?

    public init (
        message: Swift.String? = nil,
        response: Swift.String? = nil,
        statusCode: Swift.Int = 0,
        url: Swift.String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

struct TestIdentityProviderOutputResponseBody: Swift.Equatable {
    public let response: Swift.String?
    public let statusCode: Swift.Int
    public let message: Swift.String?
    public let url: Swift.String?
}

extension TestIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case response = "Response"
        case statusCode = "StatusCode"
        case url = "Url"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let statusCodeDecoded = try containerValues.decode(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
///
///          <p> HTTP Status Code: 400</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var retryAfterSeconds: Swift.String?

    public init (
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.retryAfterSeconds = retryAfterSeconds
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(arn: \(Swift.String(describing: arn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
    ///       an identifier for a specific AWS resource, such as a server, user, or role.</p>
    public let arn: Swift.String?
    /// <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
    ///       resources by type. This metadata can be attached to resources for any purpose.</p>
    public let tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessOutputError>
}

extension UpdateAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccessInput(externalId: \(Swift.String(describing: externalId)), homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)), serverId: \(Swift.String(describing: serverId)))"}
}

extension UpdateAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct UpdateAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessOutputError>
}

public struct UpdateAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessOutputError>
}

public struct UpdateAccessInput: Swift.Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: Swift.String?
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    ///          <p>A <code>HomeDirectory</code> example is <code>/directory_name/home/mydirectory</code>.</p>
    public let homeDirectory: Swift.String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    ///       be visible to your user and how you want to make them visible. You must specify the
    ///       <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    ///       only specify a target, it will be displayed as is. You also must ensure that your AWS Identity
    ///       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    ///       can only be set when <code>HomeDirectoryType</code> is set to
    ///       <i>LOGICAL</i>.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///         user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
    ///         <code>HomeDirectory</code> parameter value.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or Amazon EFS, the
    ///         entry will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create
    ///         0-byte objects as place holders for your directory. If using the AWS CLI, use the
    ///         <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code> or
    ///         <code>efs</code> so you can use the <code>put-object</code> operation. For example, you
    ///         can use the following.</p>
    ///             <p>
    ///                <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>
    ///             </p>
    ///             <p>The end of the key name must end in a <code>/</code> for it to be considered a
    ///           folder.</p>
    ///          </note>
    ///          <p>Required: No</p>
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///       <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// <p></p>
    ///          <p>A scope-down policy for your user so that you can use the same IAM role across multiple
    ///       users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables
    ///       that you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///       <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>This only applies when domain of <code>ServerId</code> is S3. Amazon EFS does not use scope
    ///       down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
    ///         scope-down policy</a>.</p>
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS Security Token Service API
    ///           Reference</i>.</p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: TransferClientTypes.PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    ///       file system. The policies attached to this role determine the level of access that you want to
    ///       provide your users when transferring files into and out of your Amazon S3 bucket or EFS file
    ///       system. The IAM role should also contain a trust relationship that allows the server to access
    ///       your resources when servicing your users' transfer requests.</p>
    public let role: Swift.String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct UpdateAccessInputBody: Swift.Equatable {
    public let homeDirectory: Swift.String?
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    public let policy: Swift.String?
    public let posixProfile: TransferClientTypes.PosixProfile?
    public let role: Swift.String?
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension UpdateAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccessOutputResponse(externalId: \(Swift.String(describing: externalId)), serverId: \(Swift.String(describing: serverId)))"}
}

extension UpdateAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateAccessOutputResponse: Swift.Equatable {
    /// <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family.</p>
    public let externalId: Swift.String?
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct UpdateAccessOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let externalId: Swift.String?
}

extension UpdateAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

public struct UpdateServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

extension UpdateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerInput(certificate: \(Swift.String(describing: certificate)), endpointDetails: \(Swift.String(describing: endpointDetails)), endpointType: \(Swift.String(describing: endpointType)), hostKey: \(Swift.String(describing: hostKey)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), loggingRole: \(Swift.String(describing: loggingRole)), protocols: \(Swift.String(describing: protocols)), securityPolicyName: \(Swift.String(describing: securityPolicyName)), serverId: \(Swift.String(describing: serverId)))"}
}

extension UpdateServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct UpdateServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

public struct UpdateServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

public struct UpdateServerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. Required
    ///       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    ///
    ///          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
    ///         private certificate</a> in the <i> AWS Certificate Manager User
    ///       Guide</i>.</p>
    ///
    ///          <p>Certificates with the following cryptographic algorithms and key sizes are
    ///       supported:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>2048-bit RSA (RSA_2048)</p>
    ///             </li>
    ///             <li>
    ///                <p>4096-bit RSA (RSA_4096)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
    ///         address specified and information about the issuer.</p>
    ///          </note>
    public let certificate: Swift.String?
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
    ///       With a VPC endpoint, you can restrict access to your server to resources only within your VPC.
    ///       To control incoming internet traffic, you will need to associate one or more Elastic IP
    ///       addresses with your server's endpoint.</p>
    public let endpointDetails: TransferClientTypes.EndpointDetails?
    /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
    ///       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
    ///       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
    ///          <note>
    ///             <p> After March 31, 2021, you won't be able to create a server using
    ///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
    ///       done so before March 31, 2021. If you have already created servers with
    ///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
    ///         you will not be affected. After this date, use
    ///         <code>EndpointType</code>=<code>VPC</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
    ///         this endpoint type, you have the option to directly associate up to three Elastic IPv4
    ///         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
    ///         restrict traffic by the client's public IP address. This is not possible with
    ///           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
    ///          </note>
    public let endpointType: TransferClientTypes.EndpointType?
    /// <p>The RSA private key as generated by <code>ssh-keygen -N "" -m PEM -f
    ///         my-new-server-key</code>.</p>
    ///
    ///          <important>
    ///             <p>If you aren't planning to migrate existing users from an existing server to a new
    ///         server, don't update the host key. Accidentally changing a server's host key can
    ///         be disruptive.</p>
    ///          </important>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>AWS Transfer
    ///         Family User Guide</i>.</p>
    public let hostKey: Swift.String?
    /// <p>An array containing all of the information required to call a customer's
    ///       authentication API method.</p>
    public let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    /// <p>Changes the AWS Identity and Access Management (IAM) role that allows Amazon S3 or Amazon EFS events to
    ///       be logged in Amazon CloudWatch, turning logging on or off.</p>
    public let loggingRole: Swift.String?
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    ///       client can connect to your server's endpoint. The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>If you select <code>FTPS</code>, you must choose a certificate stored in AWS Certificate
    ///         Manager (ACM) which will be used to identify your server when clients connect to it over
    ///         FTPS.</p>
    ///
    ///
    ///             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
    ///         <code>EndpointType</code> must be <code>VPC</code> and the
    ///         <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
    ///
    ///             <p>If <code>Protocol</code> includes <code>FTP</code>, then
    ///           <code>AddressAllocationIds</code> cannot be associated.</p>
    ///
    ///             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
    ///         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
    ///           <code>SERVICE_MANAGED</code>.</p>
    ///          </note>
    public let protocols: [TransferClientTypes.ModelProtocol]?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: Swift.String?
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        endpointDetails: TransferClientTypes.EndpointDetails? = nil,
        endpointType: TransferClientTypes.EndpointType? = nil,
        hostKey: Swift.String? = nil,
        identityProviderDetails: TransferClientTypes.IdentityProviderDetails? = nil,
        loggingRole: Swift.String? = nil,
        protocols: [TransferClientTypes.ModelProtocol]? = nil,
        securityPolicyName: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    public let certificate: Swift.String?
    public let endpointDetails: TransferClientTypes.EndpointDetails?
    public let endpointType: TransferClientTypes.EndpointType?
    public let hostKey: Swift.String?
    public let identityProviderDetails: TransferClientTypes.IdentityProviderDetails?
    public let loggingRole: Swift.String?
    public let protocols: [TransferClientTypes.ModelProtocol]?
    public let securityPolicyName: Swift.String?
    public let serverId: Swift.String?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(TransferClientTypes.IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([TransferClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[TransferClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [TransferClientTypes.ModelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension UpdateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerOutputResponse(serverId: \(Swift.String(describing: serverId)))"}
}

extension UpdateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct UpdateServerOutputResponse: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server that the user account is assigned
    ///       to.</p>
    public let serverId: Swift.String?

    public init (
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct UpdateServerOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
}

extension UpdateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

public struct UpdateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(homeDirectory: \(Swift.String(describing: homeDirectory)), homeDirectoryMappings: \(Swift.String(describing: homeDirectoryMappings)), homeDirectoryType: \(Swift.String(describing: homeDirectoryType)), policy: \(Swift.String(describing: policy)), posixProfile: \(Swift.String(describing: posixProfile)), role: \(Swift.String(describing: role)), serverId: \(Swift.String(describing: serverId)), userName: \(Swift.String(describing: userName)))"}
}

extension UpdateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Swift.Equatable {
    /// <p>Specifies the landing directory (folder) for a user when they log in to the server using
    ///       their file transfer protocol client.</p>
    ///
    ///          <p>An example is <code>your-Amazon-S3-bucket-name>/home/username</code>.</p>
    public let homeDirectory: Swift.String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to
    ///       your user and how you want to make them visible. You will need to specify the
    ///         "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code> shows how the
    ///       path is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you only specify
    ///       a target, it will be displayed as is. You will need to also make sure that your IAM role
    ///       provides access to paths in <code>Target</code>. The following is an example.</p>
    ///
    ///          <p>
    ///             <code>'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf", "Target":
    ///         "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]'</code>
    ///          </p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    ///
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry
    ///         will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0-byte
    ///         objects as place holders for your directory. If using the AWS CLI, use the
    ///           <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code>
    ///                <code>efs</code> so you can use the put-object operation. For example, you use the
    ///         following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
    ///         sure that the end of the key name ends in a / for it to be considered a folder.</p>
    ///          </note>
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) you want your users' home directory to be when
    ///       they log into the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or EFS paths visible to your
    ///       users.</p>
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    /// <p>Allows you to supply a scope-down policy for your user so you can use the same IAM role
    ///       across multiple users. The policy scopes down user access to portions of your Amazon S3
    ///       bucket. Variables you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead
    ///         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
    ///         it in the <code>Policy</code> argument.</p>
    ///
    ///
    ///
    ///
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down">Creating a scope-down
    ///           policy</a>.</p>
    ///
    ///
    ///
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS
    ///           Security Token Service API Reference</i>.</p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
    ///       that are set on files and directories in your file system determines the level of access your
    ///       users get when transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: TransferClientTypes.PosixProfile?
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket. The policies
    ///       attached to this role determine the level of access you want to provide your users when
    ///       transferring files into and out of your S3 bucket or buckets. The IAM role should also contain
    ///       a trust relationship that allows the server to access your resources when servicing your
    ///       users' transfer requests.</p>
    public let role: Swift.String?
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: Swift.String?
    /// <p>A unique string that identifies a user and is associated with a server as specified by the
    ///         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
    ///       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
    ///       '-', period '.', and at sign '@'. The user name can't start
    ///       with a hyphen, period, or at sign.</p>
    public let userName: Swift.String?

    public init (
        homeDirectory: Swift.String? = nil,
        homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: TransferClientTypes.HomeDirectoryType? = nil,
        policy: Swift.String? = nil,
        posixProfile: TransferClientTypes.PosixProfile? = nil,
        role: Swift.String? = nil,
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    public let homeDirectory: Swift.String?
    public let homeDirectoryType: TransferClientTypes.HomeDirectoryType?
    public let homeDirectoryMappings: [TransferClientTypes.HomeDirectoryMapEntry]?
    public let policy: Swift.String?
    public let posixProfile: TransferClientTypes.PosixProfile?
    public let role: Swift.String?
    public let serverId: Swift.String?
    public let userName: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(TransferClientTypes.HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([TransferClientTypes.HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[TransferClientTypes.HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [TransferClientTypes.HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(TransferClientTypes.PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserOutputResponse(serverId: \(Swift.String(describing: serverId)), userName: \(Swift.String(describing: userName)))"}
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

/// <p>
///             <code>UpdateUserResponse</code> returns the user name and identifier for the request to
///       update a user's properties.</p>
public struct UpdateUserOutputResponse: Swift.Equatable {
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: Swift.String?
    /// <p>The unique identifier for a user that is assigned to a server instance that was specified
    ///       in the request.</p>
    public let userName: Swift.String?

    public init (
        serverId: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    public let serverId: Swift.String?
    public let userName: Swift.String?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}
