// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IotWirelessClientTypes.AbpV1_0_x: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SessionKeysAbpV1_0_x.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension IotWirelessClientTypes.AbpV1_0_x: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbpV1_0_x(devAddr: \(Swift.String(describing: devAddr)), sessionKeys: \(Swift.String(describing: sessionKeys)))"}
}

extension IotWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.0.x
    public struct AbpV1_0_x: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// Session keys for ABP v1.0.x
        public var sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_0_x?

        public init (
            devAddr: Swift.String? = nil,
            sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_0_x? = nil
        )
        {
            self.devAddr = devAddr
            self.sessionKeys = sessionKeys
        }
    }

}

extension IotWirelessClientTypes.AbpV1_1: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SessionKeysAbpV1_1.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension IotWirelessClientTypes.AbpV1_1: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbpV1_1(devAddr: \(Swift.String(describing: devAddr)), sessionKeys: \(Swift.String(describing: sessionKeys)))"}
}

extension IotWirelessClientTypes {
    /// ABP device object for LoRaWAN specification v1.1
    public struct AbpV1_1: Swift.Equatable {
        /// The DevAddr value.
        public var devAddr: Swift.String?
        /// Session keys for ABP v1.1
        public var sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_1?

        public init (
            devAddr: Swift.String? = nil,
            sessionKeys: IotWirelessClientTypes.SessionKeysAbpV1_1? = nil
        )
        {
            self.devAddr = devAddr
            self.sessionKeys = sessionKeys
        }
    }

}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateAwsAccountWithPartnerAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAwsAccountWithPartnerAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

extension AssociateAwsAccountWithPartnerAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAwsAccountWithPartnerAccountInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), sidewalk: \(Swift.String(describing: sidewalk)), tags: \(Swift.String(describing: tags)))"}
}

extension AssociateAwsAccountWithPartnerAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAwsAccountWithPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

public struct AssociateAwsAccountWithPartnerAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAwsAccountWithPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

public struct AssociateAwsAccountWithPartnerAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAwsAccountWithPartnerAccountInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateAwsAccountWithPartnerAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/partner-accounts"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateAwsAccountWithPartnerAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

public struct AssociateAwsAccountWithPartnerAccountInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfo? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct AssociateAwsAccountWithPartnerAccountInputBody: Swift.Equatable {
    public let sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    public let clientRequestToken: Swift.String?
    public let tags: [IotWirelessClientTypes.Tag]?
}

extension AssociateAwsAccountWithPartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAwsAccountWithPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAwsAccountWithPartnerAccountOutputResponse(arn: \(Swift.String(describing: arn)), sidewalk: \(Swift.String(describing: sidewalk)))"}
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateAwsAccountWithPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.sidewalk = nil
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?

    public init (
        arn: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

struct AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Equatable {
    public let sidewalk: IotWirelessClientTypes.SidewalkAccountInfo?
    public let arn: Swift.String?
}

extension AssociateAwsAccountWithPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct AssociateWirelessDeviceWithThingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessDeviceWithThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessDeviceWithThingOutputError>
}

extension AssociateWirelessDeviceWithThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessDeviceWithThingInput(id: \(Swift.String(describing: id)), thingArn: \(Swift.String(describing: thingArn)))"}
}

extension AssociateWirelessDeviceWithThingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

public struct AssociateWirelessDeviceWithThingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessDeviceWithThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessDeviceWithThingOutputError>
}

public struct AssociateWirelessDeviceWithThingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessDeviceWithThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessDeviceWithThingOutputError>
}

public struct AssociateWirelessDeviceWithThingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessDeviceWithThingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateWirelessDeviceWithThingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())/thing"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateWirelessDeviceWithThingInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessDeviceWithThingOutputError>
}

public struct AssociateWirelessDeviceWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless device.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessDeviceWithThingInputBody: Swift.Equatable {
    public let thingArn: Swift.String?
}

extension AssociateWirelessDeviceWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessDeviceWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessDeviceWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithThingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessDeviceWithThingOutputResponse()"}
}

extension AssociateWirelessDeviceWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithThingOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateWirelessDeviceWithThingOutputResponseBody: Swift.Equatable {
}

extension AssociateWirelessDeviceWithThingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateWirelessGatewayWithCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

extension AssociateWirelessGatewayWithCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessGatewayWithCertificateInput(id: \(Swift.String(describing: id)), iotCertificateId: \(Swift.String(describing: iotCertificateId)))"}
}

extension AssociateWirelessGatewayWithCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotCertificateId = iotCertificateId {
            try encodeContainer.encode(iotCertificateId, forKey: .iotCertificateId)
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

public struct AssociateWirelessGatewayWithCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

public struct AssociateWirelessGatewayWithCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithCertificateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateWirelessGatewayWithCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateWirelessGatewayWithCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

public struct AssociateWirelessGatewayWithCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the certificate to associate with the wireless gateway.
    /// This member is required.
    public var iotCertificateId: Swift.String?

    public init (
        id: Swift.String? = nil,
        iotCertificateId: Swift.String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateInputBody: Swift.Equatable {
    public let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessGatewayWithCertificateOutputResponse(iotCertificateId: \(Swift.String(describing: iotCertificateId)))"}
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateWirelessGatewayWithCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
        } else {
            self.iotCertificateId = nil
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Equatable {
    public let iotCertificateId: Swift.String?
}

extension AssociateWirelessGatewayWithCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

public struct AssociateWirelessGatewayWithThingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithThingOutputError>
}

extension AssociateWirelessGatewayWithThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessGatewayWithThingInput(id: \(Swift.String(describing: id)), thingArn: \(Swift.String(describing: thingArn)))"}
}

extension AssociateWirelessGatewayWithThingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

public struct AssociateWirelessGatewayWithThingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithThingOutputError>
}

public struct AssociateWirelessGatewayWithThingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithThingOutputError>
}

public struct AssociateWirelessGatewayWithThingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateWirelessGatewayWithThingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateWirelessGatewayWithThingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/thing"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateWirelessGatewayWithThingInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateWirelessGatewayWithThingOutputError>
}

public struct AssociateWirelessGatewayWithThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ARN of the thing to associate with the wireless gateway.
    /// This member is required.
    public var thingArn: Swift.String?

    public init (
        id: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessGatewayWithThingInputBody: Swift.Equatable {
    public let thingArn: Swift.String?
}

extension AssociateWirelessGatewayWithThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessGatewayWithThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithThingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateWirelessGatewayWithThingOutputResponse()"}
}

extension AssociateWirelessGatewayWithThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessGatewayWithThingOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateWirelessGatewayWithThingOutputResponseBody: Swift.Equatable {
}

extension AssociateWirelessGatewayWithThingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device battery level.
    public enum BatteryLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case low
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [BatteryLevel] {
            return [
                .critical,
                .low,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "critical"
            case .low: return "low"
            case .normal: return "normal"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatteryLevel(rawValue: rawValue) ?? BatteryLevel.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.CertificateList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signingAlg = "SigningAlg"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAlg = signingAlg {
            try encodeContainer.encode(signingAlg.rawValue, forKey: .signingAlg)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAlgDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SigningAlg.self, forKey: .signingAlg)
        signingAlg = signingAlgDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotWirelessClientTypes.CertificateList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateList(signingAlg: \(Swift.String(describing: signingAlg)), value: \(Swift.String(describing: value)))"}
}

extension IotWirelessClientTypes {
    /// List of sidewalk certificates.
    public struct CertificateList: Swift.Equatable {
        /// The certificate chain algorithm provided by sidewalk.
        /// This member is required.
        public var signingAlg: IotWirelessClientTypes.SigningAlg?
        /// The value of the chosen sidewalk certificate.
        /// This member is required.
        public var value: Swift.String?

        public init (
            signingAlg: IotWirelessClientTypes.SigningAlg? = nil,
            value: Swift.String? = nil
        )
        {
            self.signingAlg = signingAlg
            self.value = value
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Adding, updating, or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the resource in the conflicting operation.
    public var resourceId: Swift.String?
    /// Type of the resource in the conflicting operation.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IotWirelessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .disconnected: return "Disconnected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDestinationOutputError>
}

extension CreateDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDestinationInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), expression: \(Swift.String(describing: expression)), expressionType: \(Swift.String(describing: expressionType)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDestinationOutputError>
}

public struct CreateDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDestinationOutputError>
}

public struct CreateDestinationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDestinationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDestinationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/destinations"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDestinationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDestinationOutputError>
}

public struct CreateDestinationInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    /// This member is required.
    public var expression: Swift.String?
    /// The type of value in Expression.
    /// This member is required.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let expressionType: IotWirelessClientTypes.ExpressionType?
    public let expression: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let tags: [IotWirelessClientTypes.Tag]?
    public let clientRequestToken: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDestinationOutputResponse(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)))"}
}

extension CreateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDestinationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
}

extension CreateDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateDeviceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceProfileOutputError>
}

extension CreateDeviceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceProfileInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDeviceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDeviceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceProfileOutputError>
}

public struct CreateDeviceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceProfileOutputError>
}

public struct CreateDeviceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeviceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDeviceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/device-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeviceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeviceProfileOutputError>
}

public struct CreateDeviceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The device profile information to use to create the device profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    public let tags: [IotWirelessClientTypes.Tag]?
    public let clientRequestToken: Swift.String?
}

extension CreateDeviceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceProfileOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)))"}
}

extension CreateDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new device profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateDeviceProfileOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let id: Swift.String?
}

extension CreateDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateServiceProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceProfileOutputError>
}

extension CreateServiceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceProfileInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServiceProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceProfileOutputError>
}

public struct CreateServiceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceProfileOutputError>
}

public struct CreateServiceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateServiceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/service-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceProfileOutputError>
}

public struct CreateServiceProfileInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The service profile information to use to create the service profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANServiceProfile?
    public let tags: [IotWirelessClientTypes.Tag]?
    public let clientRequestToken: Swift.String?
}

extension CreateServiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANServiceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceProfileOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)))"}
}

extension CreateServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new service profile.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateServiceProfileOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let id: Swift.String?
}

extension CreateServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessDeviceOutputError>
}

extension CreateWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessDeviceInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), destinationName: \(Swift.String(describing: destinationName)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessDeviceOutputError>
}

public struct CreateWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessDeviceOutputError>
}

public struct CreateWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessDeviceOutputError>
}

public struct CreateWirelessDeviceInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The name of the destination to assign to the new wireless device.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The device configuration information to use to create the wireless device.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?
    /// The wireless device type.
    /// This member is required.
    public var type: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil,
        type: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateWirelessDeviceInputBody: Swift.Equatable {
    public let type: IotWirelessClientTypes.WirelessDeviceType?
    public let name: Swift.String?
    public let description: Swift.String?
    public let destinationName: Swift.String?
    public let clientRequestToken: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    public let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessDeviceOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)))"}
}

extension CreateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless device.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessDeviceOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let id: Swift.String?
}

extension CreateWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayOutputError>
}

extension CreateWirelessGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateWirelessGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateWirelessGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayOutputError>
}

public struct CreateWirelessGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayOutputError>
}

public struct CreateWirelessGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWirelessGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWirelessGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayOutputError>
}

public struct CreateWirelessGatewayInput: Swift.Equatable {
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The description of the new resource.
    public var description: Swift.String?
    /// The gateway configuration information to use to create the wireless gateway.
    /// This member is required.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateWirelessGatewayInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    public let tags: [IotWirelessClientTypes.Tag]?
    public let clientRequestToken: Swift.String?
}

extension CreateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)))"}
}

extension CreateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the new resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let id: Swift.String?
}

extension CreateWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessGatewayTaskDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

extension CreateWirelessGatewayTaskDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayTaskDefinitionInput(autoCreateTasks: \(Swift.String(describing: autoCreateTasks)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), update: \(Swift.String(describing: update)))"}
}

extension CreateWirelessGatewayTaskDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoCreateTasks != false {
            try encodeContainer.encode(autoCreateTasks, forKey: .autoCreateTasks)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let update = update {
            try encodeContainer.encode(update, forKey: .update)
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

public struct CreateWirelessGatewayTaskDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

public struct CreateWirelessGatewayTaskDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWirelessGatewayTaskDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateway-task-definitions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWirelessGatewayTaskDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

public struct CreateWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    /// This member is required.
    public var autoCreateTasks: Swift.Bool
    /// Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request.
    public var clientRequestToken: Swift.String?
    /// The name of the new resource.
    public var name: Swift.String?
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?
    /// Information about the gateways to update.
    public var update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        autoCreateTasks: Swift.Bool = false,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil,
        update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

struct CreateWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
    public let autoCreateTasks: Swift.Bool
    public let name: Swift.String?
    public let update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    public let clientRequestToken: Swift.String?
    public let tags: [IotWirelessClientTypes.Tag]?
}

extension CreateWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayTaskDefinitionOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)))"}
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the new wireless gateway task definition.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let arn: Swift.String?
}

extension CreateWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateWirelessGatewayTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskOutputError>
}

extension CreateWirelessGatewayTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayTaskInput(id: \(Swift.String(describing: id)), wirelessGatewayTaskDefinitionId: \(Swift.String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension CreateWirelessGatewayTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId {
            try encodeContainer.encode(wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }
    }
}

public struct CreateWirelessGatewayTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskOutputError>
}

public struct CreateWirelessGatewayTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskOutputError>
}

public struct CreateWirelessGatewayTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWirelessGatewayTaskInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWirelessGatewayTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWirelessGatewayTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWirelessGatewayTaskOutputError>
}

public struct CreateWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the WirelessGatewayTaskDefinition.
    /// This member is required.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        id: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskInputBody: Swift.Equatable {
    public let wirelessGatewayTaskDefinitionId: Swift.String?
}

extension CreateWirelessGatewayTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
    }
}

extension CreateWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWirelessGatewayTaskOutputResponse(status: \(Swift.String(describing: status)), wirelessGatewayTaskDefinitionId: \(Swift.String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension CreateWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.status = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct CreateWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The status of the request.
    public var status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The ID of the WirelessGatewayTaskDefinition.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        status: IotWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    public let wirelessGatewayTaskDefinitionId: Swift.String?
    public let status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension CreateWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDestinationInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteDestinationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDestinationOutputError>
}

public struct DeleteDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDestinationOutputError>
}

public struct DeleteDestinationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDestinationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDestinationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/destinations/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDestinationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDestinationOutputError>
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// The name of the resource to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
}

extension DeleteDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDestinationOutputResponse()"}
}

extension DeleteDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDestinationOutputResponseBody: Swift.Equatable {
}

extension DeleteDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceProfileInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteDeviceProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDeviceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceProfileOutputError>
}

public struct DeleteDeviceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceProfileOutputError>
}

public struct DeleteDeviceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeviceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDeviceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/device-profiles/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeviceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeviceProfileOutputError>
}

public struct DeleteDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeviceProfileInputBody: Swift.Equatable {
}

extension DeleteDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeviceProfileOutputResponse()"}
}

extension DeleteDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDeviceProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteDeviceProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceProfileInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteServiceProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteServiceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceProfileOutputError>
}

public struct DeleteServiceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceProfileOutputError>
}

public struct DeleteServiceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteServiceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/service-profiles/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceProfileOutputError>
}

public struct DeleteServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceProfileInputBody: Swift.Equatable {
}

extension DeleteServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceProfileOutputResponse()"}
}

extension DeleteServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServiceProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteServiceProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessDeviceInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessDeviceOutputError>
}

public struct DeleteWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessDeviceOutputError>
}

public struct DeleteWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessDeviceOutputError>
}

public struct DeleteWirelessDeviceInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceInputBody: Swift.Equatable {
}

extension DeleteWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessDeviceOutputResponse()"}
}

extension DeleteWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessDeviceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWirelessDeviceOutputResponseBody: Swift.Equatable {
}

extension DeleteWirelessDeviceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteWirelessGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWirelessGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayOutputError>
}

public struct DeleteWirelessGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayOutputError>
}

public struct DeleteWirelessGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWirelessGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWirelessGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayOutputError>
}

public struct DeleteWirelessGatewayInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayOutputResponse()"}
}

extension DeleteWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWirelessGatewayOutputResponseBody: Swift.Equatable {
}

extension DeleteWirelessGatewayOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayTaskDefinitionInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteWirelessGatewayTaskDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskDefinitionOutputError>
}

public struct DeleteWirelessGatewayTaskDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskDefinitionOutputError>
}

public struct DeleteWirelessGatewayTaskDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWirelessGatewayTaskDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWirelessGatewayTaskDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskDefinitionOutputError>
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayTaskDefinitionOutputResponse()"}
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayTaskInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteWirelessGatewayTaskInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWirelessGatewayTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskOutputError>
}

public struct DeleteWirelessGatewayTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskOutputError>
}

public struct DeleteWirelessGatewayTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWirelessGatewayTaskInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWirelessGatewayTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWirelessGatewayTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWirelessGatewayTaskOutputError>
}

public struct DeleteWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWirelessGatewayTaskOutputResponse()"}
}

extension DeleteWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
}

extension DeleteWirelessGatewayTaskOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotWirelessClientTypes.Destinations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotWirelessClientTypes.Destinations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Destinations(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), expression: \(Swift.String(describing: expression)), expressionType: \(Swift.String(describing: expressionType)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension IotWirelessClientTypes {
    /// Describes a destination.
    public struct Destinations: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The rule name or topic rule to send messages to.
        public var expression: Swift.String?
        /// The type of value in Expression.
        public var expressionType: IotWirelessClientTypes.ExpressionType?
        /// The name of the resource.
        public var name: Swift.String?
        /// The ARN of the IAM Role that authorizes the destination.
        public var roleArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            expressionType: IotWirelessClientTypes.ExpressionType? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.expression = expression
            self.expressionType = expressionType
            self.name = name
            self.roleArn = roleArn
        }
    }

}

extension IotWirelessClientTypes.DeviceProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IotWirelessClientTypes.DeviceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceProfile(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension IotWirelessClientTypes {
    /// Describes a device profile.
    public struct DeviceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the device profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes {
    /// Device state defines the device status of sidewalk device.
    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case registerednotseen
        case registeredreachable
        case registeredunreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .provisioned,
                .registerednotseen,
                .registeredreachable,
                .registeredunreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "Provisioned"
            case .registerednotseen: return "RegisteredNotSeen"
            case .registeredreachable: return "RegisteredReachable"
            case .registeredunreachable: return "RegisteredUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAwsAccountFromPartnerAccountInput(partnerAccountId: \(Swift.String(describing: partnerAccountId)), partnerType: \(Swift.String(describing: partnerType)))"}
}

extension DisassociateAwsAccountFromPartnerAccountInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAwsAccountFromPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAwsAccountFromPartnerAccountOutputError>
}

public struct DisassociateAwsAccountFromPartnerAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAwsAccountFromPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAwsAccountFromPartnerAccountOutputError>
}

public struct DisassociateAwsAccountFromPartnerAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAwsAccountFromPartnerAccountInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateAwsAccountFromPartnerAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let partnerAccountId = input.partnerAccountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("partnerAccountId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateAwsAccountFromPartnerAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAwsAccountFromPartnerAccountOutputError>
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAwsAccountFromPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAwsAccountFromPartnerAccountOutputResponse()"}
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateAwsAccountFromPartnerAccountOutputResponseBody: Swift.Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessDeviceFromThingInput(id: \(Swift.String(describing: id)))"}
}

extension DisassociateWirelessDeviceFromThingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessDeviceFromThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessDeviceFromThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessDeviceFromThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessDeviceFromThingOutputError>
}

public struct DisassociateWirelessDeviceFromThingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessDeviceFromThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessDeviceFromThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessDeviceFromThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessDeviceFromThingOutputError>
}

public struct DisassociateWirelessDeviceFromThingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessDeviceFromThingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateWirelessDeviceFromThingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())/thing"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateWirelessDeviceFromThingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessDeviceFromThingOutputError>
}

public struct DisassociateWirelessDeviceFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessDeviceFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessDeviceFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromThingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessDeviceFromThingOutputResponse()"}
}

extension DisassociateWirelessDeviceFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateWirelessDeviceFromThingOutputResponseBody: Swift.Equatable {
}

extension DisassociateWirelessDeviceFromThingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessGatewayFromCertificateInput(id: \(Swift.String(describing: id)))"}
}

extension DisassociateWirelessGatewayFromCertificateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromCertificateOutputError>
}

public struct DisassociateWirelessGatewayFromCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromCertificateOutputError>
}

public struct DisassociateWirelessGatewayFromCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromCertificateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateWirelessGatewayFromCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateWirelessGatewayFromCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromCertificateOutputError>
}

public struct DisassociateWirelessGatewayFromCertificateInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromCertificateInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessGatewayFromCertificateOutputResponse()"}
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateWirelessGatewayFromCertificateOutputResponseBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromCertificateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessGatewayFromThingInput(id: \(Swift.String(describing: id)))"}
}

extension DisassociateWirelessGatewayFromThingInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromThingOutputError>
}

public struct DisassociateWirelessGatewayFromThingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromThingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateWirelessGatewayFromThingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromThingOutputError>
}

public struct DisassociateWirelessGatewayFromThingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateWirelessGatewayFromThingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateWirelessGatewayFromThingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/thing"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateWirelessGatewayFromThingInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateWirelessGatewayFromThingOutputError>
}

public struct DisassociateWirelessGatewayFromThingInput: Swift.Equatable {
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromThingInputBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromThingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromThingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateWirelessGatewayFromThingOutputResponse()"}
}

extension DisassociateWirelessGatewayFromThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateWirelessGatewayFromThingOutputResponseBody: Swift.Equatable {
}

extension DisassociateWirelessGatewayFromThingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device status notification.
    public enum Event: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ack
        case discovered
        case lost
        case nack
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [Event] {
            return [
                .ack,
                .discovered,
                .lost,
                .nack,
                .passthrough,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ack: return "ack"
            case .discovered: return "discovered"
            case .lost: return "lost"
            case .nack: return "nack"
            case .passthrough: return "passthrough"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum ExpressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqtttopic
        case rulename
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpressionType] {
            return [
                .mqtttopic,
                .rulename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqtttopic: return "MqttTopic"
            case .rulename: return "RuleName"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
        }
    }
}

extension GetDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDestinationInput(name: \(Swift.String(describing: name)))"}
}

extension GetDestinationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDestinationOutputError>
}

public struct GetDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDestinationOutputError>
}

public struct GetDestinationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDestinationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetDestinationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/destinations/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDestinationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDestinationOutputError>
}

public struct GetDestinationInput: Swift.Equatable {
    /// The name of the resource to get.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDestinationOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), expression: \(Swift.String(describing: expression)), expressionType: \(Swift.String(describing: expressionType)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension GetDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.expression = output.expression
            self.expressionType = output.expressionType
            self.name = output.name
            self.roleArn = output.roleArn
        } else {
            self.arn = nil
            self.description = nil
            self.expression = nil
            self.expressionType = nil
            self.name = nil
            self.roleArn = nil
        }
    }
}

public struct GetDestinationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct GetDestinationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let expression: Swift.String?
    public let expressionType: IotWirelessClientTypes.ExpressionType?
    public let description: Swift.String?
    public let roleArn: Swift.String?
}

extension GetDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetDeviceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceProfileInput(id: \(Swift.String(describing: id)))"}
}

extension GetDeviceProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeviceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceProfileOutputError>
}

public struct GetDeviceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceProfileOutputError>
}

public struct GetDeviceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetDeviceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/device-profiles/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeviceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceProfileOutputError>
}

public struct GetDeviceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceProfileInputBody: Swift.Equatable {
}

extension GetDeviceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceProfileOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)))"}
}

extension GetDeviceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetDeviceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the device profile.
    public var id: Swift.String?
    /// Information about the device profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetDeviceProfileOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let id: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceProfile?
}

extension GetDeviceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetLogLevelsByResourceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLogLevelsByResourceTypesInput()"}
}

extension GetLogLevelsByResourceTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLogLevelsByResourceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLogLevelsByResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLogLevelsByResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLogLevelsByResourceTypesOutputError>
}

public struct GetLogLevelsByResourceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLogLevelsByResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLogLevelsByResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLogLevelsByResourceTypesOutputError>
}

public struct GetLogLevelsByResourceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLogLevelsByResourceTypesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetLogLevelsByResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLogLevelsByResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLogLevelsByResourceTypesOutputError>
}

public struct GetLogLevelsByResourceTypesInput: Swift.Equatable {

    public init() {}
}

struct GetLogLevelsByResourceTypesInputBody: Swift.Equatable {
}

extension GetLogLevelsByResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLogLevelsByResourceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLogLevelsByResourceTypesOutputResponse(defaultLogLevel: \(Swift.String(describing: defaultLogLevel)), wirelessDeviceLogOptions: \(Swift.String(describing: wirelessDeviceLogOptions)), wirelessGatewayLogOptions: \(Swift.String(describing: wirelessGatewayLogOptions)))"}
}

extension GetLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLogLevelsByResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultLogLevel = output.defaultLogLevel
            self.wirelessDeviceLogOptions = output.wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = output.wirelessGatewayLogOptions
        } else {
            self.defaultLogLevel = nil
            self.wirelessDeviceLogOptions = nil
            self.wirelessGatewayLogOptions = nil
        }
    }
}

public struct GetLogLevelsByResourceTypesOutputResponse: Swift.Equatable {
    /// The log level for a log message.
    public var defaultLogLevel: IotWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IotWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct GetLogLevelsByResourceTypesOutputResponseBody: Swift.Equatable {
    public let defaultLogLevel: IotWirelessClientTypes.LogLevel?
    public let wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?
    public let wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
}

extension GetLogLevelsByResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IotWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
    }
}

extension GetPartnerAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnerAccountInput(partnerAccountId: \(Swift.String(describing: partnerAccountId)), partnerType: \(Swift.String(describing: partnerType)))"}
}

extension GetPartnerAccountInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPartnerAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPartnerAccountOutputError>
}

public struct GetPartnerAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPartnerAccountOutputError>
}

public struct GetPartnerAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPartnerAccountInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetPartnerAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let partnerAccountId = input.partnerAccountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("partnerAccountId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPartnerAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPartnerAccountOutputError>
}

public struct GetPartnerAccountInput: Swift.Equatable {
    /// The partner account ID to disassociate from the AWS account.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct GetPartnerAccountInputBody: Swift.Equatable {
}

extension GetPartnerAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartnerAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnerAccountOutputResponse(accountLinked: \(Swift.String(describing: accountLinked)), sidewalk: \(Swift.String(describing: sidewalk)))"}
}

extension GetPartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountLinked = output.accountLinked
            self.sidewalk = output.sidewalk
        } else {
            self.accountLinked = false
            self.sidewalk = nil
        }
    }
}

public struct GetPartnerAccountOutputResponse: Swift.Equatable {
    /// Whether the partner account is linked to the AWS account.
    public var accountLinked: Swift.Bool
    /// The Sidewalk account credentials.
    public var sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?

    public init (
        accountLinked: Swift.Bool = false,
        sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

struct GetPartnerAccountOutputResponseBody: Swift.Equatable {
    public let sidewalk: IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?
    public let accountLinked: Swift.Bool
}

extension GetPartnerAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLinked = "AccountLinked"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let accountLinkedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .accountLinked)
        accountLinked = accountLinkedDecoded
    }
}

extension GetResourceLogLevelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceLogLevelInput(resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension GetResourceLogLevelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetResourceLogLevelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceLogLevelOutputError>
}

public struct GetResourceLogLevelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceLogLevelOutputError>
}

public struct GetResourceLogLevelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceLogLevelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetResourceLogLevelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceIdentifier = input.resourceIdentifier else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceIdentifier is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceLogLevelInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceLogLevelOutputError>
}

public struct GetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway,
    ///             it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourceLogLevelInputBody: Swift.Equatable {
}

extension GetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceLogLevelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceLogLevelOutputResponse(logLevel: \(Swift.String(describing: logLevel)))"}
}

extension GetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceLogLevelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logLevel = output.logLevel
        } else {
            self.logLevel = nil
        }
    }
}

public struct GetResourceLogLevelOutputResponse: Swift.Equatable {
    /// The log level for a log message.
    public var logLevel: IotWirelessClientTypes.LogLevel?

    public init (
        logLevel: IotWirelessClientTypes.LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

struct GetResourceLogLevelOutputResponseBody: Swift.Equatable {
    public let logLevel: IotWirelessClientTypes.LogLevel?
}

extension GetResourceLogLevelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension GetServiceEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceEndpointInput(serviceType: \(Swift.String(describing: serviceType)))"}
}

extension GetServiceEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetServiceEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceEndpointOutputError>
}

public struct GetServiceEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let serviceType = input.operationInput.serviceType {
            let serviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(serviceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceEndpointOutputError>
}

public struct GetServiceEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetServiceEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/service-endpoint"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceEndpointOutputError>
}

public struct GetServiceEndpointInput: Swift.Equatable {
    /// The service type for which to get endpoint information about. Can be CUPS for the Configuration and Update Server endpoint, or LNS for the LoRaWAN Network Server endpoint.
    public var serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serviceType: IotWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointInputBody: Swift.Equatable {
}

extension GetServiceEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceEndpointOutputResponse(serverTrust: \(Swift.String(describing: serverTrust)), serviceEndpoint: \(Swift.String(describing: serviceEndpoint)), serviceType: \(Swift.String(describing: serviceType)))"}
}

extension GetServiceEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serverTrust = output.serverTrust
            self.serviceEndpoint = output.serviceEndpoint
            self.serviceType = output.serviceType
        } else {
            self.serverTrust = nil
            self.serviceEndpoint = nil
            self.serviceType = nil
        }
    }
}

public struct GetServiceEndpointOutputResponse: Swift.Equatable {
    /// The Root CA of the server trust certificate.
    public var serverTrust: Swift.String?
    /// The service endpoint value.
    public var serviceEndpoint: Swift.String?
    /// The endpoint's service type.
    public var serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?

    public init (
        serverTrust: Swift.String? = nil,
        serviceEndpoint: Swift.String? = nil,
        serviceType: IotWirelessClientTypes.WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointOutputResponseBody: Swift.Equatable {
    public let serviceType: IotWirelessClientTypes.WirelessGatewayServiceType?
    public let serviceEndpoint: Swift.String?
    public let serverTrust: Swift.String?
}

extension GetServiceEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverTrust = "ServerTrust"
        case serviceEndpoint = "ServiceEndpoint"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let serviceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceEndpoint)
        serviceEndpoint = serviceEndpointDecoded
        let serverTrustDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTrust)
        serverTrust = serverTrustDecoded
    }
}

extension GetServiceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceProfileInput(id: \(Swift.String(describing: id)))"}
}

extension GetServiceProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetServiceProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceProfileOutputError>
}

public struct GetServiceProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceProfileOutputError>
}

public struct GetServiceProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetServiceProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/service-profiles/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceProfileOutputError>
}

public struct GetServiceProfileInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceProfileInputBody: Swift.Equatable {
}

extension GetServiceProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceProfileOutputResponse(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)))"}
}

extension GetServiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetServiceProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The ID of the service profile.
    public var id: Swift.String?
    /// Information about the service profile.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo?
    /// The name of the resource.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetServiceProfileOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let id: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANGetServiceProfileInfo?
}

extension GetServiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGetServiceProfileInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessDeviceInput(identifier: \(Swift.String(describing: identifier)), identifierType: \(Swift.String(describing: identifierType)))"}
}

extension GetWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceOutputError>
}

public struct GetWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let identifierType = input.operationInput.identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identifierTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceOutputError>
}

public struct GetWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identifier = input.identifier else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identifier is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(identifier.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceOutputError>
}

public struct GetWirelessDeviceInput: Swift.Equatable {
    /// The identifier of the wireless device to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.WirelessDeviceIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessDeviceInputBody: Swift.Equatable {
}

extension GetWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessDeviceOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), destinationName: \(Swift.String(describing: destinationName)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), sidewalk: \(Swift.String(describing: sidewalk)), thingArn: \(Swift.String(describing: thingArn)), thingName: \(Swift.String(describing: thingName)), type: \(Swift.String(describing: type)))"}
}

extension GetWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.destinationName = output.destinationName
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.sidewalk = output.sidewalk
            self.thingArn = output.thingArn
            self.thingName = output.thingName
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.destinationName = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.sidewalk = nil
            self.thingArn = nil
            self.thingName = nil
            self.type = nil
        }
    }
}

public struct GetWirelessDeviceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The name of the destination to which the device is assigned.
    public var destinationName: Swift.String?
    /// The ID of the wireless device.
    public var id: Swift.String?
    /// Information about the wireless device.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    /// The name of the resource.
    public var name: Swift.String?
    /// Sidewalk device object.
    public var sidewalk: IotWirelessClientTypes.SidewalkDevice?
    /// The ARN of the thing associated with the wireless device.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.
    public var thingName: Swift.String?
    /// The wireless device type.
    public var type: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDevice? = nil,
        name: Swift.String? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkDevice? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil,
        type: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

struct GetWirelessDeviceOutputResponseBody: Swift.Equatable {
    public let type: IotWirelessClientTypes.WirelessDeviceType?
    public let name: Swift.String?
    public let description: Swift.String?
    public let destinationName: Swift.String?
    public let id: Swift.String?
    public let arn: Swift.String?
    public let thingName: Swift.String?
    public let thingArn: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANDevice?
    public let sidewalk: IotWirelessClientTypes.SidewalkDevice?
}

extension GetWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case destinationName = "DestinationName"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessDeviceStatisticsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessDeviceStatisticsInput(wirelessDeviceId: \(Swift.String(describing: wirelessDeviceId)))"}
}

extension GetWirelessDeviceStatisticsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessDeviceStatisticsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessDeviceStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessDeviceStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceStatisticsOutputError>
}

public struct GetWirelessDeviceStatisticsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessDeviceStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessDeviceStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceStatisticsOutputError>
}

public struct GetWirelessDeviceStatisticsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessDeviceStatisticsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessDeviceStatisticsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let wirelessDeviceId = input.wirelessDeviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("wirelessDeviceId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(wirelessDeviceId.urlPercentEncoding())/statistics"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessDeviceStatisticsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessDeviceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessDeviceStatisticsOutputError>
}

public struct GetWirelessDeviceStatisticsInput: Swift.Equatable {
    /// The ID of the wireless device for which to get the data.
    /// This member is required.
    public var wirelessDeviceId: Swift.String?

    public init (
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessDeviceStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessDeviceStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceStatisticsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessDeviceStatisticsOutputResponse(lastUplinkReceivedAt: \(Swift.String(describing: lastUplinkReceivedAt)), loRaWAN: \(Swift.String(describing: loRaWAN)), sidewalk: \(Swift.String(describing: sidewalk)), wirelessDeviceId: \(Swift.String(describing: wirelessDeviceId)))"}
}

extension GetWirelessDeviceStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessDeviceStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.loRaWAN = output.loRaWAN
            self.sidewalk = output.sidewalk
            self.wirelessDeviceId = output.wirelessDeviceId
        } else {
            self.lastUplinkReceivedAt = nil
            self.loRaWAN = nil
            self.sidewalk = nil
            self.wirelessDeviceId = nil
        }
    }
}

public struct GetWirelessDeviceStatisticsOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// Information about the wireless device's operations.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata?
    /// MetaData for Sidewalk device.
    public var sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata?
    /// The ID of the wireless device.
    public var wirelessDeviceId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsOutputResponseBody: Swift.Equatable {
    public let wirelessDeviceId: Swift.String?
    public let lastUplinkReceivedAt: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANDeviceMetadata?
    public let sidewalk: IotWirelessClientTypes.SidewalkDeviceMetadata?
}

extension GetWirelessDeviceStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANDeviceMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkDeviceMetadata.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessGatewayCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayCertificateInput(id: \(Swift.String(describing: id)))"}
}

extension GetWirelessGatewayCertificateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayCertificateOutputError>
}

public struct GetWirelessGatewayCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayCertificateOutputError>
}

public struct GetWirelessGatewayCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayCertificateInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/certificate"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayCertificateOutputError>
}

public struct GetWirelessGatewayCertificateInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayCertificateInputBody: Swift.Equatable {
}

extension GetWirelessGatewayCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayCertificateOutputResponse(iotCertificateId: \(Swift.String(describing: iotCertificateId)), loRaWANNetworkServerCertificateId: \(Swift.String(describing: loRaWANNetworkServerCertificateId)))"}
}

extension GetWirelessGatewayCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iotCertificateId = output.iotCertificateId
            self.loRaWANNetworkServerCertificateId = output.loRaWANNetworkServerCertificateId
        } else {
            self.iotCertificateId = nil
            self.loRaWANNetworkServerCertificateId = nil
        }
    }
}

public struct GetWirelessGatewayCertificateOutputResponse: Swift.Equatable {
    /// The ID of the certificate associated with the wireless gateway.
    public var iotCertificateId: Swift.String?
    /// The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.
    public var loRaWANNetworkServerCertificateId: Swift.String?

    public init (
        iotCertificateId: Swift.String? = nil,
        loRaWANNetworkServerCertificateId: Swift.String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

struct GetWirelessGatewayCertificateOutputResponseBody: Swift.Equatable {
    public let iotCertificateId: Swift.String?
    public let loRaWANNetworkServerCertificateId: Swift.String?
}

extension GetWirelessGatewayCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotCertificateId = "IotCertificateId"
        case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
        let loRaWANNetworkServerCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loRaWANNetworkServerCertificateId)
        loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateIdDecoded
    }
}

extension GetWirelessGatewayFirmwareInformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayFirmwareInformationInput(id: \(Swift.String(describing: id)))"}
}

extension GetWirelessGatewayFirmwareInformationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayFirmwareInformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayFirmwareInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayFirmwareInformationOutputError>
}

public struct GetWirelessGatewayFirmwareInformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayFirmwareInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayFirmwareInformationOutputError>
}

public struct GetWirelessGatewayFirmwareInformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayFirmwareInformationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayFirmwareInformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/firmware-information"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayFirmwareInformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayFirmwareInformationOutputError>
}

public struct GetWirelessGatewayFirmwareInformationInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayFirmwareInformationInputBody: Swift.Equatable {
}

extension GetWirelessGatewayFirmwareInformationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayFirmwareInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayFirmwareInformationOutputResponse(loRaWAN: \(Swift.String(describing: loRaWAN)))"}
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayFirmwareInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutputResponse: Swift.Equatable {
    /// Information about the wireless gateway's firmware.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion?

    public init (
        loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Equatable {
    public let loRaWAN: IotWirelessClientTypes.LoRaWANGatewayCurrentVersion?
}

extension GetWirelessGatewayFirmwareInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayCurrentVersion.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayInput(identifier: \(Swift.String(describing: identifier)), identifierType: \(Swift.String(describing: identifierType)))"}
}

extension GetWirelessGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayOutputError>
}

public struct GetWirelessGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let identifierType = input.operationInput.identifierType {
            let identifierTypeQueryItem = ClientRuntime.URLQueryItem(name: "identifierType".urlPercentEncoding(), value: Swift.String(identifierType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identifierTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayOutputError>
}

public struct GetWirelessGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identifier = input.identifier else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identifier is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(identifier.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayOutputError>
}

public struct GetWirelessGatewayInput: Swift.Equatable {
    /// The identifier of the wireless gateway to get.
    /// This member is required.
    public var identifier: Swift.String?
    /// The type of identifier used in identifier.
    /// This member is required.
    public var identifierType: IotWirelessClientTypes.WirelessGatewayIdType?

    public init (
        identifier: Swift.String? = nil,
        identifierType: IotWirelessClientTypes.WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessGatewayInputBody: Swift.Equatable {
}

extension GetWirelessGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayOutputResponse(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), thingArn: \(Swift.String(describing: thingArn)), thingName: \(Swift.String(describing: thingName)))"}
}

extension GetWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.thingArn = output.thingArn
            self.thingName = output.thingName
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.thingArn = nil
            self.thingName = nil
        }
    }
}

public struct GetWirelessGatewayOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// The description of the resource.
    public var description: Swift.String?
    /// The ID of the wireless gateway.
    public var id: Swift.String?
    /// Information about the wireless gateway.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    /// The name of the resource.
    public var name: Swift.String?
    /// The ARN of the thing associated with the wireless gateway.
    public var thingArn: Swift.String?
    /// The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.
    public var thingName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
        name: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct GetWirelessGatewayOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let id: Swift.String?
    public let description: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
    public let arn: Swift.String?
    public let thingName: Swift.String?
    public let thingArn: Swift.String?
}

extension GetWirelessGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GetWirelessGatewayStatisticsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayStatisticsInput(wirelessGatewayId: \(Swift.String(describing: wirelessGatewayId)))"}
}

extension GetWirelessGatewayStatisticsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayStatisticsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayStatisticsOutputError>
}

public struct GetWirelessGatewayStatisticsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayStatisticsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayStatisticsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayStatisticsOutputError>
}

public struct GetWirelessGatewayStatisticsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayStatisticsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayStatisticsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let wirelessGatewayId = input.wirelessGatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("wirelessGatewayId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(wirelessGatewayId.urlPercentEncoding())/statistics"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayStatisticsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayStatisticsOutputError>
}

public struct GetWirelessGatewayStatisticsInput: Swift.Equatable {
    /// The ID of the wireless gateway for which to get the data.
    /// This member is required.
    public var wirelessGatewayId: Swift.String?

    public init (
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsInputBody: Swift.Equatable {
}

extension GetWirelessGatewayStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayStatisticsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayStatisticsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayStatisticsOutputResponse(connectionStatus: \(Swift.String(describing: connectionStatus)), lastUplinkReceivedAt: \(Swift.String(describing: lastUplinkReceivedAt)), wirelessGatewayId: \(Swift.String(describing: wirelessGatewayId)))"}
}

extension GetWirelessGatewayStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionStatus = output.connectionStatus
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.wirelessGatewayId = output.wirelessGatewayId
        } else {
            self.connectionStatus = nil
            self.lastUplinkReceivedAt = nil
            self.wirelessGatewayId = nil
        }
    }
}

public struct GetWirelessGatewayStatisticsOutputResponse: Swift.Equatable {
    /// The connection status of the wireless gateway.
    public var connectionStatus: IotWirelessClientTypes.ConnectionStatus?
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?

    public init (
        connectionStatus: IotWirelessClientTypes.ConnectionStatus? = nil,
        lastUplinkReceivedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsOutputResponseBody: Swift.Equatable {
    public let wirelessGatewayId: Swift.String?
    public let lastUplinkReceivedAt: Swift.String?
    public let connectionStatus: IotWirelessClientTypes.ConnectionStatus?
}

extension GetWirelessGatewayStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case wirelessGatewayId = "WirelessGatewayId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension GetWirelessGatewayTaskDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayTaskDefinitionInput(id: \(Swift.String(describing: id)))"}
}

extension GetWirelessGatewayTaskDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayTaskDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskDefinitionOutputError>
}

public struct GetWirelessGatewayTaskDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskDefinitionOutputError>
}

public struct GetWirelessGatewayTaskDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayTaskDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateway-task-definitions/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayTaskDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskDefinitionOutputError>
}

public struct GetWirelessGatewayTaskDefinitionInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskDefinitionInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayTaskDefinitionOutputResponse(arn: \(Swift.String(describing: arn)), autoCreateTasks: \(Swift.String(describing: autoCreateTasks)), name: \(Swift.String(describing: name)), update: \(Swift.String(describing: update)))"}
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.autoCreateTasks = output.autoCreateTasks
            self.name = output.name
            self.update = output.update
        } else {
            self.arn = nil
            self.autoCreateTasks = false
            self.name = nil
            self.update = nil
        }
    }
}

public struct GetWirelessGatewayTaskDefinitionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    public var arn: Swift.String?
    /// Whether to automatically create tasks using this task definition for all gateways with the specified current version. If false, the task must me created by calling CreateWirelessGatewayTask.
    public var autoCreateTasks: Swift.Bool
    /// The name of the resource.
    public var name: Swift.String?
    /// Information about the gateways to update.
    public var update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?

    public init (
        arn: Swift.String? = nil,
        autoCreateTasks: Swift.Bool = false,
        name: Swift.String? = nil,
        update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

struct GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Equatable {
    public let autoCreateTasks: Swift.Bool
    public let name: Swift.String?
    public let update: IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate?
    public let arn: Swift.String?
}

extension GetWirelessGatewayTaskDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case autoCreateTasks = "AutoCreateTasks"
        case name = "Name"
        case update = "Update"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetWirelessGatewayTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayTaskInput(id: \(Swift.String(describing: id)))"}
}

extension GetWirelessGatewayTaskInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetWirelessGatewayTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskOutputError>
}

public struct GetWirelessGatewayTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWirelessGatewayTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskOutputError>
}

public struct GetWirelessGatewayTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWirelessGatewayTaskInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWirelessGatewayTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())/tasks"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWirelessGatewayTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWirelessGatewayTaskOutputError>
}

public struct GetWirelessGatewayTaskInput: Swift.Equatable {
    /// The ID of the resource to get.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskInputBody: Swift.Equatable {
}

extension GetWirelessGatewayTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWirelessGatewayTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWirelessGatewayTaskOutputResponse(lastUplinkReceivedAt: \(Swift.String(describing: lastUplinkReceivedAt)), status: \(Swift.String(describing: status)), taskCreatedAt: \(Swift.String(describing: taskCreatedAt)), wirelessGatewayId: \(Swift.String(describing: wirelessGatewayId)), wirelessGatewayTaskDefinitionId: \(Swift.String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension GetWirelessGatewayTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.status = output.status
            self.taskCreatedAt = output.taskCreatedAt
            self.wirelessGatewayId = output.wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.lastUplinkReceivedAt = nil
            self.status = nil
            self.taskCreatedAt = nil
            self.wirelessGatewayId = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct GetWirelessGatewayTaskOutputResponse: Swift.Equatable {
    /// The date and time when the most recent uplink was received.
    public var lastUplinkReceivedAt: Swift.String?
    /// The status of the request.
    public var status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
    /// The date and time when the task was created.
    public var taskCreatedAt: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayId: Swift.String?
    /// The ID of the WirelessGatewayTask.
    public var wirelessGatewayTaskDefinitionId: Swift.String?

    public init (
        lastUplinkReceivedAt: Swift.String? = nil,
        status: IotWirelessClientTypes.WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: Swift.String? = nil,
        wirelessGatewayId: Swift.String? = nil,
        wirelessGatewayTaskDefinitionId: Swift.String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct GetWirelessGatewayTaskOutputResponseBody: Swift.Equatable {
    public let wirelessGatewayId: Swift.String?
    public let wirelessGatewayTaskDefinitionId: Swift.String?
    public let lastUplinkReceivedAt: Swift.String?
    public let taskCreatedAt: Swift.String?
    public let status: IotWirelessClientTypes.WirelessGatewayTaskStatus?
}

extension GetWirelessGatewayTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case status = "Status"
        case taskCreatedAt = "TaskCreatedAt"
        case wirelessGatewayId = "WirelessGatewayId"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let taskCreatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDestinationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDestinationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDestinationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDestinationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDestinationsOutputError>
}

public struct ListDestinationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDestinationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDestinationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDestinationsOutputError>
}

public struct ListDestinationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDestinationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDestinationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/destinations"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDestinationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDestinationsOutputError>
}

public struct ListDestinationsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDestinationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDestinationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDestinationsOutputResponse(destinationList: \(Swift.String(describing: destinationList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationList = output.destinationList
            self.nextToken = output.nextToken
        } else {
            self.destinationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutputResponse: Swift.Equatable {
    /// The list of destinations.
    public var destinationList: [IotWirelessClientTypes.Destinations]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        destinationList: [IotWirelessClientTypes.Destinations]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let destinationList: [IotWirelessClientTypes.Destinations]?
}

extension ListDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationList = "DestinationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Destinations?].self, forKey: .destinationList)
        var destinationListDecoded0:[IotWirelessClientTypes.Destinations]? = nil
        if let destinationListContainer = destinationListContainer {
            destinationListDecoded0 = [IotWirelessClientTypes.Destinations]()
            for structure0 in destinationListContainer {
                if let structure0 = structure0 {
                    destinationListDecoded0?.append(structure0)
                }
            }
        }
        destinationList = destinationListDecoded0
    }
}

extension ListDeviceProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeviceProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeviceProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceProfilesOutputError>
}

public struct ListDeviceProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceProfilesOutputError>
}

public struct ListDeviceProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceProfilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDeviceProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/device-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeviceProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceProfilesOutputError>
}

public struct ListDeviceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesInputBody: Swift.Equatable {
}

extension ListDeviceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceProfilesOutputResponse(deviceProfileList: \(Swift.String(describing: deviceProfileList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeviceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeviceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceProfileList = output.deviceProfileList
            self.nextToken = output.nextToken
        } else {
            self.deviceProfileList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceProfilesOutputResponse: Swift.Equatable {
    /// The list of device profiles.
    public var deviceProfileList: [IotWirelessClientTypes.DeviceProfile]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deviceProfileList: [IotWirelessClientTypes.DeviceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let deviceProfileList: [IotWirelessClientTypes.DeviceProfile]?
}

extension ListDeviceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileList = "DeviceProfileList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deviceProfileListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.DeviceProfile?].self, forKey: .deviceProfileList)
        var deviceProfileListDecoded0:[IotWirelessClientTypes.DeviceProfile]? = nil
        if let deviceProfileListContainer = deviceProfileListContainer {
            deviceProfileListDecoded0 = [IotWirelessClientTypes.DeviceProfile]()
            for structure0 in deviceProfileListContainer {
                if let structure0 = structure0 {
                    deviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        deviceProfileList = deviceProfileListDecoded0
    }
}

extension ListPartnerAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerAccountsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPartnerAccountsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPartnerAccountsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerAccountsOutputError>
}

public struct ListPartnerAccountsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPartnerAccountsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPartnerAccountsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerAccountsOutputError>
}

public struct ListPartnerAccountsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPartnerAccountsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPartnerAccountsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/partner-accounts"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPartnerAccountsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPartnerAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPartnerAccountsOutputError>
}

public struct ListPartnerAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPartnerAccountsInputBody: Swift.Equatable {
}

extension ListPartnerAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPartnerAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerAccountsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPartnerAccountsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sidewalk: \(Swift.String(describing: sidewalk)))"}
}

extension ListPartnerAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPartnerAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sidewalk = output.sidewalk
        } else {
            self.nextToken = nil
            self.sidewalk = nil
        }
    }
}

public struct ListPartnerAccountsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The Sidewalk account credentials.
    public var sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?

    public init (
        nextToken: Swift.String? = nil,
        sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

struct ListPartnerAccountsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let sidewalk: [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]?
}

extension ListPartnerAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sidewalkContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint?].self, forKey: .sidewalk)
        var sidewalkDecoded0:[IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]? = nil
        if let sidewalkContainer = sidewalkContainer {
            sidewalkDecoded0 = [IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint]()
            for structure0 in sidewalkContainer {
                if let structure0 = structure0 {
                    sidewalkDecoded0?.append(structure0)
                }
            }
        }
        sidewalk = sidewalkDecoded0
    }
}

extension ListServiceProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServiceProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListServiceProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceProfilesOutputError>
}

public struct ListServiceProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceProfilesOutputError>
}

public struct ListServiceProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceProfilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListServiceProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/service-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceProfilesOutputError>
}

public struct ListServiceProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceProfilesInputBody: Swift.Equatable {
}

extension ListServiceProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceProfilesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serviceProfileList: \(Swift.String(describing: serviceProfileList)))"}
}

extension ListServiceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceProfileList = output.serviceProfileList
        } else {
            self.nextToken = nil
            self.serviceProfileList = nil
        }
    }
}

public struct ListServiceProfilesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of service profiles.
    public var serviceProfileList: [IotWirelessClientTypes.ServiceProfile]?

    public init (
        nextToken: Swift.String? = nil,
        serviceProfileList: [IotWirelessClientTypes.ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

struct ListServiceProfilesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let serviceProfileList: [IotWirelessClientTypes.ServiceProfile]?
}

extension ListServiceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceProfileList = "ServiceProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceProfileListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.ServiceProfile?].self, forKey: .serviceProfileList)
        var serviceProfileListDecoded0:[IotWirelessClientTypes.ServiceProfile]? = nil
        if let serviceProfileListContainer = serviceProfileListContainer {
            serviceProfileListDecoded0 = [IotWirelessClientTypes.ServiceProfile]()
            for structure0 in serviceProfileListContainer {
                if let structure0 = structure0 {
                    serviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        serviceProfileList = serviceProfileListDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [IotWirelessClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWirelessDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessDevicesInput(destinationName: \(Swift.String(describing: destinationName)), deviceProfileId: \(Swift.String(describing: deviceProfileId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceProfileId: \(Swift.String(describing: serviceProfileId)), wirelessDeviceType: \(Swift.String(describing: wirelessDeviceType)))"}
}

extension ListWirelessDevicesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListWirelessDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessDevicesOutputError>
}

public struct ListWirelessDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceProfileId = input.operationInput.deviceProfileId {
            let deviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: Swift.String(deviceProfileId).urlPercentEncoding())
            input.builder.withQueryItem(deviceProfileIdQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let destinationName = input.operationInput.destinationName {
            let destinationNameQueryItem = ClientRuntime.URLQueryItem(name: "destinationName".urlPercentEncoding(), value: Swift.String(destinationName).urlPercentEncoding())
            input.builder.withQueryItem(destinationNameQueryItem)
        }
        if let wirelessDeviceType = input.operationInput.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: Swift.String(wirelessDeviceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(wirelessDeviceTypeQueryItem)
        }
        if let serviceProfileId = input.operationInput.serviceProfileId {
            let serviceProfileIdQueryItem = ClientRuntime.URLQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: Swift.String(serviceProfileId).urlPercentEncoding())
            input.builder.withQueryItem(serviceProfileIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessDevicesOutputError>
}

public struct ListWirelessDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessDevicesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWirelessDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWirelessDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessDevicesOutputError>
}

public struct ListWirelessDevicesInput: Swift.Equatable {
    /// A filter to list only the wireless devices that use this destination.
    public var destinationName: Swift.String?
    /// A filter to list only the wireless devices that use this device profile.
    public var deviceProfileId: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless devices that use this service profile.
    public var serviceProfileId: Swift.String?
    /// A filter to list only the wireless devices that use this wireless device type.
    public var wirelessDeviceType: IotWirelessClientTypes.WirelessDeviceType?

    public init (
        destinationName: Swift.String? = nil,
        deviceProfileId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        serviceProfileId: Swift.String? = nil,
        wirelessDeviceType: IotWirelessClientTypes.WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListWirelessDevicesInputBody: Swift.Equatable {
}

extension ListWirelessDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessDevicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), wirelessDeviceList: \(Swift.String(describing: wirelessDeviceList)))"}
}

extension ListWirelessDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessDeviceList = output.wirelessDeviceList
        } else {
            self.nextToken = nil
            self.wirelessDeviceList = nil
        }
    }
}

public struct ListWirelessDevicesOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless device.
    public var wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

struct ListWirelessDevicesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let wirelessDeviceList: [IotWirelessClientTypes.WirelessDeviceStatistics]?
}

extension ListWirelessDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceList = "WirelessDeviceList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceStatistics?].self, forKey: .wirelessDeviceList)
        var wirelessDeviceListDecoded0:[IotWirelessClientTypes.WirelessDeviceStatistics]? = nil
        if let wirelessDeviceListContainer = wirelessDeviceListContainer {
            wirelessDeviceListDecoded0 = [IotWirelessClientTypes.WirelessDeviceStatistics]()
            for structure0 in wirelessDeviceListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceList = wirelessDeviceListDecoded0
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessGatewayTaskDefinitionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), taskDefinitionType: \(Swift.String(describing: taskDefinitionType)))"}
}

extension ListWirelessGatewayTaskDefinitionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListWirelessGatewayTaskDefinitionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewayTaskDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewayTaskDefinitionsOutputError>
}

public struct ListWirelessGatewayTaskDefinitionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewayTaskDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let taskDefinitionType = input.operationInput.taskDefinitionType {
            let taskDefinitionTypeQueryItem = ClientRuntime.URLQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: Swift.String(taskDefinitionType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(taskDefinitionTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewayTaskDefinitionsOutputError>
}

public struct ListWirelessGatewayTaskDefinitionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewayTaskDefinitionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWirelessGatewayTaskDefinitionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateway-task-definitions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWirelessGatewayTaskDefinitionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewayTaskDefinitionsOutputError>
}

public struct ListWirelessGatewayTaskDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter to list only the wireless gateway task definitions that use this task definition type.
    public var taskDefinitionType: IotWirelessClientTypes.WirelessGatewayTaskDefinitionType?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        taskDefinitionType: IotWirelessClientTypes.WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

struct ListWirelessGatewayTaskDefinitionsInputBody: Swift.Equatable {
}

extension ListWirelessGatewayTaskDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewayTaskDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessGatewayTaskDefinitionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), taskDefinitions: \(Swift.String(describing: taskDefinitions)))"}
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessGatewayTaskDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskDefinitions = output.taskDefinitions
        } else {
            self.nextToken = nil
            self.taskDefinitions = nil
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of task definitions.
    public var taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?

    public init (
        nextToken: Swift.String? = nil,
        taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

struct ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let taskDefinitions: [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]?
}

extension ListWirelessGatewayTaskDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case taskDefinitions = "TaskDefinitions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let taskDefinitionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry?].self, forKey: .taskDefinitions)
        var taskDefinitionsDecoded0:[IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]? = nil
        if let taskDefinitionsContainer = taskDefinitionsContainer {
            taskDefinitionsDecoded0 = [IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry]()
            for structure0 in taskDefinitionsContainer {
                if let structure0 = structure0 {
                    taskDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        taskDefinitions = taskDefinitionsDecoded0
    }
}

extension ListWirelessGatewaysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessGatewaysInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWirelessGatewaysInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListWirelessGatewaysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewaysOutputError>
}

public struct ListWirelessGatewaysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWirelessGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWirelessGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewaysOutputError>
}

public struct ListWirelessGatewaysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWirelessGatewaysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWirelessGatewaysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWirelessGatewaysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWirelessGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWirelessGatewaysOutputError>
}

public struct ListWirelessGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessGatewaysInputBody: Swift.Equatable {
}

extension ListWirelessGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWirelessGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewaysOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewaysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWirelessGatewaysOutputResponse(nextToken: \(Swift.String(describing: nextToken)), wirelessGatewayList: \(Swift.String(describing: wirelessGatewayList)))"}
}

extension ListWirelessGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWirelessGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.wirelessGatewayList = output.wirelessGatewayList
        } else {
            self.nextToken = nil
            self.wirelessGatewayList = nil
        }
    }
}

public struct ListWirelessGatewaysOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the wireless gateway.
    public var wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]?

    public init (
        nextToken: Swift.String? = nil,
        wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

struct ListWirelessGatewaysOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let wirelessGatewayList: [IotWirelessClientTypes.WirelessGatewayStatistics]?
}

extension ListWirelessGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case wirelessGatewayList = "WirelessGatewayList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessGatewayListContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayStatistics?].self, forKey: .wirelessGatewayList)
        var wirelessGatewayListDecoded0:[IotWirelessClientTypes.WirelessGatewayStatistics]? = nil
        if let wirelessGatewayListContainer = wirelessGatewayListContainer {
            wirelessGatewayListDecoded0 = [IotWirelessClientTypes.WirelessGatewayStatistics]()
            for structure0 in wirelessGatewayListContainer {
                if let structure0 = structure0 {
                    wirelessGatewayListDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayList = wirelessGatewayListDecoded0
    }
}

extension IotWirelessClientTypes.LoRaWANDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case devEui = "DevEui"
        case deviceProfileId = "DeviceProfileId"
        case otaaV1_0_x = "OtaaV1_0_x"
        case otaaV1_1 = "OtaaV1_1"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let otaaV1_0_x = otaaV1_0_x {
            try encodeContainer.encode(otaaV1_0_x, forKey: .otaaV1_0_x)
        }
        if let otaaV1_1 = otaaV1_1 {
            try encodeContainer.encode(otaaV1_1, forKey: .otaaV1_1)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let otaaV1_1Decoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.OtaaV1_1.self, forKey: .otaaV1_1)
        otaaV1_1 = otaaV1_1Decoded
        let otaaV1_0_xDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.OtaaV1_0_x.self, forKey: .otaaV1_0_x)
        otaaV1_0_x = otaaV1_0_xDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.AbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.AbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANDevice(abpV1_0_x: \(Swift.String(describing: abpV1_0_x)), abpV1_1: \(Swift.String(describing: abpV1_1)), devEui: \(Swift.String(describing: devEui)), deviceProfileId: \(Swift.String(describing: deviceProfileId)), otaaV1_0_x: \(Swift.String(describing: otaaV1_0_x)), otaaV1_1: \(Swift.String(describing: otaaV1_1)), serviceProfileId: \(Swift.String(describing: serviceProfileId)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for create functions.
    public struct LoRaWANDevice: Swift.Equatable {
        /// LoRaWAN object for create APIs
        public var abpV1_0_x: IotWirelessClientTypes.AbpV1_0_x?
        /// ABP device object for create APIs for v1.1
        public var abpV1_1: IotWirelessClientTypes.AbpV1_1?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The ID of the device profile for the new wireless device.
        public var deviceProfileId: Swift.String?
        /// OTAA device object for create APIs for v1.0.x
        public var otaaV1_0_x: IotWirelessClientTypes.OtaaV1_0_x?
        /// OTAA device object for v1.1 for create APIs
        public var otaaV1_1: IotWirelessClientTypes.OtaaV1_1?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            abpV1_0_x: IotWirelessClientTypes.AbpV1_0_x? = nil,
            abpV1_1: IotWirelessClientTypes.AbpV1_1? = nil,
            devEui: Swift.String? = nil,
            deviceProfileId: Swift.String? = nil,
            otaaV1_0_x: IotWirelessClientTypes.OtaaV1_0_x? = nil,
            otaaV1_1: IotWirelessClientTypes.OtaaV1_1? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.abpV1_0_x = abpV1_0_x
            self.abpV1_1 = abpV1_1
            self.devEui = devEui
            self.deviceProfileId = deviceProfileId
            self.otaaV1_0_x = otaaV1_0_x
            self.otaaV1_1 = otaaV1_1
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IotWirelessClientTypes.LoRaWANDeviceMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRate = "DataRate"
        case devEui = "DevEui"
        case fPort = "FPort"
        case frequency = "Frequency"
        case gateways = "Gateways"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let gateways = gateways {
            var gatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gateways)
            for lorawangatewaymetadatalist0 in gateways {
                try gatewaysContainer.encode(lorawangatewaymetadatalist0)
            }
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let dataRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let gatewaysContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.LoRaWANGatewayMetadata?].self, forKey: .gateways)
        var gatewaysDecoded0:[IotWirelessClientTypes.LoRaWANGatewayMetadata]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [IotWirelessClientTypes.LoRaWANGatewayMetadata]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
    }
}

extension IotWirelessClientTypes.LoRaWANDeviceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANDeviceMetadata(dataRate: \(Swift.String(describing: dataRate)), devEui: \(Swift.String(describing: devEui)), fPort: \(Swift.String(describing: fPort)), frequency: \(Swift.String(describing: frequency)), gateways: \(Swift.String(describing: gateways)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN device metatdata.
    public struct LoRaWANDeviceMetadata: Swift.Equatable {
        /// The DataRate value.
        public var dataRate: Swift.Int?
        /// The DevEUI value.
        public var devEui: Swift.String?
        /// The FPort value.
        public var fPort: Swift.Int?
        /// The device's channel frequency in Hz.
        public var frequency: Swift.Int?
        /// Information about the gateways accessed by the device.
        public var gateways: [IotWirelessClientTypes.LoRaWANGatewayMetadata]?
        /// The date and time of the metadata.
        public var timestamp: Swift.String?

        public init (
            dataRate: Swift.Int? = nil,
            devEui: Swift.String? = nil,
            fPort: Swift.Int? = nil,
            frequency: Swift.Int? = nil,
            gateways: [IotWirelessClientTypes.LoRaWANGatewayMetadata]? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.dataRate = dataRate
            self.devEui = devEui
            self.fPort = fPort
            self.frequency = frequency
            self.gateways = gateways
            self.timestamp = timestamp
        }
    }

}

extension IotWirelessClientTypes.LoRaWANDeviceProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classBTimeout = "ClassBTimeout"
        case classCTimeout = "ClassCTimeout"
        case factoryPresetFreqsList = "FactoryPresetFreqsList"
        case macVersion = "MacVersion"
        case maxDutyCycle = "MaxDutyCycle"
        case maxEirp = "MaxEirp"
        case pingSlotDr = "PingSlotDr"
        case pingSlotFreq = "PingSlotFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case regParamsRevision = "RegParamsRevision"
        case rfRegion = "RfRegion"
        case rxDataRate2 = "RxDataRate2"
        case rxDelay1 = "RxDelay1"
        case rxDrOffset1 = "RxDrOffset1"
        case rxFreq2 = "RxFreq2"
        case supports32BitFCnt = "Supports32BitFCnt"
        case supportsClassB = "SupportsClassB"
        case supportsClassC = "SupportsClassC"
        case supportsJoin = "SupportsJoin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classBTimeout = classBTimeout {
            try encodeContainer.encode(classBTimeout, forKey: .classBTimeout)
        }
        if let classCTimeout = classCTimeout {
            try encodeContainer.encode(classCTimeout, forKey: .classCTimeout)
        }
        if let factoryPresetFreqsList = factoryPresetFreqsList {
            var factoryPresetFreqsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .factoryPresetFreqsList)
            for factorypresetfreqslist0 in factoryPresetFreqsList {
                try factoryPresetFreqsListContainer.encode(factorypresetfreqslist0)
            }
        }
        if let macVersion = macVersion {
            try encodeContainer.encode(macVersion, forKey: .macVersion)
        }
        if let maxDutyCycle = maxDutyCycle {
            try encodeContainer.encode(maxDutyCycle, forKey: .maxDutyCycle)
        }
        if let maxEirp = maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let pingSlotDr = pingSlotDr {
            try encodeContainer.encode(pingSlotDr, forKey: .pingSlotDr)
        }
        if let pingSlotFreq = pingSlotFreq {
            try encodeContainer.encode(pingSlotFreq, forKey: .pingSlotFreq)
        }
        if let pingSlotPeriod = pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let regParamsRevision = regParamsRevision {
            try encodeContainer.encode(regParamsRevision, forKey: .regParamsRevision)
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let rxDataRate2 = rxDataRate2 {
            try encodeContainer.encode(rxDataRate2, forKey: .rxDataRate2)
        }
        if let rxDelay1 = rxDelay1 {
            try encodeContainer.encode(rxDelay1, forKey: .rxDelay1)
        }
        if let rxDrOffset1 = rxDrOffset1 {
            try encodeContainer.encode(rxDrOffset1, forKey: .rxDrOffset1)
        }
        if let rxFreq2 = rxFreq2 {
            try encodeContainer.encode(rxFreq2, forKey: .rxFreq2)
        }
        if supports32BitFCnt != false {
            try encodeContainer.encode(supports32BitFCnt, forKey: .supports32BitFCnt)
        }
        if supportsClassB != false {
            try encodeContainer.encode(supportsClassB, forKey: .supportsClassB)
        }
        if supportsClassC != false {
            try encodeContainer.encode(supportsClassC, forKey: .supportsClassC)
        }
        if let supportsJoin = supportsJoin {
            try encodeContainer.encode(supportsJoin, forKey: .supportsJoin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportsClassBDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClassB)
        supportsClassB = supportsClassBDecoded
        let classBTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classBTimeout)
        classBTimeout = classBTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
        let pingSlotDrDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotDr)
        pingSlotDr = pingSlotDrDecoded
        let pingSlotFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pingSlotFreq)
        pingSlotFreq = pingSlotFreqDecoded
        let supportsClassCDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClassC)
        supportsClassC = supportsClassCDecoded
        let classCTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .classCTimeout)
        classCTimeout = classCTimeoutDecoded
        let macVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macVersion)
        macVersion = macVersionDecoded
        let regParamsRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regParamsRevision)
        regParamsRevision = regParamsRevisionDecoded
        let rxDelay1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDelay1)
        rxDelay1 = rxDelay1Decoded
        let rxDrOffset1Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDrOffset1)
        rxDrOffset1 = rxDrOffset1Decoded
        let rxDataRate2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxDataRate2)
        rxDataRate2 = rxDataRate2Decoded
        let rxFreq2Decoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rxFreq2)
        rxFreq2 = rxFreq2Decoded
        let factoryPresetFreqsListContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .factoryPresetFreqsList)
        var factoryPresetFreqsListDecoded0:[Swift.Int]? = nil
        if let factoryPresetFreqsListContainer = factoryPresetFreqsListContainer {
            factoryPresetFreqsListDecoded0 = [Swift.Int]()
            for integer0 in factoryPresetFreqsListContainer {
                if let integer0 = integer0 {
                    factoryPresetFreqsListDecoded0?.append(integer0)
                }
            }
        }
        factoryPresetFreqsList = factoryPresetFreqsListDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
        let maxDutyCycleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDutyCycle)
        maxDutyCycle = maxDutyCycleDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let supportsJoinDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsJoin)
        supportsJoin = supportsJoinDecoded
        let supports32BitFCntDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supports32BitFCnt)
        supports32BitFCnt = supports32BitFCntDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANDeviceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANDeviceProfile(classBTimeout: \(Swift.String(describing: classBTimeout)), classCTimeout: \(Swift.String(describing: classCTimeout)), factoryPresetFreqsList: \(Swift.String(describing: factoryPresetFreqsList)), macVersion: \(Swift.String(describing: macVersion)), maxDutyCycle: \(Swift.String(describing: maxDutyCycle)), maxEirp: \(Swift.String(describing: maxEirp)), pingSlotDr: \(Swift.String(describing: pingSlotDr)), pingSlotFreq: \(Swift.String(describing: pingSlotFreq)), pingSlotPeriod: \(Swift.String(describing: pingSlotPeriod)), regParamsRevision: \(Swift.String(describing: regParamsRevision)), rfRegion: \(Swift.String(describing: rfRegion)), rxDataRate2: \(Swift.String(describing: rxDataRate2)), rxDelay1: \(Swift.String(describing: rxDelay1)), rxDrOffset1: \(Swift.String(describing: rxDrOffset1)), rxFreq2: \(Swift.String(describing: rxFreq2)), supports32BitFCnt: \(Swift.String(describing: supports32BitFCnt)), supportsClassB: \(Swift.String(describing: supportsClassB)), supportsClassC: \(Swift.String(describing: supportsClassC)), supportsJoin: \(Swift.String(describing: supportsJoin)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANDeviceProfile object.
    public struct LoRaWANDeviceProfile: Swift.Equatable {
        /// The ClassBTimeout value.
        public var classBTimeout: Swift.Int?
        /// The ClassCTimeout value.
        public var classCTimeout: Swift.Int?
        /// The list of values that make up the FactoryPresetFreqs value.
        public var factoryPresetFreqsList: [Swift.Int]?
        /// The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.
        public var macVersion: Swift.String?
        /// The MaxDutyCycle value.
        public var maxDutyCycle: Swift.Int?
        /// The MaxEIRP value.
        public var maxEirp: Swift.Int?
        /// The PingSlotDR value.
        public var pingSlotDr: Swift.Int?
        /// The PingSlotFreq value.
        public var pingSlotFreq: Swift.Int?
        /// The PingSlotPeriod value.
        public var pingSlotPeriod: Swift.Int?
        /// The version of regional parameters.
        public var regParamsRevision: Swift.String?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// The RXDataRate2 value.
        public var rxDataRate2: Swift.Int?
        /// The RXDelay1 value.
        public var rxDelay1: Swift.Int?
        /// The RXDROffset1 value.
        public var rxDrOffset1: Swift.Int?
        /// The RXFreq2 value.
        public var rxFreq2: Swift.Int?
        /// The Supports32BitFCnt value.
        public var supports32BitFCnt: Swift.Bool
        /// The SupportsClassB value.
        public var supportsClassB: Swift.Bool
        /// The SupportsClassC value.
        public var supportsClassC: Swift.Bool
        /// The SupportsJoin value.
        public var supportsJoin: Swift.Bool?

        public init (
            classBTimeout: Swift.Int? = nil,
            classCTimeout: Swift.Int? = nil,
            factoryPresetFreqsList: [Swift.Int]? = nil,
            macVersion: Swift.String? = nil,
            maxDutyCycle: Swift.Int? = nil,
            maxEirp: Swift.Int? = nil,
            pingSlotDr: Swift.Int? = nil,
            pingSlotFreq: Swift.Int? = nil,
            pingSlotPeriod: Swift.Int? = nil,
            regParamsRevision: Swift.String? = nil,
            rfRegion: Swift.String? = nil,
            rxDataRate2: Swift.Int? = nil,
            rxDelay1: Swift.Int? = nil,
            rxDrOffset1: Swift.Int? = nil,
            rxFreq2: Swift.Int? = nil,
            supports32BitFCnt: Swift.Bool = false,
            supportsClassB: Swift.Bool = false,
            supportsClassC: Swift.Bool = false,
            supportsJoin: Swift.Bool? = nil
        )
        {
            self.classBTimeout = classBTimeout
            self.classCTimeout = classCTimeout
            self.factoryPresetFreqsList = factoryPresetFreqsList
            self.macVersion = macVersion
            self.maxDutyCycle = maxDutyCycle
            self.maxEirp = maxEirp
            self.pingSlotDr = pingSlotDr
            self.pingSlotFreq = pingSlotFreq
            self.pingSlotPeriod = pingSlotPeriod
            self.regParamsRevision = regParamsRevision
            self.rfRegion = rfRegion
            self.rxDataRate2 = rxDataRate2
            self.rxDelay1 = rxDelay1
            self.rxDrOffset1 = rxDrOffset1
            self.rxFreq2 = rxFreq2
            self.supports32BitFCnt = supports32BitFCnt
            self.supportsClassB = supportsClassB
            self.supportsClassC = supportsClassC
            self.supportsJoin = supportsJoin
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGateway: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case joinEuiFilters = "JoinEuiFilters"
        case netIdFilters = "NetIdFilters"
        case rfRegion = "RfRegion"
        case subBands = "SubBands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let subBands = subBands {
            var subBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subBands)
            for subbands0 in subBands {
                try subBandsContainer.encode(subbands0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let subBandsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .subBands)
        var subBandsDecoded0:[Swift.Int]? = nil
        if let subBandsContainer = subBandsContainer {
            subBandsDecoded0 = [Swift.Int]()
            for integer0 in subBandsContainer {
                if let integer0 = integer0 {
                    subBandsDecoded0?.append(integer0)
                }
            }
        }
        subBands = subBandsDecoded0
    }
}

extension IotWirelessClientTypes.LoRaWANGateway: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANGateway(gatewayEui: \(Swift.String(describing: gatewayEui)), joinEuiFilters: \(Swift.String(describing: joinEuiFilters)), netIdFilters: \(Swift.String(describing: netIdFilters)), rfRegion: \(Swift.String(describing: rfRegion)), subBands: \(Swift.String(describing: subBands)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANGateway object.
    public struct LoRaWANGateway: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
        public var joinEuiFilters: [[Swift.String]]?
        /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
        public var netIdFilters: [Swift.String]?
        /// The frequency band (RFRegion) value.
        public var rfRegion: Swift.String?
        /// A list of integer indicating which sub bands are supported by LoRa gateway.
        public var subBands: [Swift.Int]?

        public init (
            gatewayEui: Swift.String? = nil,
            joinEuiFilters: [[Swift.String]]? = nil,
            netIdFilters: [Swift.String]? = nil,
            rfRegion: Swift.String? = nil,
            subBands: [Swift.Int]? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.joinEuiFilters = joinEuiFilters
            self.netIdFilters = netIdFilters
            self.rfRegion = rfRegion
            self.subBands = subBands
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayCurrentVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANGatewayCurrentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANGatewayCurrentVersion(currentVersion: \(Swift.String(describing: currentVersion)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANGatewayCurrentVersion object.
    public struct LoRaWANGatewayCurrentVersion: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayEui = "GatewayEui"
        case rssi = "Rssi"
        case snr = "Snr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
        if let snr = snr {
            try encodeContainer.encode(snr, forKey: .snr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let snrDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .snr)
        snr = snrDecoded
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rssi)
        rssi = rssiDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANGatewayMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANGatewayMetadata(gatewayEui: \(Swift.String(describing: gatewayEui)), rssi: \(Swift.String(describing: rssi)), snr: \(Swift.String(describing: snr)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN gateway metatdata.
    public struct LoRaWANGatewayMetadata: Swift.Equatable {
        /// The gateway's EUI value.
        public var gatewayEui: Swift.String?
        /// The RSSI value.
        public var rssi: Swift.Double?
        /// The SNR value.
        public var snr: Swift.Double?

        public init (
            gatewayEui: Swift.String? = nil,
            rssi: Swift.Double? = nil,
            snr: Swift.Double? = nil
        )
        {
            self.gatewayEui = gatewayEui
            self.rssi = rssi
            self.snr = snr
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGatewayVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case model = "Model"
        case packageVersion = "PackageVersion"
        case station = "Station"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let packageVersion = packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let station = station {
            try encodeContainer.encode(station, forKey: .station)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let stationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .station)
        station = stationDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANGatewayVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANGatewayVersion(model: \(Swift.String(describing: model)), packageVersion: \(Swift.String(describing: packageVersion)), station: \(Swift.String(describing: station)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANGatewayVersion object.
    public struct LoRaWANGatewayVersion: Swift.Equatable {
        /// The model number of the wireless gateway.
        public var model: Swift.String?
        /// The version of the wireless gateway firmware.
        public var packageVersion: Swift.String?
        /// The basic station version of the wireless gateway.
        public var station: Swift.String?

        public init (
            model: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            station: Swift.String? = nil
        )
        {
            self.model = model
            self.packageVersion = packageVersion
            self.station = station
        }
    }

}

extension IotWirelessClientTypes.LoRaWANGetServiceProfileInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case channelMask = "ChannelMask"
        case devStatusReqFreq = "DevStatusReqFreq"
        case dlBucketSize = "DlBucketSize"
        case dlRate = "DlRate"
        case dlRatePolicy = "DlRatePolicy"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case hrAllowed = "HrAllowed"
        case minGwDiversity = "MinGwDiversity"
        case nwkGeoLoc = "NwkGeoLoc"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
        case reportDevStatusBattery = "ReportDevStatusBattery"
        case reportDevStatusMargin = "ReportDevStatusMargin"
        case targetPer = "TargetPer"
        case ulBucketSize = "UlBucketSize"
        case ulRate = "UlRate"
        case ulRatePolicy = "UlRatePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let channelMask = channelMask {
            try encodeContainer.encode(channelMask, forKey: .channelMask)
        }
        if let devStatusReqFreq = devStatusReqFreq {
            try encodeContainer.encode(devStatusReqFreq, forKey: .devStatusReqFreq)
        }
        if let dlBucketSize = dlBucketSize {
            try encodeContainer.encode(dlBucketSize, forKey: .dlBucketSize)
        }
        if let dlRate = dlRate {
            try encodeContainer.encode(dlRate, forKey: .dlRate)
        }
        if let dlRatePolicy = dlRatePolicy {
            try encodeContainer.encode(dlRatePolicy, forKey: .dlRatePolicy)
        }
        if drMax != 0 {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if drMin != 0 {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if hrAllowed != false {
            try encodeContainer.encode(hrAllowed, forKey: .hrAllowed)
        }
        if let minGwDiversity = minGwDiversity {
            try encodeContainer.encode(minGwDiversity, forKey: .minGwDiversity)
        }
        if nwkGeoLoc != false {
            try encodeContainer.encode(nwkGeoLoc, forKey: .nwkGeoLoc)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
        if reportDevStatusBattery != false {
            try encodeContainer.encode(reportDevStatusBattery, forKey: .reportDevStatusBattery)
        }
        if reportDevStatusMargin != false {
            try encodeContainer.encode(reportDevStatusMargin, forKey: .reportDevStatusMargin)
        }
        if targetPer != 0 {
            try encodeContainer.encode(targetPer, forKey: .targetPer)
        }
        if let ulBucketSize = ulBucketSize {
            try encodeContainer.encode(ulBucketSize, forKey: .ulBucketSize)
        }
        if let ulRate = ulRate {
            try encodeContainer.encode(ulRate, forKey: .ulRate)
        }
        if let ulRatePolicy = ulRatePolicy {
            try encodeContainer.encode(ulRatePolicy, forKey: .ulRatePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ulRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulRate)
        ulRate = ulRateDecoded
        let ulBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ulBucketSize)
        ulBucketSize = ulBucketSizeDecoded
        let ulRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ulRatePolicy)
        ulRatePolicy = ulRatePolicyDecoded
        let dlRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlRate)
        dlRate = dlRateDecoded
        let dlBucketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dlBucketSize)
        dlBucketSize = dlBucketSizeDecoded
        let dlRatePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dlRatePolicy)
        dlRatePolicy = dlRatePolicyDecoded
        let addGwMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
        let devStatusReqFreqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .devStatusReqFreq)
        devStatusReqFreq = devStatusReqFreqDecoded
        let reportDevStatusBatteryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reportDevStatusBattery)
        reportDevStatusBattery = reportDevStatusBatteryDecoded
        let reportDevStatusMarginDecoded = try containerValues.decode(Swift.Bool.self, forKey: .reportDevStatusMargin)
        reportDevStatusMargin = reportDevStatusMarginDecoded
        let drMinDecoded = try containerValues.decode(Swift.Int.self, forKey: .drMin)
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decode(Swift.Int.self, forKey: .drMax)
        drMax = drMaxDecoded
        let channelMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelMask)
        channelMask = channelMaskDecoded
        let prAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .prAllowed)
        prAllowed = prAllowedDecoded
        let hrAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hrAllowed)
        hrAllowed = hrAllowedDecoded
        let raAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .raAllowed)
        raAllowed = raAllowedDecoded
        let nwkGeoLocDecoded = try containerValues.decode(Swift.Bool.self, forKey: .nwkGeoLoc)
        nwkGeoLoc = nwkGeoLocDecoded
        let targetPerDecoded = try containerValues.decode(Swift.Int.self, forKey: .targetPer)
        targetPer = targetPerDecoded
        let minGwDiversityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minGwDiversity)
        minGwDiversity = minGwDiversityDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANGetServiceProfileInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANGetServiceProfileInfo(addGwMetadata: \(Swift.String(describing: addGwMetadata)), channelMask: \(Swift.String(describing: channelMask)), devStatusReqFreq: \(Swift.String(describing: devStatusReqFreq)), dlBucketSize: \(Swift.String(describing: dlBucketSize)), dlRate: \(Swift.String(describing: dlRate)), dlRatePolicy: \(Swift.String(describing: dlRatePolicy)), drMax: \(Swift.String(describing: drMax)), drMin: \(Swift.String(describing: drMin)), hrAllowed: \(Swift.String(describing: hrAllowed)), minGwDiversity: \(Swift.String(describing: minGwDiversity)), nwkGeoLoc: \(Swift.String(describing: nwkGeoLoc)), prAllowed: \(Swift.String(describing: prAllowed)), raAllowed: \(Swift.String(describing: raAllowed)), reportDevStatusBattery: \(Swift.String(describing: reportDevStatusBattery)), reportDevStatusMargin: \(Swift.String(describing: reportDevStatusMargin)), targetPer: \(Swift.String(describing: targetPer)), ulBucketSize: \(Swift.String(describing: ulBucketSize)), ulRate: \(Swift.String(describing: ulRate)), ulRatePolicy: \(Swift.String(describing: ulRatePolicy)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANGetServiceProfileInfo object.
    public struct LoRaWANGetServiceProfileInfo: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool
        /// The ChannelMask value.
        public var channelMask: Swift.String?
        /// The DevStatusReqFreq value.
        public var devStatusReqFreq: Swift.Int?
        /// The DLBucketSize value.
        public var dlBucketSize: Swift.Int?
        /// The DLRate value.
        public var dlRate: Swift.Int?
        /// The DLRatePolicy value.
        public var dlRatePolicy: Swift.String?
        /// The DRMax value.
        public var drMax: Swift.Int
        /// The DRMin value.
        public var drMin: Swift.Int
        /// The HRAllowed value that describes whether handover roaming is allowed.
        public var hrAllowed: Swift.Bool
        /// The MinGwDiversity value.
        public var minGwDiversity: Swift.Int?
        /// The NwkGeoLoc value.
        public var nwkGeoLoc: Swift.Bool
        /// The PRAllowed value that describes whether passive roaming is allowed.
        public var prAllowed: Swift.Bool
        /// The RAAllowed value that describes whether roaming activation is allowed.
        public var raAllowed: Swift.Bool
        /// The ReportDevStatusBattery value.
        public var reportDevStatusBattery: Swift.Bool
        /// The ReportDevStatusMargin value.
        public var reportDevStatusMargin: Swift.Bool
        /// The TargetPER value.
        public var targetPer: Swift.Int
        /// The ULBucketSize value.
        public var ulBucketSize: Swift.Int?
        /// The ULRate value.
        public var ulRate: Swift.Int?
        /// The ULRatePolicy value.
        public var ulRatePolicy: Swift.String?

        public init (
            addGwMetadata: Swift.Bool = false,
            channelMask: Swift.String? = nil,
            devStatusReqFreq: Swift.Int? = nil,
            dlBucketSize: Swift.Int? = nil,
            dlRate: Swift.Int? = nil,
            dlRatePolicy: Swift.String? = nil,
            drMax: Swift.Int = 0,
            drMin: Swift.Int = 0,
            hrAllowed: Swift.Bool = false,
            minGwDiversity: Swift.Int? = nil,
            nwkGeoLoc: Swift.Bool = false,
            prAllowed: Swift.Bool = false,
            raAllowed: Swift.Bool = false,
            reportDevStatusBattery: Swift.Bool = false,
            reportDevStatusMargin: Swift.Bool = false,
            targetPer: Swift.Int = 0,
            ulBucketSize: Swift.Int? = nil,
            ulRate: Swift.Int? = nil,
            ulRatePolicy: Swift.String? = nil
        )
        {
            self.addGwMetadata = addGwMetadata
            self.channelMask = channelMask
            self.devStatusReqFreq = devStatusReqFreq
            self.dlBucketSize = dlBucketSize
            self.dlRate = dlRate
            self.dlRatePolicy = dlRatePolicy
            self.drMax = drMax
            self.drMin = drMin
            self.hrAllowed = hrAllowed
            self.minGwDiversity = minGwDiversity
            self.nwkGeoLoc = nwkGeoLoc
            self.prAllowed = prAllowed
            self.raAllowed = raAllowed
            self.reportDevStatusBattery = reportDevStatusBattery
            self.reportDevStatusMargin = reportDevStatusMargin
            self.targetPer = targetPer
            self.ulBucketSize = ulBucketSize
            self.ulRate = ulRate
            self.ulRatePolicy = ulRatePolicy
        }
    }

}

extension IotWirelessClientTypes.LoRaWANListDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEui = "DevEui"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEui)
        devEui = devEuiDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANListDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANListDevice(devEui: \(Swift.String(describing: devEui)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for list functions.
    public struct LoRaWANListDevice: Swift.Equatable {
        /// The DevEUI value.
        public var devEui: Swift.String?

        public init (
            devEui: Swift.String? = nil
        )
        {
            self.devEui = devEui
        }
    }

}

extension IotWirelessClientTypes.LoRaWANSendDataToDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANSendDataToDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANSendDataToDevice(fPort: \(Swift.String(describing: fPort)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN router info.
    public struct LoRaWANSendDataToDevice: Swift.Equatable {
        /// The Fport value.
        public var fPort: Swift.Int?

        public init (
            fPort: Swift.Int? = nil
        )
        {
            self.fPort = fPort
        }
    }

}

extension IotWirelessClientTypes.LoRaWANServiceProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGwMetadata = "AddGwMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addGwMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANServiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANServiceProfile(addGwMetadata: \(Swift.String(describing: addGwMetadata)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANServiceProfile object.
    public struct LoRaWANServiceProfile: Swift.Equatable {
        /// The AddGWMetaData value.
        public var addGwMetadata: Swift.Bool

        public init (
            addGwMetadata: Swift.Bool = false
        )
        {
            self.addGwMetadata = addGwMetadata
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceProfileId = "DeviceProfileId"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANUpdateDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANUpdateDevice(deviceProfileId: \(Swift.String(describing: deviceProfileId)), serviceProfileId: \(Swift.String(describing: serviceProfileId)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWAN object for update functions.
    public struct LoRaWANUpdateDevice: Swift.Equatable {
        /// The ID of the device profile for the wireless device.
        public var deviceProfileId: Swift.String?
        /// The ID of the service profile.
        public var serviceProfileId: Swift.String?

        public init (
            deviceProfileId: Swift.String? = nil,
            serviceProfileId: Swift.String? = nil
        )
        {
            self.deviceProfileId = deviceProfileId
            self.serviceProfileId = serviceProfileId
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case sigKeyCrc = "SigKeyCrc"
        case updateSignature = "UpdateSignature"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let sigKeyCrc = sigKeyCrc {
            try encodeContainer.encode(sigKeyCrc, forKey: .sigKeyCrc)
        }
        if let updateSignature = updateSignature {
            try encodeContainer.encode(updateSignature, forKey: .updateSignature)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateSignature)
        updateSignature = updateSignatureDecoded
        let sigKeyCrcDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sigKeyCrc)
        sigKeyCrc = sigKeyCrcDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANUpdateGatewayTaskCreate(currentVersion: \(Swift.String(describing: currentVersion)), sigKeyCrc: \(Swift.String(describing: sigKeyCrc)), updateSignature: \(Swift.String(describing: updateSignature)), updateVersion: \(Swift.String(describing: updateVersion)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskCreate object.
    public struct LoRaWANUpdateGatewayTaskCreate: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?
        /// The CRC of the signature private key to check.
        public var sigKeyCrc: Swift.Int?
        /// The signature used to verify the update firmware.
        public var updateSignature: Swift.String?
        /// The firmware version to update the gateway to.
        public var updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            sigKeyCrc: Swift.Int? = nil,
            updateSignature: Swift.String? = nil,
            updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.sigKeyCrc = sigKeyCrc
            self.updateSignature = updateSignature
            self.updateVersion = updateVersion
        }
    }

}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoRaWANUpdateGatewayTaskEntry(currentVersion: \(Swift.String(describing: currentVersion)), updateVersion: \(Swift.String(describing: updateVersion)))"}
}

extension IotWirelessClientTypes {
    /// LoRaWANUpdateGatewayTaskEntry object.
    public struct LoRaWANUpdateGatewayTaskEntry: Swift.Equatable {
        /// The version of the gateways that should receive the update.
        public var currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?
        /// The firmware version to update the gateway to.
        public var updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion?

        public init (
            currentVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil,
            updateVersion: IotWirelessClientTypes.LoRaWANGatewayVersion? = nil
        )
        {
            self.currentVersion = currentVersion
            self.updateVersion = updateVersion
        }
    }

}

extension IotWirelessClientTypes {
    /// The log level for a log message.
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .disabled,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customCommandIdGet
        case customCommandIdNotify
        case customCommandIdResp
        case customCommandIdSet
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .customCommandIdGet,
                .customCommandIdNotify,
                .customCommandIdResp,
                .customCommandIdSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
            case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
            case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
            case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.OtaaV1_0_x: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appEui = "AppEui"
        case appKey = "AppKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appEui = appEui {
            try encodeContainer.encode(appEui, forKey: .appEui)
        }
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let appEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appEui)
        appEui = appEuiDecoded
    }
}

extension IotWirelessClientTypes.OtaaV1_0_x: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OtaaV1_0_x(appEui: \(Swift.String(describing: appEui)), appKey: \(Swift.String(describing: appKey)))"}
}

extension IotWirelessClientTypes {
    /// OTAA device object for v1.0.x
    public struct OtaaV1_0_x: Swift.Equatable {
        /// The AppEUI value.
        public var appEui: Swift.String?
        /// The AppKey value.
        public var appKey: Swift.String?

        public init (
            appEui: Swift.String? = nil,
            appKey: Swift.String? = nil
        )
        {
            self.appEui = appEui
            self.appKey = appKey
        }
    }

}

extension IotWirelessClientTypes.OtaaV1_1: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appKey = "AppKey"
        case joinEui = "JoinEui"
        case nwkKey = "NwkKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let joinEui = joinEui {
            try encodeContainer.encode(joinEui, forKey: .joinEui)
        }
        if let nwkKey = nwkKey {
            try encodeContainer.encode(nwkKey, forKey: .nwkKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let nwkKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkKey)
        nwkKey = nwkKeyDecoded
        let joinEuiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinEui)
        joinEui = joinEuiDecoded
    }
}

extension IotWirelessClientTypes.OtaaV1_1: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OtaaV1_1(appKey: \(Swift.String(describing: appKey)), joinEui: \(Swift.String(describing: joinEui)), nwkKey: \(Swift.String(describing: nwkKey)))"}
}

extension IotWirelessClientTypes {
    /// OTAA device object for v1.1
    public struct OtaaV1_1: Swift.Equatable {
        /// The AppKey value.
        public var appKey: Swift.String?
        /// The JoinEUI value.
        public var joinEui: Swift.String?
        /// The NwkKey value.
        public var nwkKey: Swift.String?

        public init (
            appKey: Swift.String? = nil,
            joinEui: Swift.String? = nil,
            nwkKey: Swift.String? = nil
        )
        {
            self.appKey = appKey
            self.joinEui = joinEui
            self.nwkKey = nwkKey
        }
    }

}

extension IotWirelessClientTypes {
    public enum PartnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [PartnerType] {
            return [
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartnerType(rawValue: rawValue) ?? PartnerType.sdkUnknown(rawValue)
        }
    }
}

public struct PutResourceLogLevelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceLogLevelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceLogLevelOutputError>
}

extension PutResourceLogLevelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourceLogLevelInput(logLevel: \(Swift.String(describing: logLevel)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension PutResourceLogLevelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }
}

public struct PutResourceLogLevelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceLogLevelOutputError>
}

public struct PutResourceLogLevelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceLogLevelOutputError>
}

public struct PutResourceLogLevelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceLogLevelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutResourceLogLevelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceIdentifier = input.resourceIdentifier else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceIdentifier is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutResourceLogLevelInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceLogLevelOutputError>
}

public struct PutResourceLogLevelInput: Swift.Equatable {
    /// The log level for a log message.
    /// This member is required.
    public var logLevel: IotWirelessClientTypes.LogLevel?
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway,
    ///             it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        logLevel: IotWirelessClientTypes.LogLevel? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct PutResourceLogLevelInputBody: Swift.Equatable {
    public let logLevel: IotWirelessClientTypes.LogLevel?
}

extension PutResourceLogLevelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension PutResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceLogLevelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourceLogLevelOutputResponse()"}
}

extension PutResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceLogLevelOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutResourceLogLevelOutputResponseBody: Swift.Equatable {
}

extension PutResourceLogLevelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetAllResourceLogLevelsInput()"}
}

extension ResetAllResourceLogLevelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ResetAllResourceLogLevelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetAllResourceLogLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetAllResourceLogLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetAllResourceLogLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetAllResourceLogLevelsOutputError>
}

public struct ResetAllResourceLogLevelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetAllResourceLogLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetAllResourceLogLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetAllResourceLogLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetAllResourceLogLevelsOutputError>
}

public struct ResetAllResourceLogLevelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetAllResourceLogLevelsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResetAllResourceLogLevelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetAllResourceLogLevelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetAllResourceLogLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetAllResourceLogLevelsOutputError>
}

public struct ResetAllResourceLogLevelsInput: Swift.Equatable {

    public init() {}
}

struct ResetAllResourceLogLevelsInputBody: Swift.Equatable {
}

extension ResetAllResourceLogLevelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAllResourceLogLevelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetAllResourceLogLevelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAllResourceLogLevelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetAllResourceLogLevelsOutputResponse()"}
}

extension ResetAllResourceLogLevelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetAllResourceLogLevelsOutputResponse: Swift.Equatable {

    public init() {}
}

struct ResetAllResourceLogLevelsOutputResponseBody: Swift.Equatable {
}

extension ResetAllResourceLogLevelsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetResourceLogLevelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetResourceLogLevelInput(resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResetResourceLogLevelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ResetResourceLogLevelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetResourceLogLevelOutputError>
}

public struct ResetResourceLogLevelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetResourceLogLevelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetResourceLogLevelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetResourceLogLevelOutputError>
}

public struct ResetResourceLogLevelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetResourceLogLevelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResetResourceLogLevelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceIdentifier = input.resourceIdentifier else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceIdentifier is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels/\(resourceIdentifier.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetResourceLogLevelInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetResourceLogLevelOutputError>
}

public struct ResetResourceLogLevelInput: Swift.Equatable {
    /// The identifier of the resource. For a Wireless Device, it is the wireless device ID. For a wireless gateway,
    ///             it is the wireless gateway ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of the resource, which can be WirelessDevice or WirelessGateway.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResetResourceLogLevelInputBody: Swift.Equatable {
}

extension ResetResourceLogLevelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResetResourceLogLevelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetResourceLogLevelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetResourceLogLevelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetResourceLogLevelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetResourceLogLevelOutputResponse()"}
}

extension ResetResourceLogLevelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetResourceLogLevelOutputResponse: Swift.Equatable {

    public init() {}
}

struct ResetResourceLogLevelOutputResponseBody: Swift.Equatable {
}

extension ResetResourceLogLevelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Id of the not found resource.
    public var resourceId: Swift.String?
    /// Type of the font found resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct SendDataToWirelessDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendDataToWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendDataToWirelessDeviceOutputError>
}

extension SendDataToWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendDataToWirelessDeviceInput(id: \(Swift.String(describing: id)), payloadData: \(Swift.String(describing: payloadData)), transmitMode: \(Swift.String(describing: transmitMode)), wirelessMetadata: \(Swift.String(describing: wirelessMetadata)))"}
}

extension SendDataToWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let transmitMode = transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
        if let wirelessMetadata = wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

public struct SendDataToWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendDataToWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendDataToWirelessDeviceOutputError>
}

public struct SendDataToWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendDataToWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendDataToWirelessDeviceOutputError>
}

public struct SendDataToWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendDataToWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SendDataToWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())/data"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendDataToWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendDataToWirelessDeviceOutputError>
}

public struct SendDataToWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to receive the data.
    /// This member is required.
    public var id: Swift.String?
    /// The binary to be sent to the end device, encoded in base64.
    /// This member is required.
    public var payloadData: Swift.String?
    /// The transmit mode to use to send data to the wireless device. Can be: 0 for UM (unacknowledge mode) or 1 for AM (acknowledge mode).
    /// This member is required.
    public var transmitMode: Swift.Int?
    /// Metadata about the message request.
    public var wirelessMetadata: IotWirelessClientTypes.WirelessMetadata?

    public init (
        id: Swift.String? = nil,
        payloadData: Swift.String? = nil,
        transmitMode: Swift.Int? = nil,
        wirelessMetadata: IotWirelessClientTypes.WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToWirelessDeviceInputBody: Swift.Equatable {
    public let transmitMode: Swift.Int?
    public let payloadData: Swift.String?
    public let wirelessMetadata: IotWirelessClientTypes.WirelessMetadata?
}

extension SendDataToWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let payloadDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendDataToWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendDataToWirelessDeviceOutputResponse(messageId: \(Swift.String(describing: messageId)))"}
}

extension SendDataToWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendDataToWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToWirelessDeviceOutputResponse: Swift.Equatable {
    /// The ID of the message sent to the wireless device.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToWirelessDeviceOutputResponseBody: Swift.Equatable {
    public let messageId: Swift.String?
}

extension SendDataToWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension IotWirelessClientTypes.ServiceProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IotWirelessClientTypes.ServiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceProfile(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension IotWirelessClientTypes {
    /// Information about a service profile.
    public struct ServiceProfile: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the service profile.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.name = name
        }
    }

}

extension IotWirelessClientTypes.SessionKeysAbpV1_0_x: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case nwkSKey = "NwkSKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let nwkSKey = nwkSKey {
            try encodeContainer.encode(nwkSKey, forKey: .nwkSKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nwkSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSKey)
        nwkSKey = nwkSKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IotWirelessClientTypes.SessionKeysAbpV1_0_x: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeysAbpV1_0_x(appSKey: \(Swift.String(describing: appSKey)), nwkSKey: \(Swift.String(describing: nwkSKey)))"}
}

extension IotWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_0_x: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The NwkSKey value.
        public var nwkSKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            nwkSKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.nwkSKey = nwkSKey
        }
    }

}

extension IotWirelessClientTypes.SessionKeysAbpV1_1: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSKey = "AppSKey"
        case fNwkSIntKey = "FNwkSIntKey"
        case nwkSEncKey = "NwkSEncKey"
        case sNwkSIntKey = "SNwkSIntKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let fNwkSIntKey = fNwkSIntKey {
            try encodeContainer.encode(fNwkSIntKey, forKey: .fNwkSIntKey)
        }
        if let nwkSEncKey = nwkSEncKey {
            try encodeContainer.encode(nwkSEncKey, forKey: .nwkSEncKey)
        }
        if let sNwkSIntKey = sNwkSIntKey {
            try encodeContainer.encode(sNwkSIntKey, forKey: .sNwkSIntKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fNwkSIntKey)
        fNwkSIntKey = fNwkSIntKeyDecoded
        let sNwkSIntKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNwkSIntKey)
        sNwkSIntKey = sNwkSIntKeyDecoded
        let nwkSEncKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nwkSEncKey)
        nwkSEncKey = nwkSEncKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension IotWirelessClientTypes.SessionKeysAbpV1_1: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionKeysAbpV1_1(appSKey: \(Swift.String(describing: appSKey)), fNwkSIntKey: \(Swift.String(describing: fNwkSIntKey)), nwkSEncKey: \(Swift.String(describing: nwkSEncKey)), sNwkSIntKey: \(Swift.String(describing: sNwkSIntKey)))"}
}

extension IotWirelessClientTypes {
    /// Session keys for ABP v1.1
    public struct SessionKeysAbpV1_1: Swift.Equatable {
        /// The AppSKey value.
        public var appSKey: Swift.String?
        /// The FNwkSIntKey value.
        public var fNwkSIntKey: Swift.String?
        /// The NwkSEncKey value.
        public var nwkSEncKey: Swift.String?
        /// The SNwkSIntKey value.
        public var sNwkSIntKey: Swift.String?

        public init (
            appSKey: Swift.String? = nil,
            fNwkSIntKey: Swift.String? = nil,
            nwkSEncKey: Swift.String? = nil,
            sNwkSIntKey: Swift.String? = nil
        )
        {
            self.appSKey = appSKey
            self.fNwkSIntKey = fNwkSIntKey
            self.nwkSEncKey = nwkSEncKey
            self.sNwkSIntKey = sNwkSIntKey
        }
    }

}

extension IotWirelessClientTypes.SidewalkAccountInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IotWirelessClientTypes.SidewalkAccountInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfo(amazonId: \(Swift.String(describing: amazonId)), appServerPrivateKey: \(Swift.String(describing: appServerPrivateKey)))"}
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfo: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case arn = "Arn"
        case fingerprint = "Fingerprint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IotWirelessClientTypes.SidewalkAccountInfoWithFingerprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkAccountInfoWithFingerprint(amazonId: \(Swift.String(describing: amazonId)), arn: \(Swift.String(describing: arn)), fingerprint: \(Swift.String(describing: fingerprint)))"}
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk account.
    public struct SidewalkAccountInfoWithFingerprint: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The fingerprint of the Sidewalk application server private key.
        public var fingerprint: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.arn = arn
            self.fingerprint = fingerprint
        }
    }

}

extension IotWirelessClientTypes.SidewalkDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IotWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IotWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IotWirelessClientTypes.SidewalkDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkDevice(amazonId: \(Swift.String(describing: amazonId)), deviceCertificates: \(Swift.String(describing: deviceCertificates)), sidewalkId: \(Swift.String(describing: sidewalkId)), sidewalkManufacturingSn: \(Swift.String(describing: sidewalkManufacturingSn)))"}
}

extension IotWirelessClientTypes {
    /// Sidewalk device object.
    public struct SidewalkDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IotWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IotWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IotWirelessClientTypes.SidewalkDeviceMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batteryLevel = "BatteryLevel"
        case deviceState = "DeviceState"
        case event = "Event"
        case rssi = "Rssi"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batteryLevel = batteryLevel {
            try encodeContainer.encode(batteryLevel.rawValue, forKey: .batteryLevel)
        }
        if let deviceState = deviceState {
            try encodeContainer.encode(deviceState.rawValue, forKey: .deviceState)
        }
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rssiDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rssi)
        rssi = rssiDecoded
        let batteryLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.BatteryLevel.self, forKey: .batteryLevel)
        batteryLevel = batteryLevelDecoded
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.DeviceState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
    }
}

extension IotWirelessClientTypes.SidewalkDeviceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkDeviceMetadata(batteryLevel: \(Swift.String(describing: batteryLevel)), deviceState: \(Swift.String(describing: deviceState)), event: \(Swift.String(describing: event)), rssi: \(Swift.String(describing: rssi)))"}
}

extension IotWirelessClientTypes {
    /// MetaData for Sidewalk device.
    public struct SidewalkDeviceMetadata: Swift.Equatable {
        /// Sidewalk device battery level.
        public var batteryLevel: IotWirelessClientTypes.BatteryLevel?
        /// Device state defines the device status of sidewalk device.
        public var deviceState: IotWirelessClientTypes.DeviceState?
        /// Sidewalk device status notification.
        public var event: IotWirelessClientTypes.Event?
        /// The RSSI value.
        public var rssi: Swift.Int?

        public init (
            batteryLevel: IotWirelessClientTypes.BatteryLevel? = nil,
            deviceState: IotWirelessClientTypes.DeviceState? = nil,
            event: IotWirelessClientTypes.Event? = nil,
            rssi: Swift.Int? = nil
        )
        {
            self.batteryLevel = batteryLevel
            self.deviceState = deviceState
            self.event = event
            self.rssi = rssi
        }
    }

}

extension IotWirelessClientTypes.SidewalkListDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[IotWirelessClientTypes.CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [IotWirelessClientTypes.CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension IotWirelessClientTypes.SidewalkListDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkListDevice(amazonId: \(Swift.String(describing: amazonId)), deviceCertificates: \(Swift.String(describing: deviceCertificates)), sidewalkId: \(Swift.String(describing: sidewalkId)), sidewalkManufacturingSn: \(Swift.String(describing: sidewalkManufacturingSn)))"}
}

extension IotWirelessClientTypes {
    /// Sidewalk object used by list functions.
    public struct SidewalkListDevice: Swift.Equatable {
        /// The Sidewalk Amazon ID.
        public var amazonId: Swift.String?
        /// The sidewalk device certificates for Ed25519 and P256r1.
        public var deviceCertificates: [IotWirelessClientTypes.CertificateList]?
        /// The sidewalk device identification.
        public var sidewalkId: Swift.String?
        /// The Sidewalk manufacturing series number.
        public var sidewalkManufacturingSn: Swift.String?

        public init (
            amazonId: Swift.String? = nil,
            deviceCertificates: [IotWirelessClientTypes.CertificateList]? = nil,
            sidewalkId: Swift.String? = nil,
            sidewalkManufacturingSn: Swift.String? = nil
        )
        {
            self.amazonId = amazonId
            self.deviceCertificates = deviceCertificates
            self.sidewalkId = sidewalkId
            self.sidewalkManufacturingSn = sidewalkManufacturingSn
        }
    }

}

extension IotWirelessClientTypes.SidewalkSendDataToDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageType = "MessageType"
        case seq = "Seq"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let seq = seq {
            try encodeContainer.encode(seq, forKey: .seq)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seqDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seq)
        seq = seqDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

extension IotWirelessClientTypes.SidewalkSendDataToDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkSendDataToDevice(messageType: \(Swift.String(describing: messageType)), seq: \(Swift.String(describing: seq)))"}
}

extension IotWirelessClientTypes {
    /// Information about a Sidewalk router.
    public struct SidewalkSendDataToDevice: Swift.Equatable {
        /// Sidewalk device message type. Default value is CUSTOM_COMMAND_ID_NOTIFY.
        public var messageType: IotWirelessClientTypes.MessageType?
        /// The sequence number.
        public var seq: Swift.Int?

        public init (
            messageType: IotWirelessClientTypes.MessageType? = nil,
            seq: Swift.Int? = nil
        )
        {
            self.messageType = messageType
            self.seq = seq
        }
    }

}

extension IotWirelessClientTypes.SidewalkUpdateAccount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension IotWirelessClientTypes.SidewalkUpdateAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SidewalkUpdateAccount(appServerPrivateKey: \(Swift.String(describing: appServerPrivateKey)))"}
}

extension IotWirelessClientTypes {
    /// Sidewalk update.
    public struct SidewalkUpdateAccount: Swift.Equatable {
        /// The new Sidewalk application server private key.
        public var appServerPrivateKey: Swift.String?

        public init (
            appServerPrivateKey: Swift.String? = nil
        )
        {
            self.appServerPrivateKey = appServerPrivateKey
        }
    }

}

extension IotWirelessClientTypes {
    /// The certificate chain algorithm provided by sidewalk.
    public enum SigningAlg: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ed25519
        case p256r1
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlg] {
            return [
                .ed25519,
                .p256r1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ed25519: return "Ed25519"
            case .p256r1: return "P256r1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotWirelessClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension IotWirelessClientTypes {
    /// A simple label consisting of a customer-defined key-value pair
    public struct Tag: Swift.Equatable {
        /// The tag's key value.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.
    /// This member is required.
    public var tags: [IotWirelessClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [IotWirelessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [IotWirelessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IotWirelessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IotWirelessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TestWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestWirelessDeviceInput(id: \(Swift.String(describing: id)))"}
}

extension TestWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct TestWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestWirelessDeviceOutputError>
}

public struct TestWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestWirelessDeviceOutputError>
}

public struct TestWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TestWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())/test"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TestWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TestWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestWirelessDeviceOutputError>
}

public struct TestWirelessDeviceInput: Swift.Equatable {
    /// The ID of the wireless device to test.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct TestWirelessDeviceInputBody: Swift.Equatable {
}

extension TestWirelessDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TestWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestWirelessDeviceOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension TestWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct TestWirelessDeviceOutputResponse: Swift.Equatable {
    /// The result returned by the test.
    public var result: Swift.String?

    public init (
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct TestWirelessDeviceOutputResponseBody: Swift.Equatable {
    public let result: Swift.String?
}

extension TestWirelessDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because it exceeded the allowed API request rate.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied because the resource can't have any more tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Name of the resource that exceeds maximum number of tags allowed.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDestinationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDestinationOutputError>
}

extension UpdateDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDestinationInput(description: \(Swift.String(describing: description)), expression: \(Swift.String(describing: expression)), expressionType: \(Swift.String(describing: expressionType)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension UpdateDestinationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateDestinationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDestinationOutputError>
}

public struct UpdateDestinationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDestinationOutputError>
}

public struct UpdateDestinationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDestinationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDestinationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/destinations/\(name.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDestinationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDestinationOutputError>
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The new rule name or topic rule to send messages to.
    public var expression: Swift.String?
    /// The type of value in Expression.
    public var expressionType: IotWirelessClientTypes.ExpressionType?
    /// The new name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the IAM Role that authorizes the destination.
    public var roleArn: Swift.String?

    public init (
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        expressionType: IotWirelessClientTypes.ExpressionType? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    public let expressionType: IotWirelessClientTypes.ExpressionType?
    public let expression: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionTypeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDestinationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDestinationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDestinationOutputResponse()"}
}

extension UpdateDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDestinationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDestinationOutputResponseBody: Swift.Equatable {
}

extension UpdateDestinationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLogLevelsByResourceTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

extension UpdateLogLevelsByResourceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLogLevelsByResourceTypesInput(defaultLogLevel: \(Swift.String(describing: defaultLogLevel)), wirelessDeviceLogOptions: \(Swift.String(describing: wirelessDeviceLogOptions)), wirelessGatewayLogOptions: \(Swift.String(describing: wirelessGatewayLogOptions)))"}
}

extension UpdateLogLevelsByResourceTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let wirelessDeviceLogOptions = wirelessDeviceLogOptions {
            var wirelessDeviceLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDeviceLogOptions)
            for wirelessdevicelogoptionlist0 in wirelessDeviceLogOptions {
                try wirelessDeviceLogOptionsContainer.encode(wirelessdevicelogoptionlist0)
            }
        }
        if let wirelessGatewayLogOptions = wirelessGatewayLogOptions {
            var wirelessGatewayLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewayLogOptions)
            for wirelessgatewaylogoptionlist0 in wirelessGatewayLogOptions {
                try wirelessGatewayLogOptionsContainer.encode(wirelessgatewaylogoptionlist0)
            }
        }
    }
}

public struct UpdateLogLevelsByResourceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLogLevelsByResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

public struct UpdateLogLevelsByResourceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLogLevelsByResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

public struct UpdateLogLevelsByResourceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLogLevelsByResourceTypesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateLogLevelsByResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/log-levels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLogLevelsByResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

public struct UpdateLogLevelsByResourceTypesInput: Swift.Equatable {
    /// The log level for a log message.
    public var defaultLogLevel: IotWirelessClientTypes.LogLevel?
    /// The list of wireless device log options.
    public var wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    /// The list of wireless gateway log options.
    public var wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: IotWirelessClientTypes.LogLevel? = nil,
        wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct UpdateLogLevelsByResourceTypesInputBody: Swift.Equatable {
    public let defaultLogLevel: IotWirelessClientTypes.LogLevel?
    public let wirelessDeviceLogOptions: [IotWirelessClientTypes.WirelessDeviceLogOption]?
    public let wirelessGatewayLogOptions: [IotWirelessClientTypes.WirelessGatewayLogOption]?
}

extension UpdateLogLevelsByResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[IotWirelessClientTypes.WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[IotWirelessClientTypes.WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [IotWirelessClientTypes.WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
    }
}

extension UpdateLogLevelsByResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogLevelsByResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLogLevelsByResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogLevelsByResourceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLogLevelsByResourceTypesOutputResponse()"}
}

extension UpdateLogLevelsByResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLogLevelsByResourceTypesOutputResponseBody: Swift.Equatable {
}

extension UpdateLogLevelsByResourceTypesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePartnerAccountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerAccountOutputError>
}

extension UpdatePartnerAccountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnerAccountInput(partnerAccountId: \(Swift.String(describing: partnerAccountId)), partnerType: \(Swift.String(describing: partnerType)), sidewalk: \(Swift.String(describing: sidewalk)))"}
}

extension UpdatePartnerAccountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

public struct UpdatePartnerAccountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerAccountOutputError>
}

public struct UpdatePartnerAccountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = ClientRuntime.URLQueryItem(name: "partnerType".urlPercentEncoding(), value: Swift.String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerAccountOutputError>
}

public struct UpdatePartnerAccountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePartnerAccountInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdatePartnerAccountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let partnerAccountId = input.partnerAccountId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("partnerAccountId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/partner-accounts/\(partnerAccountId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePartnerAccountInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePartnerAccountOutputError>
}

public struct UpdatePartnerAccountInput: Swift.Equatable {
    /// The ID of the partner account to update.
    /// This member is required.
    public var partnerAccountId: Swift.String?
    /// The partner type.
    /// This member is required.
    public var partnerType: IotWirelessClientTypes.PartnerType?
    /// The Sidewalk account credentials.
    /// This member is required.
    public var sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount?

    public init (
        partnerAccountId: Swift.String? = nil,
        partnerType: IotWirelessClientTypes.PartnerType? = nil,
        sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

struct UpdatePartnerAccountInputBody: Swift.Equatable {
    public let sidewalk: IotWirelessClientTypes.SidewalkUpdateAccount?
}

extension UpdatePartnerAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkUpdateAccount.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdatePartnerAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePartnerAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartnerAccountOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerAccountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnerAccountOutputResponse()"}
}

extension UpdatePartnerAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePartnerAccountOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdatePartnerAccountOutputResponseBody: Swift.Equatable {
}

extension UpdatePartnerAccountOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateWirelessDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessDeviceOutputError>
}

extension UpdateWirelessDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessDeviceInput(description: \(Swift.String(describing: description)), destinationName: \(Swift.String(describing: destinationName)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)))"}
}

extension UpdateWirelessDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateWirelessDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessDeviceOutputError>
}

public struct UpdateWirelessDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessDeviceOutputError>
}

public struct UpdateWirelessDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateWirelessDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-devices/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWirelessDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessDeviceOutputError>
}

public struct UpdateWirelessDeviceInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The name of the new destination for the device.
    public var destinationName: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// The updated wireless device's configuration.
    public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice?
    /// The new name of the resource.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateWirelessDeviceInputBody: Swift.Equatable {
    public let destinationName: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let loRaWAN: IotWirelessClientTypes.LoRaWANUpdateDevice?
}

extension UpdateWirelessDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateWirelessDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessDeviceOutputResponse()"}
}

extension UpdateWirelessDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessDeviceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateWirelessDeviceOutputResponseBody: Swift.Equatable {
}

extension UpdateWirelessDeviceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateWirelessGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessGatewayOutputError>
}

extension UpdateWirelessGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessGatewayInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), joinEuiFilters: \(Swift.String(describing: joinEuiFilters)), name: \(Swift.String(describing: name)), netIdFilters: \(Swift.String(describing: netIdFilters)))"}
}

extension UpdateWirelessGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
    }
}

public struct UpdateWirelessGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessGatewayOutputError>
}

public struct UpdateWirelessGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessGatewayOutputError>
}

public struct UpdateWirelessGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWirelessGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateWirelessGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/wireless-gateways/\(id.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWirelessGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWirelessGatewayOutputError>
}

public struct UpdateWirelessGatewayInput: Swift.Equatable {
    /// A new description of the resource.
    public var description: Swift.String?
    /// The ID of the resource to update.
    /// This member is required.
    public var id: Swift.String?
    /// A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.
    public var joinEuiFilters: [[Swift.String]]?
    /// The new name of the resource.
    public var name: Swift.String?
    /// A list of NetId values that are used by LoRa gateways to filter the uplink frames.
    public var netIdFilters: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        joinEuiFilters: [[Swift.String]]? = nil,
        name: Swift.String? = nil,
        netIdFilters: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

struct UpdateWirelessGatewayInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let joinEuiFilters: [[Swift.String]]?
    public let netIdFilters: [Swift.String]?
}

extension UpdateWirelessGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[Swift.String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[Swift.String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[Swift.String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [Swift.String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
    }
}

extension UpdateWirelessGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessGatewayOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessGatewayOutputResponse()"}
}

extension UpdateWirelessGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessGatewayOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateWirelessGatewayOutputResponseBody: Swift.Equatable {
}

extension UpdateWirelessGatewayOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case updateDataRole = "UpdateDataRole"
        case updateDataSource = "UpdateDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let updateDataRole = updateDataRole {
            try encodeContainer.encode(updateDataRole, forKey: .updateDataRole)
        }
        if let updateDataSource = updateDataSource {
            try encodeContainer.encode(updateDataSource, forKey: .updateDataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataSource)
        updateDataSource = updateDataSourceDecoded
        let updateDataRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDataRole)
        updateDataRole = updateDataRoleDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskCreate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessGatewayTaskCreate(loRaWAN: \(Swift.String(describing: loRaWAN)), updateDataRole: \(Swift.String(describing: updateDataRole)), updateDataSource: \(Swift.String(describing: updateDataSource)))"}
}

extension IotWirelessClientTypes {
    /// UpdateWirelessGatewayTaskCreate object.
    public struct UpdateWirelessGatewayTaskCreate: Swift.Equatable {
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate?
        /// The IAM role used to read data from the S3 bucket.
        public var updateDataRole: Swift.String?
        /// The link to the S3 bucket.
        public var updateDataSource: Swift.String?

        public init (
            loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskCreate? = nil,
            updateDataRole: Swift.String? = nil,
            updateDataSource: Swift.String? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.updateDataRole = updateDataRole
            self.updateDataSource = updateDataSource
        }
    }

}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IotWirelessClientTypes.UpdateWirelessGatewayTaskEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWirelessGatewayTaskEntry(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), loRaWAN: \(Swift.String(describing: loRaWAN)))"}
}

extension IotWirelessClientTypes {
    /// UpdateWirelessGatewayTaskEntry object.
    public struct UpdateWirelessGatewayTaskEntry: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The ID of the new wireless gateway task entry.
        public var id: Swift.String?
        /// The properties that relate to the LoRaWAN wireless gateway.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANUpdateGatewayTaskEntry? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.loRaWAN = loRaWAN
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input did not meet the specified constraints.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless device.
    public enum WirelessDeviceEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case downlinkData
        case join
        case registration
        case rejoin
        case uplinkData
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceEvent] {
            return [
                .downlinkData,
                .join,
                .registration,
                .rejoin,
                .uplinkData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .downlinkData: return "Downlink_Data"
            case .join: return "Join"
            case .registration: return "Registration"
            case .rejoin: return "Rejoin"
            case .uplinkData: return "Uplink_Data"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceEvent(rawValue: rawValue) ?? WirelessDeviceEvent.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessDeviceEventLogOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IotWirelessClientTypes.WirelessDeviceEventLogOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessDeviceEventLogOption(event: \(Swift.String(describing: event)), logLevel: \(Swift.String(describing: logLevel)))"}
}

extension IotWirelessClientTypes {
    /// The log options for a wireless device event and can be used to set log levels for a specific wireless device event.
    ///          For a LoRaWAN device, possible events for a log messsage are: Join, Rejoin,
    ///              Downlink_Data, and Uplink_Data. For a Sidewalk device, possible events for a log message are
    ///              Registration, Downlink_Data, and Uplink_Data.
    public struct WirelessDeviceEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless device.
        /// This member is required.
        public var event: IotWirelessClientTypes.WirelessDeviceEvent?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?

        public init (
            event: IotWirelessClientTypes.WirelessDeviceEvent? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessDeviceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deveui
        case sidewalkmanufacturingsn
        case thingname
        case wirelessdeviceid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceIdType] {
            return [
                .deveui,
                .sidewalkmanufacturingsn,
                .thingname,
                .wirelessdeviceid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deveui: return "DevEui"
            case .sidewalkmanufacturingsn: return "SidewalkManufacturingSn"
            case .thingname: return "ThingName"
            case .wirelessdeviceid: return "WirelessDeviceId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceIdType(rawValue: rawValue) ?? WirelessDeviceIdType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessDeviceLogOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessdeviceeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessdeviceeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessDeviceEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IotWirelessClientTypes.WirelessDeviceEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotWirelessClientTypes.WirelessDeviceEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotWirelessClientTypes.WirelessDeviceLogOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessDeviceLogOption(events: \(Swift.String(describing: events)), logLevel: \(Swift.String(describing: logLevel)), type: \(Swift.String(describing: type)))"}
}

extension IotWirelessClientTypes {
    /// The log options for wireless devices and can be used to set log levels for a specific type of wireless device.
    public struct WirelessDeviceLogOption: Swift.Equatable {
        /// The list of wireless device event log options.
        public var events: [IotWirelessClientTypes.WirelessDeviceEventLogOption]?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?
        /// The wireless device type.
        /// This member is required.
        public var type: IotWirelessClientTypes.WirelessDeviceType?

        public init (
            events: [IotWirelessClientTypes.WirelessDeviceEventLogOption]? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil,
            type: IotWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IotWirelessClientTypes.WirelessDeviceStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case destinationName = "DestinationName"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANListDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkListDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IotWirelessClientTypes.WirelessDeviceStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessDeviceStatistics(arn: \(Swift.String(describing: arn)), destinationName: \(Swift.String(describing: destinationName)), id: \(Swift.String(describing: id)), lastUplinkReceivedAt: \(Swift.String(describing: lastUplinkReceivedAt)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)), sidewalk: \(Swift.String(describing: sidewalk)), type: \(Swift.String(describing: type)))"}
}

extension IotWirelessClientTypes {
    /// Information about a wireless device's operation.
    public struct WirelessDeviceStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The name of the destination to which the device is assigned.
        public var destinationName: Swift.String?
        /// The ID of the wireless device reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN device info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANListDevice?
        /// The name of the resource.
        public var name: Swift.String?
        /// The Sidewalk account credentials.
        public var sidewalk: IotWirelessClientTypes.SidewalkListDevice?
        /// The wireless device type.
        public var type: IotWirelessClientTypes.WirelessDeviceType?

        public init (
            arn: Swift.String? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANListDevice? = nil,
            name: Swift.String? = nil,
            sidewalk: IotWirelessClientTypes.SidewalkListDevice? = nil,
            type: IotWirelessClientTypes.WirelessDeviceType? = nil
        )
        {
            self.arn = arn
            self.destinationName = destinationName
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
            self.sidewalk = sidewalk
            self.type = type
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sidewalk
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessDeviceType] {
            return [
                .lorawan,
                .sidewalk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case .sidewalk: return "Sidewalk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessDeviceType(rawValue: rawValue) ?? WirelessDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// The event for a log message, if the log message is tied to a wireless gateway.
    public enum WirelessGatewayEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cupsRequest
        case certificate
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayEvent] {
            return [
                .cupsRequest,
                .certificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cupsRequest: return "CUPS_Request"
            case .certificate: return "Certificate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayEvent(rawValue: rawValue) ?? WirelessGatewayEvent.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayEventLogOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IotWirelessClientTypes.WirelessGatewayEventLogOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessGatewayEventLogOption(event: \(Swift.String(describing: event)), logLevel: \(Swift.String(describing: logLevel)))"}
}

extension IotWirelessClientTypes {
    /// The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event.
    ///          For a LoRaWAN gateway, possible events for a log message are CUPS_Request and Certificate.
    public struct WirelessGatewayEventLogOption: Swift.Equatable {
        /// The event for a log message, if the log message is tied to a wireless gateway.
        /// This member is required.
        public var event: IotWirelessClientTypes.WirelessGatewayEvent?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?

        public init (
            event: IotWirelessClientTypes.WirelessGatewayEvent? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil
        )
        {
            self.event = event
            self.logLevel = logLevel
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gatewayeui
        case thingname
        case wirelessgatewayid
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayIdType] {
            return [
                .gatewayeui,
                .thingname,
                .wirelessgatewayid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gatewayeui: return "GatewayEui"
            case .thingname: return "ThingName"
            case .wirelessgatewayid: return "WirelessGatewayId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayIdType(rawValue: rawValue) ?? WirelessGatewayIdType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayLogOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessgatewayeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessgatewayeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.WirelessGatewayType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([IotWirelessClientTypes.WirelessGatewayEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[IotWirelessClientTypes.WirelessGatewayEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IotWirelessClientTypes.WirelessGatewayEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension IotWirelessClientTypes.WirelessGatewayLogOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessGatewayLogOption(events: \(Swift.String(describing: events)), logLevel: \(Swift.String(describing: logLevel)), type: \(Swift.String(describing: type)))"}
}

extension IotWirelessClientTypes {
    /// The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.
    public struct WirelessGatewayLogOption: Swift.Equatable {
        /// The list of wireless gateway event log options.
        public var events: [IotWirelessClientTypes.WirelessGatewayEventLogOption]?
        /// The log level for a log message.
        /// This member is required.
        public var logLevel: IotWirelessClientTypes.LogLevel?
        /// The wireless gateway type.
        /// This member is required.
        public var type: IotWirelessClientTypes.WirelessGatewayType?

        public init (
            events: [IotWirelessClientTypes.WirelessGatewayEventLogOption]? = nil,
            logLevel: IotWirelessClientTypes.LogLevel? = nil,
            type: IotWirelessClientTypes.WirelessGatewayType? = nil
        )
        {
            self.events = events
            self.logLevel = logLevel
            self.type = type
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cups
        case lns
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayServiceType] {
            return [
                .cups,
                .lns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cups: return "CUPS"
            case .lns: return "LNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayServiceType(rawValue: rawValue) ?? WirelessGatewayServiceType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessGatewayStatistics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
    }
}

extension IotWirelessClientTypes.WirelessGatewayStatistics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessGatewayStatistics(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUplinkReceivedAt: \(Swift.String(describing: lastUplinkReceivedAt)), loRaWAN: \(Swift.String(describing: loRaWAN)), name: \(Swift.String(describing: name)))"}
}

extension IotWirelessClientTypes {
    /// Information about a wireless gateway's operation.
    public struct WirelessGatewayStatistics: Swift.Equatable {
        /// The Amazon Resource Name of the resource.
        public var arn: Swift.String?
        /// The description of the resource.
        public var description: Swift.String?
        /// The ID of the wireless gateway reporting the data.
        public var id: Swift.String?
        /// The date and time when the most recent uplink was received.
        public var lastUplinkReceivedAt: Swift.String?
        /// LoRaWAN gateway info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANGateway?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUplinkReceivedAt: Swift.String? = nil,
            loRaWAN: IotWirelessClientTypes.LoRaWANGateway? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.lastUplinkReceivedAt = lastUplinkReceivedAt
            self.loRaWAN = loRaWAN
            self.name = name
        }
    }

}

extension IotWirelessClientTypes {
    public enum WirelessGatewayTaskDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskDefinitionType] {
            return [
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskDefinitionType(rawValue: rawValue) ?? WirelessGatewayTaskDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    public enum WirelessGatewayTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case firstRetry
        case inProgress
        case pending
        case secondRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayTaskStatus] {
            return [
                .completed,
                .failed,
                .firstRetry,
                .inProgress,
                .pending,
                .secondRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .firstRetry: return "FIRST_RETRY"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .secondRetry: return "SECOND_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayTaskStatus(rawValue: rawValue) ?? WirelessGatewayTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes {
    /// The wireless gateway type.
    public enum WirelessGatewayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lorawan
        case sdkUnknown(Swift.String)

        public static var allCases: [WirelessGatewayType] {
            return [
                .lorawan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lorawan: return "LoRaWAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WirelessGatewayType(rawValue: rawValue) ?? WirelessGatewayType.sdkUnknown(rawValue)
        }
    }
}

extension IotWirelessClientTypes.WirelessMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(IotWirelessClientTypes.SidewalkSendDataToDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension IotWirelessClientTypes.WirelessMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessMetadata(loRaWAN: \(Swift.String(describing: loRaWAN)), sidewalk: \(Swift.String(describing: sidewalk)))"}
}

extension IotWirelessClientTypes {
    /// WirelessMetadata object.
    public struct WirelessMetadata: Swift.Equatable {
        /// LoRaWAN device info.
        public var loRaWAN: IotWirelessClientTypes.LoRaWANSendDataToDevice?
        /// The Sidewalk account credentials.
        public var sidewalk: IotWirelessClientTypes.SidewalkSendDataToDevice?

        public init (
            loRaWAN: IotWirelessClientTypes.LoRaWANSendDataToDevice? = nil,
            sidewalk: IotWirelessClientTypes.SidewalkSendDataToDevice? = nil
        )
        {
            self.loRaWAN = loRaWAN
            self.sidewalk = sidewalk
        }
    }

}
