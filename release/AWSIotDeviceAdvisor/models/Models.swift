// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a Conflict Exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Conflict Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateSuiteDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSuiteDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSuiteDefinitionOutputError>
}

extension CreateSuiteDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSuiteDefinitionInput(suiteDefinitionConfiguration: \(Swift.String(describing: suiteDefinitionConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSuiteDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSuiteDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSuiteDefinitionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSuiteDefinitionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/suiteDefinitions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInput: Swift.Equatable {
    /// Creates a Device Advisor test suite with suite definition configuration.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// The tags to be attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init (
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.tags = tags
    }
}

struct CreateSuiteDefinitionInputBody: Swift.Equatable {
    public let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSuiteDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSuiteDefinitionOutputResponse(createdAt: \(Swift.String(describing: createdAt)), suiteDefinitionArn: \(Swift.String(describing: suiteDefinitionArn)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionName: \(Swift.String(describing: suiteDefinitionName)))"}
}

extension CreateSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
        } else {
            self.createdAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
        }
    }
}

public struct CreateSuiteDefinitionOutputResponse: Swift.Equatable {
    /// Creates a Device Advisor test suite with TimeStamp of when it was created.
    public var createdAt: ClientRuntime.Date?
    /// Creates a Device Advisor test suite with Amazon Resource Name (ARN).
    public var suiteDefinitionArn: Swift.String?
    /// Creates a Device Advisor test suite with suite UUID.
    public var suiteDefinitionId: Swift.String?
    /// Creates a Device Advisor test suite with suite definition name.
    public var suiteDefinitionName: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

struct CreateSuiteDefinitionOutputResponseBody: Swift.Equatable {
    public let suiteDefinitionId: Swift.String?
    public let suiteDefinitionArn: Swift.String?
    public let suiteDefinitionName: Swift.String?
    public let createdAt: ClientRuntime.Date?
}

extension CreateSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DeleteSuiteDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSuiteDefinitionInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)))"}
}

extension DeleteSuiteDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSuiteDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuiteDefinitionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSuiteDefinitionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to be deleted.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct DeleteSuiteDefinitionInputBody: Swift.Equatable {
}

extension DeleteSuiteDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuiteDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSuiteDefinitionOutputResponse()"}
}

extension DeleteSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSuiteDefinitionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSuiteDefinitionOutputResponseBody: Swift.Equatable {
}

extension DeleteSuiteDefinitionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotDeviceAdvisorClientTypes.DeviceUnderTest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case thingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension IotDeviceAdvisorClientTypes.DeviceUnderTest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceUnderTest(certificateArn: \(Swift.String(describing: certificateArn)), thingArn: \(Swift.String(describing: thingArn)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Information of a test device. A thing ARN or a certificate ARN is required.
    public struct DeviceUnderTest: Swift.Equatable {
        /// Lists devices certificate ARN.
        public var certificateArn: Swift.String?
        /// Lists devices thing ARN.
        public var thingArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.thingArn = thingArn
        }
    }

}

extension GetEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), thingArn: \(Swift.String(describing: thingArn)))"}
}

extension GetEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointOutputError>
}

public struct GetEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let thingArn = input.operationInput.thingArn {
            let thingArnQueryItem = ClientRuntime.URLQueryItem(name: "thingArn".urlPercentEncoding(), value: Swift.String(thingArn).urlPercentEncoding())
            input.builder.withQueryItem(thingArnQueryItem)
        }
        if let certificateArn = input.operationInput.certificateArn {
            let certificateArnQueryItem = ClientRuntime.URLQueryItem(name: "certificateArn".urlPercentEncoding(), value: Swift.String(certificateArn).urlPercentEncoding())
            input.builder.withQueryItem(certificateArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointOutputError>
}

public struct GetEndpointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointOutputError>
}

public struct GetEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEndpointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/endpoint"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEndpointOutputError>
}

public struct GetEndpointInput: Swift.Equatable {
    /// The certificate ARN of the device. This is an optional parameter.
    public var certificateArn: Swift.String?
    /// The thing ARN of the device. This is an optional parameter.
    public var thingArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.thingArn = thingArn
    }
}

struct GetEndpointInputBody: Swift.Equatable {
}

extension GetEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEndpointOutputResponse(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension GetEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetEndpointOutputResponse: Swift.Equatable {
    /// The response of an Device Advisor endpoint.
    public var endpoint: Swift.String?

    public init (
        endpoint: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetEndpointOutputResponseBody: Swift.Equatable {
    public let endpoint: Swift.String?
}

extension GetEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GetSuiteDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteDefinitionInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)))"}
}

extension GetSuiteDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSuiteDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let suiteDefinitionVersion = input.operationInput.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteDefinitionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteDefinitionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to get.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite to get.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct GetSuiteDefinitionInputBody: Swift.Equatable {
}

extension GetSuiteDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteDefinitionOutputResponse(createdAt: \(Swift.String(describing: createdAt)), lastModifiedAt: \(Swift.String(describing: lastModifiedAt)), latestVersion: \(Swift.String(describing: latestVersion)), suiteDefinitionArn: \(Swift.String(describing: suiteDefinitionArn)), suiteDefinitionConfiguration: \(Swift.String(describing: suiteDefinitionConfiguration)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)), tags: \(Swift.String(describing: tags)))"}
}

extension GetSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastModifiedAt = output.lastModifiedAt
            self.latestVersion = output.latestVersion
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionConfiguration = output.suiteDefinitionConfiguration
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.lastModifiedAt = nil
            self.latestVersion = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionConfiguration = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.tags = nil
        }
    }
}

public struct GetSuiteDefinitionOutputResponse: Swift.Equatable {
    /// Date (in Unix epoch time) when the suite definition was created.
    public var createdAt: ClientRuntime.Date?
    /// Date (in Unix epoch time) when the suite definition was last modified.
    public var lastModifiedAt: ClientRuntime.Date?
    /// Latest suite definition version of the suite definition.
    public var latestVersion: Swift.String?
    /// The ARN of the suite definition.
    public var suiteDefinitionArn: Swift.String?
    /// Suite configuration of the suite definition.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the suite definition.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the suite definition.
    public var suiteDefinitionVersion: Swift.String?
    /// Tags attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        lastModifiedAt: ClientRuntime.Date? = nil,
        latestVersion: Swift.String? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.lastModifiedAt = lastModifiedAt
        self.latestVersion = latestVersion
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.tags = tags
    }
}

struct GetSuiteDefinitionOutputResponseBody: Swift.Equatable {
    public let suiteDefinitionId: Swift.String?
    public let suiteDefinitionArn: Swift.String?
    public let suiteDefinitionVersion: Swift.String?
    public let latestVersion: Swift.String?
    public let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    public let createdAt: ClientRuntime.Date?
    public let lastModifiedAt: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension GetSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModifiedAt
        case latestVersion
        case suiteDefinitionArn
        case suiteDefinitionConfiguration
        case suiteDefinitionId
        case suiteDefinitionVersion
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteRunInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteRunId: \(Swift.String(describing: suiteRunId)))"}
}

extension GetSuiteRunInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSuiteRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        guard let suiteRunId = input.suiteRunId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteRunId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInput: Swift.Equatable {
    /// Suite definition ID for the test suite run.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID for the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunInputBody: Swift.Equatable {
}

extension GetSuiteRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteRunOutputResponse(endTime: \(Swift.String(describing: endTime)), errorReason: \(Swift.String(describing: errorReason)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)), suiteRunArn: \(Swift.String(describing: suiteRunArn)), suiteRunConfiguration: \(Swift.String(describing: suiteRunConfiguration)), suiteRunId: \(Swift.String(describing: suiteRunId)), tags: \(Swift.String(describing: tags)), testResult: \(Swift.String(describing: testResult)))"}
}

extension GetSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorReason = output.errorReason
            self.startTime = output.startTime
            self.status = output.status
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunConfiguration = output.suiteRunConfiguration
            self.suiteRunId = output.suiteRunId
            self.tags = output.tags
            self.testResult = output.testResult
        } else {
            self.endTime = nil
            self.errorReason = nil
            self.startTime = nil
            self.status = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.suiteRunArn = nil
            self.suiteRunConfiguration = nil
            self.suiteRunId = nil
            self.tags = nil
            self.testResult = nil
        }
    }
}

public struct GetSuiteRunOutputResponse: Swift.Equatable {
    /// Date (in Unix epoch time) when the test suite run ended.
    public var endTime: ClientRuntime.Date?
    /// Error reason for any test suite run failure.
    public var errorReason: Swift.String?
    /// Date (in Unix epoch time) when the test suite run started.
    public var startTime: ClientRuntime.Date?
    /// Status for the test suite run.
    public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    /// Suite definition ID for the test suite run.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version for the test suite run.
    public var suiteDefinitionVersion: Swift.String?
    /// The ARN of the suite run.
    public var suiteRunArn: Swift.String?
    /// Suite run configuration for the test suite run.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// Suite run ID for the test suite run.
    public var suiteRunId: Swift.String?
    /// The tags attached to the suite run.
    public var tags: [Swift.String:Swift.String]?
    /// Test results for the test suite run.
    public var testResult: IotDeviceAdvisorClientTypes.TestResult?

    public init (
        endTime: ClientRuntime.Date? = nil,
        errorReason: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        suiteRunId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        testResult: IotDeviceAdvisorClientTypes.TestResult? = nil
    )
    {
        self.endTime = endTime
        self.errorReason = errorReason
        self.startTime = startTime
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunArn = suiteRunArn
        self.suiteRunConfiguration = suiteRunConfiguration
        self.suiteRunId = suiteRunId
        self.tags = tags
        self.testResult = testResult
    }
}

struct GetSuiteRunOutputResponseBody: Swift.Equatable {
    public let suiteDefinitionId: Swift.String?
    public let suiteDefinitionVersion: Swift.String?
    public let suiteRunId: Swift.String?
    public let suiteRunArn: Swift.String?
    public let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    public let testResult: IotDeviceAdvisorClientTypes.TestResult?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    public let errorReason: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension GetSuiteRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorReason
        case startTime
        case status
        case suiteDefinitionId
        case suiteDefinitionVersion
        case suiteRunArn
        case suiteRunConfiguration
        case suiteRunId
        case tags
        case testResult
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let testResultDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteRunReportInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteRunId: \(Swift.String(describing: suiteRunId)))"}
}

extension GetSuiteRunReportInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSuiteRunReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteRunReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteRunReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSuiteRunReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSuiteRunReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunReportInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSuiteRunReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteRunReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSuiteRunReportInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSuiteRunReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        guard let suiteRunId = input.suiteRunId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteRunId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/report"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSuiteRunReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunReportInputBody: Swift.Equatable {
}

extension GetSuiteRunReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteRunReportOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSuiteRunReportOutputResponse(qualificationReportDownloadUrl: \(Swift.String(describing: qualificationReportDownloadUrl)))"}
}

extension GetSuiteRunReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSuiteRunReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualificationReportDownloadUrl = output.qualificationReportDownloadUrl
        } else {
            self.qualificationReportDownloadUrl = nil
        }
    }
}

public struct GetSuiteRunReportOutputResponse: Swift.Equatable {
    /// Download URL of the qualification report.
    public var qualificationReportDownloadUrl: Swift.String?

    public init (
        qualificationReportDownloadUrl: Swift.String? = nil
    )
    {
        self.qualificationReportDownloadUrl = qualificationReportDownloadUrl
    }
}

struct GetSuiteRunReportOutputResponseBody: Swift.Equatable {
    public let qualificationReportDownloadUrl: Swift.String?
}

extension GetSuiteRunReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationReportDownloadUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationReportDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationReportDownloadUrl)
        qualificationReportDownloadUrl = qualificationReportDownloadUrlDecoded
    }
}

extension IotDeviceAdvisorClientTypes.GroupResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
        case tests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tests = tests {
            var testsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tests)
            for testcaseruns0 in tests {
                try testsContainer.encode(testcaseruns0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let testsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.TestCaseRun?].self, forKey: .tests)
        var testsDecoded0:[IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [IotDeviceAdvisorClientTypes.TestCaseRun]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes.GroupResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupResult(groupId: \(Swift.String(describing: groupId)), groupName: \(Swift.String(describing: groupName)), tests: \(Swift.String(describing: tests)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Show Group Result.
    public struct GroupResult: Swift.Equatable {
        /// Group result ID.
        public var groupId: Swift.String?
        /// Group Result Name.
        public var groupName: Swift.String?
        /// Tests under Group Result.
        public var tests: [IotDeviceAdvisorClientTypes.TestCaseRun]?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            tests: [IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.tests = tests
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends an Internal Failure exception.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Sends an Internal Failure Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSuiteDefinitionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuiteDefinitionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSuiteDefinitionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSuiteDefinitionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuiteDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuiteDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuiteDefinitionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuiteDefinitionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteDefinitionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSuiteDefinitionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuiteDefinitionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteDefinitionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSuiteDefinitionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/suiteDefinitions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuiteDefinitionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuiteDefinitionsInputBody: Swift.Equatable {
}

extension ListSuiteDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuiteDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteDefinitionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuiteDefinitionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), suiteDefinitionInformationList: \(Swift.String(describing: suiteDefinitionInformationList)))"}
}

extension ListSuiteDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSuiteDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteDefinitionInformationList = output.suiteDefinitionInformationList
        } else {
            self.nextToken = nil
            self.suiteDefinitionInformationList = nil
        }
    }
}

public struct ListSuiteDefinitionsOutputResponse: Swift.Equatable {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite definitions in the list.
    public var suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteDefinitionInformationList = suiteDefinitionInformationList
    }
}

struct ListSuiteDefinitionsOutputResponseBody: Swift.Equatable {
    public let suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?
    public let nextToken: Swift.String?
}

extension ListSuiteDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteDefinitionInformationList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionInformationListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteDefinitionInformation?].self, forKey: .suiteDefinitionInformationList)
        var suiteDefinitionInformationListDecoded0:[IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
        if let suiteDefinitionInformationListContainer = suiteDefinitionInformationListContainer {
            suiteDefinitionInformationListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]()
            for structure0 in suiteDefinitionInformationListContainer {
                if let structure0 = structure0 {
                    suiteDefinitionInformationListDecoded0?.append(structure0)
                }
            }
        }
        suiteDefinitionInformationList = suiteDefinitionInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuiteRunsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuiteRunsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)))"}
}

extension ListSuiteRunsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSuiteRunsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuiteRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuiteRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSuiteRunsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let suiteDefinitionId = input.operationInput.suiteDefinitionId {
            let suiteDefinitionIdQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionId".urlPercentEncoding(), value: Swift.String(suiteDefinitionId).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionIdQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let suiteDefinitionVersion = input.operationInput.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSuiteRunsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteRunsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSuiteRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuiteRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSuiteRunsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSuiteRunsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/suiteRuns"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSuiteRunsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Lists the test suite runs of the specified test suite based on suite definition ID.
    public var suiteDefinitionId: Swift.String?
    /// Must be passed along with suiteDefinitionId. Lists the test suite runs of the specified test suite based on suite definition version.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct ListSuiteRunsInputBody: Swift.Equatable {
}

extension ListSuiteRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuiteRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteRunsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSuiteRunsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), suiteRunsList: \(Swift.String(describing: suiteRunsList)))"}
}

extension ListSuiteRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSuiteRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteRunsList = output.suiteRunsList
        } else {
            self.nextToken = nil
            self.suiteRunsList = nil
        }
    }
}

public struct ListSuiteRunsOutputResponse: Swift.Equatable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite runs in the list.
    public var suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?

    public init (
        nextToken: Swift.String? = nil,
        suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteRunsList = suiteRunsList
    }
}

struct ListSuiteRunsOutputResponseBody: Swift.Equatable {
    public let suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?
    public let nextToken: Swift.String?
}

extension ListSuiteRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteRunsList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunsListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteRunInformation?].self, forKey: .suiteRunsList)
        var suiteRunsListDecoded0:[IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
        if let suiteRunsListContainer = suiteRunsListContainer {
            suiteRunsListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteRunInformation]()
            for structure0 in suiteRunsListContainer {
                if let structure0 = structure0 {
                    suiteRunsListDecoded0?.append(structure0)
                }
            }
        }
        suiteRunsList = suiteRunsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the IoT Device Advisor resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags attached to the IoT Device Advisor resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a Resource Not Found exception.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Resource Not Found Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartSuiteRunInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSuiteRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSuiteRunOutputError>
}

extension StartSuiteRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSuiteRunInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)), suiteRunConfiguration: \(Swift.String(describing: suiteRunConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension StartSuiteRunInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionVersion = suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunConfiguration = suiteRunConfiguration {
            try encodeContainer.encode(suiteRunConfiguration, forKey: .suiteRunConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartSuiteRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSuiteRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSuiteRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite.
    public var suiteDefinitionVersion: Swift.String?
    /// Suite run configuration.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// The tags to be attached to the suite run.
    public var tags: [Swift.String:Swift.String]?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunConfiguration = suiteRunConfiguration
        self.tags = tags
    }
}

struct StartSuiteRunInputBody: Swift.Equatable {
    public let suiteDefinitionVersion: Swift.String?
    public let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension StartSuiteRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSuiteRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSuiteRunOutputResponse(createdAt: \(Swift.String(describing: createdAt)), suiteRunArn: \(Swift.String(describing: suiteRunArn)), suiteRunId: \(Swift.String(describing: suiteRunId)))"}
}

extension StartSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunId = output.suiteRunId
        } else {
            self.createdAt = nil
            self.suiteRunArn = nil
            self.suiteRunId = nil
        }
    }
}

public struct StartSuiteRunOutputResponse: Swift.Equatable {
    /// Starts a Device Advisor test suite run based on suite create time.
    public var createdAt: ClientRuntime.Date?
    /// Amazon Resource Name (ARN) of the started suite run.
    public var suiteRunArn: Swift.String?
    /// Suite Run ID of the started suite run.
    public var suiteRunId: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteRunArn = suiteRunArn
        self.suiteRunId = suiteRunId
    }
}

struct StartSuiteRunOutputResponseBody: Swift.Equatable {
    public let suiteRunId: Swift.String?
    public let suiteRunArn: Swift.String?
    public let createdAt: ClientRuntime.Date?
}

extension StartSuiteRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case suiteRunArn
        case suiteRunId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopSuiteRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopSuiteRunInput(suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteRunId: \(Swift.String(describing: suiteRunId)))"}
}

extension StopSuiteRunInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopSuiteRunInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopSuiteRunInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopSuiteRunInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSuiteRunInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSuiteRunInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopSuiteRunInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        guard let suiteRunId = input.suiteRunId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteRunId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/stop"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopSuiteRunInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct StopSuiteRunInputBody: Swift.Equatable {
}

extension StopSuiteRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSuiteRunOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopSuiteRunOutputResponse()"}
}

extension StopSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopSuiteRunOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopSuiteRunOutputResponseBody: Swift.Equatable {
}

extension StopSuiteRunOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePermissionRoleArn
        case devices
        case intendedForQualification
        case rootGroup
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePermissionRoleArn = devicePermissionRoleArn {
            try encodeContainer.encode(devicePermissionRoleArn, forKey: .devicePermissionRoleArn)
        }
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for deviceundertestlist0 in devices {
                try devicesContainer.encode(deviceundertestlist0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if let rootGroup = rootGroup {
            try encodeContainer.encode(rootGroup, forKey: .rootGroup)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let devicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .devices)
        var devicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .intendedForQualification)
        intendedForQualification = intendedForQualificationDecoded
        let rootGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootGroup)
        rootGroup = rootGroupDecoded
        let devicePermissionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePermissionRoleArn)
        devicePermissionRoleArn = devicePermissionRoleArnDecoded
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuiteDefinitionConfiguration(devicePermissionRoleArn: \(Swift.String(describing: devicePermissionRoleArn)), devices: \(Swift.String(describing: devices)), intendedForQualification: \(Swift.String(describing: intendedForQualification)), rootGroup: \(Swift.String(describing: rootGroup)), suiteDefinitionName: \(Swift.String(describing: suiteDefinitionName)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Gets Suite Definition Configuration.
    public struct SuiteDefinitionConfiguration: Swift.Equatable {
        /// Gets the device permission ARN.
        public var devicePermissionRoleArn: Swift.String?
        /// Gets the devices configured.
        public var devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Gets the tests intended for qualification in a suite.
        public var intendedForQualification: Swift.Bool
        /// Gets test suite root group.
        public var rootGroup: Swift.String?
        /// Gets Suite Definition Configuration name.
        public var suiteDefinitionName: Swift.String?

        public init (
            devicePermissionRoleArn: Swift.String? = nil,
            devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            rootGroup: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.devicePermissionRoleArn = devicePermissionRoleArn
            self.devices = devices
            self.intendedForQualification = intendedForQualification
            self.rootGroup = rootGroup
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case defaultDevices
        case intendedForQualification
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultDevices = defaultDevices {
            var defaultDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultDevices)
            for deviceundertestlist0 in defaultDevices {
                try defaultDevicesContainer.encode(deviceundertestlist0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if let suiteDefinitionId = suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let defaultDevicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .defaultDevices)
        var defaultDevicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let defaultDevicesContainer = defaultDevicesContainer {
            defaultDevicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in defaultDevicesContainer {
                if let structure0 = structure0 {
                    defaultDevicesDecoded0?.append(structure0)
                }
            }
        }
        defaultDevices = defaultDevicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .intendedForQualification)
        intendedForQualification = intendedForQualificationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuiteDefinitionInformation(createdAt: \(Swift.String(describing: createdAt)), defaultDevices: \(Swift.String(describing: defaultDevices)), intendedForQualification: \(Swift.String(describing: intendedForQualification)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionName: \(Swift.String(describing: suiteDefinitionName)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite definition.
    public struct SuiteDefinitionInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the test suite was created.
        public var createdAt: ClientRuntime.Date?
        /// Specifies the devices that are under test for the test suite.
        public var defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Specifies if the test suite is intended for qualification.
        public var intendedForQualification: Swift.Bool
        /// Suite definition ID of the test suite.
        public var suiteDefinitionId: Swift.String?
        /// Suite name of the test suite.
        public var suiteDefinitionName: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultDevices = defaultDevices
            self.intendedForQualification = intendedForQualification
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parallelRun
        case primaryDevice
        case selectedTestList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if parallelRun != false {
            try encodeContainer.encode(parallelRun, forKey: .parallelRun)
        }
        if let primaryDevice = primaryDevice {
            try encodeContainer.encode(primaryDevice, forKey: .primaryDevice)
        }
        if let selectedTestList = selectedTestList {
            var selectedTestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedTestList)
            for selectedtestlist0 in selectedTestList {
                try selectedTestListContainer.encode(selectedtestlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDeviceDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.DeviceUnderTest.self, forKey: .primaryDevice)
        primaryDevice = primaryDeviceDecoded
        let selectedTestListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedTestList)
        var selectedTestListDecoded0:[Swift.String]? = nil
        if let selectedTestListContainer = selectedTestListContainer {
            selectedTestListDecoded0 = [Swift.String]()
            for string0 in selectedTestListContainer {
                if let string0 = string0 {
                    selectedTestListDecoded0?.append(string0)
                }
            }
        }
        selectedTestList = selectedTestListDecoded0
        let parallelRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .parallelRun)
        parallelRun = parallelRunDecoded
    }
}

extension IotDeviceAdvisorClientTypes.SuiteRunConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuiteRunConfiguration(parallelRun: \(Swift.String(describing: parallelRun)), primaryDevice: \(Swift.String(describing: primaryDevice)), selectedTestList: \(Swift.String(describing: selectedTestList)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Gets suite run configuration.
    public struct SuiteRunConfiguration: Swift.Equatable {
        /// TRUE if multiple test suites run in parallel.
        public var parallelRun: Swift.Bool
        /// Gets the primary device for suite run.
        public var primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest?
        /// Gets test case list.
        public var selectedTestList: [Swift.String]?

        public init (
            parallelRun: Swift.Bool = false,
            primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest? = nil,
            selectedTestList: [Swift.String]? = nil
        )
        {
            self.parallelRun = parallelRun
            self.primaryDevice = primaryDevice
            self.selectedTestList = selectedTestList
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endAt
        case failed
        case passed
        case startedAt
        case status
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
        case suiteRunId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let endAt = endAt {
            try encodeContainer.encode(endAt.timeIntervalSince1970, forKey: .endAt)
        }
        if failed != 0 {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if passed != 0 {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let suiteDefinitionId = suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
        if let suiteDefinitionVersion = suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunId = suiteRunId {
            try encodeContainer.encode(suiteRunId, forKey: .suiteRunId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endAt)
        endAt = endAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let passedDecoded = try containerValues.decode(Swift.Int.self, forKey: .passed)
        passed = passedDecoded
        let failedDecoded = try containerValues.decode(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension IotDeviceAdvisorClientTypes.SuiteRunInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuiteRunInformation(createdAt: \(Swift.String(describing: createdAt)), endAt: \(Swift.String(describing: endAt)), failed: \(Swift.String(describing: failed)), passed: \(Swift.String(describing: passed)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionName: \(Swift.String(describing: suiteDefinitionName)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)), suiteRunId: \(Swift.String(describing: suiteRunId)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite run. Requires permission to access the [SuiteRunInformation](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
    public struct SuiteRunInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the suite run was created.
        public var createdAt: ClientRuntime.Date?
        /// Date (in Unix epoch time) when the suite run ended.
        public var endAt: ClientRuntime.Date?
        /// Number of test cases that failed in the suite run.
        public var failed: Swift.Int
        /// Number of test cases that passed in the suite run.
        public var passed: Swift.Int
        /// Date (in Unix epoch time) when the suite run was started.
        public var startedAt: ClientRuntime.Date?
        /// Status of the suite run.
        public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
        /// Suite definition ID of the suite run.
        public var suiteDefinitionId: Swift.String?
        /// Suite definition name of the suite run.
        public var suiteDefinitionName: Swift.String?
        /// Suite definition version of the suite run.
        public var suiteDefinitionVersion: Swift.String?
        /// Suite run ID of the suite run.
        public var suiteRunId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            endAt: ClientRuntime.Date? = nil,
            failed: Swift.Int = 0,
            passed: Swift.Int = 0,
            startedAt: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil,
            suiteDefinitionVersion: Swift.String? = nil,
            suiteRunId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.endAt = endAt
            self.failed = failed
            self.passed = passed
            self.startedAt = startedAt
            self.status = status
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
            self.suiteDefinitionVersion = suiteDefinitionVersion
            self.suiteRunId = suiteRunId
        }
    }

}

extension IotDeviceAdvisorClientTypes {
    public enum SuiteRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [SuiteRunStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuiteRunStatus(rawValue: rawValue) ?? SuiteRunStatus.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be attached to the IoT Device Advisor resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IotDeviceAdvisorClientTypes.TestCaseRun: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case failure
        case logUrl
        case startTime
        case status
        case testCaseDefinitionId
        case testCaseDefinitionName
        case testCaseRunId
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let failure = failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testCaseDefinitionId = testCaseDefinitionId {
            try encodeContainer.encode(testCaseDefinitionId, forKey: .testCaseDefinitionId)
        }
        if let testCaseDefinitionName = testCaseDefinitionName {
            try encodeContainer.encode(testCaseDefinitionName, forKey: .testCaseDefinitionName)
        }
        if let testCaseRunId = testCaseRunId {
            try encodeContainer.encode(testCaseRunId, forKey: .testCaseRunId)
        }
        if let warnings = warnings {
            try encodeContainer.encode(warnings, forKey: .warnings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseRunId)
        testCaseRunId = testCaseRunIdDecoded
        let testCaseDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionId)
        testCaseDefinitionId = testCaseDefinitionIdDecoded
        let testCaseDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionName)
        testCaseDefinitionName = testCaseDefinitionNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let warningsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warnings)
        warnings = warningsDecoded
        let failureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failure)
        failure = failureDecoded
    }
}

extension IotDeviceAdvisorClientTypes.TestCaseRun: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestCaseRun(endTime: \(Swift.String(describing: endTime)), failure: \(Swift.String(describing: failure)), logUrl: \(Swift.String(describing: logUrl)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), testCaseDefinitionId: \(Swift.String(describing: testCaseDefinitionId)), testCaseDefinitionName: \(Swift.String(describing: testCaseDefinitionName)), testCaseRunId: \(Swift.String(describing: testCaseRunId)), warnings: \(Swift.String(describing: warnings)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Provides the test case run.
    public struct TestCaseRun: Swift.Equatable {
        /// Provides test case run end time.
        public var endTime: ClientRuntime.Date?
        /// Provides test case run failure result.
        public var failure: Swift.String?
        /// Provides test case run log URL.
        public var logUrl: Swift.String?
        /// Provides test case run start time.
        public var startTime: ClientRuntime.Date?
        /// Provides the test case run status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.Status?
        /// Provides the test case run definition ID.
        public var testCaseDefinitionId: Swift.String?
        /// Provides the test case run definition name.
        public var testCaseDefinitionName: Swift.String?
        /// Provides the test case run ID.
        public var testCaseRunId: Swift.String?
        /// Provides test case run warnings.
        public var warnings: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            failure: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.Status? = nil,
            testCaseDefinitionId: Swift.String? = nil,
            testCaseDefinitionName: Swift.String? = nil,
            testCaseRunId: Swift.String? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.failure = failure
            self.logUrl = logUrl
            self.startTime = startTime
            self.status = status
            self.testCaseDefinitionId = testCaseDefinitionId
            self.testCaseDefinitionName = testCaseDefinitionName
            self.testCaseRunId = testCaseRunId
            self.warnings = warnings
        }
    }

}

extension IotDeviceAdvisorClientTypes.TestResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupresultlist0 in groups {
                try groupsContainer.encode(groupresultlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.GroupResult?].self, forKey: .groups)
        var groupsDecoded0:[IotDeviceAdvisorClientTypes.GroupResult]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IotDeviceAdvisorClientTypes.GroupResult]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(groups: \(Swift.String(describing: groups)))"}
}

extension IotDeviceAdvisorClientTypes {
    /// Show each group result.
    public struct TestResult: Swift.Equatable {
        /// Show each group of test results.
        public var groups: [IotDeviceAdvisorClientTypes.GroupResult]?

        public init (
            groups: [IotDeviceAdvisorClientTypes.GroupResult]? = nil
        )
        {
            self.groups = groups
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// List of tag keys to remove from the IoT Device Advisor resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateSuiteDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSuiteDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSuiteDefinitionOutputError>
}

extension UpdateSuiteDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSuiteDefinitionInput(suiteDefinitionConfiguration: \(Swift.String(describing: suiteDefinitionConfiguration)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)))"}
}

extension UpdateSuiteDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
    }
}

public struct UpdateSuiteDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSuiteDefinitionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSuiteDefinitionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSuiteDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let suiteDefinitionId = input.suiteDefinitionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("suiteDefinitionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSuiteDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInput: Swift.Equatable {
    /// Updates a Device Advisor test suite with suite definition configuration.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the test suite to be updated.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init (
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct UpdateSuiteDefinitionInputBody: Swift.Equatable {
    public let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
}

extension UpdateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
    }
}

extension UpdateSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSuiteDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSuiteDefinitionOutputResponse(createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), suiteDefinitionArn: \(Swift.String(describing: suiteDefinitionArn)), suiteDefinitionId: \(Swift.String(describing: suiteDefinitionId)), suiteDefinitionName: \(Swift.String(describing: suiteDefinitionName)), suiteDefinitionVersion: \(Swift.String(describing: suiteDefinitionVersion)))"}
}

extension UpdateSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
            self.suiteDefinitionVersion = nil
        }
    }
}

public struct UpdateSuiteDefinitionOutputResponse: Swift.Equatable {
    /// Timestamp of when the test suite was created.
    public var createdAt: ClientRuntime.Date?
    /// Timestamp of when the test suite was updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Amazon Resource Name (ARN) of the updated test suite.
    public var suiteDefinitionArn: Swift.String?
    /// Suite definition ID of the updated test suite.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition name of the updated test suite.
    public var suiteDefinitionName: Swift.String?
    /// Suite definition version of the updated test suite.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct UpdateSuiteDefinitionOutputResponseBody: Swift.Equatable {
    public let suiteDefinitionId: Swift.String?
    public let suiteDefinitionArn: Swift.String?
    public let suiteDefinitionName: Swift.String?
    public let suiteDefinitionVersion: Swift.String?
    public let createdAt: ClientRuntime.Date?
    public let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastUpdatedAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a validation exception.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Validation Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
