// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptGrantOutputError>
}

extension AcceptGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptGrantInput(grantArn: \(Swift.String(describing: grantArn)))"}
}

extension AcceptGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

public struct AcceptGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptGrantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AcceptGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptGrantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AcceptGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptGrantOutputError>
}

public struct AcceptGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init (
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct AcceptGrantInputBody: Swift.Equatable {
    public let grantArn: Swift.String?
}

extension AcceptGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension AcceptGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptGrantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptGrantOutputResponse(grantArn: \(Swift.String(describing: grantArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension AcceptGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct AcceptGrantOutputResponse: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct AcceptGrantOutputResponseBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let version: Swift.String?
}

extension AcceptGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access to resource denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum AllowedOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checkoutBorrowLicense
        case checkoutLicense
        case checkInLicense
        case createGrant
        case createToken
        case extendConsumptionLicense
        case listPurchasedLicenses
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowedOperation] {
            return [
                .checkoutBorrowLicense,
                .checkoutLicense,
                .checkInLicense,
                .createGrant,
                .createToken,
                .extendConsumptionLicense,
                .listPurchasedLicenses,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checkoutBorrowLicense: return "CheckoutBorrowLicense"
            case .checkoutLicense: return "CheckoutLicense"
            case .checkInLicense: return "CheckInLicense"
            case .createGrant: return "CreateGrant"
            case .createToken: return "CreateToken"
            case .extendConsumptionLicense: return "ExtendConsumptionLicense"
            case .listPurchasedLicenses: return "ListPurchasedLicenses"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowedOperation(rawValue: rawValue) ?? AllowedOperation.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationException(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Web Services user account does not have permission to perform the action. Check the IAM policy associated with this account.
public struct AuthorizationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.AutomatedDiscoveryInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastRunTime = "LastRunTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastRunTime = lastRunTime {
            try encodeContainer.encode(lastRunTime.timeIntervalSince1970, forKey: .lastRunTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastRunTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRunTime)
        lastRunTime = lastRunTimeDecoded
    }
}

extension LicenseManagerClientTypes.AutomatedDiscoveryInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedDiscoveryInformation(lastRunTime: \(Swift.String(describing: lastRunTime)))"}
}

extension LicenseManagerClientTypes {
    /// Describes automated discovery.
    public struct AutomatedDiscoveryInformation: Swift.Equatable {
        /// Time that automated discovery last ran.
        public var lastRunTime: ClientRuntime.Date?

        public init (
            lastRunTime: ClientRuntime.Date? = nil
        )
        {
            self.lastRunTime = lastRunTime
        }
    }

}

extension LicenseManagerClientTypes.BorrowConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowEarlyCheckIn = "AllowEarlyCheckIn"
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowEarlyCheckIn = allowEarlyCheckIn {
            try encodeContainer.encode(allowEarlyCheckIn, forKey: .allowEarlyCheckIn)
        }
        if let maxTimeToLiveInMinutes = maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowEarlyCheckInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowEarlyCheckIn)
        allowEarlyCheckIn = allowEarlyCheckInDecoded
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension LicenseManagerClientTypes.BorrowConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BorrowConfiguration(allowEarlyCheckIn: \(Swift.String(describing: allowEarlyCheckIn)), maxTimeToLiveInMinutes: \(Swift.String(describing: maxTimeToLiveInMinutes)))"}
}

extension LicenseManagerClientTypes {
    /// Details about a borrow configuration.
    public struct BorrowConfiguration: Swift.Equatable {
        /// Indicates whether early check-ins are allowed.
        /// This member is required.
        public var allowEarlyCheckIn: Swift.Bool?
        /// Maximum time for the borrow configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init (
            allowEarlyCheckIn: Swift.Bool? = nil,
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.allowEarlyCheckIn = allowEarlyCheckIn
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

public struct CheckInLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckInLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckInLicenseOutputError>
}

extension CheckInLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckInLicenseInput(beneficiary: \(Swift.String(describing: beneficiary)), licenseConsumptionToken: \(Swift.String(describing: licenseConsumptionToken)))"}
}

extension CheckInLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let licenseConsumptionToken = licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

public struct CheckInLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckInLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckInLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckInLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckInLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckInLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CheckInLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckInLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckInLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CheckInLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckInLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckInLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckInLicenseOutputError>
}

public struct CheckInLicenseInput: Swift.Equatable {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init (
        beneficiary: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct CheckInLicenseInputBody: Swift.Equatable {
    public let licenseConsumptionToken: Swift.String?
    public let beneficiary: Swift.String?
}

extension CheckInLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
    }
}

extension CheckInLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckInLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckInLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckInLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckInLicenseOutputResponse()"}
}

extension CheckInLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CheckInLicenseOutputResponse: Swift.Equatable {

    public init() {}
}

struct CheckInLicenseOutputResponseBody: Swift.Equatable {
}

extension CheckInLicenseOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CheckoutBorrowLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutBorrowLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutBorrowLicenseOutputError>
}

extension CheckoutBorrowLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckoutBorrowLicenseInput(checkoutMetadata: \(Swift.String(describing: checkoutMetadata)), clientToken: \(Swift.String(describing: clientToken)), digitalSignatureMethod: \(Swift.String(describing: digitalSignatureMethod)), entitlements: \(Swift.String(describing: entitlements)), licenseArn: \(Swift.String(describing: licenseArn)), nodeId: \(Swift.String(describing: nodeId)))"}
}

extension CheckoutBorrowLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkoutMetadata = checkoutMetadata {
            var checkoutMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkoutMetadata)
            for metadatalist0 in checkoutMetadata {
                try checkoutMetadataContainer.encode(metadatalist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let digitalSignatureMethod = digitalSignatureMethod {
            try encodeContainer.encode(digitalSignatureMethod.rawValue, forKey: .digitalSignatureMethod)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdatalist0 in entitlements {
                try entitlementsContainer.encode(entitlementdatalist0)
            }
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

public struct CheckoutBorrowLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutBorrowLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutBorrowLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutBorrowLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutBorrowLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CheckoutBorrowLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckoutBorrowLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutBorrowLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CheckoutBorrowLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckoutBorrowLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutBorrowLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutBorrowLicenseOutputError>
}

public struct CheckoutBorrowLicenseInput: Swift.Equatable {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Digital signature method. The possible value is JSON Web Signature (JWS) algorithm PS384. For more information, see [RFC 7518 Digital Signature with RSASSA-PSS](https://tools.ietf.org/html/rfc7518#section-3.5).
    /// This member is required.
    public var digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod?
    /// License entitlements. Partial checkouts are not supported.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Amazon Resource Name (ARN) of the license. The license must use the borrow consumption configuration.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?

    public init (
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        clientToken: Swift.String? = nil,
        digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        licenseArn: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.clientToken = clientToken
        self.digitalSignatureMethod = digitalSignatureMethod
        self.entitlements = entitlements
        self.licenseArn = licenseArn
        self.nodeId = nodeId
    }
}

struct CheckoutBorrowLicenseInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let entitlements: [LicenseManagerClientTypes.EntitlementData]?
    public let digitalSignatureMethod: LicenseManagerClientTypes.DigitalSignatureMethod?
    public let nodeId: Swift.String?
    public let checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    public let clientToken: Swift.String?
}

extension CheckoutBorrowLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case clientToken = "ClientToken"
        case digitalSignatureMethod = "DigitalSignatureMethod"
        case entitlements = "Entitlements"
        case licenseArn = "LicenseArn"
        case nodeId = "NodeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let digitalSignatureMethodDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DigitalSignatureMethod.self, forKey: .digitalSignatureMethod)
        digitalSignatureMethod = digitalSignatureMethodDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CheckoutBorrowLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckoutBorrowLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntitlementNotAllowedException" : self = .entitlementNotAllowedException(try EntitlementNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoEntitlementsAllowedException" : self = .noEntitlementsAllowedException(try NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDigitalSignatureMethodException" : self = .unsupportedDigitalSignatureMethodException(try UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckoutBorrowLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case entitlementNotAllowedException(EntitlementNotAllowedException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noEntitlementsAllowedException(NoEntitlementsAllowedException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case unsupportedDigitalSignatureMethodException(UnsupportedDigitalSignatureMethodException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckoutBorrowLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckoutBorrowLicenseOutputResponse(checkoutMetadata: \(Swift.String(describing: checkoutMetadata)), entitlementsAllowed: \(Swift.String(describing: entitlementsAllowed)), expiration: \(Swift.String(describing: expiration)), issuedAt: \(Swift.String(describing: issuedAt)), licenseArn: \(Swift.String(describing: licenseArn)), licenseConsumptionToken: \(Swift.String(describing: licenseConsumptionToken)), nodeId: \(Swift.String(describing: nodeId)), signedToken: \(Swift.String(describing: signedToken)))"}
}

extension CheckoutBorrowLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CheckoutBorrowLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.checkoutMetadata = output.checkoutMetadata
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseArn = output.licenseArn
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutMetadata = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseArn = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutBorrowLicenseOutputResponse: Swift.Equatable {
    /// Information about constraints.
    public var checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init (
        checkoutMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutMetadata = checkoutMetadata
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutBorrowLicenseOutputResponseBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let licenseConsumptionToken: Swift.String?
    public let entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    public let nodeId: Swift.String?
    public let signedToken: Swift.String?
    public let issuedAt: Swift.String?
    public let expiration: Swift.String?
    public let checkoutMetadata: [LicenseManagerClientTypes.Metadata]?
}

extension CheckoutBorrowLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutMetadata = "CheckoutMetadata"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseArn = "LicenseArn"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let signedTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
        let checkoutMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .checkoutMetadata)
        var checkoutMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let checkoutMetadataContainer = checkoutMetadataContainer {
            checkoutMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in checkoutMetadataContainer {
                if let structure0 = structure0 {
                    checkoutMetadataDecoded0?.append(structure0)
                }
            }
        }
        checkoutMetadata = checkoutMetadataDecoded0
    }
}

public struct CheckoutLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutLicenseOutputError>
}

extension CheckoutLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckoutLicenseInput(beneficiary: \(Swift.String(describing: beneficiary)), checkoutType: \(Swift.String(describing: checkoutType)), clientToken: \(Swift.String(describing: clientToken)), entitlements: \(Swift.String(describing: entitlements)), keyFingerprint: \(Swift.String(describing: keyFingerprint)), nodeId: \(Swift.String(describing: nodeId)), productSKU: \(Swift.String(describing: productSKU)))"}
}

extension CheckoutLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let checkoutType = checkoutType {
            try encodeContainer.encode(checkoutType.rawValue, forKey: .checkoutType)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementdatalist0 in entitlements {
                try entitlementsContainer.encode(entitlementdatalist0)
            }
        }
        if let keyFingerprint = keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
    }
}

public struct CheckoutLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CheckoutLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CheckoutLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CheckoutLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckoutLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CheckoutLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CheckoutLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CheckoutLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CheckoutLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CheckoutLicenseOutputError>
}

public struct CheckoutLicenseInput: Swift.Equatable {
    /// License beneficiary.
    public var beneficiary: Swift.String?
    /// Checkout type.
    /// This member is required.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.EntitlementData]?
    /// Key fingerprint identifying the license.
    /// This member is required.
    public var keyFingerprint: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?

    public init (
        beneficiary: Swift.String? = nil,
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        clientToken: Swift.String? = nil,
        entitlements: [LicenseManagerClientTypes.EntitlementData]? = nil,
        keyFingerprint: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        productSKU: Swift.String? = nil
    )
    {
        self.beneficiary = beneficiary
        self.checkoutType = checkoutType
        self.clientToken = clientToken
        self.entitlements = entitlements
        self.keyFingerprint = keyFingerprint
        self.nodeId = nodeId
        self.productSKU = productSKU
    }
}

struct CheckoutLicenseInputBody: Swift.Equatable {
    public let productSKU: Swift.String?
    public let checkoutType: LicenseManagerClientTypes.CheckoutType?
    public let keyFingerprint: Swift.String?
    public let entitlements: [LicenseManagerClientTypes.EntitlementData]?
    public let clientToken: Swift.String?
    public let beneficiary: Swift.String?
    public let nodeId: Swift.String?
}

extension CheckoutLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case checkoutType = "CheckoutType"
        case clientToken = "ClientToken"
        case entitlements = "Entitlements"
        case keyFingerprint = "KeyFingerprint"
        case nodeId = "NodeId"
        case productSKU = "ProductSKU"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension CheckoutLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckoutLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoEntitlementsAllowedException" : self = .noEntitlementsAllowedException(try NoEntitlementsAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDigitalSignatureMethodException" : self = .unsupportedDigitalSignatureMethodException(try UnsupportedDigitalSignatureMethodException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckoutLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noEntitlementsAllowedException(NoEntitlementsAllowedException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case unsupportedDigitalSignatureMethodException(UnsupportedDigitalSignatureMethodException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckoutLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckoutLicenseOutputResponse(checkoutType: \(Swift.String(describing: checkoutType)), entitlementsAllowed: \(Swift.String(describing: entitlementsAllowed)), expiration: \(Swift.String(describing: expiration)), issuedAt: \(Swift.String(describing: issuedAt)), licenseArn: \(Swift.String(describing: licenseArn)), licenseConsumptionToken: \(Swift.String(describing: licenseConsumptionToken)), nodeId: \(Swift.String(describing: nodeId)), signedToken: \(Swift.String(describing: signedToken)))"}
}

extension CheckoutLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CheckoutLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.checkoutType = output.checkoutType
            self.entitlementsAllowed = output.entitlementsAllowed
            self.expiration = output.expiration
            self.issuedAt = output.issuedAt
            self.licenseArn = output.licenseArn
            self.licenseConsumptionToken = output.licenseConsumptionToken
            self.nodeId = output.nodeId
            self.signedToken = output.signedToken
        } else {
            self.checkoutType = nil
            self.entitlementsAllowed = nil
            self.expiration = nil
            self.issuedAt = nil
            self.licenseArn = nil
            self.licenseConsumptionToken = nil
            self.nodeId = nil
            self.signedToken = nil
        }
    }
}

public struct CheckoutLicenseOutputResponse: Swift.Equatable {
    /// Checkout type.
    public var checkoutType: LicenseManagerClientTypes.CheckoutType?
    /// Allowed license entitlements.
    public var entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    /// Date and time at which the license checkout expires.
    public var expiration: Swift.String?
    /// Date and time at which the license checkout is issued.
    public var issuedAt: Swift.String?
    /// Amazon Resource Name (ARN) of the checkout license.
    public var licenseArn: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?
    /// Node ID.
    public var nodeId: Swift.String?
    /// Signed token.
    public var signedToken: Swift.String?

    public init (
        checkoutType: LicenseManagerClientTypes.CheckoutType? = nil,
        entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]? = nil,
        expiration: Swift.String? = nil,
        issuedAt: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        signedToken: Swift.String? = nil
    )
    {
        self.checkoutType = checkoutType
        self.entitlementsAllowed = entitlementsAllowed
        self.expiration = expiration
        self.issuedAt = issuedAt
        self.licenseArn = licenseArn
        self.licenseConsumptionToken = licenseConsumptionToken
        self.nodeId = nodeId
        self.signedToken = signedToken
    }
}

struct CheckoutLicenseOutputResponseBody: Swift.Equatable {
    public let checkoutType: LicenseManagerClientTypes.CheckoutType?
    public let licenseConsumptionToken: Swift.String?
    public let entitlementsAllowed: [LicenseManagerClientTypes.EntitlementData]?
    public let signedToken: Swift.String?
    public let nodeId: Swift.String?
    public let issuedAt: Swift.String?
    public let expiration: Swift.String?
    public let licenseArn: Swift.String?
}

extension CheckoutLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkoutType = "CheckoutType"
        case entitlementsAllowed = "EntitlementsAllowed"
        case expiration = "Expiration"
        case issuedAt = "IssuedAt"
        case licenseArn = "LicenseArn"
        case licenseConsumptionToken = "LicenseConsumptionToken"
        case nodeId = "NodeId"
        case signedToken = "SignedToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkoutTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.CheckoutType.self, forKey: .checkoutType)
        checkoutType = checkoutTypeDecoded
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let entitlementsAllowedContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementData?].self, forKey: .entitlementsAllowed)
        var entitlementsAllowedDecoded0:[LicenseManagerClientTypes.EntitlementData]? = nil
        if let entitlementsAllowedContainer = entitlementsAllowedContainer {
            entitlementsAllowedDecoded0 = [LicenseManagerClientTypes.EntitlementData]()
            for structure0 in entitlementsAllowedContainer {
                if let structure0 = structure0 {
                    entitlementsAllowedDecoded0?.append(structure0)
                }
            }
        }
        entitlementsAllowed = entitlementsAllowedDecoded0
        let signedTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedToken)
        signedToken = signedTokenDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum CheckoutType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case perpetual
        case provisional
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckoutType] {
            return [
                .perpetual,
                .provisional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .perpetual: return "PERPETUAL"
            case .provisional: return "PROVISIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CheckoutType(rawValue: rawValue) ?? CheckoutType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.ConsumedLicenseSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedLicenses = "ConsumedLicenses"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension LicenseManagerClientTypes.ConsumedLicenseSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConsumedLicenseSummary(consumedLicenses: \(Swift.String(describing: consumedLicenses)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Details about license consumption.
    public struct ConsumedLicenseSummary: Swift.Equatable {
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Resource type of the resource consuming a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            consumedLicenses: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.consumedLicenses = consumedLicenses
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.ConsumptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case borrowConfiguration = "BorrowConfiguration"
        case provisionalConfiguration = "ProvisionalConfiguration"
        case renewType = "RenewType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let borrowConfiguration = borrowConfiguration {
            try encodeContainer.encode(borrowConfiguration, forKey: .borrowConfiguration)
        }
        if let provisionalConfiguration = provisionalConfiguration {
            try encodeContainer.encode(provisionalConfiguration, forKey: .provisionalConfiguration)
        }
        if let renewType = renewType {
            try encodeContainer.encode(renewType.rawValue, forKey: .renewType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renewTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.RenewType.self, forKey: .renewType)
        renewType = renewTypeDecoded
        let provisionalConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ProvisionalConfiguration.self, forKey: .provisionalConfiguration)
        provisionalConfiguration = provisionalConfigurationDecoded
        let borrowConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.BorrowConfiguration.self, forKey: .borrowConfiguration)
        borrowConfiguration = borrowConfigurationDecoded
    }
}

extension LicenseManagerClientTypes.ConsumptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConsumptionConfiguration(borrowConfiguration: \(Swift.String(describing: borrowConfiguration)), provisionalConfiguration: \(Swift.String(describing: provisionalConfiguration)), renewType: \(Swift.String(describing: renewType)))"}
}

extension LicenseManagerClientTypes {
    /// Details about a consumption configuration.
    public struct ConsumptionConfiguration: Swift.Equatable {
        /// Details about a borrow configuration.
        public var borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration?
        /// Details about a provisional configuration.
        public var provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration?
        /// Renewal frequency.
        public var renewType: LicenseManagerClientTypes.RenewType?

        public init (
            borrowConfiguration: LicenseManagerClientTypes.BorrowConfiguration? = nil,
            provisionalConfiguration: LicenseManagerClientTypes.ProvisionalConfiguration? = nil,
            renewType: LicenseManagerClientTypes.RenewType? = nil
        )
        {
            self.borrowConfiguration = borrowConfiguration
            self.provisionalConfiguration = provisionalConfiguration
            self.renewType = renewType
        }
    }

}

public struct CreateGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantOutputError>
}

extension CreateGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGrantInput(allowedOperations: \(Swift.String(describing: allowedOperations)), clientToken: \(Swift.String(describing: clientToken)), grantName: \(Swift.String(describing: grantName)), homeRegion: \(Swift.String(describing: homeRegion)), licenseArn: \(Swift.String(describing: licenseArn)), principals: \(Swift.String(describing: principals)))"}
}

extension CreateGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnlist0 in principals {
                try principalsContainer.encode(principalarnlist0)
            }
        }
    }
}

public struct CreateGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantOutputError>
}

public struct CreateGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantOutputError>
}

public struct CreateGrantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantOutputError>
}

public struct CreateGrantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantOutputError>
}

public struct CreateGrantInput: Swift.Equatable {
    /// Allowed operations for the grant.
    /// This member is required.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Grant name.
    /// This member is required.
    public var grantName: Swift.String?
    /// Home Region of the grant.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// The grant principals.
    /// This member is required.
    public var principals: [Swift.String]?

    public init (
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantName: Swift.String? = nil,
        homeRegion: Swift.String? = nil,
        licenseArn: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantName = grantName
        self.homeRegion = homeRegion
        self.licenseArn = licenseArn
        self.principals = principals
    }
}

struct CreateGrantInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let grantName: Swift.String?
    public let licenseArn: Swift.String?
    public let principals: [Swift.String]?
    public let homeRegion: Swift.String?
    public let allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
}

extension CreateGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantName = "GrantName"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case principals = "Principals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension CreateGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGrantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGrantOutputResponse(grantArn: \(Swift.String(describing: grantArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension CreateGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantOutputResponse: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantOutputResponseBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let version: Swift.String?
}

extension CreateGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateGrantVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantVersionOutputError>
}

extension CreateGrantVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGrantVersionInput(allowedOperations: \(Swift.String(describing: allowedOperations)), clientToken: \(Swift.String(describing: clientToken)), grantArn: \(Swift.String(describing: grantArn)), grantName: \(Swift.String(describing: grantName)), sourceVersion: \(Swift.String(describing: sourceVersion)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension CreateGrantVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }
}

public struct CreateGrantVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGrantVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGrantVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGrantVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGrantVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGrantVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGrantVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGrantVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGrantVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGrantVersionOutputError>
}

public struct CreateGrantVersionInput: Swift.Equatable {
    /// Allowed operations for the grant.
    public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant name.
    public var grantName: Swift.String?
    /// Current version of the grant.
    public var sourceVersion: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant status reason.
    public var statusReason: Swift.String?

    public init (
        allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
        clientToken: Swift.String? = nil,
        grantArn: Swift.String? = nil,
        grantName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.allowedOperations = allowedOperations
        self.clientToken = clientToken
        self.grantArn = grantArn
        self.grantName = grantName
        self.sourceVersion = sourceVersion
        self.status = status
        self.statusReason = statusReason
    }
}

struct CreateGrantVersionInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let grantArn: Swift.String?
    public let grantName: Swift.String?
    public let allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let statusReason: Swift.String?
    public let sourceVersion: Swift.String?
}

extension CreateGrantVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case clientToken = "ClientToken"
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CreateGrantVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGrantVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGrantVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGrantVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGrantVersionOutputResponse(grantArn: \(Swift.String(describing: grantArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension CreateGrantVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGrantVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateGrantVersionOutputResponse: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// New version of the grant.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct CreateGrantVersionOutputResponseBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let version: Swift.String?
}

extension CreateGrantVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConfigurationOutputError>
}

extension CreateLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseConfigurationInput(description: \(Swift.String(describing: description)), disassociateWhenNotFound: \(Swift.String(describing: disassociateWhenNotFound)), licenseCount: \(Swift.String(describing: licenseCount)), licenseCountHardLimit: \(Swift.String(describing: licenseCountHardLimit)), licenseCountingType: \(Swift.String(describing: licenseCountingType)), licenseRules: \(Swift.String(describing: licenseRules)), name: \(Swift.String(describing: name)), productInformationList: \(Swift.String(describing: productInformationList)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConfigurationOutputError>
}

public struct CreateLicenseConfigurationInput: Swift.Equatable {
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension used to track the license inventory.
    /// This member is required.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.
    ///
    /// * Cores dimension: allowedTenancy | licenseAffinityToHost | maximumCores | minimumCores
    ///
    /// * Instances dimension: allowedTenancy | maximumCores | minimumCores | maximumSockets | minimumSockets | maximumVcpus | minimumVcpus
    ///
    /// * Sockets dimension: allowedTenancy | licenseAffinityToHost | maximumSockets | minimumSockets
    ///
    /// * vCPUs dimension: allowedTenancy | honorVcpuOptimization | maximumVcpus | minimumVcpus
    ///
    ///
    /// The unit for licenseAffinityToHost is days and the range is 1 to 180. The possible values for allowedTenancy are EC2-Default, EC2-DedicatedHost, and EC2-DedicatedInstance. The possible values for honorVcpuOptimization are True and False.
    public var licenseRules: [Swift.String]?
    /// Name of the license configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// Tags to add to the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
        self.tags = tags
    }
}

struct CreateLicenseConfigurationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    public let licenseCount: Swift.Int?
    public let licenseCountHardLimit: Swift.Bool?
    public let licenseRules: [Swift.String]?
    public let tags: [LicenseManagerClientTypes.Tag]?
    public let disassociateWhenNotFound: Swift.Bool?
    public let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
}

extension CreateLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
    }
}

extension CreateLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseConfigurationOutputResponse(licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)))"}
}

extension CreateLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationArn = output.licenseConfigurationArn
        } else {
            self.licenseConfigurationArn = nil
        }
    }
}

public struct CreateLicenseConfigurationOutputResponse: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?

    public init (
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct CreateLicenseConfigurationOutputResponseBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
}

extension CreateLicenseConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

public struct CreateLicenseConversionTaskForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConversionTaskForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConversionTaskForResourceOutputError>
}

extension CreateLicenseConversionTaskForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseConversionTaskForResourceInput(destinationLicenseContext: \(Swift.String(describing: destinationLicenseContext)), resourceArn: \(Swift.String(describing: resourceArn)), sourceLicenseContext: \(Swift.String(describing: sourceLicenseContext)))"}
}

extension CreateLicenseConversionTaskForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationLicenseContext = destinationLicenseContext {
            try encodeContainer.encode(destinationLicenseContext, forKey: .destinationLicenseContext)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceLicenseContext = sourceLicenseContext {
            try encodeContainer.encode(sourceLicenseContext, forKey: .sourceLicenseContext)
        }
    }
}

public struct CreateLicenseConversionTaskForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConversionTaskForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConversionTaskForResourceOutputError>
}

public struct CreateLicenseConversionTaskForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConversionTaskForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseConversionTaskForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConversionTaskForResourceOutputError>
}

public struct CreateLicenseConversionTaskForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConversionTaskForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseConversionTaskForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseConversionTaskForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConversionTaskForResourceOutputError>
}

public struct CreateLicenseConversionTaskForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseConversionTaskForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseConversionTaskForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseConversionTaskForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseConversionTaskForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseConversionTaskForResourceOutputError>
}

public struct CreateLicenseConversionTaskForResourceInput: Swift.Equatable {
    /// Information that identifies the license type you are converting to. For the structure of the destination license, see [Convert a license type using the AWS CLI](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Amazon Resource Name (ARN) of the resource you are converting the license type for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Information that identifies the license type you are converting from. For the structure of the source license, see [Convert a license type using the AWS CLI](https://docs.aws.amazon.com/license-manager/latest/userguide/conversion-procedures.html#conversion-cli) in the License Manager User Guide.
    /// This member is required.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?

    public init (
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
    }
}

struct CreateLicenseConversionTaskForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    public let destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
}

extension CreateLicenseConversionTaskForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
    }
}

extension CreateLicenseConversionTaskForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseConversionTaskForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseConversionTaskForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseConversionTaskForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseConversionTaskForResourceOutputResponse(licenseConversionTaskId: \(Swift.String(describing: licenseConversionTaskId)))"}
}

extension CreateLicenseConversionTaskForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLicenseConversionTaskForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConversionTaskId = output.licenseConversionTaskId
        } else {
            self.licenseConversionTaskId = nil
        }
    }
}

public struct CreateLicenseConversionTaskForResourceOutputResponse: Swift.Equatable {
    /// The ID of the created license type conversion task.
    public var licenseConversionTaskId: Swift.String?

    public init (
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

struct CreateLicenseConversionTaskForResourceOutputResponseBody: Swift.Equatable {
    public let licenseConversionTaskId: Swift.String?
}

extension CreateLicenseConversionTaskForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
    }
}

public struct CreateLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseOutputError>
}

extension CreateLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseInput(beneficiary: \(Swift.String(describing: beneficiary)), clientToken: \(Swift.String(describing: clientToken)), consumptionConfiguration: \(Swift.String(describing: consumptionConfiguration)), entitlements: \(Swift.String(describing: entitlements)), homeRegion: \(Swift.String(describing: homeRegion)), issuer: \(Swift.String(describing: issuer)), licenseMetadata: \(Swift.String(describing: licenseMetadata)), licenseName: \(Swift.String(describing: licenseName)), productName: \(Swift.String(describing: productName)), productSKU: \(Swift.String(describing: productSKU)), validity: \(Swift.String(describing: validity)))"}
}

extension CreateLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseOutputError>
}

public struct CreateLicenseInput: Swift.Equatable {
    /// License beneficiary.
    /// This member is required.
    public var beneficiary: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region for the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Product SKU.
    /// This member is required.
    public var productSKU: Swift.String?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init (
        beneficiary: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        productSKU: Swift.String? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.beneficiary = beneficiary
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.productSKU = productSKU
        self.validity = validity
    }
}

struct CreateLicenseInputBody: Swift.Equatable {
    public let licenseName: Swift.String?
    public let productName: Swift.String?
    public let productSKU: Swift.String?
    public let issuer: LicenseManagerClientTypes.Issuer?
    public let homeRegion: Swift.String?
    public let validity: LicenseManagerClientTypes.DatetimeRange?
    public let entitlements: [LicenseManagerClientTypes.Entitlement]?
    public let beneficiary: Swift.String?
    public let consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    public let licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    public let clientToken: Swift.String?
}

extension CreateLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct CreateLicenseManagerReportGeneratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

extension CreateLicenseManagerReportGeneratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseManagerReportGeneratorInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), reportContext: \(Swift.String(describing: reportContext)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportGeneratorName: \(Swift.String(describing: reportGeneratorName)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateLicenseManagerReportGeneratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttypelist0 in type {
                try typeContainer.encode(reporttypelist0.rawValue)
            }
        }
    }
}

public struct CreateLicenseManagerReportGeneratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseManagerReportGeneratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseManagerReportGeneratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseManagerReportGeneratorOutputError>
}

public struct CreateLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Defines the type of license configuration the report generator tracks.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated. Reports can be generated daily, monthly, or weekly.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Tags to add to the report generator.
    public var tags: [LicenseManagerClientTypes.Tag]?
    /// Type of reports to generate. The following report types an be generated:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.tags = tags
        self.type = type
    }
}

struct CreateLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    public let reportGeneratorName: Swift.String?
    public let type: [LicenseManagerClientTypes.ReportType]?
    public let reportContext: LicenseManagerClientTypes.ReportContext?
    public let reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    public let clientToken: Swift.String?
    public let description: Swift.String?
    public let tags: [LicenseManagerClientTypes.Tag]?
}

extension CreateLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .type)
        var typeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseManagerReportGeneratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseManagerReportGeneratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseManagerReportGeneratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseManagerReportGeneratorOutputResponse(licenseManagerReportGeneratorArn: \(Swift.String(describing: licenseManagerReportGeneratorArn)))"}
}

extension CreateLicenseManagerReportGeneratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLicenseManagerReportGeneratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseManagerReportGeneratorArn = output.licenseManagerReportGeneratorArn
        } else {
            self.licenseManagerReportGeneratorArn = nil
        }
    }
}

public struct CreateLicenseManagerReportGeneratorOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new report generator.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init (
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct CreateLicenseManagerReportGeneratorOutputResponseBody: Swift.Equatable {
    public let licenseManagerReportGeneratorArn: Swift.String?
}

extension CreateLicenseManagerReportGeneratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension CreateLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseOutputResponse(licenseArn: \(Swift.String(describing: licenseArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension CreateLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseOutputResponse: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// License version.
    public var version: Swift.String?

    public init (
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseOutputResponseBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let status: LicenseManagerClientTypes.LicenseStatus?
    public let version: Swift.String?
}

extension CreateLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct CreateLicenseVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseVersionOutputError>
}

extension CreateLicenseVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseVersionInput(clientToken: \(Swift.String(describing: clientToken)), consumptionConfiguration: \(Swift.String(describing: consumptionConfiguration)), entitlements: \(Swift.String(describing: entitlements)), homeRegion: \(Swift.String(describing: homeRegion)), issuer: \(Swift.String(describing: issuer)), licenseArn: \(Swift.String(describing: licenseArn)), licenseMetadata: \(Swift.String(describing: licenseMetadata)), licenseName: \(Swift.String(describing: licenseName)), productName: \(Swift.String(describing: productName)), sourceVersion: \(Swift.String(describing: sourceVersion)), status: \(Swift.String(describing: status)), validity: \(Swift.String(describing: validity)))"}
}

extension CreateLicenseVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

public struct CreateLicenseVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLicenseVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLicenseVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateLicenseVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLicenseVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLicenseVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLicenseVersionOutputError>
}

public struct CreateLicenseVersionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Configuration for consumption of the license. Choose a provisional configuration for workloads running with continuous connectivity. Choose a borrow configuration for workloads with offline usage.
    /// This member is required.
    public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    /// License entitlements.
    /// This member is required.
    public var entitlements: [LicenseManagerClientTypes.Entitlement]?
    /// Home Region of the license.
    /// This member is required.
    public var homeRegion: Swift.String?
    /// License issuer.
    /// This member is required.
    public var issuer: LicenseManagerClientTypes.Issuer?
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Information about the license.
    public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    /// License name.
    /// This member is required.
    public var licenseName: Swift.String?
    /// Product name.
    /// This member is required.
    public var productName: Swift.String?
    /// Current version of the license.
    public var sourceVersion: Swift.String?
    /// License status.
    /// This member is required.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// Date and time range during which the license is valid, in ISO8601-UTC format.
    /// This member is required.
    public var validity: LicenseManagerClientTypes.DatetimeRange?

    public init (
        clientToken: Swift.String? = nil,
        consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
        entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
        homeRegion: Swift.String? = nil,
        issuer: LicenseManagerClientTypes.Issuer? = nil,
        licenseArn: Swift.String? = nil,
        licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
        licenseName: Swift.String? = nil,
        productName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        validity: LicenseManagerClientTypes.DatetimeRange? = nil
    )
    {
        self.clientToken = clientToken
        self.consumptionConfiguration = consumptionConfiguration
        self.entitlements = entitlements
        self.homeRegion = homeRegion
        self.issuer = issuer
        self.licenseArn = licenseArn
        self.licenseMetadata = licenseMetadata
        self.licenseName = licenseName
        self.productName = productName
        self.sourceVersion = sourceVersion
        self.status = status
        self.validity = validity
    }
}

struct CreateLicenseVersionInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let licenseName: Swift.String?
    public let productName: Swift.String?
    public let issuer: LicenseManagerClientTypes.Issuer?
    public let homeRegion: Swift.String?
    public let validity: LicenseManagerClientTypes.DatetimeRange?
    public let licenseMetadata: [LicenseManagerClientTypes.Metadata]?
    public let entitlements: [LicenseManagerClientTypes.Entitlement]?
    public let consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
    public let status: LicenseManagerClientTypes.LicenseStatus?
    public let clientToken: Swift.String?
    public let sourceVersion: Swift.String?
}

extension CreateLicenseVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case sourceVersion = "SourceVersion"
        case status = "Status"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Issuer.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension CreateLicenseVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLicenseVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLicenseVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLicenseVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseVersionOutputResponse(licenseArn: \(Swift.String(describing: licenseArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension CreateLicenseVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLicenseVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseArn = output.licenseArn
            self.status = output.status
            self.version = output.version
        } else {
            self.licenseArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct CreateLicenseVersionOutputResponse: Swift.Equatable {
    /// License ARN.
    public var licenseArn: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseStatus?
    /// New version of the license.
    public var version: Swift.String?

    public init (
        licenseArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.status = status
        self.version = version
    }
}

struct CreateLicenseVersionOutputResponseBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let version: Swift.String?
    public let status: LicenseManagerClientTypes.LicenseStatus?
}

extension CreateLicenseVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

extension CreateTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenInput(clientToken: \(Swift.String(describing: clientToken)), expirationInDays: \(Swift.String(describing: expirationInDays)), licenseArn: \(Swift.String(describing: licenseArn)), roleArns: \(Swift.String(describing: roleArns)), tokenProperties: \(Swift.String(describing: tokenProperties)))"}
}

extension CreateTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let expirationInDays = expirationInDays {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arnlist0 in roleArns {
                try roleArnsContainer.encode(arnlist0)
            }
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
    }
}

public struct CreateTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInput: Swift.Equatable {
    /// Idempotency token, valid for 10 minutes.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Token expiration, in days, counted from token creation. The default is 365 days.
    public var expirationInDays: Swift.Int?
    /// Amazon Resource Name (ARN) of the license. The ARN is mapped to the aud claim of the JWT token.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Amazon Resource Name (ARN) of the IAM roles to embed in the token. License Manager does not check whether the roles are in use.
    public var roleArns: [Swift.String]?
    /// Data specified by the caller to be included in the JWT token. The data is mapped to the amr claim of the JWT token.
    public var tokenProperties: [Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        expirationInDays: Swift.Int? = nil,
        licenseArn: Swift.String? = nil,
        roleArns: [Swift.String]? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInDays = expirationInDays
        self.licenseArn = licenseArn
        self.roleArns = roleArns
        self.tokenProperties = tokenProperties
    }
}

struct CreateTokenInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let roleArns: [Swift.String]?
    public let expirationInDays: Swift.Int?
    public let tokenProperties: [Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case expirationInDays = "ExpirationInDays"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case tokenProperties = "TokenProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenOutputResponse(token: \(Swift.String(describing: token)), tokenId: \(Swift.String(describing: tokenId)), tokenType: \(Swift.String(describing: tokenType)))"}
}

extension CreateTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.token = output.token
            self.tokenId = output.tokenId
            self.tokenType = output.tokenType
        } else {
            self.token = nil
            self.tokenId = nil
            self.tokenType = nil
        }
    }
}

public struct CreateTokenOutputResponse: Swift.Equatable {
    /// Refresh token, encoded as a JWT token.
    public var token: Swift.String?
    /// Token ID.
    public var tokenId: Swift.String?
    /// Token type.
    public var tokenType: LicenseManagerClientTypes.TokenType?

    public init (
        token: Swift.String? = nil,
        tokenId: Swift.String? = nil,
        tokenType: LicenseManagerClientTypes.TokenType? = nil
    )
    {
        self.token = token
        self.tokenId = tokenId
        self.tokenType = tokenType
    }
}

struct CreateTokenOutputResponseBody: Swift.Equatable {
    public let tokenId: Swift.String?
    public let tokenType: LicenseManagerClientTypes.TokenType?
    public let token: Swift.String?
}

extension CreateTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenId = "TokenId"
        case tokenType = "TokenType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.TokenType.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension LicenseManagerClientTypes.DatetimeRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case begin = "Begin"
        case end = "End"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let begin = begin {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
    }
}

extension LicenseManagerClientTypes.DatetimeRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatetimeRange(begin: \(Swift.String(describing: begin)), end: \(Swift.String(describing: end)))"}
}

extension LicenseManagerClientTypes {
    /// Describes a time range, in ISO8601-UTC format.
    public struct DatetimeRange: Swift.Equatable {
        /// Start of the time range.
        /// This member is required.
        public var begin: Swift.String?
        /// End of the time range.
        public var end: Swift.String?

        public init (
            begin: Swift.String? = nil,
            end: Swift.String? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

public struct DeleteGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGrantOutputError>
}

extension DeleteGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGrantInput(grantArn: \(Swift.String(describing: grantArn)), statusReason: \(Swift.String(describing: statusReason)), version: \(Swift.String(describing: version)))"}
}

extension DeleteGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct DeleteGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGrantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGrantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGrantOutputError>
}

public struct DeleteGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// The Status reason for the delete request.
    public var statusReason: Swift.String?
    /// Current version of the grant.
    /// This member is required.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        statusReason: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.statusReason = statusReason
        self.version = version
    }
}

struct DeleteGrantInputBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let statusReason: Swift.String?
    public let version: Swift.String?
}

extension DeleteGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DeleteGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGrantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGrantOutputResponse(grantArn: \(Swift.String(describing: grantArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension DeleteGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct DeleteGrantOutputResponse: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct DeleteGrantOutputResponseBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let version: Swift.String?
}

extension DeleteGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct DeleteLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseConfigurationOutputError>
}

extension DeleteLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseConfigurationInput(licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)))"}
}

extension DeleteLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

public struct DeleteLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseConfigurationOutputError>
}

public struct DeleteLicenseConfigurationInput: Swift.Equatable {
    /// ID of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init (
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct DeleteLicenseConfigurationInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
}

extension DeleteLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension DeleteLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseConfigurationOutputResponse()"}
}

extension DeleteLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLicenseConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLicenseConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteLicenseConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseOutputError>
}

extension DeleteLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseInput(licenseArn: \(Swift.String(describing: licenseArn)), sourceVersion: \(Swift.String(describing: sourceVersion)))"}
}

extension DeleteLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

public struct DeleteLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseOutputError>
}

public struct DeleteLicenseInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Current version of the license.
    /// This member is required.
    public var sourceVersion: Swift.String?

    public init (
        licenseArn: Swift.String? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.sourceVersion = sourceVersion
    }
}

struct DeleteLicenseInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let sourceVersion: Swift.String?
}

extension DeleteLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case sourceVersion = "SourceVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

public struct DeleteLicenseManagerReportGeneratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

extension DeleteLicenseManagerReportGeneratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseManagerReportGeneratorInput(licenseManagerReportGeneratorArn: \(Swift.String(describing: licenseManagerReportGeneratorArn)))"}
}

extension DeleteLicenseManagerReportGeneratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

public struct DeleteLicenseManagerReportGeneratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseManagerReportGeneratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLicenseManagerReportGeneratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLicenseManagerReportGeneratorOutputError>
}

public struct DeleteLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the report generator to be deleted.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init (
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct DeleteLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    public let licenseManagerReportGeneratorArn: Swift.String?
}

extension DeleteLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension DeleteLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseManagerReportGeneratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseManagerReportGeneratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseManagerReportGeneratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseManagerReportGeneratorOutputResponse()"}
}

extension DeleteLicenseManagerReportGeneratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLicenseManagerReportGeneratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLicenseManagerReportGeneratorOutputResponseBody: Swift.Equatable {
}

extension DeleteLicenseManagerReportGeneratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLicenseOutputResponse(deletionDate: \(Swift.String(describing: deletionDate)), status: \(Swift.String(describing: status)))"}
}

extension DeleteLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deletionDate = output.deletionDate
            self.status = output.status
        } else {
            self.deletionDate = nil
            self.status = nil
        }
    }
}

public struct DeleteLicenseOutputResponse: Swift.Equatable {
    /// Date when the license is deleted.
    public var deletionDate: Swift.String?
    /// License status.
    public var status: LicenseManagerClientTypes.LicenseDeletionStatus?

    public init (
        deletionDate: Swift.String? = nil,
        status: LicenseManagerClientTypes.LicenseDeletionStatus? = nil
    )
    {
        self.deletionDate = deletionDate
        self.status = status
    }
}

struct DeleteLicenseOutputResponseBody: Swift.Equatable {
    public let status: LicenseManagerClientTypes.LicenseDeletionStatus?
    public let deletionDate: Swift.String?
}

extension DeleteLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionDate = "DeletionDate"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseDeletionStatus.self, forKey: .status)
        status = statusDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
    }
}

public struct DeleteTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

extension DeleteTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTokenInput(tokenId: \(Swift.String(describing: tokenId)))"}
}

extension DeleteTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tokenId = "TokenId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tokenId = tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }
}

public struct DeleteTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInput: Swift.Equatable {
    /// Token ID.
    /// This member is required.
    public var tokenId: Swift.String?

    public init (
        tokenId: Swift.String? = nil
    )
    {
        self.tokenId = tokenId
    }
}

struct DeleteTokenInputBody: Swift.Equatable {
    public let tokenId: Swift.String?
}

extension DeleteTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tokenId = "TokenId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
    }
}

extension DeleteTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RedirectException" : self = .redirectException(try RedirectException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case redirectException(RedirectException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTokenOutputResponse()"}
}

extension DeleteTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTokenOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTokenOutputResponseBody: Swift.Equatable {
}

extension DeleteTokenOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LicenseManagerClientTypes {
    public enum DigitalSignatureMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jwtPs384
        case sdkUnknown(Swift.String)

        public static var allCases: [DigitalSignatureMethod] {
            return [
                .jwtPs384,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jwtPs384: return "JWT_PS384"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DigitalSignatureMethod(rawValue: rawValue) ?? DigitalSignatureMethod.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.Entitlement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCheckIn = "AllowCheckIn"
        case maxCount = "MaxCount"
        case name = "Name"
        case overage = "Overage"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCheckIn = allowCheckIn {
            try encodeContainer.encode(allowCheckIn, forKey: .allowCheckIn)
        }
        if let maxCount = maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overage = overage {
            try encodeContainer.encode(overage, forKey: .overage)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let overageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overage)
        overage = overageDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementUnit.self, forKey: .unit)
        unit = unitDecoded
        let allowCheckInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCheckIn)
        allowCheckIn = allowCheckInDecoded
    }
}

extension LicenseManagerClientTypes.Entitlement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Entitlement(allowCheckIn: \(Swift.String(describing: allowCheckIn)), maxCount: \(Swift.String(describing: maxCount)), name: \(Swift.String(describing: name)), overage: \(Swift.String(describing: overage)), unit: \(Swift.String(describing: unit)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// Describes a resource entitled for use with a license.
    public struct Entitlement: Swift.Equatable {
        /// Indicates whether check-ins are allowed.
        public var allowCheckIn: Swift.Bool?
        /// Maximum entitlement count. Use if the unit is not None.
        public var maxCount: Swift.Int?
        /// Entitlement name.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether overages are allowed.
        public var overage: Swift.Bool?
        /// Entitlement unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementUnit?
        /// Entitlement resource. Use only if the unit is None.
        public var value: Swift.String?

        public init (
            allowCheckIn: Swift.Bool? = nil,
            maxCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            overage: Swift.Bool? = nil,
            unit: LicenseManagerClientTypes.EntitlementUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowCheckIn = allowCheckIn
            self.maxCount = maxCount
            self.name = name
            self.overage = overage
            self.unit = unit
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes.EntitlementData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LicenseManagerClientTypes.EntitlementData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntitlementData(name: \(Swift.String(describing: name)), unit: \(Swift.String(describing: unit)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// Data associated with an entitlement resource.
    public struct EntitlementData: Swift.Equatable {
        /// Entitlement data name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement data unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?
        /// Entitlement data value.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.unit = unit
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum EntitlementDataUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementDataUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementDataUnit(rawValue: rawValue) ?? EntitlementDataUnit.sdkUnknown(rawValue)
        }
    }
}

extension EntitlementNotAllowedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntitlementNotAllowedException(message: \(Swift.String(describing: message)))"}
}

extension EntitlementNotAllowedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntitlementNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The entitlement is not allowed.
public struct EntitlementNotAllowedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntitlementNotAllowedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EntitlementNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum EntitlementUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitsPerSecond
        case bytes
        case bytesPerSecond
        case count
        case countPerSecond
        case gigabits
        case gigabitsPerSecond
        case gigabytes
        case gigabytesPerSecond
        case kilobits
        case kilobitsPerSecond
        case kilobytes
        case kilobytesPerSecond
        case megabits
        case megabitsPerSecond
        case megabytes
        case megabytesPerSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsPerSecond
        case terabytes
        case terabytesPerSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementUnit] {
            return [
                .bits,
                .bitsPerSecond,
                .bytes,
                .bytesPerSecond,
                .count,
                .countPerSecond,
                .gigabits,
                .gigabitsPerSecond,
                .gigabytes,
                .gigabytesPerSecond,
                .kilobits,
                .kilobitsPerSecond,
                .kilobytes,
                .kilobytesPerSecond,
                .megabits,
                .megabitsPerSecond,
                .megabytes,
                .megabytesPerSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsPerSecond,
                .terabytes,
                .terabytesPerSecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsPerSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesPerSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countPerSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsPerSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesPerSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsPerSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesPerSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsPerSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesPerSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsPerSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesPerSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementUnit(rawValue: rawValue) ?? EntitlementUnit.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.EntitlementUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedValue = "ConsumedValue"
        case maxCount = "MaxCount"
        case name = "Name"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedValue = consumedValue {
            try encodeContainer.encode(consumedValue, forKey: .consumedValue)
        }
        if let maxCount = maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let consumedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consumedValue)
        consumedValue = consumedValueDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.EntitlementDataUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension LicenseManagerClientTypes.EntitlementUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntitlementUsage(consumedValue: \(Swift.String(describing: consumedValue)), maxCount: \(Swift.String(describing: maxCount)), name: \(Swift.String(describing: name)), unit: \(Swift.String(describing: unit)))"}
}

extension LicenseManagerClientTypes {
    /// Usage associated with an entitlement resource.
    public struct EntitlementUsage: Swift.Equatable {
        /// Resource usage consumed.
        /// This member is required.
        public var consumedValue: Swift.String?
        /// Maximum entitlement usage count.
        public var maxCount: Swift.String?
        /// Entitlement usage name.
        /// This member is required.
        public var name: Swift.String?
        /// Entitlement usage unit.
        /// This member is required.
        public var unit: LicenseManagerClientTypes.EntitlementDataUnit?

        public init (
            consumedValue: Swift.String? = nil,
            maxCount: Swift.String? = nil,
            name: Swift.String? = nil,
            unit: LicenseManagerClientTypes.EntitlementDataUnit? = nil
        )
        {
            self.consumedValue = consumedValue
            self.maxCount = maxCount
            self.name = name
            self.unit = unit
        }
    }

}

public struct ExtendLicenseConsumptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExtendLicenseConsumptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExtendLicenseConsumptionOutputError>
}

extension ExtendLicenseConsumptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExtendLicenseConsumptionInput(dryRun: \(Swift.String(describing: dryRun)), licenseConsumptionToken: \(Swift.String(describing: licenseConsumptionToken)))"}
}

extension ExtendLicenseConsumptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let licenseConsumptionToken = licenseConsumptionToken {
            try encodeContainer.encode(licenseConsumptionToken, forKey: .licenseConsumptionToken)
        }
    }
}

public struct ExtendLicenseConsumptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExtendLicenseConsumptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExtendLicenseConsumptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExtendLicenseConsumptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExtendLicenseConsumptionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ExtendLicenseConsumptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExtendLicenseConsumptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExtendLicenseConsumptionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ExtendLicenseConsumptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExtendLicenseConsumptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExtendLicenseConsumptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExtendLicenseConsumptionOutputError>
}

public struct ExtendLicenseConsumptionInput: Swift.Equatable {
    /// Checks whether you have the required permissions for the action, without actually making the request. Provides an error response if you do not have the required permissions.
    public var dryRun: Swift.Bool
    /// License consumption token.
    /// This member is required.
    public var licenseConsumptionToken: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionInputBody: Swift.Equatable {
    public let licenseConsumptionToken: Swift.String?
    public let dryRun: Swift.Bool
}

extension ExtendLicenseConsumptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ExtendLicenseConsumptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExtendLicenseConsumptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExtendLicenseConsumptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExtendLicenseConsumptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExtendLicenseConsumptionOutputResponse(expiration: \(Swift.String(describing: expiration)), licenseConsumptionToken: \(Swift.String(describing: licenseConsumptionToken)))"}
}

extension ExtendLicenseConsumptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExtendLicenseConsumptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expiration = output.expiration
            self.licenseConsumptionToken = output.licenseConsumptionToken
        } else {
            self.expiration = nil
            self.licenseConsumptionToken = nil
        }
    }
}

public struct ExtendLicenseConsumptionOutputResponse: Swift.Equatable {
    /// Date and time at which the license consumption expires.
    public var expiration: Swift.String?
    /// License consumption token.
    public var licenseConsumptionToken: Swift.String?

    public init (
        expiration: Swift.String? = nil,
        licenseConsumptionToken: Swift.String? = nil
    )
    {
        self.expiration = expiration
        self.licenseConsumptionToken = licenseConsumptionToken
    }
}

struct ExtendLicenseConsumptionOutputResponseBody: Swift.Equatable {
    public let licenseConsumptionToken: Swift.String?
    public let expiration: Swift.String?
}

extension ExtendLicenseConsumptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiration = "Expiration"
        case licenseConsumptionToken = "LicenseConsumptionToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConsumptionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConsumptionToken)
        licenseConsumptionToken = licenseConsumptionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension FailedDependencyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedDependencyException(errorCode: \(Swift.String(describing: errorCode)), message: \(Swift.String(describing: message)))"}
}

extension FailedDependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A dependency required to run the API is missing.
public struct FailedDependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var errorCode: Swift.String?
    public var message: Swift.String?

    public init (
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

struct FailedDependencyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let errorCode: Swift.String?
}

extension FailedDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension LicenseManagerClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LicenseManagerClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension LicenseManagerClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// Name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// Filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension FilterLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension FilterLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FilterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request uses too many filters or too many filter values.
public struct FilterLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FilterLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FilterLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAccessTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessTokenOutputError>
}

extension GetAccessTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessTokenInput(token: \(Swift.String(describing: token)), tokenProperties: \(Swift.String(describing: tokenProperties)))"}
}

extension GetAccessTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
    }
}

public struct GetAccessTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessTokenInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccessTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccessTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessTokenInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccessTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccessTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessTokenOutputError>
}

public struct GetAccessTokenInput: Swift.Equatable {
    /// Refresh token, encoded as a JWT token.
    /// This member is required.
    public var token: Swift.String?
    /// Token properties to validate against those present in the JWT token.
    public var tokenProperties: [Swift.String]?

    public init (
        token: Swift.String? = nil,
        tokenProperties: [Swift.String]? = nil
    )
    {
        self.token = token
        self.tokenProperties = tokenProperties
    }
}

struct GetAccessTokenInputBody: Swift.Equatable {
    public let token: Swift.String?
    public let tokenProperties: [Swift.String]?
}

extension GetAccessTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token = "Token"
        case tokenProperties = "TokenProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
    }
}

extension GetAccessTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessTokenOutputResponse(accessToken: \(Swift.String(describing: accessToken)))"}
}

extension GetAccessTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccessTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
        } else {
            self.accessToken = nil
        }
    }
}

public struct GetAccessTokenOutputResponse: Swift.Equatable {
    /// Temporary access token.
    public var accessToken: Swift.String?

    public init (
        accessToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct GetAccessTokenOutputResponseBody: Swift.Equatable {
    public let accessToken: Swift.String?
}

extension GetAccessTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken = "AccessToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

public struct GetGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGrantOutputError>
}

extension GetGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGrantInput(grantArn: \(Swift.String(describing: grantArn)), version: \(Swift.String(describing: version)))"}
}

extension GetGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGrantOutputError>
}

public struct GetGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGrantOutputError>
}

public struct GetGrantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGrantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGrantOutputError>
}

public struct GetGrantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetGrantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetGrantOutputError>
}

public struct GetGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?
    /// Grant version.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.version = version
    }
}

struct GetGrantInputBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let version: Swift.String?
}

extension GetGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGrantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGrantOutputResponse(grant: \(Swift.String(describing: grant)))"}
}

extension GetGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grant = output.grant
        } else {
            self.grant = nil
        }
    }
}

public struct GetGrantOutputResponse: Swift.Equatable {
    /// Grant details.
    public var grant: LicenseManagerClientTypes.Grant?

    public init (
        grant: LicenseManagerClientTypes.Grant? = nil
    )
    {
        self.grant = grant
    }
}

struct GetGrantOutputResponseBody: Swift.Equatable {
    public let grant: LicenseManagerClientTypes.Grant?
}

extension GetGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grant = "Grant"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

public struct GetLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConfigurationOutputError>
}

extension GetLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseConfigurationInput(licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)))"}
}

extension GetLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }
}

public struct GetLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConfigurationOutputError>
}

public struct GetLicenseConfigurationInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?

    public init (
        licenseConfigurationArn: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
    }
}

struct GetLicenseConfigurationInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
}

extension GetLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension GetLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseConfigurationOutputResponse(automatedDiscoveryInformation: \(Swift.String(describing: automatedDiscoveryInformation)), consumedLicenseSummaryList: \(Swift.String(describing: consumedLicenseSummaryList)), consumedLicenses: \(Swift.String(describing: consumedLicenses)), description: \(Swift.String(describing: description)), disassociateWhenNotFound: \(Swift.String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), licenseConfigurationId: \(Swift.String(describing: licenseConfigurationId)), licenseCount: \(Swift.String(describing: licenseCount)), licenseCountHardLimit: \(Swift.String(describing: licenseCountHardLimit)), licenseCountingType: \(Swift.String(describing: licenseCountingType)), licenseRules: \(Swift.String(describing: licenseRules)), managedResourceSummaryList: \(Swift.String(describing: managedResourceSummaryList)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), productInformationList: \(Swift.String(describing: productInformationList)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension GetLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.automatedDiscoveryInformation = output.automatedDiscoveryInformation
            self.consumedLicenseSummaryList = output.consumedLicenseSummaryList
            self.consumedLicenses = output.consumedLicenses
            self.description = output.description
            self.disassociateWhenNotFound = output.disassociateWhenNotFound
            self.licenseConfigurationArn = output.licenseConfigurationArn
            self.licenseConfigurationId = output.licenseConfigurationId
            self.licenseCount = output.licenseCount
            self.licenseCountHardLimit = output.licenseCountHardLimit
            self.licenseCountingType = output.licenseCountingType
            self.licenseRules = output.licenseRules
            self.managedResourceSummaryList = output.managedResourceSummaryList
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.productInformationList = output.productInformationList
            self.status = output.status
            self.tags = output.tags
        } else {
            self.automatedDiscoveryInformation = nil
            self.consumedLicenseSummaryList = nil
            self.consumedLicenses = nil
            self.description = nil
            self.disassociateWhenNotFound = nil
            self.licenseConfigurationArn = nil
            self.licenseConfigurationId = nil
            self.licenseCount = nil
            self.licenseCountHardLimit = nil
            self.licenseCountingType = nil
            self.licenseRules = nil
            self.managedResourceSummaryList = nil
            self.name = nil
            self.ownerAccountId = nil
            self.productInformationList = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetLicenseConfigurationOutputResponse: Swift.Equatable {
    /// Automated discovery information.
    public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
    /// Summaries of the licenses consumed by resources.
    public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
    /// Number of licenses assigned to resources.
    public var consumedLicenses: Swift.Int?
    /// Description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    public var licenseConfigurationArn: Swift.String?
    /// Unique ID for the license configuration.
    public var licenseConfigurationId: Swift.String?
    /// Number of available licenses.
    public var licenseCount: Swift.Int?
    /// Sets the number of available licenses as a hard limit.
    public var licenseCountHardLimit: Swift.Bool?
    /// Dimension for which the licenses are counted.
    public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    /// License rules.
    public var licenseRules: [Swift.String]?
    /// Summaries of the managed resources.
    public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
    /// Name of the license configuration.
    public var name: Swift.String?
    /// Account ID of the owner of the license configuration.
    public var ownerAccountId: Swift.String?
    /// Product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    /// License configuration status.
    public var status: Swift.String?
    /// Tags for the license configuration.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init (
        automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
        consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
        consumedLicenses: Swift.Int? = nil,
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationId: Swift.String? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
        licenseRules: [Swift.String]? = nil,
        managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
        status: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.automatedDiscoveryInformation = automatedDiscoveryInformation
        self.consumedLicenseSummaryList = consumedLicenseSummaryList
        self.consumedLicenses = consumedLicenses
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationId = licenseConfigurationId
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseCountingType = licenseCountingType
        self.licenseRules = licenseRules
        self.managedResourceSummaryList = managedResourceSummaryList
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.productInformationList = productInformationList
        self.status = status
        self.tags = tags
    }
}

struct GetLicenseConfigurationOutputResponseBody: Swift.Equatable {
    public let licenseConfigurationId: Swift.String?
    public let licenseConfigurationArn: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
    public let licenseRules: [Swift.String]?
    public let licenseCount: Swift.Int?
    public let licenseCountHardLimit: Swift.Bool?
    public let consumedLicenses: Swift.Int?
    public let status: Swift.String?
    public let ownerAccountId: Swift.String?
    public let consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
    public let managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
    public let tags: [LicenseManagerClientTypes.Tag]?
    public let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    public let automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
    public let disassociateWhenNotFound: Swift.Bool?
}

extension GetLicenseConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [LicenseManagerClientTypes.ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[LicenseManagerClientTypes.ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [LicenseManagerClientTypes.ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

public struct GetLicenseConversionTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConversionTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConversionTaskOutputError>
}

extension GetLicenseConversionTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseConversionTaskInput(licenseConversionTaskId: \(Swift.String(describing: licenseConversionTaskId)))"}
}

extension GetLicenseConversionTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConversionTaskId = licenseConversionTaskId {
            try encodeContainer.encode(licenseConversionTaskId, forKey: .licenseConversionTaskId)
        }
    }
}

public struct GetLicenseConversionTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConversionTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConversionTaskOutputError>
}

public struct GetLicenseConversionTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConversionTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseConversionTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConversionTaskOutputError>
}

public struct GetLicenseConversionTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConversionTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLicenseConversionTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseConversionTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConversionTaskOutputError>
}

public struct GetLicenseConversionTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseConversionTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLicenseConversionTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseConversionTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseConversionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseConversionTaskOutputError>
}

public struct GetLicenseConversionTaskInput: Swift.Equatable {
    /// ID of the license type conversion task to retrieve information on.
    /// This member is required.
    public var licenseConversionTaskId: Swift.String?

    public init (
        licenseConversionTaskId: Swift.String? = nil
    )
    {
        self.licenseConversionTaskId = licenseConversionTaskId
    }
}

struct GetLicenseConversionTaskInputBody: Swift.Equatable {
    public let licenseConversionTaskId: Swift.String?
}

extension GetLicenseConversionTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTaskId = "LicenseConversionTaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
    }
}

extension GetLicenseConversionTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseConversionTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseConversionTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseConversionTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseConversionTaskOutputResponse(destinationLicenseContext: \(Swift.String(describing: destinationLicenseContext)), endTime: \(Swift.String(describing: endTime)), licenseConversionTaskId: \(Swift.String(describing: licenseConversionTaskId)), licenseConversionTime: \(Swift.String(describing: licenseConversionTime)), resourceArn: \(Swift.String(describing: resourceArn)), sourceLicenseContext: \(Swift.String(describing: sourceLicenseContext)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension GetLicenseConversionTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLicenseConversionTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationLicenseContext = output.destinationLicenseContext
            self.endTime = output.endTime
            self.licenseConversionTaskId = output.licenseConversionTaskId
            self.licenseConversionTime = output.licenseConversionTime
            self.resourceArn = output.resourceArn
            self.sourceLicenseContext = output.sourceLicenseContext
            self.startTime = output.startTime
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.destinationLicenseContext = nil
            self.endTime = nil
            self.licenseConversionTaskId = nil
            self.licenseConversionTime = nil
            self.resourceArn = nil
            self.sourceLicenseContext = nil
            self.startTime = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetLicenseConversionTaskOutputResponse: Swift.Equatable {
    /// Information about the license type converted to.
    public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was completed.
    public var endTime: ClientRuntime.Date?
    /// ID of the license type conversion task.
    public var licenseConversionTaskId: Swift.String?
    /// Amount of time to complete the license type conversion.
    public var licenseConversionTime: ClientRuntime.Date?
    /// Amazon Resource Names (ARN) of the resources the license conversion task is associated with.
    public var resourceArn: Swift.String?
    /// Information about the license type converted from.
    public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    /// Time at which the license type conversion task was started .
    public var startTime: ClientRuntime.Date?
    /// Status of the license type conversion task.
    public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
    /// The status message for the conversion task.
    public var statusMessage: Swift.String?

    public init (
        destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        endTime: ClientRuntime.Date? = nil,
        licenseConversionTaskId: Swift.String? = nil,
        licenseConversionTime: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.destinationLicenseContext = destinationLicenseContext
        self.endTime = endTime
        self.licenseConversionTaskId = licenseConversionTaskId
        self.licenseConversionTime = licenseConversionTime
        self.resourceArn = resourceArn
        self.sourceLicenseContext = sourceLicenseContext
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetLicenseConversionTaskOutputResponseBody: Swift.Equatable {
    public let licenseConversionTaskId: Swift.String?
    public let resourceArn: Swift.String?
    public let sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    public let destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
    public let statusMessage: Swift.String?
    public let status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
    public let startTime: ClientRuntime.Date?
    public let licenseConversionTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension GetLicenseConversionTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case endTime = "EndTime"
        case licenseConversionTaskId = "LicenseConversionTaskId"
        case licenseConversionTime = "LicenseConversionTime"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let licenseConversionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .licenseConversionTime)
        licenseConversionTime = licenseConversionTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct GetLicenseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseOutputError>
}

extension GetLicenseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseInput(licenseArn: \(Swift.String(describing: licenseArn)), version: \(Swift.String(describing: version)))"}
}

extension GetLicenseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetLicenseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseOutputError>
}

public struct GetLicenseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseOutputError>
}

public struct GetLicenseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseOutputError>
}

public struct GetLicenseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLicenseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseOutputError>
}

public struct GetLicenseInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// License version.
    public var version: Swift.String?

    public init (
        licenseArn: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.version = version
    }
}

struct GetLicenseInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let version: Swift.String?
}

extension GetLicenseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

public struct GetLicenseManagerReportGeneratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseManagerReportGeneratorOutputError>
}

extension GetLicenseManagerReportGeneratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseManagerReportGeneratorInput(licenseManagerReportGeneratorArn: \(Swift.String(describing: licenseManagerReportGeneratorArn)))"}
}

extension GetLicenseManagerReportGeneratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
    }
}

public struct GetLicenseManagerReportGeneratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseManagerReportGeneratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseManagerReportGeneratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseManagerReportGeneratorOutputError>
}

public struct GetLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the report generator.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?

    public init (
        licenseManagerReportGeneratorArn: Swift.String? = nil
    )
    {
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
    }
}

struct GetLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    public let licenseManagerReportGeneratorArn: Swift.String?
}

extension GetLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
    }
}

extension GetLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseManagerReportGeneratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseManagerReportGeneratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseManagerReportGeneratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseManagerReportGeneratorOutputResponse(reportGenerator: \(Swift.String(describing: reportGenerator)))"}
}

extension GetLicenseManagerReportGeneratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLicenseManagerReportGeneratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportGenerator = output.reportGenerator
        } else {
            self.reportGenerator = nil
        }
    }
}

public struct GetLicenseManagerReportGeneratorOutputResponse: Swift.Equatable {
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerator: LicenseManagerClientTypes.ReportGenerator?

    public init (
        reportGenerator: LicenseManagerClientTypes.ReportGenerator? = nil
    )
    {
        self.reportGenerator = reportGenerator
    }
}

struct GetLicenseManagerReportGeneratorOutputResponseBody: Swift.Equatable {
    public let reportGenerator: LicenseManagerClientTypes.ReportGenerator?
}

extension GetLicenseManagerReportGeneratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportGenerator = "ReportGenerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportGenerator.self, forKey: .reportGenerator)
        reportGenerator = reportGeneratorDecoded
    }
}

extension GetLicenseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseOutputResponse(license: \(Swift.String(describing: license)))"}
}

extension GetLicenseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLicenseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.license = output.license
        } else {
            self.license = nil
        }
    }
}

public struct GetLicenseOutputResponse: Swift.Equatable {
    /// License details.
    public var license: LicenseManagerClientTypes.License?

    public init (
        license: LicenseManagerClientTypes.License? = nil
    )
    {
        self.license = license
    }
}

struct GetLicenseOutputResponseBody: Swift.Equatable {
    public let license: LicenseManagerClientTypes.License?
}

extension GetLicenseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case license = "License"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.License.self, forKey: .license)
        license = licenseDecoded
    }
}

public struct GetLicenseUsageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseUsageOutputError>
}

extension GetLicenseUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseUsageInput(licenseArn: \(Swift.String(describing: licenseArn)))"}
}

extension GetLicenseUsageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
    }
}

public struct GetLicenseUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLicenseUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLicenseUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseUsageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetLicenseUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLicenseUsageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetLicenseUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLicenseUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLicenseUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLicenseUsageOutputError>
}

public struct GetLicenseUsageInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?

    public init (
        licenseArn: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
    }
}

struct GetLicenseUsageInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
}

extension GetLicenseUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
    }
}

extension GetLicenseUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLicenseUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLicenseUsageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLicenseUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLicenseUsageOutputResponse(licenseUsage: \(Swift.String(describing: licenseUsage)))"}
}

extension GetLicenseUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLicenseUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseUsage = output.licenseUsage
        } else {
            self.licenseUsage = nil
        }
    }
}

public struct GetLicenseUsageOutputResponse: Swift.Equatable {
    /// License usage details.
    public var licenseUsage: LicenseManagerClientTypes.LicenseUsage?

    public init (
        licenseUsage: LicenseManagerClientTypes.LicenseUsage? = nil
    )
    {
        self.licenseUsage = licenseUsage
    }
}

struct GetLicenseUsageOutputResponseBody: Swift.Equatable {
    public let licenseUsage: LicenseManagerClientTypes.LicenseUsage?
}

extension GetLicenseUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseUsage = "LicenseUsage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseUsageDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseUsage.self, forKey: .licenseUsage)
        licenseUsage = licenseUsageDecoded
    }
}

extension GetServiceSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceSettingsInput()"}
}

extension GetServiceSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetServiceSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetServiceSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetServiceSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetServiceSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceSettingsOutputError>
}

public struct GetServiceSettingsInput: Swift.Equatable {

    public init() {}
}

struct GetServiceSettingsInputBody: Swift.Equatable {
}

extension GetServiceSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceSettingsOutputResponse(enableCrossAccountsDiscovery: \(Swift.String(describing: enableCrossAccountsDiscovery)), licenseManagerResourceShareArn: \(Swift.String(describing: licenseManagerResourceShareArn)), organizationConfiguration: \(Swift.String(describing: organizationConfiguration)), s3BucketArn: \(Swift.String(describing: s3BucketArn)), snsTopicArn: \(Swift.String(describing: snsTopicArn)))"}
}

extension GetServiceSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.enableCrossAccountsDiscovery = output.enableCrossAccountsDiscovery
            self.licenseManagerResourceShareArn = output.licenseManagerResourceShareArn
            self.organizationConfiguration = output.organizationConfiguration
            self.s3BucketArn = output.s3BucketArn
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.enableCrossAccountsDiscovery = nil
            self.licenseManagerResourceShareArn = nil
            self.organizationConfiguration = nil
            self.s3BucketArn = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetServiceSettingsOutputResponse: Swift.Equatable {
    /// Indicates whether cross-account discovery is enabled.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Amazon Resource Name (ARN) of the resource share. The License Manager management account provides member accounts with access to this share.
    public var licenseManagerResourceShareArn: Swift.String?
    /// Indicates whether Organizations is integrated with License Manager for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Regional S3 bucket path for storing reports, license trail event data, discovery data, and so on.
    public var s3BucketArn: Swift.String?
    /// SNS topic configured to receive notifications from License Manager.
    public var snsTopicArn: Swift.String?

    public init (
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        licenseManagerResourceShareArn: Swift.String? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.licenseManagerResourceShareArn = licenseManagerResourceShareArn
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct GetServiceSettingsOutputResponseBody: Swift.Equatable {
    public let s3BucketArn: Swift.String?
    public let snsTopicArn: Swift.String?
    public let organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    public let enableCrossAccountsDiscovery: Swift.Bool?
    public let licenseManagerResourceShareArn: Swift.String?
}

extension GetServiceSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case licenseManagerResourceShareArn = "LicenseManagerResourceShareArn"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
        let licenseManagerResourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerResourceShareArn)
        licenseManagerResourceShareArn = licenseManagerResourceShareArnDecoded
    }
}

extension LicenseManagerClientTypes.Grant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case grantName = "GrantName"
        case grantStatus = "GrantStatus"
        case grantedOperations = "GrantedOperations"
        case granteePrincipalArn = "GranteePrincipalArn"
        case homeRegion = "HomeRegion"
        case licenseArn = "LicenseArn"
        case parentArn = "ParentArn"
        case statusReason = "StatusReason"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
        if let grantName = grantName {
            try encodeContainer.encode(grantName, forKey: .grantName)
        }
        if let grantStatus = grantStatus {
            try encodeContainer.encode(grantStatus.rawValue, forKey: .grantStatus)
        }
        if let grantedOperations = grantedOperations {
            var grantedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantedOperations)
            for allowedoperationlist0 in grantedOperations {
                try grantedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let granteePrincipalArn = granteePrincipalArn {
            try encodeContainer.encode(granteePrincipalArn, forKey: .granteePrincipalArn)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let parentArn = parentArn {
            try encodeContainer.encode(parentArn, forKey: .parentArn)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let grantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantName)
        grantName = grantNameDecoded
        let parentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentArn)
        parentArn = parentArnDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let granteePrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteePrincipalArn)
        granteePrincipalArn = granteePrincipalArnDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let grantStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .grantStatus)
        grantStatus = grantStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let grantedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .grantedOperations)
        var grantedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let grantedOperationsContainer = grantedOperationsContainer {
            grantedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for string0 in grantedOperationsContainer {
                if let string0 = string0 {
                    grantedOperationsDecoded0?.append(string0)
                }
            }
        }
        grantedOperations = grantedOperationsDecoded0
    }
}

extension LicenseManagerClientTypes.Grant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Grant(grantArn: \(Swift.String(describing: grantArn)), grantName: \(Swift.String(describing: grantName)), grantStatus: \(Swift.String(describing: grantStatus)), grantedOperations: \(Swift.String(describing: grantedOperations)), granteePrincipalArn: \(Swift.String(describing: granteePrincipalArn)), homeRegion: \(Swift.String(describing: homeRegion)), licenseArn: \(Swift.String(describing: licenseArn)), parentArn: \(Swift.String(describing: parentArn)), statusReason: \(Swift.String(describing: statusReason)), version: \(Swift.String(describing: version)))"}
}

extension LicenseManagerClientTypes {
    /// Describes a grant.
    public struct Grant: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the grant.
        /// This member is required.
        public var grantArn: Swift.String?
        /// Grant name.
        /// This member is required.
        public var grantName: Swift.String?
        /// Grant status.
        /// This member is required.
        public var grantStatus: LicenseManagerClientTypes.GrantStatus?
        /// Granted operations.
        /// This member is required.
        public var grantedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// The grantee principal ARN.
        /// This member is required.
        public var granteePrincipalArn: Swift.String?
        /// Home Region of the grant.
        /// This member is required.
        public var homeRegion: Swift.String?
        /// License ARN.
        /// This member is required.
        public var licenseArn: Swift.String?
        /// Parent ARN.
        /// This member is required.
        public var parentArn: Swift.String?
        /// Grant status reason.
        public var statusReason: Swift.String?
        /// Grant version.
        /// This member is required.
        public var version: Swift.String?

        public init (
            grantArn: Swift.String? = nil,
            grantName: Swift.String? = nil,
            grantStatus: LicenseManagerClientTypes.GrantStatus? = nil,
            grantedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            granteePrincipalArn: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            parentArn: Swift.String? = nil,
            statusReason: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.grantArn = grantArn
            self.grantName = grantName
            self.grantStatus = grantStatus
            self.grantedOperations = grantedOperations
            self.granteePrincipalArn = granteePrincipalArn
            self.homeRegion = homeRegion
            self.licenseArn = licenseArn
            self.parentArn = parentArn
            self.statusReason = statusReason
            self.version = version
        }
    }

}

extension LicenseManagerClientTypes {
    public enum GrantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingDelete
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [GrantStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingDelete,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingDelete: return "PENDING_DELETE"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrantStatus(rawValue: rawValue) ?? GrantStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.GrantedLicense: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case receivedMetadata = "ReceivedMetadata"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let receivedMetadata = receivedMetadata {
            try encodeContainer.encode(receivedMetadata, forKey: .receivedMetadata)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let receivedMetadataDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReceivedMetadata.self, forKey: .receivedMetadata)
        receivedMetadata = receivedMetadataDecoded
    }
}

extension LicenseManagerClientTypes.GrantedLicense: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GrantedLicense(beneficiary: \(Swift.String(describing: beneficiary)), consumptionConfiguration: \(Swift.String(describing: consumptionConfiguration)), createTime: \(Swift.String(describing: createTime)), entitlements: \(Swift.String(describing: entitlements)), homeRegion: \(Swift.String(describing: homeRegion)), issuer: \(Swift.String(describing: issuer)), licenseArn: \(Swift.String(describing: licenseArn)), licenseMetadata: \(Swift.String(describing: licenseMetadata)), licenseName: \(Swift.String(describing: licenseName)), productName: \(Swift.String(describing: productName)), productSKU: \(Swift.String(describing: productSKU)), receivedMetadata: \(Swift.String(describing: receivedMetadata)), status: \(Swift.String(describing: status)), validity: \(Swift.String(describing: validity)), version: \(Swift.String(describing: version)))"}
}

extension LicenseManagerClientTypes {
    /// Describes a license that is granted to a grantee.
    public struct GrantedLicense: Swift.Equatable {
        /// Granted license beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// Creation time of the granted license.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the granted license.
        public var homeRegion: Swift.String?
        /// Granted license issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Granted license metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// Granted license received metadata.
        public var receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata?
        /// Granted license status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the granted license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// Version of the granted license.
        public var version: Swift.String?

        public init (
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            receivedMetadata: LicenseManagerClientTypes.ReceivedMetadata? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.receivedMetadata = receivedMetadata
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// License Manager cannot allocate a license to a resource because of its state. For example, you cannot allocate a license to an instance in the process of shutting down.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.InventoryFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.InventoryFilterCondition.self, forKey: .condition)
        condition = conditionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes.InventoryFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InventoryFilter(condition: \(Swift.String(describing: condition)), name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// An inventory filter.
    public struct InventoryFilter: Swift.Equatable {
        /// Condition of the filter.
        /// This member is required.
        public var condition: LicenseManagerClientTypes.InventoryFilterCondition?
        /// Name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init (
            condition: LicenseManagerClientTypes.InventoryFilterCondition? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum InventoryFilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case contains
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryFilterCondition] {
            return [
                .beginsWith,
                .contains,
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InventoryFilterCondition(rawValue: rawValue) ?? InventoryFilterCondition.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.Issuer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signKey)
        signKey = signKeyDecoded
    }
}

extension LicenseManagerClientTypes.Issuer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Issuer(name: \(Swift.String(describing: name)), signKey: \(Swift.String(describing: signKey)))"}
}

extension LicenseManagerClientTypes {
    /// Details about the issuer of a license.
    public struct Issuer: Swift.Equatable {
        /// Issuer name.
        /// This member is required.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init (
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes.IssuerDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyFingerprint = "KeyFingerprint"
        case name = "Name"
        case signKey = "SignKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyFingerprint = keyFingerprint {
            try encodeContainer.encode(keyFingerprint, forKey: .keyFingerprint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signKey = signKey {
            try encodeContainer.encode(signKey, forKey: .signKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let signKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signKey)
        signKey = signKeyDecoded
        let keyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyFingerprint)
        keyFingerprint = keyFingerprintDecoded
    }
}

extension LicenseManagerClientTypes.IssuerDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IssuerDetails(keyFingerprint: \(Swift.String(describing: keyFingerprint)), name: \(Swift.String(describing: name)), signKey: \(Swift.String(describing: signKey)))"}
}

extension LicenseManagerClientTypes {
    /// Details associated with the issuer of a license.
    public struct IssuerDetails: Swift.Equatable {
        /// Issuer key fingerprint.
        public var keyFingerprint: Swift.String?
        /// Issuer name.
        public var name: Swift.String?
        /// Asymmetric KMS key from Key Management Service. The KMS key must have a key usage of sign and verify, and support the RSASSA-PSS SHA-256 signing algorithm.
        public var signKey: Swift.String?

        public init (
            keyFingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            signKey: Swift.String? = nil
        )
        {
            self.keyFingerprint = keyFingerprint
            self.name = name
            self.signKey = signKey
        }
    }

}

extension LicenseManagerClientTypes.License: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beneficiary = "Beneficiary"
        case consumptionConfiguration = "ConsumptionConfiguration"
        case createTime = "CreateTime"
        case entitlements = "Entitlements"
        case homeRegion = "HomeRegion"
        case issuer = "Issuer"
        case licenseArn = "LicenseArn"
        case licenseMetadata = "LicenseMetadata"
        case licenseName = "LicenseName"
        case productName = "ProductName"
        case productSKU = "ProductSKU"
        case status = "Status"
        case validity = "Validity"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beneficiary = beneficiary {
            try encodeContainer.encode(beneficiary, forKey: .beneficiary)
        }
        if let consumptionConfiguration = consumptionConfiguration {
            try encodeContainer.encode(consumptionConfiguration, forKey: .consumptionConfiguration)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for entitlementlist0 in entitlements {
                try entitlementsContainer.encode(entitlementlist0)
            }
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let licenseMetadata = licenseMetadata {
            var licenseMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseMetadata)
            for metadatalist0 in licenseMetadata {
                try licenseMetadataContainer.encode(metadatalist0)
            }
        }
        if let licenseName = licenseName {
            try encodeContainer.encode(licenseName, forKey: .licenseName)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSKU = productSKU {
            try encodeContainer.encode(productSKU, forKey: .productSKU)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let licenseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseName)
        licenseName = licenseNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let productSKUDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSKU)
        productSKU = productSKUDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.IssuerDetails.self, forKey: .issuer)
        issuer = issuerDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseStatus.self, forKey: .status)
        status = statusDecoded
        let validityDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.DatetimeRange.self, forKey: .validity)
        validity = validityDecoded
        let beneficiaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beneficiary)
        beneficiary = beneficiaryDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[LicenseManagerClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [LicenseManagerClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let consumptionConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ConsumptionConfiguration.self, forKey: .consumptionConfiguration)
        consumptionConfiguration = consumptionConfigurationDecoded
        let licenseMetadataContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .licenseMetadata)
        var licenseMetadataDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let licenseMetadataContainer = licenseMetadataContainer {
            licenseMetadataDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in licenseMetadataContainer {
                if let structure0 = structure0 {
                    licenseMetadataDecoded0?.append(structure0)
                }
            }
        }
        licenseMetadata = licenseMetadataDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension LicenseManagerClientTypes.License: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "License(beneficiary: \(Swift.String(describing: beneficiary)), consumptionConfiguration: \(Swift.String(describing: consumptionConfiguration)), createTime: \(Swift.String(describing: createTime)), entitlements: \(Swift.String(describing: entitlements)), homeRegion: \(Swift.String(describing: homeRegion)), issuer: \(Swift.String(describing: issuer)), licenseArn: \(Swift.String(describing: licenseArn)), licenseMetadata: \(Swift.String(describing: licenseMetadata)), licenseName: \(Swift.String(describing: licenseName)), productName: \(Swift.String(describing: productName)), productSKU: \(Swift.String(describing: productSKU)), status: \(Swift.String(describing: status)), validity: \(Swift.String(describing: validity)), version: \(Swift.String(describing: version)))"}
}

extension LicenseManagerClientTypes {
    /// Software license that is managed in License Manager.
    public struct License: Swift.Equatable {
        /// License beneficiary.
        public var beneficiary: Swift.String?
        /// Configuration for consumption of the license.
        public var consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration?
        /// License creation time.
        public var createTime: Swift.String?
        /// License entitlements.
        public var entitlements: [LicenseManagerClientTypes.Entitlement]?
        /// Home Region of the license.
        public var homeRegion: Swift.String?
        /// License issuer.
        public var issuer: LicenseManagerClientTypes.IssuerDetails?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// License metadata.
        public var licenseMetadata: [LicenseManagerClientTypes.Metadata]?
        /// License name.
        public var licenseName: Swift.String?
        /// Product name.
        public var productName: Swift.String?
        /// Product SKU.
        public var productSKU: Swift.String?
        /// License status.
        public var status: LicenseManagerClientTypes.LicenseStatus?
        /// Date and time range during which the license is valid, in ISO8601-UTC format.
        public var validity: LicenseManagerClientTypes.DatetimeRange?
        /// License version.
        public var version: Swift.String?

        public init (
            beneficiary: Swift.String? = nil,
            consumptionConfiguration: LicenseManagerClientTypes.ConsumptionConfiguration? = nil,
            createTime: Swift.String? = nil,
            entitlements: [LicenseManagerClientTypes.Entitlement]? = nil,
            homeRegion: Swift.String? = nil,
            issuer: LicenseManagerClientTypes.IssuerDetails? = nil,
            licenseArn: Swift.String? = nil,
            licenseMetadata: [LicenseManagerClientTypes.Metadata]? = nil,
            licenseName: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSKU: Swift.String? = nil,
            status: LicenseManagerClientTypes.LicenseStatus? = nil,
            validity: LicenseManagerClientTypes.DatetimeRange? = nil,
            version: Swift.String? = nil
        )
        {
            self.beneficiary = beneficiary
            self.consumptionConfiguration = consumptionConfiguration
            self.createTime = createTime
            self.entitlements = entitlements
            self.homeRegion = homeRegion
            self.issuer = issuer
            self.licenseArn = licenseArn
            self.licenseMetadata = licenseMetadata
            self.licenseName = licenseName
            self.productName = productName
            self.productSKU = productSKU
            self.status = status
            self.validity = validity
            self.version = version
        }
    }

}

extension LicenseManagerClientTypes.LicenseConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedDiscoveryInformation = "AutomatedDiscoveryInformation"
        case consumedLicenseSummaryList = "ConsumedLicenseSummaryList"
        case consumedLicenses = "ConsumedLicenses"
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationId = "LicenseConfigurationId"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseCountingType = "LicenseCountingType"
        case licenseRules = "LicenseRules"
        case managedResourceSummaryList = "ManagedResourceSummaryList"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case productInformationList = "ProductInformationList"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedDiscoveryInformation = automatedDiscoveryInformation {
            try encodeContainer.encode(automatedDiscoveryInformation, forKey: .automatedDiscoveryInformation)
        }
        if let consumedLicenseSummaryList = consumedLicenseSummaryList {
            var consumedLicenseSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .consumedLicenseSummaryList)
            for consumedlicensesummarylist0 in consumedLicenseSummaryList {
                try consumedLicenseSummaryListContainer.encode(consumedlicensesummarylist0)
            }
        }
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationId = licenseConfigurationId {
            try encodeContainer.encode(licenseConfigurationId, forKey: .licenseConfigurationId)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseCountingType = licenseCountingType {
            try encodeContainer.encode(licenseCountingType.rawValue, forKey: .licenseCountingType)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let managedResourceSummaryList = managedResourceSummaryList {
            var managedResourceSummaryListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedResourceSummaryList)
            for managedresourcesummarylist0 in managedResourceSummaryList {
                try managedResourceSummaryListContainer.encode(managedresourcesummarylist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationId)
        licenseConfigurationId = licenseConfigurationIdDecoded
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseCountingTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseCountingType.self, forKey: .licenseCountingType)
        licenseCountingType = licenseCountingTypeDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let consumedLicenseSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ConsumedLicenseSummary?].self, forKey: .consumedLicenseSummaryList)
        var consumedLicenseSummaryListDecoded0:[LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil
        if let consumedLicenseSummaryListContainer = consumedLicenseSummaryListContainer {
            consumedLicenseSummaryListDecoded0 = [LicenseManagerClientTypes.ConsumedLicenseSummary]()
            for structure0 in consumedLicenseSummaryListContainer {
                if let structure0 = structure0 {
                    consumedLicenseSummaryListDecoded0?.append(structure0)
                }
            }
        }
        consumedLicenseSummaryList = consumedLicenseSummaryListDecoded0
        let managedResourceSummaryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ManagedResourceSummary?].self, forKey: .managedResourceSummaryList)
        var managedResourceSummaryListDecoded0:[LicenseManagerClientTypes.ManagedResourceSummary]? = nil
        if let managedResourceSummaryListContainer = managedResourceSummaryListContainer {
            managedResourceSummaryListDecoded0 = [LicenseManagerClientTypes.ManagedResourceSummary]()
            for structure0 in managedResourceSummaryListContainer {
                if let structure0 = structure0 {
                    managedResourceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        managedResourceSummaryList = managedResourceSummaryListDecoded0
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let automatedDiscoveryInformationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.AutomatedDiscoveryInformation.self, forKey: .automatedDiscoveryInformation)
        automatedDiscoveryInformation = automatedDiscoveryInformationDecoded
    }
}

extension LicenseManagerClientTypes.LicenseConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseConfiguration(automatedDiscoveryInformation: \(Swift.String(describing: automatedDiscoveryInformation)), consumedLicenseSummaryList: \(Swift.String(describing: consumedLicenseSummaryList)), consumedLicenses: \(Swift.String(describing: consumedLicenses)), description: \(Swift.String(describing: description)), disassociateWhenNotFound: \(Swift.String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), licenseConfigurationId: \(Swift.String(describing: licenseConfigurationId)), licenseCount: \(Swift.String(describing: licenseCount)), licenseCountHardLimit: \(Swift.String(describing: licenseCountHardLimit)), licenseCountingType: \(Swift.String(describing: licenseCountingType)), licenseRules: \(Swift.String(describing: licenseRules)), managedResourceSummaryList: \(Swift.String(describing: managedResourceSummaryList)), name: \(Swift.String(describing: name)), ownerAccountId: \(Swift.String(describing: ownerAccountId)), productInformationList: \(Swift.String(describing: productInformationList)), status: \(Swift.String(describing: status)))"}
}

extension LicenseManagerClientTypes {
    /// A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), host affinity (how long a VM must be associated with a host), and the number of licenses purchased and used.
    public struct LicenseConfiguration: Swift.Equatable {
        /// Automated discovery information.
        public var automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation?
        /// Summaries for licenses consumed by various resources.
        public var consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]?
        /// Number of licenses consumed.
        public var consumedLicenses: Swift.Int?
        /// Description of the license configuration.
        public var description: Swift.String?
        /// When true, disassociates a resource when software is uninstalled.
        public var disassociateWhenNotFound: Swift.Bool?
        /// Amazon Resource Name (ARN) of the license configuration.
        public var licenseConfigurationArn: Swift.String?
        /// Unique ID of the license configuration.
        public var licenseConfigurationId: Swift.String?
        /// Number of licenses managed by the license configuration.
        public var licenseCount: Swift.Int?
        /// Number of available licenses as a hard limit.
        public var licenseCountHardLimit: Swift.Bool?
        /// Dimension to use to track the license inventory.
        public var licenseCountingType: LicenseManagerClientTypes.LicenseCountingType?
        /// License rules.
        public var licenseRules: [Swift.String]?
        /// Summaries for managed resources.
        public var managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]?
        /// Name of the license configuration.
        public var name: Swift.String?
        /// Account ID of the license configuration's owner.
        public var ownerAccountId: Swift.String?
        /// Product information.
        public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?
        /// Status of the license configuration.
        public var status: Swift.String?

        public init (
            automatedDiscoveryInformation: LicenseManagerClientTypes.AutomatedDiscoveryInformation? = nil,
            consumedLicenseSummaryList: [LicenseManagerClientTypes.ConsumedLicenseSummary]? = nil,
            consumedLicenses: Swift.Int? = nil,
            description: Swift.String? = nil,
            disassociateWhenNotFound: Swift.Bool? = nil,
            licenseConfigurationArn: Swift.String? = nil,
            licenseConfigurationId: Swift.String? = nil,
            licenseCount: Swift.Int? = nil,
            licenseCountHardLimit: Swift.Bool? = nil,
            licenseCountingType: LicenseManagerClientTypes.LicenseCountingType? = nil,
            licenseRules: [Swift.String]? = nil,
            managedResourceSummaryList: [LicenseManagerClientTypes.ManagedResourceSummary]? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil,
            status: Swift.String? = nil
        )
        {
            self.automatedDiscoveryInformation = automatedDiscoveryInformation
            self.consumedLicenseSummaryList = consumedLicenseSummaryList
            self.consumedLicenses = consumedLicenses
            self.description = description
            self.disassociateWhenNotFound = disassociateWhenNotFound
            self.licenseConfigurationArn = licenseConfigurationArn
            self.licenseConfigurationId = licenseConfigurationId
            self.licenseCount = licenseCount
            self.licenseCountHardLimit = licenseCountHardLimit
            self.licenseCountingType = licenseCountingType
            self.licenseRules = licenseRules
            self.managedResourceSummaryList = managedResourceSummaryList
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.productInformationList = productInformationList
            self.status = status
        }
    }

}

extension LicenseManagerClientTypes.LicenseConfigurationAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case associationTime = "AssociationTime"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let associationTime = associationTime {
            try encodeContainer.encode(associationTime.timeIntervalSince1970, forKey: .associationTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseConfigurationAssociation(amiAssociationScope: \(Swift.String(describing: amiAssociationScope)), associationTime: \(Swift.String(describing: associationTime)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwnerId: \(Swift.String(describing: resourceOwnerId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Describes an association with a license configuration.
    public struct LicenseConfigurationAssociation: Swift.Equatable {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Time when the license configuration was associated with the resource.
        public var associationTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource consuming licenses.
        public var resourceOwnerId: Swift.String?
        /// Type of server resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            amiAssociationScope: Swift.String? = nil,
            associationTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.associationTime = associationTime
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConfigurationStatus] {
            return [
                .available,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseConfigurationStatus(rawValue: rawValue) ?? LicenseConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTime = "AssociationTime"
        case consumedLicenses = "ConsumedLicenses"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceStatus = "ResourceStatus"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTime = associationTime {
            try encodeContainer.encode(associationTime.timeIntervalSince1970, forKey: .associationTime)
        }
        if let consumedLicenses = consumedLicenses {
            try encodeContainer.encode(consumedLicenses, forKey: .consumedLicenses)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceStatus = resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let associationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let consumedLicensesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedLicenses)
        consumedLicenses = consumedLicensesDecoded
    }
}

extension LicenseManagerClientTypes.LicenseConfigurationUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseConfigurationUsage(associationTime: \(Swift.String(describing: associationTime)), consumedLicenses: \(Swift.String(describing: consumedLicenses)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwnerId: \(Swift.String(describing: resourceOwnerId)), resourceStatus: \(Swift.String(describing: resourceStatus)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Details about the usage of a resource associated with a license configuration.
    public struct LicenseConfigurationUsage: Swift.Equatable {
        /// Time when the license configuration was initially associated with the resource.
        public var associationTime: ClientRuntime.Date?
        /// Number of licenses consumed by the resource.
        public var consumedLicenses: Swift.Int?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Status of the resource.
        public var resourceStatus: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            associationTime: ClientRuntime.Date? = nil,
            consumedLicenses: Swift.Int? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceStatus: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationTime = associationTime
            self.consumedLicenses = consumedLicenses
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceStatus = resourceStatus
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.LicenseConversionContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usageOperation = "UsageOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usageOperation = usageOperation {
            try encodeContainer.encode(usageOperation, forKey: .usageOperation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
    }
}

extension LicenseManagerClientTypes.LicenseConversionContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseConversionContext(usageOperation: \(Swift.String(describing: usageOperation)))"}
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionContext: Swift.Equatable {
        /// The Usage operation value that corresponds to the license type you are converting your resource from. For more information about which platforms correspond to which usage operation values see [Sample data: usage operation by platform ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html#billing-info)
        public var usageOperation: Swift.String?

        public init (
            usageOperation: Swift.String? = nil
        )
        {
            self.usageOperation = usageOperation
        }
    }

}

extension LicenseManagerClientTypes.LicenseConversionTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationLicenseContext = "DestinationLicenseContext"
        case endTime = "EndTime"
        case licenseConversionTaskId = "LicenseConversionTaskId"
        case licenseConversionTime = "LicenseConversionTime"
        case resourceArn = "ResourceArn"
        case sourceLicenseContext = "SourceLicenseContext"
        case startTime = "StartTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationLicenseContext = destinationLicenseContext {
            try encodeContainer.encode(destinationLicenseContext, forKey: .destinationLicenseContext)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let licenseConversionTaskId = licenseConversionTaskId {
            try encodeContainer.encode(licenseConversionTaskId, forKey: .licenseConversionTaskId)
        }
        if let licenseConversionTime = licenseConversionTime {
            try encodeContainer.encode(licenseConversionTime.timeIntervalSince1970, forKey: .licenseConversionTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let sourceLicenseContext = sourceLicenseContext {
            try encodeContainer.encode(sourceLicenseContext, forKey: .sourceLicenseContext)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConversionTaskId)
        licenseConversionTaskId = licenseConversionTaskIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .sourceLicenseContext)
        sourceLicenseContext = sourceLicenseContextDecoded
        let destinationLicenseContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionContext.self, forKey: .destinationLicenseContext)
        destinationLicenseContext = destinationLicenseContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConversionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let licenseConversionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .licenseConversionTime)
        licenseConversionTime = licenseConversionTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension LicenseManagerClientTypes.LicenseConversionTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseConversionTask(destinationLicenseContext: \(Swift.String(describing: destinationLicenseContext)), endTime: \(Swift.String(describing: endTime)), licenseConversionTaskId: \(Swift.String(describing: licenseConversionTaskId)), licenseConversionTime: \(Swift.String(describing: licenseConversionTime)), resourceArn: \(Swift.String(describing: resourceArn)), sourceLicenseContext: \(Swift.String(describing: sourceLicenseContext)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension LicenseManagerClientTypes {
    /// Information about a license type conversion task.
    public struct LicenseConversionTask: Swift.Equatable {
        /// Information about the license type this conversion task converted to.
        public var destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was completed.
        public var endTime: ClientRuntime.Date?
        /// The ID of the license type conversion task.
        public var licenseConversionTaskId: Swift.String?
        /// The time the usage operation value of the resource was changed.
        public var licenseConversionTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource associated with the license type conversion task.
        public var resourceArn: Swift.String?
        /// Information about the license type this conversion task converted from.
        public var sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext?
        /// The time the conversion task was started at.
        public var startTime: ClientRuntime.Date?
        /// The status of the conversion task.
        public var status: LicenseManagerClientTypes.LicenseConversionTaskStatus?
        /// The status message for the conversion task.
        public var statusMessage: Swift.String?

        public init (
            destinationLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            endTime: ClientRuntime.Date? = nil,
            licenseConversionTaskId: Swift.String? = nil,
            licenseConversionTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            sourceLicenseContext: LicenseManagerClientTypes.LicenseConversionContext? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: LicenseManagerClientTypes.LicenseConversionTaskStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.destinationLicenseContext = destinationLicenseContext
            self.endTime = endTime
            self.licenseConversionTaskId = licenseConversionTaskId
            self.licenseConversionTime = licenseConversionTime
            self.resourceArn = resourceArn
            self.sourceLicenseContext = sourceLicenseContext
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseConversionTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseConversionTaskStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseConversionTaskStatus(rawValue: rawValue) ?? LicenseConversionTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum LicenseCountingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case core
        case instance
        case socket
        case vcpu
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseCountingType] {
            return [
                .core,
                .instance,
                .socket,
                .vcpu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .core: return "Core"
            case .instance: return "Instance"
            case .socket: return "Socket"
            case .vcpu: return "vCPU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseCountingType(rawValue: rawValue) ?? LicenseCountingType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes {
    public enum LicenseDeletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case pendingDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseDeletionStatus] {
            return [
                .deleted,
                .pendingDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .pendingDelete: return "PENDING_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseDeletionStatus(rawValue: rawValue) ?? LicenseDeletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseOperationFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case failureTime = "FailureTime"
        case metadataList = "MetadataList"
        case operationName = "OperationName"
        case operationRequestedBy = "OperationRequestedBy"
        case resourceArn = "ResourceArn"
        case resourceOwnerId = "ResourceOwnerId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failureTime = failureTime {
            try encodeContainer.encode(failureTime.timeIntervalSince1970, forKey: .failureTime)
        }
        if let metadataList = metadataList {
            var metadataListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadataList)
            for metadatalist0 in metadataList {
                try metadataListContainer.encode(metadatalist0)
            }
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let operationRequestedBy = operationRequestedBy {
            try encodeContainer.encode(operationRequestedBy, forKey: .operationRequestedBy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerId = resourceOwnerId {
            try encodeContainer.encode(resourceOwnerId, forKey: .resourceOwnerId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let failureTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .failureTime)
        failureTime = failureTimeDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let resourceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerId)
        resourceOwnerId = resourceOwnerIdDecoded
        let operationRequestedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationRequestedBy)
        operationRequestedBy = operationRequestedByDecoded
        let metadataListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Metadata?].self, forKey: .metadataList)
        var metadataListDecoded0:[LicenseManagerClientTypes.Metadata]? = nil
        if let metadataListContainer = metadataListContainer {
            metadataListDecoded0 = [LicenseManagerClientTypes.Metadata]()
            for structure0 in metadataListContainer {
                if let structure0 = structure0 {
                    metadataListDecoded0?.append(structure0)
                }
            }
        }
        metadataList = metadataListDecoded0
    }
}

extension LicenseManagerClientTypes.LicenseOperationFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseOperationFailure(errorMessage: \(Swift.String(describing: errorMessage)), failureTime: \(Swift.String(describing: failureTime)), metadataList: \(Swift.String(describing: metadataList)), operationName: \(Swift.String(describing: operationName)), operationRequestedBy: \(Swift.String(describing: operationRequestedBy)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwnerId: \(Swift.String(describing: resourceOwnerId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Describes the failure of a license operation.
    public struct LicenseOperationFailure: Swift.Equatable {
        /// Error message.
        public var errorMessage: Swift.String?
        /// Failure time.
        public var failureTime: ClientRuntime.Date?
        /// Reserved.
        public var metadataList: [LicenseManagerClientTypes.Metadata]?
        /// Name of the operation.
        public var operationName: Swift.String?
        /// The requester is "License Manager Automated Discovery".
        public var operationRequestedBy: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the Amazon Web Services account that owns the resource.
        public var resourceOwnerId: Swift.String?
        /// Resource type.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            errorMessage: Swift.String? = nil,
            failureTime: ClientRuntime.Date? = nil,
            metadataList: [LicenseManagerClientTypes.Metadata]? = nil,
            operationName: Swift.String? = nil,
            operationRequestedBy: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.errorMessage = errorMessage
            self.failureTime = failureTime
            self.metadataList = metadataList
            self.operationName = operationName
            self.operationRequestedBy = operationRequestedBy
            self.resourceArn = resourceArn
            self.resourceOwnerId = resourceOwnerId
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.LicenseSpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiAssociationScope = "AmiAssociationScope"
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiAssociationScope = amiAssociationScope {
            try encodeContainer.encode(amiAssociationScope, forKey: .amiAssociationScope)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let amiAssociationScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiAssociationScope)
        amiAssociationScope = amiAssociationScopeDecoded
    }
}

extension LicenseManagerClientTypes.LicenseSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseSpecification(amiAssociationScope: \(Swift.String(describing: amiAssociationScope)), licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)))"}
}

extension LicenseManagerClientTypes {
    /// Details for associating a license configuration with a resource.
    public struct LicenseSpecification: Swift.Equatable {
        /// Scope of AMI associations. The possible value is cross-account.
        public var amiAssociationScope: Swift.String?
        /// Amazon Resource Name (ARN) of the license configuration.
        /// This member is required.
        public var licenseConfigurationArn: Swift.String?

        public init (
            amiAssociationScope: Swift.String? = nil,
            licenseConfigurationArn: Swift.String? = nil
        )
        {
            self.amiAssociationScope = amiAssociationScope
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }

}

extension LicenseManagerClientTypes {
    public enum LicenseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deactivated
        case deleted
        case expired
        case pendingAvailable
        case pendingDelete
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseStatus] {
            return [
                .available,
                .deactivated,
                .deleted,
                .expired,
                .pendingAvailable,
                .pendingDelete,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deactivated: return "DEACTIVATED"
            case .deleted: return "DELETED"
            case .expired: return "EXPIRED"
            case .pendingAvailable: return "PENDING_AVAILABLE"
            case .pendingDelete: return "PENDING_DELETE"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseStatus(rawValue: rawValue) ?? LicenseStatus.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.LicenseUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementUsages = "EntitlementUsages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlementUsages = entitlementUsages {
            var entitlementUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlementUsages)
            for entitlementusagelist0 in entitlementUsages {
                try entitlementUsagesContainer.encode(entitlementusagelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementUsagesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.EntitlementUsage?].self, forKey: .entitlementUsages)
        var entitlementUsagesDecoded0:[LicenseManagerClientTypes.EntitlementUsage]? = nil
        if let entitlementUsagesContainer = entitlementUsagesContainer {
            entitlementUsagesDecoded0 = [LicenseManagerClientTypes.EntitlementUsage]()
            for structure0 in entitlementUsagesContainer {
                if let structure0 = structure0 {
                    entitlementUsagesDecoded0?.append(structure0)
                }
            }
        }
        entitlementUsages = entitlementUsagesDecoded0
    }
}

extension LicenseManagerClientTypes.LicenseUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseUsage(entitlementUsages: \(Swift.String(describing: entitlementUsages)))"}
}

extension LicenseManagerClientTypes {
    /// Describes the entitlement usage associated with a license.
    public struct LicenseUsage: Swift.Equatable {
        /// License entitlement usages.
        public var entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]?

        public init (
            entitlementUsages: [LicenseManagerClientTypes.EntitlementUsage]? = nil
        )
        {
            self.entitlementUsages = entitlementUsages
        }
    }

}

extension LicenseUsageException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseUsageException(message: \(Swift.String(describing: message)))"}
}

extension LicenseUsageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LicenseUsageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have enough licenses available to support a new resource launch.
public struct LicenseUsageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LicenseUsageExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LicenseUsageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAssociationsForLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsForLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

extension ListAssociationsForLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationsForLicenseConfigurationInput(licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationsForLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationsForLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsForLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsForLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociationsForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsForLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAssociationsForLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationsForLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociationsForLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAssociationsForLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociationsForLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociationsForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociationsForLicenseConfigurationOutputError>
}

public struct ListAssociationsForLicenseConfigurationInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of a license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListAssociationsForLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsForLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationsForLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceeded" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationsForLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationsForLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociationsForLicenseConfigurationOutputResponse(licenseConfigurationAssociations: \(Swift.String(describing: licenseConfigurationAssociations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociationsForLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociationsForLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationAssociations = output.licenseConfigurationAssociations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsForLicenseConfigurationOutputResponse: Swift.Equatable {
    /// Information about the associations for the license configuration.
    public var licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationAssociations = licenseConfigurationAssociations
        self.nextToken = nextToken
    }
}

struct ListAssociationsForLicenseConfigurationOutputResponseBody: Swift.Equatable {
    public let licenseConfigurationAssociations: [LicenseManagerClientTypes.LicenseConfigurationAssociation]?
    public let nextToken: Swift.String?
}

extension ListAssociationsForLicenseConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationAssociations = "LicenseConfigurationAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationAssociationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfigurationAssociation?].self, forKey: .licenseConfigurationAssociations)
        var licenseConfigurationAssociationsDecoded0:[LicenseManagerClientTypes.LicenseConfigurationAssociation]? = nil
        if let licenseConfigurationAssociationsContainer = licenseConfigurationAssociationsContainer {
            licenseConfigurationAssociationsDecoded0 = [LicenseManagerClientTypes.LicenseConfigurationAssociation]()
            for structure0 in licenseConfigurationAssociationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationAssociations = licenseConfigurationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDistributedGrantsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributedGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributedGrantsOutputError>
}

extension ListDistributedGrantsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributedGrantsInput(filters: \(Swift.String(describing: filters)), grantArns: \(Swift.String(describing: grantArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDistributedGrantsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arnlist0 in grantArns {
                try grantArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDistributedGrantsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributedGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributedGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributedGrantsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributedGrantsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributedGrantsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributedGrantsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributedGrantsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributedGrantsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributedGrantsOutputError>
}

public struct ListDistributedGrantsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranteePrincipalARN
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsInputBody: Swift.Equatable {
    public let grantArns: [Swift.String]?
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDistributedGrantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[Swift.String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [Swift.String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDistributedGrantsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDistributedGrantsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributedGrantsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributedGrantsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributedGrantsOutputResponse(grants: \(Swift.String(describing: grants)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDistributedGrantsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDistributedGrantsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListDistributedGrantsOutputResponse: Swift.Equatable {
    /// Distributed grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListDistributedGrantsOutputResponseBody: Swift.Equatable {
    public let grants: [LicenseManagerClientTypes.Grant]?
    public let nextToken: Swift.String?
}

extension ListDistributedGrantsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Grant?].self, forKey: .grants)
        var grantsDecoded0:[LicenseManagerClientTypes.Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [LicenseManagerClientTypes.Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFailuresForLicenseConfigurationOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

extension ListFailuresForLicenseConfigurationOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFailuresForLicenseConfigurationOperationsInput(licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFailuresForLicenseConfigurationOperationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFailuresForLicenseConfigurationOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFailuresForLicenseConfigurationOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFailuresForLicenseConfigurationOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFailuresForLicenseConfigurationOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFailuresForLicenseConfigurationOperationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFailuresForLicenseConfigurationOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFailuresForLicenseConfigurationOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFailuresForLicenseConfigurationOperationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFailuresForLicenseConfigurationOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFailuresForLicenseConfigurationOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFailuresForLicenseConfigurationOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFailuresForLicenseConfigurationOperationsOutputError>
}

public struct ListFailuresForLicenseConfigurationOperationsInput: Swift.Equatable {
    /// Amazon Resource Name of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListFailuresForLicenseConfigurationOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFailuresForLicenseConfigurationOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFailuresForLicenseConfigurationOperationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFailuresForLicenseConfigurationOperationsOutputResponse(licenseOperationFailureList: \(Swift.String(describing: licenseOperationFailureList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFailuresForLicenseConfigurationOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseOperationFailureList = output.licenseOperationFailureList
            self.nextToken = output.nextToken
        } else {
            self.licenseOperationFailureList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFailuresForLicenseConfigurationOperationsOutputResponse: Swift.Equatable {
    /// License configuration operations that failed.
    public var licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseOperationFailureList = licenseOperationFailureList
        self.nextToken = nextToken
    }
}

struct ListFailuresForLicenseConfigurationOperationsOutputResponseBody: Swift.Equatable {
    public let licenseOperationFailureList: [LicenseManagerClientTypes.LicenseOperationFailure]?
    public let nextToken: Swift.String?
}

extension ListFailuresForLicenseConfigurationOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseOperationFailureList = "LicenseOperationFailureList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseOperationFailureListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseOperationFailure?].self, forKey: .licenseOperationFailureList)
        var licenseOperationFailureListDecoded0:[LicenseManagerClientTypes.LicenseOperationFailure]? = nil
        if let licenseOperationFailureListContainer = licenseOperationFailureListContainer {
            licenseOperationFailureListDecoded0 = [LicenseManagerClientTypes.LicenseOperationFailure]()
            for structure0 in licenseOperationFailureListContainer {
                if let structure0 = structure0 {
                    licenseOperationFailureListDecoded0?.append(structure0)
                }
            }
        }
        licenseOperationFailureList = licenseOperationFailureListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConfigurationsOutputError>
}

extension ListLicenseConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseConfigurationsInput(filters: \(Swift.String(describing: filters)), licenseConfigurationArns: \(Swift.String(describing: licenseConfigurationArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for stringlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(stringlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicenseConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicenseConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConfigurationsOutputError>
}

public struct ListLicenseConfigurationsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * licenseCountingType - The dimension for which licenses are counted. Possible values are vCPU | Instance | Core | Socket. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * enforceLicenseCount - A Boolean value that indicates whether hard license enforcement is used. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * usagelimitExceeded - A Boolean value that indicates whether the available licenses have been exceeded. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARN) of the license configurations.
    public var licenseConfigurationArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArns = licenseConfigurationArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsInputBody: Swift.Equatable {
    public let licenseConfigurationArns: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListLicenseConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArns = "LicenseConfigurationArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLicenseConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceeded" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseConfigurationsOutputResponse(licenseConfigurations: \(Swift.String(describing: licenseConfigurations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicenseConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurations = output.licenseConfigurations
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseConfigurationsOutputResponse: Swift.Equatable {
    /// Information about the license configurations.
    public var licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurations = licenseConfigurations
        self.nextToken = nextToken
    }
}

struct ListLicenseConfigurationsOutputResponseBody: Swift.Equatable {
    public let licenseConfigurations: [LicenseManagerClientTypes.LicenseConfiguration]?
    public let nextToken: Swift.String?
}

extension ListLicenseConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurations = "LicenseConfigurations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfiguration?].self, forKey: .licenseConfigurations)
        var licenseConfigurationsDecoded0:[LicenseManagerClientTypes.LicenseConfiguration]? = nil
        if let licenseConfigurationsContainer = licenseConfigurationsContainer {
            licenseConfigurationsDecoded0 = [LicenseManagerClientTypes.LicenseConfiguration]()
            for structure0 in licenseConfigurationsContainer {
                if let structure0 = structure0 {
                    licenseConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurations = licenseConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseConversionTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConversionTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConversionTasksOutputError>
}

extension ListLicenseConversionTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseConversionTasksInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseConversionTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseConversionTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConversionTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConversionTasksOutputError>
}

public struct ListLicenseConversionTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConversionTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseConversionTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConversionTasksOutputError>
}

public struct ListLicenseConversionTasksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConversionTasksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicenseConversionTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseConversionTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConversionTasksOutputError>
}

public struct ListLicenseConversionTasksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseConversionTasksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicenseConversionTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseConversionTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseConversionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseConversionTasksOutputError>
}

public struct ListLicenseConversionTasksInput: Swift.Equatable {
    /// Filters to scope the results. Valid filters are ResourceArns and Status.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseConversionTasksInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListLicenseConversionTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListLicenseConversionTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseConversionTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseConversionTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseConversionTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseConversionTasksOutputResponse(licenseConversionTasks: \(Swift.String(describing: licenseConversionTasks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseConversionTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicenseConversionTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConversionTasks = output.licenseConversionTasks
            self.nextToken = output.nextToken
        } else {
            self.licenseConversionTasks = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseConversionTasksOutputResponse: Swift.Equatable {
    /// Information about the license configuration tasks for your account.
    public var licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConversionTasks = licenseConversionTasks
        self.nextToken = nextToken
    }
}

struct ListLicenseConversionTasksOutputResponseBody: Swift.Equatable {
    public let licenseConversionTasks: [LicenseManagerClientTypes.LicenseConversionTask]?
    public let nextToken: Swift.String?
}

extension ListLicenseConversionTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConversionTasks = "LicenseConversionTasks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConversionTasksContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConversionTask?].self, forKey: .licenseConversionTasks)
        var licenseConversionTasksDecoded0:[LicenseManagerClientTypes.LicenseConversionTask]? = nil
        if let licenseConversionTasksContainer = licenseConversionTasksContainer {
            licenseConversionTasksDecoded0 = [LicenseManagerClientTypes.LicenseConversionTask]()
            for structure0 in licenseConversionTasksContainer {
                if let structure0 = structure0 {
                    licenseConversionTasksDecoded0?.append(structure0)
                }
            }
        }
        licenseConversionTasks = licenseConversionTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseManagerReportGeneratorsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseManagerReportGeneratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

extension ListLicenseManagerReportGeneratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseManagerReportGeneratorsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseManagerReportGeneratorsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseManagerReportGeneratorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseManagerReportGeneratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseManagerReportGeneratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseManagerReportGeneratorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseManagerReportGeneratorsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicenseManagerReportGeneratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseManagerReportGeneratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseManagerReportGeneratorsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicenseManagerReportGeneratorsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseManagerReportGeneratorsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseManagerReportGeneratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseManagerReportGeneratorsOutputError>
}

public struct ListLicenseManagerReportGeneratorsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * LicenseConfigurationArn
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseManagerReportGeneratorsInputBody: Swift.Equatable {
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListLicenseManagerReportGeneratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseManagerReportGeneratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseManagerReportGeneratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseManagerReportGeneratorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseManagerReportGeneratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseManagerReportGeneratorsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), reportGenerators: \(Swift.String(describing: reportGenerators)))"}
}

extension ListLicenseManagerReportGeneratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicenseManagerReportGeneratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportGenerators = output.reportGenerators
        } else {
            self.nextToken = nil
            self.reportGenerators = nil
        }
    }
}

public struct ListLicenseManagerReportGeneratorsOutputResponse: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// A report generator that creates periodic reports about your license configurations.
    public var reportGenerators: [LicenseManagerClientTypes.ReportGenerator]?

    public init (
        nextToken: Swift.String? = nil,
        reportGenerators: [LicenseManagerClientTypes.ReportGenerator]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportGenerators = reportGenerators
    }
}

struct ListLicenseManagerReportGeneratorsOutputResponseBody: Swift.Equatable {
    public let reportGenerators: [LicenseManagerClientTypes.ReportGenerator]?
    public let nextToken: Swift.String?
}

extension ListLicenseManagerReportGeneratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportGenerators = "ReportGenerators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportGenerator?].self, forKey: .reportGenerators)
        var reportGeneratorsDecoded0:[LicenseManagerClientTypes.ReportGenerator]? = nil
        if let reportGeneratorsContainer = reportGeneratorsContainer {
            reportGeneratorsDecoded0 = [LicenseManagerClientTypes.ReportGenerator]()
            for structure0 in reportGeneratorsContainer {
                if let structure0 = structure0 {
                    reportGeneratorsDecoded0?.append(structure0)
                }
            }
        }
        reportGenerators = reportGeneratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseSpecificationsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseSpecificationsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseSpecificationsForResourceOutputError>
}

extension ListLicenseSpecificationsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseSpecificationsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListLicenseSpecificationsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListLicenseSpecificationsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseSpecificationsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseSpecificationsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseSpecificationsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicenseSpecificationsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseSpecificationsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseSpecificationsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicenseSpecificationsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseSpecificationsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseSpecificationsForResourceOutputError>
}

public struct ListLicenseSpecificationsForResourceInput: Swift.Equatable {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) of a resource that has an associated license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListLicenseSpecificationsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListLicenseSpecificationsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLicenseSpecificationsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseSpecificationsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseSpecificationsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseSpecificationsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseSpecificationsForResourceOutputResponse(licenseSpecifications: \(Swift.String(describing: licenseSpecifications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseSpecificationsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicenseSpecificationsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseSpecifications = output.licenseSpecifications
            self.nextToken = output.nextToken
        } else {
            self.licenseSpecifications = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseSpecificationsForResourceOutputResponse: Swift.Equatable {
    /// License configurations associated with a resource.
    public var licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseSpecifications = licenseSpecifications
        self.nextToken = nextToken
    }
}

struct ListLicenseSpecificationsForResourceOutputResponseBody: Swift.Equatable {
    public let licenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    public let nextToken: Swift.String?
}

extension ListLicenseSpecificationsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseSpecifications = "LicenseSpecifications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .licenseSpecifications)
        var licenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let licenseSpecificationsContainer = licenseSpecificationsContainer {
            licenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in licenseSpecificationsContainer {
                if let structure0 = structure0 {
                    licenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        licenseSpecifications = licenseSpecificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicenseVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseVersionsOutputError>
}

extension ListLicenseVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseVersionsInput(licenseArn: \(Swift.String(describing: licenseArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicenseVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicenseVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicenseVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicenseVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicenseVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicenseVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicenseVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicenseVersionsOutputError>
}

public struct ListLicenseVersionsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license.
    /// This member is required.
    public var licenseArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseArn = licenseArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsInputBody: Swift.Equatable {
    public let licenseArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListLicenseVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseArn = "LicenseArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicenseVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicenseVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicenseVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicenseVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicenseVersionsOutputResponse(licenses: \(Swift.String(describing: licenses)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicenseVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicenseVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicenseVersionsOutputResponse: Swift.Equatable {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicenseVersionsOutputResponseBody: Swift.Equatable {
    public let licenses: [LicenseManagerClientTypes.License]?
    public let nextToken: Swift.String?
}

extension ListLicenseVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.License?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLicensesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicensesOutputError>
}

extension ListLicensesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicensesInput(filters: \(Swift.String(describing: filters)), licenseArns: \(Swift.String(describing: licenseArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicensesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arnlist0 in licenseArns {
                try licenseArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLicensesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicensesOutputError>
}

public struct ListLicensesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicensesOutputError>
}

public struct ListLicensesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicensesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListLicensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicensesOutputError>
}

public struct ListLicensesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLicensesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListLicensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLicensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLicensesOutputError>
}

public struct ListLicensesInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * Beneficiary
    ///
    /// * ProductSKU
    ///
    /// * Fingerprint
    ///
    /// * Status
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLicensesInputBody: Swift.Equatable {
    public let licenseArns: [Swift.String]?
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListLicensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[Swift.String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [Swift.String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListLicensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLicensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLicensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLicensesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLicensesOutputResponse(licenses: \(Swift.String(describing: licenses)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLicensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLicensesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListLicensesOutputResponse: Swift.Equatable {
    /// License details.
    public var licenses: [LicenseManagerClientTypes.License]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenses: [LicenseManagerClientTypes.License]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListLicensesOutputResponseBody: Swift.Equatable {
    public let licenses: [LicenseManagerClientTypes.License]?
    public let nextToken: Swift.String?
}

extension ListLicensesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.License?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.License]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.License]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReceivedGrantsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedGrantsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedGrantsOutputError>
}

extension ListReceivedGrantsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReceivedGrantsInput(filters: \(Swift.String(describing: filters)), grantArns: \(Swift.String(describing: grantArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReceivedGrantsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let grantArns = grantArns {
            var grantArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantArns)
            for arnlist0 in grantArns {
                try grantArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListReceivedGrantsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedGrantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedGrantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedGrantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedGrantsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListReceivedGrantsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReceivedGrantsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedGrantsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListReceivedGrantsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReceivedGrantsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedGrantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedGrantsOutputError>
}

public struct ListReceivedGrantsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * LicenseIssuerName
    ///
    /// * LicenseArn
    ///
    /// * GrantStatus
    ///
    /// * GranterAccountId
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the grants.
    public var grantArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        grantArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.grantArns = grantArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsInputBody: Swift.Equatable {
    public let grantArns: [Swift.String]?
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListReceivedGrantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case grantArns = "GrantArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .grantArns)
        var grantArnsDecoded0:[Swift.String]? = nil
        if let grantArnsContainer = grantArnsContainer {
            grantArnsDecoded0 = [Swift.String]()
            for string0 in grantArnsContainer {
                if let string0 = string0 {
                    grantArnsDecoded0?.append(string0)
                }
            }
        }
        grantArns = grantArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedGrantsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReceivedGrantsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceivedGrantsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceivedGrantsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReceivedGrantsOutputResponse(grants: \(Swift.String(describing: grants)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReceivedGrantsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReceivedGrantsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedGrantsOutputResponse: Swift.Equatable {
    /// Received grant details.
    public var grants: [LicenseManagerClientTypes.Grant]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        grants: [LicenseManagerClientTypes.Grant]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListReceivedGrantsOutputResponseBody: Swift.Equatable {
    public let grants: [LicenseManagerClientTypes.Grant]?
    public let nextToken: Swift.String?
}

extension ListReceivedGrantsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Grant?].self, forKey: .grants)
        var grantsDecoded0:[LicenseManagerClientTypes.Grant]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [LicenseManagerClientTypes.Grant]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReceivedLicensesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedLicensesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedLicensesOutputError>
}

extension ListReceivedLicensesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReceivedLicensesInput(filters: \(Swift.String(describing: filters)), licenseArns: \(Swift.String(describing: licenseArns)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReceivedLicensesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let licenseArns = licenseArns {
            var licenseArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseArns)
            for arnlist0 in licenseArns {
                try licenseArnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListReceivedLicensesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedLicensesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedLicensesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReceivedLicensesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedLicensesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListReceivedLicensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReceivedLicensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReceivedLicensesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListReceivedLicensesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReceivedLicensesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReceivedLicensesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReceivedLicensesOutputError>
}

public struct ListReceivedLicensesInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * ProductSKU
    ///
    /// * Status
    ///
    /// * Fingerprint
    ///
    /// * IssuerName
    ///
    /// * Beneficiary
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Names (ARNs) of the licenses.
    public var licenseArns: [Swift.String]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseArns = licenseArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesInputBody: Swift.Equatable {
    public let licenseArns: [Swift.String]?
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListReceivedLicensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseArns = "LicenseArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseArns)
        var licenseArnsDecoded0:[Swift.String]? = nil
        if let licenseArnsContainer = licenseArnsContainer {
            licenseArnsDecoded0 = [Swift.String]()
            for string0 in licenseArnsContainer {
                if let string0 = string0 {
                    licenseArnsDecoded0?.append(string0)
                }
            }
        }
        licenseArns = licenseArnsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListReceivedLicensesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReceivedLicensesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceivedLicensesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceivedLicensesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReceivedLicensesOutputResponse(licenses: \(Swift.String(describing: licenses)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReceivedLicensesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReceivedLicensesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenses = output.licenses
            self.nextToken = output.nextToken
        } else {
            self.licenses = nil
            self.nextToken = nil
        }
    }
}

public struct ListReceivedLicensesOutputResponse: Swift.Equatable {
    /// Received license details.
    public var licenses: [LicenseManagerClientTypes.GrantedLicense]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenses: [LicenseManagerClientTypes.GrantedLicense]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenses = licenses
        self.nextToken = nextToken
    }
}

struct ListReceivedLicensesOutputResponseBody: Swift.Equatable {
    public let licenses: [LicenseManagerClientTypes.GrantedLicense]?
    public let nextToken: Swift.String?
}

extension ListReceivedLicensesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenses = "Licenses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licensesContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.GrantedLicense?].self, forKey: .licenses)
        var licensesDecoded0:[LicenseManagerClientTypes.GrantedLicense]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [LicenseManagerClientTypes.GrantedLicense]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceInventoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceInventoryOutputError>
}

extension ListResourceInventoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceInventoryInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceInventoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceInventoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceInventoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceInventoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceInventoryInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceInventoryInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceInventoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceInventoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceInventoryOutputError>
}

public struct ListResourceInventoryInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * account_id - The ID of the Amazon Web Services account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * application_name - The name of the application. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * license_included - The type of license included. Logical operators are EQUALS | NOT_EQUALS. Possible values are sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
    ///
    /// * platform - The platform of the resource. Logical operators are EQUALS | BEGINS_WITH.
    ///
    /// * resource_id - The ID of the resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * tag: - The key/value combination of a tag assigned to the resource. Logical operators are EQUALS (single account) or EQUALS | NOT_EQUALS (cross account).
    public var filters: [LicenseManagerClientTypes.InventoryFilter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceInventoryInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let filters: [LicenseManagerClientTypes.InventoryFilter]?
}

extension ListResourceInventoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResourceInventoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceInventoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependency" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceeded" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceInventoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case failedDependencyException(FailedDependencyException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceInventoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceInventoryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceInventoryList: \(Swift.String(describing: resourceInventoryList)))"}
}

extension ListResourceInventoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceInventoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceInventoryList = output.resourceInventoryList
        } else {
            self.nextToken = nil
            self.resourceInventoryList = nil
        }
    }
}

public struct ListResourceInventoryOutputResponse: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Information about the resources.
    public var resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]?

    public init (
        nextToken: Swift.String? = nil,
        resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInventoryList = resourceInventoryList
    }
}

struct ListResourceInventoryOutputResponseBody: Swift.Equatable {
    public let resourceInventoryList: [LicenseManagerClientTypes.ResourceInventory]?
    public let nextToken: Swift.String?
}

extension ListResourceInventoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceInventoryList = "ResourceInventoryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceInventoryListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ResourceInventory?].self, forKey: .resourceInventoryList)
        var resourceInventoryListDecoded0:[LicenseManagerClientTypes.ResourceInventory]? = nil
        if let resourceInventoryListContainer = resourceInventoryListContainer {
            resourceInventoryListDecoded0 = [LicenseManagerClientTypes.ResourceInventory]()
            for structure0 in resourceInventoryListContainer {
                if let structure0 = structure0 {
                    resourceInventoryListDecoded0?.append(structure0)
                }
            }
        }
        resourceInventoryList = resourceInventoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init (
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [LicenseManagerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTokensInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTokensInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTokensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTokensOutputError>
}

extension ListTokensInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTokensInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), tokenIds: \(Swift.String(describing: tokenIds)))"}
}

extension ListTokensInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let tokenIds = tokenIds {
            var tokenIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenIds)
            for stringlist0 in tokenIds {
                try tokenIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct ListTokensInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTokensInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTokensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTokensOutputError>
}

public struct ListTokensInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTokensInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTokensInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTokensInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTokensOutputError>
}

public struct ListTokensInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTokensInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTokensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTokensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTokensOutputError>
}

public struct ListTokensInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTokensInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTokensInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTokensOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTokensInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTokensOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTokensOutputError>
}

public struct ListTokensInput: Swift.Equatable {
    /// Filters to scope the results. The following filter is supported:
    ///
    /// * LicenseArns
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Token IDs.
    public var tokenIds: [Swift.String]?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tokenIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tokenIds = tokenIds
    }
}

struct ListTokensInputBody: Swift.Equatable {
    public let tokenIds: [Swift.String]?
    public let filters: [LicenseManagerClientTypes.Filter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTokensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case tokenIds = "TokenIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenIds)
        var tokenIdsDecoded0:[Swift.String]? = nil
        if let tokenIdsContainer = tokenIdsContainer {
            tokenIdsDecoded0 = [Swift.String]()
            for string0 in tokenIdsContainer {
                if let string0 = string0 {
                    tokenIdsDecoded0?.append(string0)
                }
            }
        }
        tokenIds = tokenIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTokensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTokensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTokensOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTokensOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTokensOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tokens: \(Swift.String(describing: tokens)))"}
}

extension ListTokensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTokensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tokens = output.tokens
        } else {
            self.nextToken = nil
            self.tokens = nil
        }
    }
}

public struct ListTokensOutputResponse: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Received token details.
    public var tokens: [LicenseManagerClientTypes.TokenData]?

    public init (
        nextToken: Swift.String? = nil,
        tokens: [LicenseManagerClientTypes.TokenData]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokens = tokens
    }
}

struct ListTokensOutputResponseBody: Swift.Equatable {
    public let tokens: [LicenseManagerClientTypes.TokenData]?
    public let nextToken: Swift.String?
}

extension ListTokensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tokens = "Tokens"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokensContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.TokenData?].self, forKey: .tokens)
        var tokensDecoded0:[LicenseManagerClientTypes.TokenData]? = nil
        if let tokensContainer = tokensContainer {
            tokensDecoded0 = [LicenseManagerClientTypes.TokenData]()
            for structure0 in tokensContainer {
                if let structure0 = structure0 {
                    tokensDecoded0?.append(structure0)
                }
            }
        }
        tokens = tokensDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUsageForLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsageForLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsageForLicenseConfigurationOutputError>
}

extension ListUsageForLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsageForLicenseConfigurationInput(filters: \(Swift.String(describing: filters)), licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUsageForLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUsageForLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsageForLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsageForLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsageForLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsageForLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUsageForLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsageForLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsageForLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUsageForLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsageForLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsageForLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsageForLicenseConfigurationOutputError>
}

public struct ListUsageForLicenseConfigurationInput: Swift.Equatable {
    /// Filters to scope the results. The following filters and logical operators are supported:
    ///
    /// * resourceArn - The ARN of the license configuration resource. Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceType - The resource type (EC2_INSTANCE | EC2_HOST | EC2_AMI | SYSTEMS_MANAGER_MANAGED_INSTANCE). Logical operators are EQUALS | NOT_EQUALS.
    ///
    /// * resourceAccount - The ID of the account that owns the resource. Logical operators are EQUALS | NOT_EQUALS.
    public var filters: [LicenseManagerClientTypes.Filter]?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [LicenseManagerClientTypes.Filter]? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.licenseConfigurationArn = licenseConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let filters: [LicenseManagerClientTypes.Filter]?
}

extension ListUsageForLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsageForLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsageForLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilterLimitExceeded" : self = .filterLimitExceededException(try FilterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsageForLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case filterLimitExceededException(FilterLimitExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsageForLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsageForLicenseConfigurationOutputResponse(licenseConfigurationUsageList: \(Swift.String(describing: licenseConfigurationUsageList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUsageForLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsageForLicenseConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.licenseConfigurationUsageList = output.licenseConfigurationUsageList
            self.nextToken = output.nextToken
        } else {
            self.licenseConfigurationUsageList = nil
            self.nextToken = nil
        }
    }
}

public struct ListUsageForLicenseConfigurationOutputResponse: Swift.Equatable {
    /// Information about the license configurations.
    public var licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseConfigurationUsageList = licenseConfigurationUsageList
        self.nextToken = nextToken
    }
}

struct ListUsageForLicenseConfigurationOutputResponseBody: Swift.Equatable {
    public let licenseConfigurationUsageList: [LicenseManagerClientTypes.LicenseConfigurationUsage]?
    public let nextToken: Swift.String?
}

extension ListUsageForLicenseConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationUsageList = "LicenseConfigurationUsageList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationUsageListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseConfigurationUsage?].self, forKey: .licenseConfigurationUsageList)
        var licenseConfigurationUsageListDecoded0:[LicenseManagerClientTypes.LicenseConfigurationUsage]? = nil
        if let licenseConfigurationUsageListContainer = licenseConfigurationUsageListContainer {
            licenseConfigurationUsageListDecoded0 = [LicenseManagerClientTypes.LicenseConfigurationUsage]()
            for structure0 in licenseConfigurationUsageListContainer {
                if let structure0 = structure0 {
                    licenseConfigurationUsageListDecoded0?.append(structure0)
                }
            }
        }
        licenseConfigurationUsageList = licenseConfigurationUsageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LicenseManagerClientTypes.ManagedResourceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationCount = "AssociationCount"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationCount = associationCount {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationCount)
        associationCount = associationCountDecoded
    }
}

extension LicenseManagerClientTypes.ManagedResourceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedResourceSummary(associationCount: \(Swift.String(describing: associationCount)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Summary information about a managed resource.
    public struct ManagedResourceSummary: Swift.Equatable {
        /// Number of resources associated with licenses.
        public var associationCount: Swift.Int?
        /// Type of resource associated with a license.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            associationCount: Swift.Int? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.associationCount = associationCount
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.Metadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes.Metadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Metadata(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// Describes key/value pairs.
    public struct Metadata: Swift.Equatable {
        /// The key name.
        public var name: Swift.String?
        /// The value.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NoEntitlementsAllowedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoEntitlementsAllowedException(message: \(Swift.String(describing: message)))"}
}

extension NoEntitlementsAllowedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoEntitlementsAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are no entitlements found for this license, or the entitlement maximum count is reached.
public struct NoEntitlementsAllowedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoEntitlementsAllowedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoEntitlementsAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.OrganizationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableIntegration = "EnableIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableIntegration != false {
            try encodeContainer.encode(enableIntegration, forKey: .enableIntegration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableIntegrationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableIntegration)
        enableIntegration = enableIntegrationDecoded
    }
}

extension LicenseManagerClientTypes.OrganizationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationConfiguration(enableIntegration: \(Swift.String(describing: enableIntegration)))"}
}

extension LicenseManagerClientTypes {
    /// Configuration information for Organizations.
    public struct OrganizationConfiguration: Swift.Equatable {
        /// Enables Organizations integration.
        /// This member is required.
        public var enableIntegration: Swift.Bool

        public init (
            enableIntegration: Swift.Bool = false
        )
        {
            self.enableIntegration = enableIntegration
        }
    }

}

extension LicenseManagerClientTypes.ProductInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productInformationFilterList = "ProductInformationFilterList"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterList = productInformationFilterList {
            var productInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterList)
            for productinformationfilterlist0 in productInformationFilterList {
                try productInformationFilterListContainer.encode(productinformationfilterlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let productInformationFilterListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformationFilter?].self, forKey: .productInformationFilterList)
        var productInformationFilterListDecoded0:[LicenseManagerClientTypes.ProductInformationFilter]? = nil
        if let productInformationFilterListContainer = productInformationFilterListContainer {
            productInformationFilterListDecoded0 = [LicenseManagerClientTypes.ProductInformationFilter]()
            for structure0 in productInformationFilterListContainer {
                if let structure0 = structure0 {
                    productInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        productInformationFilterList = productInformationFilterListDecoded0
    }
}

extension LicenseManagerClientTypes.ProductInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProductInformation(productInformationFilterList: \(Swift.String(describing: productInformationFilterList)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Describes product information for a license configuration.
    public struct ProductInformation: Swift.Equatable {
        /// A Product information filter consists of a ProductInformationFilterComparator which is a logical operator, a ProductInformationFilterName which specifies the type of filter being declared, and a ProductInformationFilterValue that specifies the value to filter on. Accepted values for ProductInformationFilterName are listed here along with descriptions and valid options for ProductInformationFilterComparator. The following filters and are supported when the resource type is SSM_MANAGED:
        ///
        /// * Application Name - The name of the application. Logical operator is EQUALS.
        ///
        /// * Application Publisher - The publisher of the application. Logical operator is EQUALS.
        ///
        /// * Application Version - The version of the application. Logical operator is EQUALS.
        ///
        /// * Platform Name - The name of the platform. Logical operator is EQUALS.
        ///
        /// * Platform Type - The platform type. Logical operator is EQUALS.
        ///
        /// * Tag:key - The key of a tag attached to an Amazon Web Services resource you wish to exclude from automated discovery. Logical operator is NOT_EQUALS. The key for your tag must be appended to Tag: following the example: Tag:name-of-your-key. ProductInformationFilterValue is optional if you are not using values for the key.
        ///
        /// * AccountId - The 12-digit ID of an Amazon Web Services account you wish to exclude from automated discovery. Logical operator is NOT_EQUALS.
        ///
        /// * License Included - The type of license included. Logical operators are EQUALS and NOT_EQUALS. Possible values are: sql-server-enterprise | sql-server-standard | sql-server-web | windows-server-datacenter.
        ///
        ///
        /// The following filters and logical operators are supported when the resource type is RDS:
        ///
        /// * Engine Edition - The edition of the database engine. Logical operator is EQUALS. Possible values are: oracle-ee | oracle-se | oracle-se1 | oracle-se2.
        ///
        /// * License Pack - The license pack. Logical operator is EQUALS. Possible values are: data guard | diagnostic pack sqlt | tuning pack sqlt | ols | olap.
        /// This member is required.
        public var productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]?
        /// Resource type. The possible values are SSM_MANAGED | RDS.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            productInformationFilterList: [LicenseManagerClientTypes.ProductInformationFilter]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.productInformationFilterList = productInformationFilterList
            self.resourceType = resourceType
        }
    }

}

extension LicenseManagerClientTypes.ProductInformationFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productInformationFilterComparator = "ProductInformationFilterComparator"
        case productInformationFilterName = "ProductInformationFilterName"
        case productInformationFilterValue = "ProductInformationFilterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productInformationFilterComparator = productInformationFilterComparator {
            try encodeContainer.encode(productInformationFilterComparator, forKey: .productInformationFilterComparator)
        }
        if let productInformationFilterName = productInformationFilterName {
            try encodeContainer.encode(productInformationFilterName, forKey: .productInformationFilterName)
        }
        if let productInformationFilterValue = productInformationFilterValue {
            var productInformationFilterValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationFilterValue)
            for stringlist0 in productInformationFilterValue {
                try productInformationFilterValueContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productInformationFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productInformationFilterName)
        productInformationFilterName = productInformationFilterNameDecoded
        let productInformationFilterValueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .productInformationFilterValue)
        var productInformationFilterValueDecoded0:[Swift.String]? = nil
        if let productInformationFilterValueContainer = productInformationFilterValueContainer {
            productInformationFilterValueDecoded0 = [Swift.String]()
            for string0 in productInformationFilterValueContainer {
                if let string0 = string0 {
                    productInformationFilterValueDecoded0?.append(string0)
                }
            }
        }
        productInformationFilterValue = productInformationFilterValueDecoded0
        let productInformationFilterComparatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productInformationFilterComparator)
        productInformationFilterComparator = productInformationFilterComparatorDecoded
    }
}

extension LicenseManagerClientTypes.ProductInformationFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProductInformationFilter(productInformationFilterComparator: \(Swift.String(describing: productInformationFilterComparator)), productInformationFilterName: \(Swift.String(describing: productInformationFilterName)), productInformationFilterValue: \(Swift.String(describing: productInformationFilterValue)))"}
}

extension LicenseManagerClientTypes {
    /// Describes product information filters.
    public struct ProductInformationFilter: Swift.Equatable {
        /// Logical operator.
        /// This member is required.
        public var productInformationFilterComparator: Swift.String?
        /// Filter name.
        /// This member is required.
        public var productInformationFilterName: Swift.String?
        /// Filter value.
        public var productInformationFilterValue: [Swift.String]?

        public init (
            productInformationFilterComparator: Swift.String? = nil,
            productInformationFilterName: Swift.String? = nil,
            productInformationFilterValue: [Swift.String]? = nil
        )
        {
            self.productInformationFilterComparator = productInformationFilterComparator
            self.productInformationFilterName = productInformationFilterName
            self.productInformationFilterValue = productInformationFilterValue
        }
    }

}

extension LicenseManagerClientTypes.ProvisionalConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxTimeToLiveInMinutes = "MaxTimeToLiveInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxTimeToLiveInMinutes = maxTimeToLiveInMinutes {
            try encodeContainer.encode(maxTimeToLiveInMinutes, forKey: .maxTimeToLiveInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxTimeToLiveInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTimeToLiveInMinutes)
        maxTimeToLiveInMinutes = maxTimeToLiveInMinutesDecoded
    }
}

extension LicenseManagerClientTypes.ProvisionalConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionalConfiguration(maxTimeToLiveInMinutes: \(Swift.String(describing: maxTimeToLiveInMinutes)))"}
}

extension LicenseManagerClientTypes {
    /// Details about a provisional configuration.
    public struct ProvisionalConfiguration: Swift.Equatable {
        /// Maximum time for the provisional configuration, in minutes.
        /// This member is required.
        public var maxTimeToLiveInMinutes: Swift.Int?

        public init (
            maxTimeToLiveInMinutes: Swift.Int? = nil
        )
        {
            self.maxTimeToLiveInMinutes = maxTimeToLiveInMinutes
        }
    }

}

extension RateLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RateLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension RateLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many requests have been submitted. Try again after a brief wait.
public struct RateLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RateLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.ReceivedMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedOperations = "AllowedOperations"
        case receivedStatus = "ReceivedStatus"
        case receivedStatusReason = "ReceivedStatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedOperations = allowedOperations {
            var allowedOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOperations)
            for allowedoperationlist0 in allowedOperations {
                try allowedOperationsContainer.encode(allowedoperationlist0.rawValue)
            }
        }
        if let receivedStatus = receivedStatus {
            try encodeContainer.encode(receivedStatus.rawValue, forKey: .receivedStatus)
        }
        if let receivedStatusReason = receivedStatusReason {
            try encodeContainer.encode(receivedStatusReason, forKey: .receivedStatusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let receivedStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReceivedStatus.self, forKey: .receivedStatus)
        receivedStatus = receivedStatusDecoded
        let receivedStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receivedStatusReason)
        receivedStatusReason = receivedStatusReasonDecoded
        let allowedOperationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.AllowedOperation?].self, forKey: .allowedOperations)
        var allowedOperationsDecoded0:[LicenseManagerClientTypes.AllowedOperation]? = nil
        if let allowedOperationsContainer = allowedOperationsContainer {
            allowedOperationsDecoded0 = [LicenseManagerClientTypes.AllowedOperation]()
            for string0 in allowedOperationsContainer {
                if let string0 = string0 {
                    allowedOperationsDecoded0?.append(string0)
                }
            }
        }
        allowedOperations = allowedOperationsDecoded0
    }
}

extension LicenseManagerClientTypes.ReceivedMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReceivedMetadata(allowedOperations: \(Swift.String(describing: allowedOperations)), receivedStatus: \(Swift.String(describing: receivedStatus)), receivedStatusReason: \(Swift.String(describing: receivedStatusReason)))"}
}

extension LicenseManagerClientTypes {
    /// Metadata associated with received licenses and grants.
    public struct ReceivedMetadata: Swift.Equatable {
        /// Allowed operations.
        public var allowedOperations: [LicenseManagerClientTypes.AllowedOperation]?
        /// Received status.
        public var receivedStatus: LicenseManagerClientTypes.ReceivedStatus?
        /// Received status reason.
        public var receivedStatusReason: Swift.String?

        public init (
            allowedOperations: [LicenseManagerClientTypes.AllowedOperation]? = nil,
            receivedStatus: LicenseManagerClientTypes.ReceivedStatus? = nil,
            receivedStatusReason: Swift.String? = nil
        )
        {
            self.allowedOperations = allowedOperations
            self.receivedStatus = receivedStatus
            self.receivedStatusReason = receivedStatusReason
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReceivedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case failedWorkflow
        case pendingAccept
        case pendingWorkflow
        case rejected
        case workflowCompleted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceivedStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .failedWorkflow,
                .pendingAccept,
                .pendingWorkflow,
                .rejected,
                .workflowCompleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .failedWorkflow: return "FAILED_WORKFLOW"
            case .pendingAccept: return "PENDING_ACCEPT"
            case .pendingWorkflow: return "PENDING_WORKFLOW"
            case .rejected: return "REJECTED"
            case .workflowCompleted: return "WORKFLOW_COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReceivedStatus(rawValue: rawValue) ?? ReceivedStatus.sdkUnknown(rawValue)
        }
    }
}

extension RedirectException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedirectException(location: \(Swift.String(describing: location)), message: \(Swift.String(describing: message)))"}
}

extension RedirectException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RedirectExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This is not the correct Region for the resource. Try again.
public struct RedirectException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var location: Swift.String?
    public var message: Swift.String?

    public init (
        location: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.location = location
        self.message = message
    }
}

struct RedirectExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RedirectExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RejectGrantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectGrantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectGrantOutputError>
}

extension RejectGrantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectGrantInput(grantArn: \(Swift.String(describing: grantArn)))"}
}

extension RejectGrantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantArn = grantArn {
            try encodeContainer.encode(grantArn, forKey: .grantArn)
        }
    }
}

public struct RejectGrantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectGrantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectGrantOutputError>
}

public struct RejectGrantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectGrantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectGrantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectGrantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectGrantOutputError>
}

public struct RejectGrantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectGrantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RejectGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectGrantOutputError>
}

public struct RejectGrantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectGrantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RejectGrantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectGrantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectGrantInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectGrantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectGrantOutputError>
}

public struct RejectGrantInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the grant.
    /// This member is required.
    public var grantArn: Swift.String?

    public init (
        grantArn: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
    }
}

struct RejectGrantInputBody: Swift.Equatable {
    public let grantArn: Swift.String?
}

extension RejectGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
    }
}

extension RejectGrantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectGrantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectGrantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectGrantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectGrantOutputResponse(grantArn: \(Swift.String(describing: grantArn)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension RejectGrantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectGrantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.grantArn = output.grantArn
            self.status = output.status
            self.version = output.version
        } else {
            self.grantArn = nil
            self.status = nil
            self.version = nil
        }
    }
}

public struct RejectGrantOutputResponse: Swift.Equatable {
    /// Grant ARN.
    public var grantArn: Swift.String?
    /// Grant status.
    public var status: LicenseManagerClientTypes.GrantStatus?
    /// Grant version.
    public var version: Swift.String?

    public init (
        grantArn: Swift.String? = nil,
        status: LicenseManagerClientTypes.GrantStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.grantArn = grantArn
        self.status = status
        self.version = version
    }
}

struct RejectGrantOutputResponseBody: Swift.Equatable {
    public let grantArn: Swift.String?
    public let status: LicenseManagerClientTypes.GrantStatus?
    public let version: Swift.String?
}

extension RejectGrantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantArn = "GrantArn"
        case status = "Status"
        case version = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantArn)
        grantArn = grantArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.GrantStatus.self, forKey: .status)
        status = statusDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum RenewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case monthly
        case `none`
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [RenewType] {
            return [
                .monthly,
                .none,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "Monthly"
            case .none: return "None"
            case .weekly: return "Weekly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenewType(rawValue: rawValue) ?? RenewType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ReportContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for arnlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(arnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
    }
}

extension LicenseManagerClientTypes.ReportContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportContext(licenseConfigurationArns: \(Swift.String(describing: licenseConfigurationArns)))"}
}

extension LicenseManagerClientTypes {
    /// Details of the license configuration that this generator reports on.
    public struct ReportContext: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the license configuration that this generator reports on.
        /// This member is required.
        public var licenseConfigurationArns: [Swift.String]?

        public init (
            licenseConfigurationArns: [Swift.String]? = nil
        )
        {
            self.licenseConfigurationArns = licenseConfigurationArns
        }
    }

}

extension LicenseManagerClientTypes.ReportFrequency: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case period
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let periodDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequencyType.self, forKey: .period)
        period = periodDecoded
    }
}

extension LicenseManagerClientTypes.ReportFrequency: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportFrequency(period: \(Swift.String(describing: period)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// Details about how frequently reports are generated.
    public struct ReportFrequency: Swift.Equatable {
        /// Time period between each report. The period can be daily, weekly, or monthly.
        public var period: LicenseManagerClientTypes.ReportFrequencyType?
        /// Number of times within the frequency period that a report is generated. The only supported value is 1.
        public var value: Swift.Int?

        public init (
            period: LicenseManagerClientTypes.ReportFrequencyType? = nil,
            value: Swift.Int? = nil
        )
        {
            self.period = period
            self.value = value
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReportFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequencyType] {
            return [
                .day,
                .month,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFrequencyType(rawValue: rawValue) ?? ReportFrequencyType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ReportGenerator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case description = "Description"
        case lastReportGenerationTime = "LastReportGenerationTime"
        case lastRunFailureReason = "LastRunFailureReason"
        case lastRunStatus = "LastRunStatus"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportCreatorAccount = "ReportCreatorAccount"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case reportType = "ReportType"
        case s3Location = "S3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastReportGenerationTime = lastReportGenerationTime {
            try encodeContainer.encode(lastReportGenerationTime, forKey: .lastReportGenerationTime)
        }
        if let lastRunFailureReason = lastRunFailureReason {
            try encodeContainer.encode(lastRunFailureReason, forKey: .lastRunFailureReason)
        }
        if let lastRunStatus = lastRunStatus {
            try encodeContainer.encode(lastRunStatus, forKey: .lastRunStatus)
        }
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportCreatorAccount = reportCreatorAccount {
            try encodeContainer.encode(reportCreatorAccount, forKey: .reportCreatorAccount)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let reportType = reportType {
            var reportTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportType)
            for reporttypelist0 in reportType {
                try reportTypeContainer.encode(reporttypelist0.rawValue)
            }
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let reportTypeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .reportType)
        var reportTypeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let reportTypeContainer = reportTypeContainer {
            reportTypeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for string0 in reportTypeContainer {
                if let string0 = string0 {
                    reportTypeDecoded0?.append(string0)
                }
            }
        }
        reportType = reportTypeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let lastRunStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRunStatus)
        lastRunStatus = lastRunStatusDecoded
        let lastRunFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRunFailureReason)
        lastRunFailureReason = lastRunFailureReasonDecoded
        let lastReportGenerationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastReportGenerationTime)
        lastReportGenerationTime = lastReportGenerationTimeDecoded
        let reportCreatorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportCreatorAccount)
        reportCreatorAccount = reportCreatorAccountDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LicenseManagerClientTypes.ReportGenerator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportGenerator(createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), lastReportGenerationTime: \(Swift.String(describing: lastReportGenerationTime)), lastRunFailureReason: \(Swift.String(describing: lastRunFailureReason)), lastRunStatus: \(Swift.String(describing: lastRunStatus)), licenseManagerReportGeneratorArn: \(Swift.String(describing: licenseManagerReportGeneratorArn)), reportContext: \(Swift.String(describing: reportContext)), reportCreatorAccount: \(Swift.String(describing: reportCreatorAccount)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportGeneratorName: \(Swift.String(describing: reportGeneratorName)), reportType: \(Swift.String(describing: reportType)), s3Location: \(Swift.String(describing: s3Location)), tags: \(Swift.String(describing: tags)))"}
}

extension LicenseManagerClientTypes {
    /// Describe the details of a report generator.
    public struct ReportGenerator: Swift.Equatable {
        /// Time the report was created.
        public var createTime: Swift.String?
        /// Description of the report generator.
        public var description: Swift.String?
        /// Time the last report was generated at.
        public var lastReportGenerationTime: Swift.String?
        /// Failure message for the last report generation attempt.
        public var lastRunFailureReason: Swift.String?
        /// Status of the last report generation attempt.
        public var lastRunStatus: Swift.String?
        /// Amazon Resource Name (ARN) of the report generator.
        public var licenseManagerReportGeneratorArn: Swift.String?
        /// License configuration type for this generator.
        public var reportContext: LicenseManagerClientTypes.ReportContext?
        /// The Amazon Web Services account ID used to create the report generator.
        public var reportCreatorAccount: Swift.String?
        /// Details about how frequently reports are generated.
        public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
        /// Name of the report generator.
        public var reportGeneratorName: Swift.String?
        /// Type of reports that are generated.
        public var reportType: [LicenseManagerClientTypes.ReportType]?
        /// Details of the S3 bucket that report generator reports are published to.
        public var s3Location: LicenseManagerClientTypes.S3Location?
        /// Tags associated with the report generator.
        public var tags: [LicenseManagerClientTypes.Tag]?

        public init (
            createTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastReportGenerationTime: Swift.String? = nil,
            lastRunFailureReason: Swift.String? = nil,
            lastRunStatus: Swift.String? = nil,
            licenseManagerReportGeneratorArn: Swift.String? = nil,
            reportContext: LicenseManagerClientTypes.ReportContext? = nil,
            reportCreatorAccount: Swift.String? = nil,
            reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
            reportGeneratorName: Swift.String? = nil,
            reportType: [LicenseManagerClientTypes.ReportType]? = nil,
            s3Location: LicenseManagerClientTypes.S3Location? = nil,
            tags: [LicenseManagerClientTypes.Tag]? = nil
        )
        {
            self.createTime = createTime
            self.description = description
            self.lastReportGenerationTime = lastReportGenerationTime
            self.lastRunFailureReason = lastRunFailureReason
            self.lastRunStatus = lastRunStatus
            self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
            self.reportContext = reportContext
            self.reportCreatorAccount = reportCreatorAccount
            self.reportFrequency = reportFrequency
            self.reportGeneratorName = reportGeneratorName
            self.reportType = reportType
            self.s3Location = s3Location
            self.tags = tags
        }
    }

}

extension LicenseManagerClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case licenseConfigurationSummaryReport
        case licenseConfigurationUsageReport
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .licenseConfigurationSummaryReport,
                .licenseConfigurationUsageReport,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .licenseConfigurationSummaryReport: return "LicenseConfigurationSummaryReport"
            case .licenseConfigurationUsageReport: return "LicenseConfigurationUsageReport"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.ResourceInventory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case platformVersion = "PlatformVersion"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceOwningAccountId = "ResourceOwningAccountId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceOwningAccountId = resourceOwningAccountId {
            try encodeContainer.encode(resourceOwningAccountId, forKey: .resourceOwningAccountId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let resourceOwningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwningAccountId)
        resourceOwningAccountId = resourceOwningAccountIdDecoded
    }
}

extension LicenseManagerClientTypes.ResourceInventory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInventory(platform: \(Swift.String(describing: platform)), platformVersion: \(Swift.String(describing: platformVersion)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)), resourceOwningAccountId: \(Swift.String(describing: resourceOwningAccountId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension LicenseManagerClientTypes {
    /// Details about a resource.
    public struct ResourceInventory: Swift.Equatable {
        /// Platform of the resource.
        public var platform: Swift.String?
        /// Platform version of the resource in the inventory.
        public var platformVersion: Swift.String?
        /// Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// ID of the resource.
        public var resourceId: Swift.String?
        /// ID of the account that owns the resource.
        public var resourceOwningAccountId: Swift.String?
        /// Type of resource.
        public var resourceType: LicenseManagerClientTypes.ResourceType?

        public init (
            platform: Swift.String? = nil,
            platformVersion: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceOwningAccountId: Swift.String? = nil,
            resourceType: LicenseManagerClientTypes.ResourceType? = nil
        )
        {
            self.platform = platform
            self.platformVersion = platformVersion
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceOwningAccountId = resourceOwningAccountId
            self.resourceType = resourceType
        }
    }

}

extension ResourceLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2Ami
        case ec2Host
        case ec2Instance
        case rds
        case systemsManagerManagedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ec2Ami,
                .ec2Host,
                .ec2Instance,
                .rds,
                .systemsManagerManagedInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2Ami: return "EC2_AMI"
            case .ec2Host: return "EC2_HOST"
            case .ec2Instance: return "EC2_INSTANCE"
            case .rds: return "RDS"
            case .systemsManagerManagedInstance: return "SYSTEMS_MANAGER_MANAGED_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension LicenseManagerClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension LicenseManagerClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucket: \(Swift.String(describing: bucket)), keyPrefix: \(Swift.String(describing: keyPrefix)))"}
}

extension LicenseManagerClientTypes {
    /// Details of the S3 bucket that report generator reports are published to.
    public struct S3Location: Swift.Equatable {
        /// Name of the S3 bucket reports are published to.
        public var bucket: Swift.String?
        /// Prefix of the S3 bucket reports are published to.
        public var keyPrefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
        }
    }

}

extension ServerInternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerInternalException(message: \(Swift.String(describing: message)))"}
}

extension ServerInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension LicenseManagerClientTypes {
    /// Details about a tag for a license configuration.
    public struct Tag: Swift.Equatable {
        /// Tag key.
        public var key: Swift.String?
        /// Tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [LicenseManagerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [LicenseManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [LicenseManagerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[LicenseManagerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [LicenseManagerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension LicenseManagerClientTypes.TokenData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationTime = "ExpirationTime"
        case licenseArn = "LicenseArn"
        case roleArns = "RoleArns"
        case status = "Status"
        case tokenId = "TokenId"
        case tokenProperties = "TokenProperties"
        case tokenType = "TokenType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let licenseArn = licenseArn {
            try encodeContainer.encode(licenseArn, forKey: .licenseArn)
        }
        if let roleArns = roleArns {
            var roleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roleArns)
            for arnlist0 in roleArns {
                try roleArnsContainer.encode(arnlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tokenId = tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
        if let tokenProperties = tokenProperties {
            var tokenPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenProperties)
            for maxsize3stringlist0 in tokenProperties {
                try tokenPropertiesContainer.encode(maxsize3stringlist0)
            }
        }
        if let tokenType = tokenType {
            try encodeContainer.encode(tokenType, forKey: .tokenType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let licenseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseArn)
        licenseArn = licenseArnDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let tokenPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenProperties)
        var tokenPropertiesDecoded0:[Swift.String]? = nil
        if let tokenPropertiesContainer = tokenPropertiesContainer {
            tokenPropertiesDecoded0 = [Swift.String]()
            for string0 in tokenPropertiesContainer {
                if let string0 = string0 {
                    tokenPropertiesDecoded0?.append(string0)
                }
            }
        }
        tokenProperties = tokenPropertiesDecoded0
        let roleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleArns)
        var roleArnsDecoded0:[Swift.String]? = nil
        if let roleArnsContainer = roleArnsContainer {
            roleArnsDecoded0 = [Swift.String]()
            for string0 in roleArnsContainer {
                if let string0 = string0 {
                    roleArnsDecoded0?.append(string0)
                }
            }
        }
        roleArns = roleArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension LicenseManagerClientTypes.TokenData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TokenData(expirationTime: \(Swift.String(describing: expirationTime)), licenseArn: \(Swift.String(describing: licenseArn)), roleArns: \(Swift.String(describing: roleArns)), status: \(Swift.String(describing: status)), tokenId: \(Swift.String(describing: tokenId)), tokenProperties: \(Swift.String(describing: tokenProperties)), tokenType: \(Swift.String(describing: tokenType)))"}
}

extension LicenseManagerClientTypes {
    /// Describes a token.
    public struct TokenData: Swift.Equatable {
        /// Token expiration time, in ISO8601-UTC format.
        public var expirationTime: Swift.String?
        /// Amazon Resource Name (ARN) of the license.
        public var licenseArn: Swift.String?
        /// Amazon Resource Names (ARN) of the roles included in the token.
        public var roleArns: [Swift.String]?
        /// Token status. The possible values are AVAILABLE and DELETED.
        public var status: Swift.String?
        /// Token ID.
        public var tokenId: Swift.String?
        /// Data specified by the caller.
        public var tokenProperties: [Swift.String]?
        /// Type of token generated. The supported value is REFRESH_TOKEN.
        public var tokenType: Swift.String?

        public init (
            expirationTime: Swift.String? = nil,
            licenseArn: Swift.String? = nil,
            roleArns: [Swift.String]? = nil,
            status: Swift.String? = nil,
            tokenId: Swift.String? = nil,
            tokenProperties: [Swift.String]? = nil,
            tokenType: Swift.String? = nil
        )
        {
            self.expirationTime = expirationTime
            self.licenseArn = licenseArn
            self.roleArns = roleArns
            self.status = status
            self.tokenId = tokenId
            self.tokenProperties = tokenProperties
            self.tokenType = tokenType
        }
    }

}

extension LicenseManagerClientTypes {
    public enum TokenType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case refreshToken
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenType] {
            return [
                .refreshToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .refreshToken: return "REFRESH_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TokenType(rawValue: rawValue) ?? TokenType.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedDigitalSignatureMethodException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedDigitalSignatureMethodException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedDigitalSignatureMethodException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedDigitalSignatureMethodExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The digital signature method is unsupported. Try your request again.
public struct UnsupportedDigitalSignatureMethodException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedDigitalSignatureMethodExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedDigitalSignatureMethodExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys identifying the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLicenseConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseConfigurationOutputError>
}

extension UpdateLicenseConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseConfigurationInput(description: \(Swift.String(describing: description)), disassociateWhenNotFound: \(Swift.String(describing: disassociateWhenNotFound)), licenseConfigurationArn: \(Swift.String(describing: licenseConfigurationArn)), licenseConfigurationStatus: \(Swift.String(describing: licenseConfigurationStatus)), licenseCount: \(Swift.String(describing: licenseCount)), licenseCountHardLimit: \(Swift.String(describing: licenseCountHardLimit)), licenseRules: \(Swift.String(describing: licenseRules)), name: \(Swift.String(describing: name)), productInformationList: \(Swift.String(describing: productInformationList)))"}
}

extension UpdateLicenseConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disassociateWhenNotFound = disassociateWhenNotFound {
            try encodeContainer.encode(disassociateWhenNotFound, forKey: .disassociateWhenNotFound)
        }
        if let licenseConfigurationArn = licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
        if let licenseConfigurationStatus = licenseConfigurationStatus {
            try encodeContainer.encode(licenseConfigurationStatus.rawValue, forKey: .licenseConfigurationStatus)
        }
        if let licenseCount = licenseCount {
            try encodeContainer.encode(licenseCount, forKey: .licenseCount)
        }
        if let licenseCountHardLimit = licenseCountHardLimit {
            try encodeContainer.encode(licenseCountHardLimit, forKey: .licenseCountHardLimit)
        }
        if let licenseRules = licenseRules {
            var licenseRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseRules)
            for stringlist0 in licenseRules {
                try licenseRulesContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productInformationList = productInformationList {
            var productInformationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productInformationList)
            for productinformationlist0 in productInformationList {
                try productInformationListContainer.encode(productinformationlist0)
            }
        }
    }
}

public struct UpdateLicenseConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseConfigurationOutputError>
}

public struct UpdateLicenseConfigurationInput: Swift.Equatable {
    /// New description of the license configuration.
    public var description: Swift.String?
    /// When true, disassociates a resource when software is uninstalled.
    public var disassociateWhenNotFound: Swift.Bool?
    /// Amazon Resource Name (ARN) of the license configuration.
    /// This member is required.
    public var licenseConfigurationArn: Swift.String?
    /// New status of the license configuration.
    public var licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus?
    /// New number of licenses managed by the license configuration.
    public var licenseCount: Swift.Int?
    /// New hard limit of the number of available licenses.
    public var licenseCountHardLimit: Swift.Bool?
    /// New license rule. The only rule that you can add after you create a license configuration is licenseAffinityToHost.
    public var licenseRules: [Swift.String]?
    /// New name of the license configuration.
    public var name: Swift.String?
    /// New product information.
    public var productInformationList: [LicenseManagerClientTypes.ProductInformation]?

    public init (
        description: Swift.String? = nil,
        disassociateWhenNotFound: Swift.Bool? = nil,
        licenseConfigurationArn: Swift.String? = nil,
        licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus? = nil,
        licenseCount: Swift.Int? = nil,
        licenseCountHardLimit: Swift.Bool? = nil,
        licenseRules: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productInformationList: [LicenseManagerClientTypes.ProductInformation]? = nil
    )
    {
        self.description = description
        self.disassociateWhenNotFound = disassociateWhenNotFound
        self.licenseConfigurationArn = licenseConfigurationArn
        self.licenseConfigurationStatus = licenseConfigurationStatus
        self.licenseCount = licenseCount
        self.licenseCountHardLimit = licenseCountHardLimit
        self.licenseRules = licenseRules
        self.name = name
        self.productInformationList = productInformationList
    }
}

struct UpdateLicenseConfigurationInputBody: Swift.Equatable {
    public let licenseConfigurationArn: Swift.String?
    public let licenseConfigurationStatus: LicenseManagerClientTypes.LicenseConfigurationStatus?
    public let licenseRules: [Swift.String]?
    public let licenseCount: Swift.Int?
    public let licenseCountHardLimit: Swift.Bool?
    public let name: Swift.String?
    public let description: Swift.String?
    public let productInformationList: [LicenseManagerClientTypes.ProductInformation]?
    public let disassociateWhenNotFound: Swift.Bool?
}

extension UpdateLicenseConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disassociateWhenNotFound = "DisassociateWhenNotFound"
        case licenseConfigurationArn = "LicenseConfigurationArn"
        case licenseConfigurationStatus = "LicenseConfigurationStatus"
        case licenseCount = "LicenseCount"
        case licenseCountHardLimit = "LicenseCountHardLimit"
        case licenseRules = "LicenseRules"
        case name = "Name"
        case productInformationList = "ProductInformationList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
        let licenseConfigurationStatusDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.LicenseConfigurationStatus.self, forKey: .licenseConfigurationStatus)
        licenseConfigurationStatus = licenseConfigurationStatusDecoded
        let licenseRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseRules)
        var licenseRulesDecoded0:[Swift.String]? = nil
        if let licenseRulesContainer = licenseRulesContainer {
            licenseRulesDecoded0 = [Swift.String]()
            for string0 in licenseRulesContainer {
                if let string0 = string0 {
                    licenseRulesDecoded0?.append(string0)
                }
            }
        }
        licenseRules = licenseRulesDecoded0
        let licenseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCount)
        licenseCount = licenseCountDecoded
        let licenseCountHardLimitDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .licenseCountHardLimit)
        licenseCountHardLimit = licenseCountHardLimitDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productInformationListContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ProductInformation?].self, forKey: .productInformationList)
        var productInformationListDecoded0:[LicenseManagerClientTypes.ProductInformation]? = nil
        if let productInformationListContainer = productInformationListContainer {
            productInformationListDecoded0 = [LicenseManagerClientTypes.ProductInformation]()
            for structure0 in productInformationListContainer {
                if let structure0 = structure0 {
                    productInformationListDecoded0?.append(structure0)
                }
            }
        }
        productInformationList = productInformationListDecoded0
        let disassociateWhenNotFoundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disassociateWhenNotFound)
        disassociateWhenNotFound = disassociateWhenNotFoundDecoded
    }
}

extension UpdateLicenseConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseConfigurationOutputResponse()"}
}

extension UpdateLicenseConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLicenseConfigurationOutputResponseBody: Swift.Equatable {
}

extension UpdateLicenseConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLicenseManagerReportGeneratorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseManagerReportGeneratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

extension UpdateLicenseManagerReportGeneratorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseManagerReportGeneratorInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), licenseManagerReportGeneratorArn: \(Swift.String(describing: licenseManagerReportGeneratorArn)), reportContext: \(Swift.String(describing: reportContext)), reportFrequency: \(Swift.String(describing: reportFrequency)), reportGeneratorName: \(Swift.String(describing: reportGeneratorName)), type: \(Swift.String(describing: type)))"}
}

extension UpdateLicenseManagerReportGeneratorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn {
            try encodeContainer.encode(licenseManagerReportGeneratorArn, forKey: .licenseManagerReportGeneratorArn)
        }
        if let reportContext = reportContext {
            try encodeContainer.encode(reportContext, forKey: .reportContext)
        }
        if let reportFrequency = reportFrequency {
            try encodeContainer.encode(reportFrequency, forKey: .reportFrequency)
        }
        if let reportGeneratorName = reportGeneratorName {
            try encodeContainer.encode(reportGeneratorName, forKey: .reportGeneratorName)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for reporttypelist0 in type {
                try typeContainer.encode(reporttypelist0.rawValue)
            }
        }
    }
}

public struct UpdateLicenseManagerReportGeneratorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseManagerReportGeneratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseManagerReportGeneratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseManagerReportGeneratorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseManagerReportGeneratorInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseManagerReportGeneratorInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseManagerReportGeneratorInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseManagerReportGeneratorInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseManagerReportGeneratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseManagerReportGeneratorOutputError>
}

public struct UpdateLicenseManagerReportGeneratorInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Description of the report generator.
    public var description: Swift.String?
    /// Amazon Resource Name (ARN) of the report generator to update.
    /// This member is required.
    public var licenseManagerReportGeneratorArn: Swift.String?
    /// The report context.
    /// This member is required.
    public var reportContext: LicenseManagerClientTypes.ReportContext?
    /// Frequency by which reports are generated.
    /// This member is required.
    public var reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    /// Name of the report generator.
    /// This member is required.
    public var reportGeneratorName: Swift.String?
    /// Type of reports to generate. The following report types are supported:
    ///
    /// * License configuration report - Reports the number and details of consumed licenses for a license configuration.
    ///
    /// * Resource report - Reports the tracked licenses and resource consumption for a license configuration.
    /// This member is required.
    public var type: [LicenseManagerClientTypes.ReportType]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        licenseManagerReportGeneratorArn: Swift.String? = nil,
        reportContext: LicenseManagerClientTypes.ReportContext? = nil,
        reportFrequency: LicenseManagerClientTypes.ReportFrequency? = nil,
        reportGeneratorName: Swift.String? = nil,
        type: [LicenseManagerClientTypes.ReportType]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArn
        self.reportContext = reportContext
        self.reportFrequency = reportFrequency
        self.reportGeneratorName = reportGeneratorName
        self.type = type
    }
}

struct UpdateLicenseManagerReportGeneratorInputBody: Swift.Equatable {
    public let licenseManagerReportGeneratorArn: Swift.String?
    public let reportGeneratorName: Swift.String?
    public let type: [LicenseManagerClientTypes.ReportType]?
    public let reportContext: LicenseManagerClientTypes.ReportContext?
    public let reportFrequency: LicenseManagerClientTypes.ReportFrequency?
    public let clientToken: Swift.String?
    public let description: Swift.String?
}

extension UpdateLicenseManagerReportGeneratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case licenseManagerReportGeneratorArn = "LicenseManagerReportGeneratorArn"
        case reportContext = "ReportContext"
        case reportFrequency = "ReportFrequency"
        case reportGeneratorName = "ReportGeneratorName"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseManagerReportGeneratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseManagerReportGeneratorArn)
        licenseManagerReportGeneratorArn = licenseManagerReportGeneratorArnDecoded
        let reportGeneratorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportGeneratorName)
        reportGeneratorName = reportGeneratorNameDecoded
        let typeContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.ReportType?].self, forKey: .type)
        var typeDecoded0:[LicenseManagerClientTypes.ReportType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [LicenseManagerClientTypes.ReportType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
        let reportContextDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportContext.self, forKey: .reportContext)
        reportContext = reportContextDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateLicenseManagerReportGeneratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseManagerReportGeneratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResource.NotFound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseManagerReportGeneratorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalException(ServerInternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseManagerReportGeneratorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseManagerReportGeneratorOutputResponse()"}
}

extension UpdateLicenseManagerReportGeneratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseManagerReportGeneratorOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLicenseManagerReportGeneratorOutputResponseBody: Swift.Equatable {
}

extension UpdateLicenseManagerReportGeneratorOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLicenseSpecificationsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseSpecificationsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

extension UpdateLicenseSpecificationsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseSpecificationsForResourceInput(addLicenseSpecifications: \(Swift.String(describing: addLicenseSpecifications)), removeLicenseSpecifications: \(Swift.String(describing: removeLicenseSpecifications)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension UpdateLicenseSpecificationsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addLicenseSpecifications = addLicenseSpecifications {
            var addLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addLicenseSpecifications)
            for licensespecifications0 in addLicenseSpecifications {
                try addLicenseSpecificationsContainer.encode(licensespecifications0)
            }
        }
        if let removeLicenseSpecifications = removeLicenseSpecifications {
            var removeLicenseSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeLicenseSpecifications)
            for licensespecifications0 in removeLicenseSpecifications {
                try removeLicenseSpecificationsContainer.encode(licensespecifications0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct UpdateLicenseSpecificationsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseSpecificationsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseSpecificationsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLicenseSpecificationsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseSpecificationsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseSpecificationsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseSpecificationsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLicenseSpecificationsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateLicenseSpecificationsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLicenseSpecificationsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLicenseSpecificationsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLicenseSpecificationsForResourceOutputError>
}

public struct UpdateLicenseSpecificationsForResourceInput: Swift.Equatable {
    /// ARNs of the license configurations to add.
    public var addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// ARNs of the license configurations to remove.
    public var removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    /// Amazon Resource Name (ARN) of the Amazon Web Services resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.addLicenseSpecifications = addLicenseSpecifications
        self.removeLicenseSpecifications = removeLicenseSpecifications
        self.resourceArn = resourceArn
    }
}

struct UpdateLicenseSpecificationsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let addLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
    public let removeLicenseSpecifications: [LicenseManagerClientTypes.LicenseSpecification]?
}

extension UpdateLicenseSpecificationsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addLicenseSpecifications = "AddLicenseSpecifications"
        case removeLicenseSpecifications = "RemoveLicenseSpecifications"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let addLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .addLicenseSpecifications)
        var addLicenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let addLicenseSpecificationsContainer = addLicenseSpecificationsContainer {
            addLicenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in addLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    addLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        addLicenseSpecifications = addLicenseSpecificationsDecoded0
        let removeLicenseSpecificationsContainer = try containerValues.decodeIfPresent([LicenseManagerClientTypes.LicenseSpecification?].self, forKey: .removeLicenseSpecifications)
        var removeLicenseSpecificationsDecoded0:[LicenseManagerClientTypes.LicenseSpecification]? = nil
        if let removeLicenseSpecificationsContainer = removeLicenseSpecificationsContainer {
            removeLicenseSpecificationsDecoded0 = [LicenseManagerClientTypes.LicenseSpecification]()
            for structure0 in removeLicenseSpecificationsContainer {
                if let structure0 = structure0 {
                    removeLicenseSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        removeLicenseSpecifications = removeLicenseSpecificationsDecoded0
    }
}

extension UpdateLicenseSpecificationsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLicenseSpecificationsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceState" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LicenseUsageFailure" : self = .licenseUsageException(try LicenseUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLicenseSpecificationsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidResourceStateException(InvalidResourceStateException)
    case licenseUsageException(LicenseUsageException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLicenseSpecificationsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLicenseSpecificationsForResourceOutputResponse()"}
}

extension UpdateLicenseSpecificationsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLicenseSpecificationsForResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLicenseSpecificationsForResourceOutputResponseBody: Swift.Equatable {
}

extension UpdateLicenseSpecificationsForResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServiceSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingsOutputError>
}

extension UpdateServiceSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceSettingsInput(enableCrossAccountsDiscovery: \(Swift.String(describing: enableCrossAccountsDiscovery)), organizationConfiguration: \(Swift.String(describing: organizationConfiguration)), s3BucketArn: \(Swift.String(describing: s3BucketArn)), snsTopicArn: \(Swift.String(describing: snsTopicArn)))"}
}

extension UpdateServiceSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableCrossAccountsDiscovery = enableCrossAccountsDiscovery {
            try encodeContainer.encode(enableCrossAccountsDiscovery, forKey: .enableCrossAccountsDiscovery)
        }
        if let organizationConfiguration = organizationConfiguration {
            try encodeContainer.encode(organizationConfiguration, forKey: .organizationConfiguration)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

public struct UpdateServiceSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceSettingsOutputError>
}

public struct UpdateServiceSettingsInput: Swift.Equatable {
    /// Activates cross-account discovery.
    public var enableCrossAccountsDiscovery: Swift.Bool?
    /// Enables integration with Organizations for cross-account discovery.
    public var organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    /// Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.
    public var s3BucketArn: Swift.String?
    /// Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.
    public var snsTopicArn: Swift.String?

    public init (
        enableCrossAccountsDiscovery: Swift.Bool? = nil,
        organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration? = nil,
        s3BucketArn: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.enableCrossAccountsDiscovery = enableCrossAccountsDiscovery
        self.organizationConfiguration = organizationConfiguration
        self.s3BucketArn = s3BucketArn
        self.snsTopicArn = snsTopicArn
    }
}

struct UpdateServiceSettingsInputBody: Swift.Equatable {
    public let s3BucketArn: Swift.String?
    public let snsTopicArn: Swift.String?
    public let organizationConfiguration: LicenseManagerClientTypes.OrganizationConfiguration?
    public let enableCrossAccountsDiscovery: Swift.Bool?
}

extension UpdateServiceSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableCrossAccountsDiscovery = "EnableCrossAccountsDiscovery"
        case organizationConfiguration = "OrganizationConfiguration"
        case s3BucketArn = "S3BucketArn"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let organizationConfigurationDecoded = try containerValues.decodeIfPresent(LicenseManagerClientTypes.OrganizationConfiguration.self, forKey: .organizationConfiguration)
        organizationConfiguration = organizationConfigurationDecoded
        let enableCrossAccountsDiscoveryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCrossAccountsDiscovery)
        enableCrossAccountsDiscovery = enableCrossAccountsDiscoveryDecoded
    }
}

extension UpdateServiceSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceAccessDenied" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationFailure" : self = .authorizationException(try AuthorizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueProvided" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateLimitExceeded" : self = .rateLimitExceededException(try RateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case authorizationException(AuthorizationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case rateLimitExceededException(RateLimitExceededException)
    case serverInternalException(ServerInternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceSettingsOutputResponse()"}
}

extension UpdateServiceSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateServiceSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateServiceSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided input is not valid. Try your request again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
