// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchAssociateScramSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateScramSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateScramSecretOutputError>
}

extension BatchAssociateScramSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateScramSecretInput(clusterArn: \(Swift.String(describing: clusterArn)), secretArnList: \(Swift.String(describing: secretArnList)))"}
}

extension BatchAssociateScramSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __listof__string0 in secretArnList {
                try secretArnListContainer.encode(__listof__string0)
            }
        }
    }
}

public struct BatchAssociateScramSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateScramSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateScramSecretOutputError>
}

public struct BatchAssociateScramSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateScramSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateScramSecretOutputError>
}

public struct BatchAssociateScramSecretInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateScramSecretInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchAssociateScramSecretInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateScramSecretInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateScramSecretOutputError>
}

public struct BatchAssociateScramSecretInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateScramSecretInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchAssociateScramSecretInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateScramSecretInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateScramSecretOutputError>
}

/// Associates sasl scram secrets to cluster.
public struct BatchAssociateScramSecretInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init (
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchAssociateScramSecretInputBody: Swift.Equatable {
    public let secretArnList: [Swift.String]?
}

extension BatchAssociateScramSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchAssociateScramSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateScramSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateScramSecretOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateScramSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateScramSecretOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), unprocessedScramSecrets: \(Swift.String(describing: unprocessedScramSecrets)))"}
}

extension BatchAssociateScramSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateScramSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchAssociateScramSecretOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when associating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init (
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchAssociateScramSecretOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?
}

extension BatchAssociateScramSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[KafkaClientTypes.UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [KafkaClientTypes.UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

public struct BatchDisassociateScramSecretInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateScramSecretInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateScramSecretOutputError>
}

extension BatchDisassociateScramSecretInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateScramSecretInput(clusterArn: \(Swift.String(describing: clusterArn)), secretArnList: \(Swift.String(describing: secretArnList)))"}
}

extension BatchDisassociateScramSecretInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretArnList = secretArnList {
            var secretArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretArnList)
            for __listof__string0 in secretArnList {
                try secretArnListContainer.encode(__listof__string0)
            }
        }
    }
}

public struct BatchDisassociateScramSecretInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateScramSecretInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateScramSecretOutputError>
}

public struct BatchDisassociateScramSecretInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateScramSecretInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateScramSecretInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateScramSecretOutputError>
}

public struct BatchDisassociateScramSecretInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateScramSecretInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BatchDisassociateScramSecretInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateScramSecretInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateScramSecretOutputError>
}

public struct BatchDisassociateScramSecretInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateScramSecretInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BatchDisassociateScramSecretInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateScramSecretInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateScramSecretOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateScramSecretOutputError>
}

/// Disassociates sasl scram secrets to cluster.
public struct BatchDisassociateScramSecretInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// List of AWS Secrets Manager secret ARNs.
    /// This member is required.
    public var secretArnList: [Swift.String]?

    public init (
        clusterArn: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.secretArnList = secretArnList
    }
}

struct BatchDisassociateScramSecretInputBody: Swift.Equatable {
    public let secretArnList: [Swift.String]?
}

extension BatchDisassociateScramSecretInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension BatchDisassociateScramSecretOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateScramSecretOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateScramSecretOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateScramSecretOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateScramSecretOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), unprocessedScramSecrets: \(Swift.String(describing: unprocessedScramSecrets)))"}
}

extension BatchDisassociateScramSecretOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateScramSecretOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.unprocessedScramSecrets = output.unprocessedScramSecrets
        } else {
            self.clusterArn = nil
            self.unprocessedScramSecrets = nil
        }
    }
}

public struct BatchDisassociateScramSecretOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// List of errors when disassociating secrets to cluster.
    public var unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?

    public init (
        clusterArn: Swift.String? = nil,
        unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.unprocessedScramSecrets = unprocessedScramSecrets
    }
}

struct BatchDisassociateScramSecretOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let unprocessedScramSecrets: [KafkaClientTypes.UnprocessedScramSecret]?
}

extension BatchDisassociateScramSecretOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case unprocessedScramSecrets = "unprocessedScramSecrets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let unprocessedScramSecretsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.UnprocessedScramSecret?].self, forKey: .unprocessedScramSecrets)
        var unprocessedScramSecretsDecoded0:[KafkaClientTypes.UnprocessedScramSecret]? = nil
        if let unprocessedScramSecretsContainer = unprocessedScramSecretsContainer {
            unprocessedScramSecretsDecoded0 = [KafkaClientTypes.UnprocessedScramSecret]()
            for structure0 in unprocessedScramSecretsContainer {
                if let structure0 = structure0 {
                    unprocessedScramSecretsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedScramSecrets = unprocessedScramSecretsDecoded0
    }
}

extension KafkaClientTypes {
    /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
    public enum BrokerAZDistribution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerAZDistribution] {
            return [
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerAZDistribution(rawValue: rawValue) ?? BrokerAZDistribution.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.BrokerEBSVolumeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kafkaBrokerNodeId = "kafkaBrokerNodeId"
        case volumeSizeGB = "volumeSizeGB"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kafkaBrokerNodeId = kafkaBrokerNodeId {
            try encodeContainer.encode(kafkaBrokerNodeId, forKey: .kafkaBrokerNodeId)
        }
        if let volumeSizeGB = volumeSizeGB {
            try encodeContainer.encode(volumeSizeGB, forKey: .volumeSizeGB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaBrokerNodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaBrokerNodeId)
        kafkaBrokerNodeId = kafkaBrokerNodeIdDecoded
        let volumeSizeGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeGB)
        volumeSizeGB = volumeSizeGBDecoded
    }
}

extension KafkaClientTypes.BrokerEBSVolumeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerEBSVolumeInfo(kafkaBrokerNodeId: \(Swift.String(describing: kafkaBrokerNodeId)), volumeSizeGB: \(Swift.String(describing: volumeSizeGB)))"}
}

extension KafkaClientTypes {
    /// Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.
    public struct BrokerEBSVolumeInfo: Swift.Equatable {
        /// The ID of the broker to update.
        /// This member is required.
        public var kafkaBrokerNodeId: Swift.String?
        /// Size of the EBS volume to update.
        /// This member is required.
        public var volumeSizeGB: Swift.Int?

        public init (
            kafkaBrokerNodeId: Swift.String? = nil,
            volumeSizeGB: Swift.Int? = nil
        )
        {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.volumeSizeGB = volumeSizeGB
        }
    }

}

extension KafkaClientTypes.BrokerLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs = "cloudWatchLogs"
        case firehose = "firehose"
        case s3 = "s3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let firehose = firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.CloudWatchLogs.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let firehoseDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Firehose.self, forKey: .firehose)
        firehose = firehoseDecoded
        let s3Decoded = try containerValues.decodeIfPresent(KafkaClientTypes.S3.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension KafkaClientTypes.BrokerLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerLogs(cloudWatchLogs: \(Swift.String(describing: cloudWatchLogs)), firehose: \(Swift.String(describing: firehose)), s3: \(Swift.String(describing: s3)))"}
}

extension KafkaClientTypes {
    public struct BrokerLogs: Swift.Equatable {
        public var cloudWatchLogs: KafkaClientTypes.CloudWatchLogs?
        public var firehose: KafkaClientTypes.Firehose?
        public var s3: KafkaClientTypes.S3?

        public init (
            cloudWatchLogs: KafkaClientTypes.CloudWatchLogs? = nil,
            firehose: KafkaClientTypes.Firehose? = nil,
            s3: KafkaClientTypes.S3? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaClientTypes.BrokerNodeGroupInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerAZDistribution = "brokerAZDistribution"
        case clientSubnets = "clientSubnets"
        case connectivityInfo = "connectivityInfo"
        case instanceType = "instanceType"
        case securityGroups = "securityGroups"
        case storageInfo = "storageInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerAZDistribution = brokerAZDistribution {
            try encodeContainer.encode(brokerAZDistribution.rawValue, forKey: .brokerAZDistribution)
        }
        if let clientSubnets = clientSubnets {
            var clientSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientSubnets)
            for __listof__string0 in clientSubnets {
                try clientSubnetsContainer.encode(__listof__string0)
            }
        }
        if let connectivityInfo = connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let storageInfo = storageInfo {
            try encodeContainer.encode(storageInfo, forKey: .storageInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerAZDistributionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerAZDistribution.self, forKey: .brokerAZDistribution)
        brokerAZDistribution = brokerAZDistributionDecoded
        let clientSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientSubnets)
        var clientSubnetsDecoded0:[Swift.String]? = nil
        if let clientSubnetsContainer = clientSubnetsContainer {
            clientSubnetsDecoded0 = [Swift.String]()
            for string0 in clientSubnetsContainer {
                if let string0 = string0 {
                    clientSubnetsDecoded0?.append(string0)
                }
            }
        }
        clientSubnets = clientSubnetsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StorageInfo.self, forKey: .storageInfo)
        storageInfo = storageInfoDecoded
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
    }
}

extension KafkaClientTypes.BrokerNodeGroupInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerNodeGroupInfo(brokerAZDistribution: \(Swift.String(describing: brokerAZDistribution)), clientSubnets: \(Swift.String(describing: clientSubnets)), connectivityInfo: \(Swift.String(describing: connectivityInfo)), instanceType: \(Swift.String(describing: instanceType)), securityGroups: \(Swift.String(describing: securityGroups)), storageInfo: \(Swift.String(describing: storageInfo)))"}
}

extension KafkaClientTypes {
    /// Describes the setup to be used for Apache Kafka broker nodes in the cluster.
    public struct BrokerNodeGroupInfo: Swift.Equatable {
        /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
        public var brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.
        /// This member is required.
        public var clientSubnets: [Swift.String]?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.
        public var securityGroups: [Swift.String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public var storageInfo: KafkaClientTypes.StorageInfo?

        public init (
            brokerAZDistribution: KafkaClientTypes.BrokerAZDistribution? = nil,
            clientSubnets: [Swift.String]? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            instanceType: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            storageInfo: KafkaClientTypes.StorageInfo? = nil
        )
        {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.connectivityInfo = connectivityInfo
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
        }
    }

}

extension KafkaClientTypes.BrokerNodeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedENIId = "attachedENIId"
        case brokerId = "brokerId"
        case clientSubnet = "clientSubnet"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case endpoints = "endpoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if let brokerId = brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let clientSubnet = clientSubnet {
            try encodeContainer.encode(clientSubnet, forKey: .clientSubnet)
        }
        if let clientVpcIpAddress = clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let currentBrokerSoftwareInfo = currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let clientSubnetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSubnet)
        clientSubnet = clientSubnetDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension KafkaClientTypes.BrokerNodeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerNodeInfo(attachedENIId: \(Swift.String(describing: attachedENIId)), brokerId: \(Swift.String(describing: brokerId)), clientSubnet: \(Swift.String(describing: clientSubnet)), clientVpcIpAddress: \(Swift.String(describing: clientVpcIpAddress)), currentBrokerSoftwareInfo: \(Swift.String(describing: currentBrokerSoftwareInfo)), endpoints: \(Swift.String(describing: endpoints)))"}
}

extension KafkaClientTypes {
    /// BrokerNodeInfo
    public struct BrokerNodeInfo: Swift.Equatable {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The ID of the broker.
        public var brokerId: Swift.Double?
        /// The client subnet to which this broker node belongs.
        public var clientSubnet: Swift.String?
        /// The virtual private cloud (VPC) of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public var endpoints: [Swift.String]?

        public init (
            attachedENIId: Swift.String? = nil,
            brokerId: Swift.Double? = nil,
            clientSubnet: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            endpoints: [Swift.String]? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }
    }

}

extension KafkaClientTypes.BrokerSoftwareInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationArn = "configurationArn"
        case configurationRevision = "configurationRevision"
        case kafkaVersion = "kafkaVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if let configurationRevision = configurationRevision {
            try encodeContainer.encode(configurationRevision, forKey: .configurationRevision)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
        let configurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .configurationRevision)
        configurationRevision = configurationRevisionDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
    }
}

extension KafkaClientTypes.BrokerSoftwareInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerSoftwareInfo(configurationArn: \(Swift.String(describing: configurationArn)), configurationRevision: \(Swift.String(describing: configurationRevision)), kafkaVersion: \(Swift.String(describing: kafkaVersion)))"}
}

extension KafkaClientTypes {
    /// Information about the current software installed on the cluster.
    public struct BrokerSoftwareInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public var configurationArn: Swift.String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public var configurationRevision: Swift.Int?
        /// The version of Apache Kafka.
        public var kafkaVersion: Swift.String?

        public init (
            configurationArn: Swift.String? = nil,
            configurationRevision: Swift.Int? = nil,
            kafkaVersion: Swift.String? = nil
        )
        {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }
    }

}

extension KafkaClientTypes.ClientAuthentication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sasl = "sasl"
        case tls = "tls"
        case unauthenticated = "unauthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
        if let unauthenticated = unauthenticated {
            try encodeContainer.encode(unauthenticated, forKey: .unauthenticated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Sasl.self, forKey: .sasl)
        sasl = saslDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Tls.self, forKey: .tls)
        tls = tlsDecoded
        let unauthenticatedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Unauthenticated.self, forKey: .unauthenticated)
        unauthenticated = unauthenticatedDecoded
    }
}

extension KafkaClientTypes.ClientAuthentication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClientAuthentication(sasl: \(Swift.String(describing: sasl)), tls: \(Swift.String(describing: tls)), unauthenticated: \(Swift.String(describing: unauthenticated)))"}
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ClientAuthentication: Swift.Equatable {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.Sasl?
        /// Details for ClientAuthentication using TLS.
        public var tls: KafkaClientTypes.Tls?
        /// Contains information about unauthenticated traffic to the cluster.
        public var unauthenticated: KafkaClientTypes.Unauthenticated?

        public init (
            sasl: KafkaClientTypes.Sasl? = nil,
            tls: KafkaClientTypes.Tls? = nil,
            unauthenticated: KafkaClientTypes.Unauthenticated? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }
    }

}

extension KafkaClientTypes {
    /// Client-broker encryption in transit setting.
    public enum ClientBroker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case tls
        case tlsPlaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientBroker] {
            return [
                .plaintext,
                .tls,
                .tlsPlaintext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .tls: return "TLS"
            case .tlsPlaintext: return "TLS_PLAINTEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientBroker(rawValue: rawValue) ?? ClientBroker.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.CloudWatchLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
        case logGroup = "logGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
    }
}

extension KafkaClientTypes.CloudWatchLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchLogs(enabled: \(Swift.String(describing: enabled)), logGroup: \(Swift.String(describing: logGroup)))"}
}

extension KafkaClientTypes {
    public struct CloudWatchLogs: Swift.Equatable {
        /// This member is required.
        public var enabled: Swift.Bool?
        public var logGroup: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension KafkaClientTypes.Cluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeOperationArn = "activeOperationArn"
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case clusterType = "clusterType"
        case creationTime = "creationTime"
        case currentVersion = "currentVersion"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case state = "state"
        case stateInfo = "stateInfo"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeOperationArn = activeOperationArn {
            try encodeContainer.encode(activeOperationArn, forKey: .activeOperationArn)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterType = clusterType {
            try encodeContainer.encode(clusterType.rawValue, forKey: .clusterType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let provisioned = provisioned {
            try encodeContainer.encode(provisioned, forKey: .provisioned)
        }
        if let serverless = serverless {
            try encodeContainer.encode(serverless, forKey: .serverless)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateInfo = stateInfo {
            try encodeContainer.encode(stateInfo, forKey: .stateInfo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeOperationArn)
        activeOperationArn = activeOperationArnDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StateInfo.self, forKey: .stateInfo)
        stateInfo = stateInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let provisionedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Provisioned.self, forKey: .provisioned)
        provisioned = provisionedDecoded
        let serverlessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Serverless.self, forKey: .serverless)
        serverless = serverlessDecoded
    }
}

extension KafkaClientTypes.Cluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cluster(activeOperationArn: \(Swift.String(describing: activeOperationArn)), clusterArn: \(Swift.String(describing: clusterArn)), clusterName: \(Swift.String(describing: clusterName)), clusterType: \(Swift.String(describing: clusterType)), creationTime: \(Swift.String(describing: creationTime)), currentVersion: \(Swift.String(describing: currentVersion)), provisioned: \(Swift.String(describing: provisioned)), serverless: \(Swift.String(describing: serverless)), state: \(Swift.String(describing: state)), stateInfo: \(Swift.String(describing: stateInfo)), tags: \(Swift.String(describing: tags)))"}
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct Cluster: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.
        public var activeOperationArn: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// Cluster Type.
        public var clusterType: KafkaClientTypes.ClusterType?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Information about the provisioned cluster.
        public var provisioned: KafkaClientTypes.Provisioned?
        /// Information about the serverless cluster.
        public var serverless: KafkaClientTypes.Serverless?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        /// State Info for the Amazon MSK cluster.
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?

        public init (
            activeOperationArn: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterType: KafkaClientTypes.ClusterType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentVersion: Swift.String? = nil,
            provisioned: KafkaClientTypes.Provisioned? = nil,
            serverless: KafkaClientTypes.Serverless? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.provisioned = provisioned
            self.serverless = serverless
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
        }
    }

}

extension KafkaClientTypes.ClusterInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeOperationArn = "activeOperationArn"
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case creationTime = "creationTime"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case state = "state"
        case stateInfo = "stateInfo"
        case tags = "tags"
        case zookeeperConnectString = "zookeeperConnectString"
        case zookeeperConnectStringTls = "zookeeperConnectStringTls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeOperationArn = activeOperationArn {
            try encodeContainer.encode(activeOperationArn, forKey: .activeOperationArn)
        }
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let currentBrokerSoftwareInfo = currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateInfo = stateInfo {
            try encodeContainer.encode(stateInfo, forKey: .stateInfo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let zookeeperConnectString = zookeeperConnectString {
            try encodeContainer.encode(zookeeperConnectString, forKey: .zookeeperConnectString)
        }
        if let zookeeperConnectStringTls = zookeeperConnectStringTls {
            try encodeContainer.encode(zookeeperConnectStringTls, forKey: .zookeeperConnectStringTls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeOperationArn)
        activeOperationArn = activeOperationArnDecoded
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let stateInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.StateInfo.self, forKey: .stateInfo)
        stateInfo = stateInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let zookeeperConnectStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectString)
        zookeeperConnectString = zookeeperConnectStringDecoded
        let zookeeperConnectStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectStringTls)
        zookeeperConnectStringTls = zookeeperConnectStringTlsDecoded
    }
}

extension KafkaClientTypes.ClusterInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterInfo(activeOperationArn: \(Swift.String(describing: activeOperationArn)), brokerNodeGroupInfo: \(Swift.String(describing: brokerNodeGroupInfo)), clientAuthentication: \(Swift.String(describing: clientAuthentication)), clusterArn: \(Swift.String(describing: clusterArn)), clusterName: \(Swift.String(describing: clusterName)), creationTime: \(Swift.String(describing: creationTime)), currentBrokerSoftwareInfo: \(Swift.String(describing: currentBrokerSoftwareInfo)), currentVersion: \(Swift.String(describing: currentVersion)), encryptionInfo: \(Swift.String(describing: encryptionInfo)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), loggingInfo: \(Swift.String(describing: loggingInfo)), numberOfBrokerNodes: \(Swift.String(describing: numberOfBrokerNodes)), openMonitoring: \(Swift.String(describing: openMonitoring)), state: \(Swift.String(describing: state)), stateInfo: \(Swift.String(describing: stateInfo)), tags: \(Swift.String(describing: tags)), zookeeperConnectString: \(Swift.String(describing: zookeeperConnectString)), zookeeperConnectStringTls: \(Swift.String(describing: zookeeperConnectStringTls)))"}
}

extension KafkaClientTypes {
    /// Returns information about a cluster.
    public struct ClusterInfo: Swift.Equatable {
        /// Arn of active cluster operation.
        public var activeOperationArn: Swift.String?
        /// Information about the broker nodes.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public var clusterArn: Swift.String?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// The time when the cluster was created.
        public var creationTime: ClientRuntime.Date?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// The current version of the MSK cluster.
        public var currentVersion: Swift.String?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// Settings for open monitoring using Prometheus.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public var state: KafkaClientTypes.ClusterState?
        public var stateInfo: KafkaClientTypes.StateInfo?
        /// Tags attached to the cluster.
        public var tags: [Swift.String:Swift.String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public var zookeeperConnectStringTls: Swift.String?

        public init (
            activeOperationArn: Swift.String? = nil,
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            currentVersion: Swift.String? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil,
            state: KafkaClientTypes.ClusterState? = nil,
            stateInfo: KafkaClientTypes.StateInfo? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ClusterOperationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestId = "clientRequestId"
        case clusterArn = "clusterArn"
        case creationTime = "creationTime"
        case endTime = "endTime"
        case errorInfo = "errorInfo"
        case operationArn = "operationArn"
        case operationState = "operationState"
        case operationSteps = "operationSteps"
        case operationType = "operationType"
        case sourceClusterInfo = "sourceClusterInfo"
        case targetClusterInfo = "targetClusterInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestId = clientRequestId {
            try encodeContainer.encode(clientRequestId, forKey: .clientRequestId)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let operationArn = operationArn {
            try encodeContainer.encode(operationArn, forKey: .operationArn)
        }
        if let operationState = operationState {
            try encodeContainer.encode(operationState, forKey: .operationState)
        }
        if let operationSteps = operationSteps {
            var operationStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationSteps)
            for __listofclusteroperationstep0 in operationSteps {
                try operationStepsContainer.encode(__listofclusteroperationstep0)
            }
        }
        if let operationType = operationType {
            try encodeContainer.encode(operationType, forKey: .operationType)
        }
        if let sourceClusterInfo = sourceClusterInfo {
            try encodeContainer.encode(sourceClusterInfo, forKey: .sourceClusterInfo)
        }
        if let targetClusterInfo = targetClusterInfo {
            try encodeContainer.encode(targetClusterInfo, forKey: .targetClusterInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestId)
        clientRequestId = clientRequestIdDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let operationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationArn)
        operationArn = operationArnDecoded
        let operationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationState)
        operationState = operationStateDecoded
        let operationStepsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationStep?].self, forKey: .operationSteps)
        var operationStepsDecoded0:[KafkaClientTypes.ClusterOperationStep]? = nil
        if let operationStepsContainer = operationStepsContainer {
            operationStepsDecoded0 = [KafkaClientTypes.ClusterOperationStep]()
            for structure0 in operationStepsContainer {
                if let structure0 = structure0 {
                    operationStepsDecoded0?.append(structure0)
                }
            }
        }
        operationSteps = operationStepsDecoded0
        let operationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let sourceClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .sourceClusterInfo)
        sourceClusterInfo = sourceClusterInfoDecoded
        let targetClusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.MutableClusterInfo.self, forKey: .targetClusterInfo)
        targetClusterInfo = targetClusterInfoDecoded
    }
}

extension KafkaClientTypes.ClusterOperationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterOperationInfo(clientRequestId: \(Swift.String(describing: clientRequestId)), clusterArn: \(Swift.String(describing: clusterArn)), creationTime: \(Swift.String(describing: creationTime)), endTime: \(Swift.String(describing: endTime)), errorInfo: \(Swift.String(describing: errorInfo)), operationArn: \(Swift.String(describing: operationArn)), operationState: \(Swift.String(describing: operationState)), operationSteps: \(Swift.String(describing: operationSteps)), operationType: \(Swift.String(describing: operationType)), sourceClusterInfo: \(Swift.String(describing: sourceClusterInfo)), targetClusterInfo: \(Swift.String(describing: targetClusterInfo)))"}
}

extension KafkaClientTypes {
    /// Returns information about a cluster operation.
    public struct ClusterOperationInfo: Swift.Equatable {
        /// The ID of the API request that triggered this operation.
        public var clientRequestId: Swift.String?
        /// ARN of the cluster.
        public var clusterArn: Swift.String?
        /// The time that the operation was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the operation finished.
        public var endTime: ClientRuntime.Date?
        /// Describes the error if the operation fails.
        public var errorInfo: KafkaClientTypes.ErrorInfo?
        /// ARN of the cluster operation.
        public var operationArn: Swift.String?
        /// State of the cluster operation.
        public var operationState: Swift.String?
        /// Steps completed during the operation.
        public var operationSteps: [KafkaClientTypes.ClusterOperationStep]?
        /// Type of the cluster operation.
        public var operationType: Swift.String?
        /// Information about cluster attributes before a cluster is updated.
        public var sourceClusterInfo: KafkaClientTypes.MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public var targetClusterInfo: KafkaClientTypes.MutableClusterInfo?

        public init (
            clientRequestId: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorInfo: KafkaClientTypes.ErrorInfo? = nil,
            operationArn: Swift.String? = nil,
            operationState: Swift.String? = nil,
            operationSteps: [KafkaClientTypes.ClusterOperationStep]? = nil,
            operationType: Swift.String? = nil,
            sourceClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil,
            targetClusterInfo: KafkaClientTypes.MutableClusterInfo? = nil
        )
        {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
        }
    }

}

extension KafkaClientTypes.ClusterOperationStep: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepInfo = "stepInfo"
        case stepName = "stepName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepInfo = stepInfo {
            try encodeContainer.encode(stepInfo, forKey: .stepInfo)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationStepInfo.self, forKey: .stepInfo)
        stepInfo = stepInfoDecoded
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
    }
}

extension KafkaClientTypes.ClusterOperationStep: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterOperationStep(stepInfo: \(Swift.String(describing: stepInfo)), stepName: \(Swift.String(describing: stepName)))"}
}

extension KafkaClientTypes {
    /// Step taken during a cluster operation.
    public struct ClusterOperationStep: Swift.Equatable {
        /// Information about the step and its status.
        public var stepInfo: KafkaClientTypes.ClusterOperationStepInfo?
        /// The name of the step.
        public var stepName: Swift.String?

        public init (
            stepInfo: KafkaClientTypes.ClusterOperationStepInfo? = nil,
            stepName: Swift.String? = nil
        )
        {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }
    }

}

extension KafkaClientTypes.ClusterOperationStepInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepStatus = "stepStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepStatus = stepStatus {
            try encodeContainer.encode(stepStatus, forKey: .stepStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
    }
}

extension KafkaClientTypes.ClusterOperationStepInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterOperationStepInfo(stepStatus: \(Swift.String(describing: stepStatus)))"}
}

extension KafkaClientTypes {
    /// State information about the operation step.
    public struct ClusterOperationStepInfo: Swift.Equatable {
        /// The steps current status.
        public var stepStatus: Swift.String?

        public init (
            stepStatus: Swift.String? = nil
        )
        {
            self.stepStatus = stepStatus
        }
    }

}

extension KafkaClientTypes {
    /// The state of the Apache Kafka cluster.
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case healing
        case maintenance
        case rebootingBroker
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .healing,
                .maintenance,
                .rebootingBroker,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healing: return "HEALING"
            case .maintenance: return "MAINTENANCE"
            case .rebootingBroker: return "REBOOTING_BROKER"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes {
    /// The type of cluster.
    public enum ClusterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case provisioned
        case serverless
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterType] {
            return [
                .provisioned,
                .serverless,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .provisioned: return "PROVISIONED"
            case .serverless: return "SERVERLESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterType(rawValue: rawValue) ?? ClusterType.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.CompatibleKafkaVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceVersion = "sourceVersion"
        case targetVersions = "targetVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceVersion = sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let targetVersions = targetVersions {
            var targetVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetVersions)
            for __listof__string0 in targetVersions {
                try targetVersionsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let targetVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetVersions)
        var targetVersionsDecoded0:[Swift.String]? = nil
        if let targetVersionsContainer = targetVersionsContainer {
            targetVersionsDecoded0 = [Swift.String]()
            for string0 in targetVersionsContainer {
                if let string0 = string0 {
                    targetVersionsDecoded0?.append(string0)
                }
            }
        }
        targetVersions = targetVersionsDecoded0
    }
}

extension KafkaClientTypes.CompatibleKafkaVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompatibleKafkaVersion(sourceVersion: \(Swift.String(describing: sourceVersion)), targetVersions: \(Swift.String(describing: targetVersions)))"}
}

extension KafkaClientTypes {
    /// Contains source Apache Kafka versions and compatible target Apache Kafka versions.
    public struct CompatibleKafkaVersion: Swift.Equatable {
        /// An Apache Kafka version.
        public var sourceVersion: Swift.String?
        /// A list of Apache Kafka versions.
        public var targetVersions: [Swift.String]?

        public init (
            sourceVersion: Swift.String? = nil,
            targetVersions: [Swift.String]? = nil
        )
        {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }
    }

}

extension KafkaClientTypes.Configuration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __listof__string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__listof__string0)
            }
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension KafkaClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), kafkaVersions: \(Swift.String(describing: kafkaVersions)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension KafkaClientTypes {
    /// Represents an MSK Configuration.
    public struct Configuration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the configuration was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        /// This member is required.
        public var kafkaVersions: [Swift.String]?
        /// Latest revision of the configuration.
        /// This member is required.
        public var latestRevision: KafkaClientTypes.ConfigurationRevision?
        /// The name of the configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        /// This member is required.
        public var state: KafkaClientTypes.ConfigurationState?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            kafkaVersions: [Swift.String]? = nil,
            latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            state: KafkaClientTypes.ConfigurationState? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }
    }

}

extension KafkaClientTypes.ConfigurationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaClientTypes.ConfigurationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationInfo(arn: \(Swift.String(describing: arn)), revision: \(Swift.String(describing: revision)))"}
}

extension KafkaClientTypes {
    /// Specifies the configuration to use for the brokers.
    public struct ConfigurationInfo: Swift.Equatable {
        /// ARN of the configuration to use.
        /// This member is required.
        public var arn: Swift.String?
        /// The revision of the configuration to use.
        /// This member is required.
        public var revision: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.revision = revision
        }
    }

}

extension KafkaClientTypes.ConfigurationRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension KafkaClientTypes.ConfigurationRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationRevision(creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), revision: \(Swift.String(describing: revision)))"}
}

extension KafkaClientTypes {
    /// Describes a configuration revision.
    public struct ConfigurationRevision: Swift.Equatable {
        /// The time when the configuration revision was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// The revision number.
        /// This member is required.
        public var revision: Swift.Int?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }
    }

}

extension KafkaClientTypes {
    /// The state of a configuration.
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.ConnectivityInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicAccess = "publicAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicAccessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
    }
}

extension KafkaClientTypes.ConnectivityInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectivityInfo(publicAccess: \(Swift.String(describing: publicAccess)))"}
}

extension KafkaClientTypes {
    /// Information about the broker access configuration.
    public struct ConnectivityInfo: Swift.Equatable {
        /// Public access control for brokers.
        public var publicAccess: KafkaClientTypes.PublicAccess?

        public init (
            publicAccess: KafkaClientTypes.PublicAccess? = nil
        )
        {
            self.publicAccess = publicAccess
        }
    }

}

public struct CreateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(brokerNodeGroupInfo: \(Swift.String(describing: brokerNodeGroupInfo)), clientAuthentication: \(Swift.String(describing: clientAuthentication)), clusterName: \(Swift.String(describing: clusterName)), configurationInfo: \(Swift.String(describing: configurationInfo)), encryptionInfo: \(Swift.String(describing: encryptionInfo)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), kafkaVersion: \(Swift.String(describing: kafkaVersion)), loggingInfo: \(Swift.String(describing: loggingInfo)), numberOfBrokerNodes: \(Swift.String(describing: numberOfBrokerNodes)), openMonitoring: \(Swift.String(describing: openMonitoring)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/clusters"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Swift.Equatable {
    /// Information about the broker nodes in the cluster.
    /// This member is required.
    public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
    /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    /// The version of Apache Kafka.
    /// This member is required.
    public var kafkaVersion: Swift.String?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The number of broker nodes in the cluster.
    /// This member is required.
    public var numberOfBrokerNodes: Swift.Int?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    /// Create tags when creating the cluster.
    public var tags: [Swift.String:Swift.String]?

    public init (
        brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterName: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        kafkaVersion: Swift.String? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        numberOfBrokerNodes: Swift.Int? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.brokerNodeGroupInfo = brokerNodeGroupInfo
        self.clientAuthentication = clientAuthentication
        self.clusterName = clusterName
        self.configurationInfo = configurationInfo
        self.encryptionInfo = encryptionInfo
        self.enhancedMonitoring = enhancedMonitoring
        self.kafkaVersion = kafkaVersion
        self.loggingInfo = loggingInfo
        self.numberOfBrokerNodes = numberOfBrokerNodes
        self.openMonitoring = openMonitoring
        self.tags = tags
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    public let brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
    public let clientAuthentication: KafkaClientTypes.ClientAuthentication?
    public let clusterName: Swift.String?
    public let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    public let encryptionInfo: KafkaClientTypes.EncryptionInfo?
    public let enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    public let openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    public let kafkaVersion: Swift.String?
    public let loggingInfo: KafkaClientTypes.LoggingInfo?
    public let numberOfBrokerNodes: Swift.Int?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case clusterName = "clusterName"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterName: \(Swift.String(describing: clusterName)), state: \(Swift.String(describing: state)))"}
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterName = output.clusterName
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.clusterName = nil
            self.state = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init (
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.state = state
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterName: Swift.String?
    public let state: KafkaClientTypes.ClusterState?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct CreateClusterV2InputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterV2InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterV2OutputError>
}

extension CreateClusterV2Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterV2Input(clusterName: \(Swift.String(describing: clusterName)), provisioned: \(Swift.String(describing: provisioned)), serverless: \(Swift.String(describing: serverless)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateClusterV2Input: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "clusterName"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let provisioned = provisioned {
            try encodeContainer.encode(provisioned, forKey: .provisioned)
        }
        if let serverless = serverless {
            try encodeContainer.encode(serverless, forKey: .serverless)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateClusterV2InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterV2OutputError>
}

public struct CreateClusterV2InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterV2OutputError>
}

public struct CreateClusterV2InputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterV2InputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateClusterV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterV2OutputError>
}

public struct CreateClusterV2InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterV2InputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateClusterV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/api/v2/clusters"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateClusterV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterV2OutputError>
}

public struct CreateClusterV2Input: Swift.Equatable {
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// Information about the provisioned cluster.
    public var provisioned: KafkaClientTypes.ProvisionedRequest?
    /// Information about the serverless cluster.
    public var serverless: KafkaClientTypes.ServerlessRequest?
    /// A map of tags that you want the cluster to have.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clusterName: Swift.String? = nil,
        provisioned: KafkaClientTypes.ProvisionedRequest? = nil,
        serverless: KafkaClientTypes.ServerlessRequest? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.provisioned = provisioned
        self.serverless = serverless
        self.tags = tags
    }
}

struct CreateClusterV2InputBody: Swift.Equatable {
    public let clusterName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let provisioned: KafkaClientTypes.ProvisionedRequest?
    public let serverless: KafkaClientTypes.ServerlessRequest?
}

extension CreateClusterV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName = "clusterName"
        case provisioned = "provisioned"
        case serverless = "serverless"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let provisionedDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ProvisionedRequest.self, forKey: .provisioned)
        provisioned = provisionedDecoded
        let serverlessDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessRequest.self, forKey: .serverless)
        serverless = serverlessDecoded
    }
}

extension CreateClusterV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterV2OutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterV2OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterV2OutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterName: \(Swift.String(describing: clusterName)), clusterType: \(Swift.String(describing: clusterType)), state: \(Swift.String(describing: state)))"}
}

extension CreateClusterV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterName = output.clusterName
            self.clusterType = output.clusterType
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.clusterName = nil
            self.clusterType = nil
            self.state = nil
        }
    }
}

public struct CreateClusterV2OutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The name of the MSK cluster.
    public var clusterName: Swift.String?
    /// The type of the cluster. The possible states are PROVISIONED or SERVERLESS.
    public var clusterType: KafkaClientTypes.ClusterType?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init (
        clusterArn: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        clusterType: KafkaClientTypes.ClusterType? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterName = clusterName
        self.clusterType = clusterType
        self.state = state
    }
}

struct CreateClusterV2OutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterName: Swift.String?
    public let state: KafkaClientTypes.ClusterState?
    public let clusterType: KafkaClientTypes.ClusterType?
}

extension CreateClusterV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterName = "clusterName"
        case clusterType = "clusterType"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterType.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
    }
}

public struct CreateConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

extension CreateConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationInput(description: \(Swift.String(describing: description)), kafkaVersions: \(Swift.String(describing: kafkaVersions)), name: \(Swift.String(describing: name)), serverProperties: \(Swift.String(describing: serverProperties)))"}
}

extension CreateConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kafkaVersions = kafkaVersions {
            var kafkaVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kafkaVersions)
            for __listof__string0 in kafkaVersions {
                try kafkaVersionsContainer.encode(__listof__string0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverProperties = serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

public struct CreateConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInput: Swift.Equatable {
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// The name of the configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init (
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.name = name
        self.serverProperties = serverProperties
    }
}

struct CreateConfigurationInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let kafkaVersions: [Swift.String]?
    public let name: Swift.String?
    public let serverProperties: ClientRuntime.Data?
}

extension CreateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case name = "name"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension CreateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension CreateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct CreateConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let latestRevision: KafkaClientTypes.ConfigurationRevision?
    public let name: Swift.String?
    public let state: KafkaClientTypes.ConfigurationState?
}

extension CreateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterInput(clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)))"}
}

extension DeleteClusterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let currentVersion = input.operationInput.currentVersion {
            let currentVersionQueryItem = ClientRuntime.URLQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            input.builder.withQueryItem(currentVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The current version of the MSK cluster.
    public var currentVersion: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
}

extension DeleteClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteClusterOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), state: \(Swift.String(describing: state)))"}
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.state = output.state
        } else {
            self.clusterArn = nil
            self.state = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
    public var state: KafkaClientTypes.ClusterState?

    public init (
        clusterArn: Swift.String? = nil,
        state: KafkaClientTypes.ClusterState? = nil
    )
    {
        self.clusterArn = clusterArn
        self.state = state
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let state: KafkaClientTypes.ClusterState?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(arn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationOutputError>
}

public struct DeleteConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteConfigurationInputBody: Swift.Equatable {
}

extension DeleteConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), state: \(Swift.String(describing: state)))"}
}

extension DeleteConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.state = output.state
        } else {
            self.arn = nil
            self.state = nil
        }
    }
}

public struct DeleteConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    public var arn: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init (
        arn: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.state = state
    }
}

struct DeleteConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let state: KafkaClientTypes.ConfigurationState?
}

extension DeleteConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribeClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterInput(clusterArn: \(Swift.String(describing: clusterArn)))"}
}

extension DescribeClusterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DescribeClusterInputBody: Swift.Equatable {
}

extension DescribeClusterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterOperationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterOperationInput(clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension DescribeClusterOperationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeClusterOperationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterOperationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterOperationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterOperationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterOperationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterOperationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterOperationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterOperationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterOperationArn = input.clusterOperationArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterOperationArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/operations/\(clusterOperationArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterOperationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOperationOutputError>
}

public struct DescribeClusterOperationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
    /// This member is required.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterOperationArn = clusterOperationArn
    }
}

struct DescribeClusterOperationInputBody: Swift.Equatable {
}

extension DescribeClusterOperationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterOperationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOperationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOperationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOperationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterOperationOutputResponse(clusterOperationInfo: \(Swift.String(describing: clusterOperationInfo)))"}
}

extension DescribeClusterOperationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterOperationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfo = output.clusterOperationInfo
        } else {
            self.clusterOperationInfo = nil
        }
    }
}

public struct DescribeClusterOperationOutputResponse: Swift.Equatable {
    /// Cluster operation information
    public var clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo?

    public init (
        clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo? = nil
    )
    {
        self.clusterOperationInfo = clusterOperationInfo
    }
}

struct DescribeClusterOperationOutputResponseBody: Swift.Equatable {
    public let clusterOperationInfo: KafkaClientTypes.ClusterOperationInfo?
}

extension DescribeClusterOperationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfo = "clusterOperationInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterOperationInfo.self, forKey: .clusterOperationInfo)
        clusterOperationInfo = clusterOperationInfoDecoded
    }
}

extension DescribeClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterOutputResponse(clusterInfo: \(Swift.String(describing: clusterInfo)))"}
}

extension DescribeClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfo = output.clusterInfo
        } else {
            self.clusterInfo = nil
        }
    }
}

public struct DescribeClusterOutputResponse: Swift.Equatable {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.ClusterInfo?

    public init (
        clusterInfo: KafkaClientTypes.ClusterInfo? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

struct DescribeClusterOutputResponseBody: Swift.Equatable {
    public let clusterInfo: KafkaClientTypes.ClusterInfo?
}

extension DescribeClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfo = "clusterInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClusterInfo.self, forKey: .clusterInfo)
        clusterInfo = clusterInfoDecoded
    }
}

extension DescribeClusterV2Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterV2Input(clusterArn: \(Swift.String(describing: clusterArn)))"}
}

extension DescribeClusterV2Input: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeClusterV2InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterV2OutputError>
}

public struct DescribeClusterV2InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterV2OutputError>
}

public struct DescribeClusterV2InputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterV2InputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterV2OutputError>
}

public struct DescribeClusterV2InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterV2InputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeClusterV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/api/v2/clusters/\(clusterArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeClusterV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterV2OutputError>
}

public struct DescribeClusterV2Input: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DescribeClusterV2InputBody: Swift.Equatable {
}

extension DescribeClusterV2InputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeClusterV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterV2OutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterV2OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterV2OutputResponse(clusterInfo: \(Swift.String(describing: clusterInfo)))"}
}

extension DescribeClusterV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfo = output.clusterInfo
        } else {
            self.clusterInfo = nil
        }
    }
}

public struct DescribeClusterV2OutputResponse: Swift.Equatable {
    /// The cluster information.
    public var clusterInfo: KafkaClientTypes.Cluster?

    public init (
        clusterInfo: KafkaClientTypes.Cluster? = nil
    )
    {
        self.clusterInfo = clusterInfo
    }
}

struct DescribeClusterV2OutputResponseBody: Swift.Equatable {
    public let clusterInfo: KafkaClientTypes.Cluster?
}

extension DescribeClusterV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfo = "clusterInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Cluster.self, forKey: .clusterInfo)
        clusterInfo = clusterInfoDecoded
    }
}

extension DescribeConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension DescribeConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(arn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeConfigurationInputBody: Swift.Equatable {
}

extension DescribeConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), kafkaVersions: \(Swift.String(describing: kafkaVersions)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension DescribeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.kafkaVersions = output.kafkaVersions
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.kafkaVersions = nil
            self.latestRevision = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The versions of Apache Kafka with which you can use this MSK configuration.
    public var kafkaVersions: [Swift.String]?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?
    /// The name of the configuration.
    public var name: Swift.String?
    /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
    public var state: KafkaClientTypes.ConfigurationState?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        kafkaVersions: [Swift.String]? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        state: KafkaClientTypes.ConfigurationState? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.kafkaVersions = kafkaVersions
        self.latestRevision = latestRevision
        self.name = name
        self.state = state
    }
}

struct DescribeConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let description: Swift.String?
    public let kafkaVersions: [Swift.String]?
    public let latestRevision: KafkaClientTypes.ConfigurationRevision?
    public let name: Swift.String?
    public let state: KafkaClientTypes.ConfigurationState?
}

extension DescribeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case kafkaVersions = "kafkaVersions"
        case latestRevision = "latestRevision"
        case name = "name"
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[Swift.String]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [Swift.String]()
            for string0 in kafkaVersionsContainer {
                if let string0 = string0 {
                    kafkaVersionsDecoded0?.append(string0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DescribeConfigurationRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationRevisionInput(arn: \(Swift.String(describing: arn)), revision: \(Swift.String(describing: revision)))"}
}

extension DescribeConfigurationRevisionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeConfigurationRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        guard let revision = input.revision else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("revision is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(arn.urlPercentEncoding())/revisions/\(revision)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// A string that uniquely identifies a revision of an MSK configuration.
    /// This member is required.
    public var revision: Swift.Int?

    public init (
        arn: Swift.String? = nil,
        revision: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.revision = revision
    }
}

struct DescribeConfigurationRevisionInputBody: Swift.Equatable {
}

extension DescribeConfigurationRevisionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRevisionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationRevisionOutputResponse(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), revision: \(Swift.String(describing: revision)), serverProperties: \(Swift.String(describing: serverProperties)))"}
}

extension DescribeConfigurationRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.revision = output.revision
            self.serverProperties = output.serverProperties
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.revision = nil
            self.serverProperties = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// The time when the configuration was created.
    public var creationTime: ClientRuntime.Date?
    /// The description of the configuration.
    public var description: Swift.String?
    /// The revision number.
    public var revision: Swift.Int?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    public var serverProperties: ClientRuntime.Data?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        revision: Swift.Int? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.revision = revision
        self.serverProperties = serverProperties
    }
}

struct DescribeConfigurationRevisionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let creationTime: ClientRuntime.Date?
    public let description: Swift.String?
    public let revision: Swift.Int?
    public let serverProperties: ClientRuntime.Data?
}

extension DescribeConfigurationRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case creationTime = "creationTime"
        case description = "description"
        case revision = "revision"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension KafkaClientTypes.EBSStorageInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeSize = "volumeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
    }
}

extension KafkaClientTypes.EBSStorageInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EBSStorageInfo(volumeSize: \(Swift.String(describing: volumeSize)))"}
}

extension KafkaClientTypes {
    /// Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.
    public struct EBSStorageInfo: Swift.Equatable {
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public var volumeSize: Swift.Int?

        public init (
            volumeSize: Swift.Int? = nil
        )
        {
            self.volumeSize = volumeSize
        }
    }

}

extension KafkaClientTypes.EncryptionAtRest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataVolumeKMSKeyId = "dataVolumeKMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataVolumeKMSKeyId = dataVolumeKMSKeyId {
            try encodeContainer.encode(dataVolumeKMSKeyId, forKey: .dataVolumeKMSKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataVolumeKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataVolumeKMSKeyId)
        dataVolumeKMSKeyId = dataVolumeKMSKeyIdDecoded
    }
}

extension KafkaClientTypes.EncryptionAtRest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionAtRest(dataVolumeKMSKeyId: \(Swift.String(describing: dataVolumeKMSKeyId)))"}
}

extension KafkaClientTypes {
    /// The data-volume encryption details.
    public struct EncryptionAtRest: Swift.Equatable {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        /// This member is required.
        public var dataVolumeKMSKeyId: Swift.String?

        public init (
            dataVolumeKMSKeyId: Swift.String? = nil
        )
        {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }
    }

}

extension KafkaClientTypes.EncryptionInTransit: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientBroker = "clientBroker"
        case inCluster = "inCluster"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientBroker = clientBroker {
            try encodeContainer.encode(clientBroker.rawValue, forKey: .clientBroker)
        }
        if let inCluster = inCluster {
            try encodeContainer.encode(inCluster, forKey: .inCluster)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientBrokerDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientBroker.self, forKey: .clientBroker)
        clientBroker = clientBrokerDecoded
        let inClusterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inCluster)
        inCluster = inClusterDecoded
    }
}

extension KafkaClientTypes.EncryptionInTransit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionInTransit(clientBroker: \(Swift.String(describing: clientBroker)), inCluster: \(Swift.String(describing: inCluster)))"}
}

extension KafkaClientTypes {
    /// The settings for encrypting data in transit.
    public struct EncryptionInTransit: Swift.Equatable {
        /// Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values. TLS means that client-broker communication is enabled with TLS only. TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data. PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS_PLAINTEXT.
        public var clientBroker: KafkaClientTypes.ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public var inCluster: Swift.Bool?

        public init (
            clientBroker: KafkaClientTypes.ClientBroker? = nil,
            inCluster: Swift.Bool? = nil
        )
        {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }
    }

}

extension KafkaClientTypes.EncryptionInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionAtRest = "encryptionAtRest"
        case encryptionInTransit = "encryptionInTransit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionAtRest = encryptionAtRest {
            try encodeContainer.encode(encryptionAtRest, forKey: .encryptionAtRest)
        }
        if let encryptionInTransit = encryptionInTransit {
            try encodeContainer.encode(encryptionInTransit, forKey: .encryptionInTransit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionAtRestDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionAtRest.self, forKey: .encryptionAtRest)
        encryptionAtRest = encryptionAtRestDecoded
        let encryptionInTransitDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInTransit.self, forKey: .encryptionInTransit)
        encryptionInTransit = encryptionInTransitDecoded
    }
}

extension KafkaClientTypes.EncryptionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionInfo(encryptionAtRest: \(Swift.String(describing: encryptionAtRest)), encryptionInTransit: \(Swift.String(describing: encryptionInTransit)))"}
}

extension KafkaClientTypes {
    /// Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.
    public struct EncryptionInfo: Swift.Equatable {
        /// The data-volume encryption details.
        public var encryptionAtRest: KafkaClientTypes.EncryptionAtRest?
        /// The details for encryption in transit.
        public var encryptionInTransit: KafkaClientTypes.EncryptionInTransit?

        public init (
            encryptionAtRest: KafkaClientTypes.EncryptionAtRest? = nil,
            encryptionInTransit: KafkaClientTypes.EncryptionInTransit? = nil
        )
        {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }
    }

}

extension KafkaClientTypes {
    /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see [Monitoring](https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html).
    public enum EnhancedMonitoring: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case perBroker
        case perTopicPerBroker
        case perTopicPerPartition
        case sdkUnknown(Swift.String)

        public static var allCases: [EnhancedMonitoring] {
            return [
                .default,
                .perBroker,
                .perTopicPerBroker,
                .perTopicPerPartition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .perBroker: return "PER_BROKER"
            case .perTopicPerBroker: return "PER_TOPIC_PER_BROKER"
            case .perTopicPerPartition: return "PER_TOPIC_PER_PARTITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnhancedMonitoring(rawValue: rawValue) ?? EnhancedMonitoring.sdkUnknown(rawValue)
        }
    }
}

extension KafkaClientTypes.ErrorInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case errorString = "errorString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorString = errorString {
            try encodeContainer.encode(errorString, forKey: .errorString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorString)
        errorString = errorStringDecoded
    }
}

extension KafkaClientTypes.ErrorInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorInfo(errorCode: \(Swift.String(describing: errorCode)), errorString: \(Swift.String(describing: errorString)))"}
}

extension KafkaClientTypes {
    /// Returns information about an error state of the cluster.
    public struct ErrorInfo: Swift.Equatable {
        /// A number describing the error programmatically.
        public var errorCode: Swift.String?
        /// An optional field to provide more details about the error.
        public var errorString: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorString = errorString
        }
    }

}

extension KafkaClientTypes.Firehose: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStream = "deliveryStream"
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStream = deliveryStream {
            try encodeContainer.encode(deliveryStream, forKey: .deliveryStream)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStream)
        deliveryStream = deliveryStreamDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes.Firehose: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Firehose(deliveryStream: \(Swift.String(describing: deliveryStream)), enabled: \(Swift.String(describing: enabled)))"}
}

extension KafkaClientTypes {
    public struct Firehose: Swift.Equatable {
        public var deliveryStream: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBootstrapBrokersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBootstrapBrokersInput(clusterArn: \(Swift.String(describing: clusterArn)))"}
}

extension GetBootstrapBrokersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBootstrapBrokersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBootstrapBrokersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBootstrapBrokersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBootstrapBrokersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBootstrapBrokersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBootstrapBrokersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBootstrapBrokersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBootstrapBrokersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBootstrapBrokersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBootstrapBrokersInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBootstrapBrokersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBootstrapBrokersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/bootstrap-brokers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBootstrapBrokersInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBootstrapBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBootstrapBrokersOutputError>
}

public struct GetBootstrapBrokersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetBootstrapBrokersInputBody: Swift.Equatable {
}

extension GetBootstrapBrokersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBootstrapBrokersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBootstrapBrokersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBootstrapBrokersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBootstrapBrokersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBootstrapBrokersOutputResponse(bootstrapBrokerString: \(Swift.String(describing: bootstrapBrokerString)), bootstrapBrokerStringPublicSaslIam: \(Swift.String(describing: bootstrapBrokerStringPublicSaslIam)), bootstrapBrokerStringPublicSaslScram: \(Swift.String(describing: bootstrapBrokerStringPublicSaslScram)), bootstrapBrokerStringPublicTls: \(Swift.String(describing: bootstrapBrokerStringPublicTls)), bootstrapBrokerStringSaslIam: \(Swift.String(describing: bootstrapBrokerStringSaslIam)), bootstrapBrokerStringSaslScram: \(Swift.String(describing: bootstrapBrokerStringSaslScram)), bootstrapBrokerStringTls: \(Swift.String(describing: bootstrapBrokerStringTls)))"}
}

extension GetBootstrapBrokersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBootstrapBrokersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bootstrapBrokerString = output.bootstrapBrokerString
            self.bootstrapBrokerStringPublicSaslIam = output.bootstrapBrokerStringPublicSaslIam
            self.bootstrapBrokerStringPublicSaslScram = output.bootstrapBrokerStringPublicSaslScram
            self.bootstrapBrokerStringPublicTls = output.bootstrapBrokerStringPublicTls
            self.bootstrapBrokerStringSaslIam = output.bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = output.bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = output.bootstrapBrokerStringTls
        } else {
            self.bootstrapBrokerString = nil
            self.bootstrapBrokerStringPublicSaslIam = nil
            self.bootstrapBrokerStringPublicSaslScram = nil
            self.bootstrapBrokerStringPublicTls = nil
            self.bootstrapBrokerStringSaslIam = nil
            self.bootstrapBrokerStringSaslScram = nil
            self.bootstrapBrokerStringTls = nil
        }
    }
}

public struct GetBootstrapBrokersOutputResponse: Swift.Equatable {
    /// A string containing one or more hostname:port pairs.
    public var bootstrapBrokerString: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringPublicSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringPublicSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringPublicTls: Swift.String?
    /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
    public var bootstrapBrokerStringSaslIam: Swift.String?
    /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
    public var bootstrapBrokerStringSaslScram: Swift.String?
    /// A string containing one or more DNS names (or IP) and TLS port pairs.
    public var bootstrapBrokerStringTls: Swift.String?

    public init (
        bootstrapBrokerString: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslIam: Swift.String? = nil,
        bootstrapBrokerStringPublicSaslScram: Swift.String? = nil,
        bootstrapBrokerStringPublicTls: Swift.String? = nil,
        bootstrapBrokerStringSaslIam: Swift.String? = nil,
        bootstrapBrokerStringSaslScram: Swift.String? = nil,
        bootstrapBrokerStringTls: Swift.String? = nil
    )
    {
        self.bootstrapBrokerString = bootstrapBrokerString
        self.bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIam
        self.bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScram
        self.bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTls
        self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
        self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
        self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
    }
}

struct GetBootstrapBrokersOutputResponseBody: Swift.Equatable {
    public let bootstrapBrokerString: Swift.String?
    public let bootstrapBrokerStringTls: Swift.String?
    public let bootstrapBrokerStringSaslScram: Swift.String?
    public let bootstrapBrokerStringSaslIam: Swift.String?
    public let bootstrapBrokerStringPublicTls: Swift.String?
    public let bootstrapBrokerStringPublicSaslScram: Swift.String?
    public let bootstrapBrokerStringPublicSaslIam: Swift.String?
}

extension GetBootstrapBrokersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootstrapBrokerString = "bootstrapBrokerString"
        case bootstrapBrokerStringPublicSaslIam = "bootstrapBrokerStringPublicSaslIam"
        case bootstrapBrokerStringPublicSaslScram = "bootstrapBrokerStringPublicSaslScram"
        case bootstrapBrokerStringPublicTls = "bootstrapBrokerStringPublicTls"
        case bootstrapBrokerStringSaslIam = "bootstrapBrokerStringSaslIam"
        case bootstrapBrokerStringSaslScram = "bootstrapBrokerStringSaslScram"
        case bootstrapBrokerStringTls = "bootstrapBrokerStringTls"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapBrokerStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerString)
        bootstrapBrokerString = bootstrapBrokerStringDecoded
        let bootstrapBrokerStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringTls)
        bootstrapBrokerStringTls = bootstrapBrokerStringTlsDecoded
        let bootstrapBrokerStringSaslScramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringSaslScram)
        bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScramDecoded
        let bootstrapBrokerStringSaslIamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringSaslIam)
        bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIamDecoded
        let bootstrapBrokerStringPublicTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicTls)
        bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTlsDecoded
        let bootstrapBrokerStringPublicSaslScramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicSaslScram)
        bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScramDecoded
        let bootstrapBrokerStringPublicSaslIamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapBrokerStringPublicSaslIam)
        bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIamDecoded
    }
}

extension GetCompatibleKafkaVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCompatibleKafkaVersionsInput(clusterArn: \(Swift.String(describing: clusterArn)))"}
}

extension GetCompatibleKafkaVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCompatibleKafkaVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCompatibleKafkaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCompatibleKafkaVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCompatibleKafkaVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCompatibleKafkaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCompatibleKafkaVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clusterArn = input.operationInput.clusterArn {
            let clusterArnQueryItem = ClientRuntime.URLQueryItem(name: "clusterArn".urlPercentEncoding(), value: Swift.String(clusterArn).urlPercentEncoding())
            input.builder.withQueryItem(clusterArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCompatibleKafkaVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCompatibleKafkaVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCompatibleKafkaVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCompatibleKafkaVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCompatibleKafkaVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCompatibleKafkaVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/compatible-kafka-versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCompatibleKafkaVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCompatibleKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCompatibleKafkaVersionsOutputError>
}

public struct GetCompatibleKafkaVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster check.
    public var clusterArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetCompatibleKafkaVersionsInputBody: Swift.Equatable {
}

extension GetCompatibleKafkaVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCompatibleKafkaVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCompatibleKafkaVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCompatibleKafkaVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCompatibleKafkaVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCompatibleKafkaVersionsOutputResponse(compatibleKafkaVersions: \(Swift.String(describing: compatibleKafkaVersions)))"}
}

extension GetCompatibleKafkaVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCompatibleKafkaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleKafkaVersions = output.compatibleKafkaVersions
        } else {
            self.compatibleKafkaVersions = nil
        }
    }
}

public struct GetCompatibleKafkaVersionsOutputResponse: Swift.Equatable {
    /// A list of CompatibleKafkaVersion objects.
    public var compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]?

    public init (
        compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]? = nil
    )
    {
        self.compatibleKafkaVersions = compatibleKafkaVersions
    }
}

struct GetCompatibleKafkaVersionsOutputResponseBody: Swift.Equatable {
    public let compatibleKafkaVersions: [KafkaClientTypes.CompatibleKafkaVersion]?
}

extension GetCompatibleKafkaVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleKafkaVersions = "compatibleKafkaVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleKafkaVersionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.CompatibleKafkaVersion?].self, forKey: .compatibleKafkaVersions)
        var compatibleKafkaVersionsDecoded0:[KafkaClientTypes.CompatibleKafkaVersion]? = nil
        if let compatibleKafkaVersionsContainer = compatibleKafkaVersionsContainer {
            compatibleKafkaVersionsDecoded0 = [KafkaClientTypes.CompatibleKafkaVersion]()
            for structure0 in compatibleKafkaVersionsContainer {
                if let structure0 = structure0 {
                    compatibleKafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        compatibleKafkaVersions = compatibleKafkaVersionsDecoded0
    }
}

extension KafkaClientTypes.Iam: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes.Iam: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Iam(enabled: \(Swift.String(describing: enabled)))"}
}

extension KafkaClientTypes {
    /// Details for IAM access control.
    public struct Iam: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.JmxExporter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes.JmxExporter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JmxExporter(enabledInBroker: \(Swift.String(describing: enabledInBroker)))"}
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporter: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init (
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.JmxExporterInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes.JmxExporterInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JmxExporterInfo(enabledInBroker: \(Swift.String(describing: enabledInBroker)))"}
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the JMX Exporter.
    public struct JmxExporterInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init (
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.KafkaVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.KafkaVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KafkaClientTypes.KafkaVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KafkaVersion(status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension KafkaClientTypes {
    public struct KafkaVersion: Swift.Equatable {
        public var status: KafkaClientTypes.KafkaVersionStatus?
        public var version: Swift.String?

        public init (
            status: KafkaClientTypes.KafkaVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.status = status
            self.version = version
        }
    }

}

extension KafkaClientTypes {
    public enum KafkaVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaVersionStatus] {
            return [
                .active,
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaVersionStatus(rawValue: rawValue) ?? KafkaVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListClusterOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClusterOperationsInput(clusterArn: \(Swift.String(describing: clusterArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClusterOperationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListClusterOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClusterOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClusterOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClusterOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClusterOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterOperationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListClusterOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClusterOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterOperationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListClusterOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/operations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClusterOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterOperationsOutputError>
}

public struct ListClusterOperationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsInputBody: Swift.Equatable {
}

extension ListClusterOperationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListClusterOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClusterOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClusterOperationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClusterOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClusterOperationsOutputResponse(clusterOperationInfoList: \(Swift.String(describing: clusterOperationInfoList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClusterOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClusterOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterOperationInfoList = output.clusterOperationInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterOperationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterOperationsOutputResponse: Swift.Equatable {
    /// An array of cluster operation information objects.
    public var clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]?
    /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
    public var nextToken: Swift.String?

    public init (
        clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterOperationInfoList = clusterOperationInfoList
        self.nextToken = nextToken
    }
}

struct ListClusterOperationsOutputResponseBody: Swift.Equatable {
    public let clusterOperationInfoList: [KafkaClientTypes.ClusterOperationInfo]?
    public let nextToken: Swift.String?
}

extension ListClusterOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterOperationInfoList = "clusterOperationInfoList"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterOperationInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterOperationInfo?].self, forKey: .clusterOperationInfoList)
        var clusterOperationInfoListDecoded0:[KafkaClientTypes.ClusterOperationInfo]? = nil
        if let clusterOperationInfoListContainer = clusterOperationInfoListContainer {
            clusterOperationInfoListDecoded0 = [KafkaClientTypes.ClusterOperationInfo]()
            for structure0 in clusterOperationInfoListContainer {
                if let structure0 = structure0 {
                    clusterOperationInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterOperationInfoList = clusterOperationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersInput(clusterNameFilter: \(Swift.String(describing: clusterNameFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let clusterNameFilter = input.operationInput.clusterNameFilter {
            let clusterNameFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
            input.builder.withQueryItem(clusterNameFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/clusters"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInput: Swift.Equatable {
    /// Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterNameFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
}

extension ListClustersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClustersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersOutputResponse(clusterInfoList: \(Swift.String(describing: clusterInfoList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfoList = output.clusterInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Swift.Equatable {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.ClusterInfo]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterInfoList: [KafkaClientTypes.ClusterInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Swift.Equatable {
    public let clusterInfoList: [KafkaClientTypes.ClusterInfo]?
    public let nextToken: Swift.String?
}

extension ListClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfoList = "clusterInfoList"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ClusterInfo?].self, forKey: .clusterInfoList)
        var clusterInfoListDecoded0:[KafkaClientTypes.ClusterInfo]? = nil
        if let clusterInfoListContainer = clusterInfoListContainer {
            clusterInfoListDecoded0 = [KafkaClientTypes.ClusterInfo]()
            for structure0 in clusterInfoListContainer {
                if let structure0 = structure0 {
                    clusterInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterInfoList = clusterInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersV2Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersV2Input(clusterNameFilter: \(Swift.String(describing: clusterNameFilter)), clusterTypeFilter: \(Swift.String(describing: clusterTypeFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersV2Input: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListClustersV2InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersV2InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersV2OutputError>
}

public struct ListClustersV2InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersV2InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersV2Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clusterTypeFilter = input.operationInput.clusterTypeFilter {
            let clusterTypeFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterTypeFilter".urlPercentEncoding(), value: Swift.String(clusterTypeFilter).urlPercentEncoding())
            input.builder.withQueryItem(clusterTypeFilterQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let clusterNameFilter = input.operationInput.clusterNameFilter {
            let clusterNameFilterQueryItem = ClientRuntime.URLQueryItem(name: "clusterNameFilter".urlPercentEncoding(), value: Swift.String(clusterNameFilter).urlPercentEncoding())
            input.builder.withQueryItem(clusterNameFilterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersV2Input>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersV2OutputError>
}

public struct ListClustersV2InputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersV2InputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListClustersV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClustersV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersV2OutputError>
}

public struct ListClustersV2InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersV2InputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListClustersV2Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersV2OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/api/v2/clusters"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClustersV2Input
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersV2OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersV2OutputError>
}

public struct ListClustersV2Input: Swift.Equatable {
    /// Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    public var clusterNameFilter: Swift.String?
    /// Specify either PROVISIONED or SERVERLESS.
    public var clusterTypeFilter: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterNameFilter: Swift.String? = nil,
        clusterTypeFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterNameFilter = clusterNameFilter
        self.clusterTypeFilter = clusterTypeFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersV2InputBody: Swift.Equatable {
}

extension ListClustersV2InputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListClustersV2OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersV2OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClustersV2OutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersV2OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersV2OutputResponse(clusterInfoList: \(Swift.String(describing: clusterInfoList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersV2OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClustersV2OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterInfoList = output.clusterInfoList
            self.nextToken = output.nextToken
        } else {
            self.clusterInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersV2OutputResponse: Swift.Equatable {
    /// Information on each of the MSK clusters in the response.
    public var clusterInfoList: [KafkaClientTypes.Cluster]?
    /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterInfoList: [KafkaClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterInfoList = clusterInfoList
        self.nextToken = nextToken
    }
}

struct ListClustersV2OutputResponseBody: Swift.Equatable {
    public let clusterInfoList: [KafkaClientTypes.Cluster]?
    public let nextToken: Swift.String?
}

extension ListClustersV2OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterInfoList = "clusterInfoList"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.Cluster?].self, forKey: .clusterInfoList)
        var clusterInfoListDecoded0:[KafkaClientTypes.Cluster]? = nil
        if let clusterInfoListContainer = clusterInfoListContainer {
            clusterInfoListDecoded0 = [KafkaClientTypes.Cluster]()
            for structure0 in clusterInfoListContainer {
                if let structure0 = structure0 {
                    clusterInfoListDecoded0?.append(structure0)
                }
            }
        }
        clusterInfoList = clusterInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationRevisionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationRevisionsInput(arn: \(Swift.String(describing: arn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationRevisionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationRevisionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(arn.urlPercentEncoding())/revisions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Swift.Equatable {
}

extension ListConfigurationRevisionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationRevisionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationRevisionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationRevisionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), revisions: \(Swift.String(describing: revisions)))"}
}

extension ListConfigurationRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutputResponse: Swift.Equatable {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// List of ConfigurationRevision objects.
    public var revisions: [KafkaClientTypes.ConfigurationRevision]?

    public init (
        nextToken: Swift.String? = nil,
        revisions: [KafkaClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let revisions: [KafkaClientTypes.ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[KafkaClientTypes.ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [KafkaClientTypes.ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
}

extension ListConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationsOutputResponse(configurations: \(Swift.String(describing: configurations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Swift.Equatable {
    /// An array of MSK configurations.
    public var configurations: [KafkaClientTypes.Configuration]?
    /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        configurations: [KafkaClientTypes.Configuration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Swift.Equatable {
    public let configurations: [KafkaClientTypes.Configuration]?
    public let nextToken: Swift.String?
}

extension ListConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "configurations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[KafkaClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [KafkaClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKafkaVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKafkaVersionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListKafkaVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListKafkaVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKafkaVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKafkaVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKafkaVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKafkaVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKafkaVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKafkaVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKafkaVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListKafkaVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListKafkaVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKafkaVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListKafkaVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/kafka-versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListKafkaVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListKafkaVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKafkaVersionsOutputError>
}

public struct ListKafkaVersionsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsInputBody: Swift.Equatable {
}

extension ListKafkaVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKafkaVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKafkaVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKafkaVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKafkaVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKafkaVersionsOutputResponse(kafkaVersions: \(Swift.String(describing: kafkaVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListKafkaVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListKafkaVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.kafkaVersions = output.kafkaVersions
            self.nextToken = output.nextToken
        } else {
            self.kafkaVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListKafkaVersionsOutputResponse: Swift.Equatable {
    public var kafkaVersions: [KafkaClientTypes.KafkaVersion]?
    public var nextToken: Swift.String?

    public init (
        kafkaVersions: [KafkaClientTypes.KafkaVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kafkaVersions = kafkaVersions
        self.nextToken = nextToken
    }
}

struct ListKafkaVersionsOutputResponseBody: Swift.Equatable {
    public let kafkaVersions: [KafkaClientTypes.KafkaVersion]?
    public let nextToken: Swift.String?
}

extension ListKafkaVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kafkaVersions = "kafkaVersions"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kafkaVersionsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.KafkaVersion?].self, forKey: .kafkaVersions)
        var kafkaVersionsDecoded0:[KafkaClientTypes.KafkaVersion]? = nil
        if let kafkaVersionsContainer = kafkaVersionsContainer {
            kafkaVersionsDecoded0 = [KafkaClientTypes.KafkaVersion]()
            for structure0 in kafkaVersionsContainer {
                if let structure0 = structure0 {
                    kafkaVersionsDecoded0?.append(structure0)
                }
            }
        }
        kafkaVersions = kafkaVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNodesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNodesInput(clusterArn: \(Swift.String(describing: clusterArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNodesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListNodesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNodesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNodesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNodesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNodesOutputError>
}

public struct ListNodesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNodesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNodesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNodesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNodesOutputError>
}

public struct ListNodesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNodesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListNodesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNodesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNodesOutputError>
}

public struct ListNodesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNodesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListNodesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNodesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNodesOutputError>
}

public struct ListNodesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    public var maxResults: Swift.Int?
    /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNodesInputBody: Swift.Equatable {
}

extension ListNodesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNodesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNodesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNodesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), nodeInfoList: \(Swift.String(describing: nodeInfoList)))"}
}

extension ListNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeInfoList = output.nodeInfoList
        } else {
            self.nextToken = nil
            self.nodeInfoList = nil
        }
    }
}

public struct ListNodesOutputResponse: Swift.Equatable {
    /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response. To get another batch of nodes, provide this token in your next request.
    public var nextToken: Swift.String?
    /// List containing a NodeInfo object.
    public var nodeInfoList: [KafkaClientTypes.NodeInfo]?

    public init (
        nextToken: Swift.String? = nil,
        nodeInfoList: [KafkaClientTypes.NodeInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInfoList = nodeInfoList
    }
}

struct ListNodesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let nodeInfoList: [KafkaClientTypes.NodeInfo]?
}

extension ListNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case nodeInfoList = "nodeInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let nodeInfoListContainer = try containerValues.decodeIfPresent([KafkaClientTypes.NodeInfo?].self, forKey: .nodeInfoList)
        var nodeInfoListDecoded0:[KafkaClientTypes.NodeInfo]? = nil
        if let nodeInfoListContainer = nodeInfoListContainer {
            nodeInfoListDecoded0 = [KafkaClientTypes.NodeInfo]()
            for structure0 in nodeInfoListContainer {
                if let structure0 = structure0 {
                    nodeInfoListDecoded0?.append(structure0)
                }
            }
        }
        nodeInfoList = nodeInfoListDecoded0
    }
}

extension ListScramSecretsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListScramSecretsInput(clusterArn: \(Swift.String(describing: clusterArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListScramSecretsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListScramSecretsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListScramSecretsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListScramSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListScramSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListScramSecretsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListScramSecretsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListScramSecretsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListScramSecretsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListScramSecretsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListScramSecretsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListScramSecretsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListScramSecretsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/scram-secrets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListScramSecretsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListScramSecretsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListScramSecretsOutputError>
}

public struct ListScramSecretsInput: Swift.Equatable {
    /// The arn of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The maxResults of the query.
    public var maxResults: Swift.Int?
    /// The nextToken of the query.
    public var nextToken: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScramSecretsInputBody: Swift.Equatable {
}

extension ListScramSecretsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListScramSecretsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScramSecretsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListScramSecretsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScramSecretsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListScramSecretsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), secretArnList: \(Swift.String(describing: secretArnList)))"}
}

extension ListScramSecretsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListScramSecretsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.secretArnList = output.secretArnList
        } else {
            self.nextToken = nil
            self.secretArnList = nil
        }
    }
}

public struct ListScramSecretsOutputResponse: Swift.Equatable {
    /// Paginated results marker.
    public var nextToken: Swift.String?
    /// The list of scram secrets associated with the cluster.
    public var secretArnList: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        secretArnList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.secretArnList = secretArnList
    }
}

struct ListScramSecretsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let secretArnList: [Swift.String]?
}

extension ListScramSecretsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case secretArnList = "secretArnList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let secretArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secretArnList)
        var secretArnListDecoded0:[Swift.String]? = nil
        if let secretArnListContainer = secretArnListContainer {
            secretArnListDecoded0 = [Swift.String]()
            for string0 in secretArnListContainer {
                if let string0 = string0 {
                    secretArnListDecoded0?.append(string0)
                }
            }
        }
        secretArnList = secretArnListDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension KafkaClientTypes.LoggingInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerLogs = "brokerLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerLogs = brokerLogs {
            try encodeContainer.encode(brokerLogs, forKey: .brokerLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerLogsDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerLogs.self, forKey: .brokerLogs)
        brokerLogs = brokerLogsDecoded
    }
}

extension KafkaClientTypes.LoggingInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingInfo(brokerLogs: \(Swift.String(describing: brokerLogs)))"}
}

extension KafkaClientTypes {
    public struct LoggingInfo: Swift.Equatable {
        /// This member is required.
        public var brokerLogs: KafkaClientTypes.BrokerLogs?

        public init (
            brokerLogs: KafkaClientTypes.BrokerLogs? = nil
        )
        {
            self.brokerLogs = brokerLogs
        }
    }

}

extension KafkaClientTypes.MutableClusterInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerEBSVolumeInfo = "brokerEBSVolumeInfo"
        case clientAuthentication = "clientAuthentication"
        case configurationInfo = "configurationInfo"
        case connectivityInfo = "connectivityInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case instanceType = "instanceType"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerEBSVolumeInfo = brokerEBSVolumeInfo {
            var brokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerEBSVolumeInfo)
            for __listofbrokerebsvolumeinfo0 in brokerEBSVolumeInfo {
                try brokerEBSVolumeInfoContainer.encode(__listofbrokerebsvolumeinfo0)
            }
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let connectivityInfo = connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([KafkaClientTypes.BrokerEBSVolumeInfo?].self, forKey: .brokerEBSVolumeInfo)
        var brokerEBSVolumeInfoDecoded0:[KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
        if let brokerEBSVolumeInfoContainer = brokerEBSVolumeInfoContainer {
            brokerEBSVolumeInfoDecoded0 = [KafkaClientTypes.BrokerEBSVolumeInfo]()
            for structure0 in brokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    brokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        brokerEBSVolumeInfo = brokerEBSVolumeInfoDecoded0
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoring.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
    }
}

extension KafkaClientTypes.MutableClusterInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MutableClusterInfo(brokerEBSVolumeInfo: \(Swift.String(describing: brokerEBSVolumeInfo)), clientAuthentication: \(Swift.String(describing: clientAuthentication)), configurationInfo: \(Swift.String(describing: configurationInfo)), connectivityInfo: \(Swift.String(describing: connectivityInfo)), encryptionInfo: \(Swift.String(describing: encryptionInfo)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), instanceType: \(Swift.String(describing: instanceType)), kafkaVersion: \(Swift.String(describing: kafkaVersion)), loggingInfo: \(Swift.String(describing: loggingInfo)), numberOfBrokerNodes: \(Swift.String(describing: numberOfBrokerNodes)), openMonitoring: \(Swift.String(describing: openMonitoring)))"}
}

extension KafkaClientTypes {
    /// Information about cluster attributes that can be updated via update APIs.
    public struct MutableClusterInfo: Swift.Equatable {
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public var brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the changes in the configuration of the brokers.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Information about the broker access configuration.
        public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Information about the Amazon MSK broker type.
        public var instanceType: Swift.String?
        /// The Apache Kafka version.
        public var kafkaVersion: Swift.String?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoring?

        public init (
            brokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            instanceType: Swift.String? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoring? = nil
        )
        {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.connectivityInfo = connectivityInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
        }
    }

}

extension KafkaClientTypes.NodeExporter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes.NodeExporter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeExporter(enabledInBroker: \(Swift.String(describing: enabledInBroker)))"}
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporter: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init (
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeExporterInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabledInBroker = "enabledInBroker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabledInBroker = enabledInBroker {
            try encodeContainer.encode(enabledInBroker, forKey: .enabledInBroker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledInBrokerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledInBroker)
        enabledInBroker = enabledInBrokerDecoded
    }
}

extension KafkaClientTypes.NodeExporterInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeExporterInfo(enabledInBroker: \(Swift.String(describing: enabledInBroker)))"}
}

extension KafkaClientTypes {
    /// Indicates whether you want to turn on or turn off the Node Exporter.
    public struct NodeExporterInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        /// This member is required.
        public var enabledInBroker: Swift.Bool?

        public init (
            enabledInBroker: Swift.Bool? = nil
        )
        {
            self.enabledInBroker = enabledInBroker
        }
    }

}

extension KafkaClientTypes.NodeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToClusterTime = "addedToClusterTime"
        case brokerNodeInfo = "brokerNodeInfo"
        case instanceType = "instanceType"
        case nodeARN = "nodeARN"
        case nodeType = "nodeType"
        case zookeeperNodeInfo = "zookeeperNodeInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToClusterTime = addedToClusterTime {
            try encodeContainer.encode(addedToClusterTime, forKey: .addedToClusterTime)
        }
        if let brokerNodeInfo = brokerNodeInfo {
            try encodeContainer.encode(brokerNodeInfo, forKey: .brokerNodeInfo)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let nodeARN = nodeARN {
            try encodeContainer.encode(nodeARN, forKey: .nodeARN)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType.rawValue, forKey: .nodeType)
        }
        if let zookeeperNodeInfo = zookeeperNodeInfo {
            try encodeContainer.encode(zookeeperNodeInfo, forKey: .zookeeperNodeInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToClusterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToClusterTime)
        addedToClusterTime = addedToClusterTimeDecoded
        let brokerNodeInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeInfo.self, forKey: .brokerNodeInfo)
        brokerNodeInfo = brokerNodeInfoDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let nodeARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeARN)
        nodeARN = nodeARNDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeType.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let zookeeperNodeInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ZookeeperNodeInfo.self, forKey: .zookeeperNodeInfo)
        zookeeperNodeInfo = zookeeperNodeInfoDecoded
    }
}

extension KafkaClientTypes.NodeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NodeInfo(addedToClusterTime: \(Swift.String(describing: addedToClusterTime)), brokerNodeInfo: \(Swift.String(describing: brokerNodeInfo)), instanceType: \(Swift.String(describing: instanceType)), nodeARN: \(Swift.String(describing: nodeARN)), nodeType: \(Swift.String(describing: nodeType)), zookeeperNodeInfo: \(Swift.String(describing: zookeeperNodeInfo)))"}
}

extension KafkaClientTypes {
    /// The node information object.
    public struct NodeInfo: Swift.Equatable {
        /// The start time.
        public var addedToClusterTime: Swift.String?
        /// The broker node info.
        public var brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo?
        /// The instance type.
        public var instanceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the node.
        public var nodeARN: Swift.String?
        /// The node type.
        public var nodeType: KafkaClientTypes.NodeType?
        /// The ZookeeperNodeInfo.
        public var zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo?

        public init (
            addedToClusterTime: Swift.String? = nil,
            brokerNodeInfo: KafkaClientTypes.BrokerNodeInfo? = nil,
            instanceType: Swift.String? = nil,
            nodeARN: Swift.String? = nil,
            nodeType: KafkaClientTypes.NodeType? = nil,
            zookeeperNodeInfo: KafkaClientTypes.ZookeeperNodeInfo? = nil
        )
        {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }
    }

}

extension KafkaClientTypes {
    /// The broker or Zookeeper node.
    public enum NodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case broker
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .broker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .broker: return "BROKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeType(rawValue: rawValue) ?? NodeType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.OpenMonitoring: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Prometheus.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension KafkaClientTypes.OpenMonitoring: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenMonitoring(prometheus: \(Swift.String(describing: prometheus)))"}
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoring: Swift.Equatable {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.Prometheus?

        public init (
            prometheus: KafkaClientTypes.Prometheus? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.OpenMonitoringInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prometheus = "prometheus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prometheus = prometheus {
            try encodeContainer.encode(prometheus, forKey: .prometheus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prometheusDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.PrometheusInfo.self, forKey: .prometheus)
        prometheus = prometheusDecoded
    }
}

extension KafkaClientTypes.OpenMonitoringInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenMonitoringInfo(prometheus: \(Swift.String(describing: prometheus)))"}
}

extension KafkaClientTypes {
    /// JMX and Node monitoring for the MSK cluster.
    public struct OpenMonitoringInfo: Swift.Equatable {
        /// Prometheus settings.
        /// This member is required.
        public var prometheus: KafkaClientTypes.PrometheusInfo?

        public init (
            prometheus: KafkaClientTypes.PrometheusInfo? = nil
        )
        {
            self.prometheus = prometheus
        }
    }

}

extension KafkaClientTypes.Prometheus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.JmxExporter.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeExporter.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension KafkaClientTypes.Prometheus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Prometheus(jmxExporter: \(Swift.String(describing: jmxExporter)), nodeExporter: \(Swift.String(describing: nodeExporter)))"}
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct Prometheus: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporter?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporter?

        public init (
            jmxExporter: KafkaClientTypes.JmxExporter? = nil,
            nodeExporter: KafkaClientTypes.NodeExporter? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.PrometheusInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jmxExporter = "jmxExporter"
        case nodeExporter = "nodeExporter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jmxExporter = jmxExporter {
            try encodeContainer.encode(jmxExporter, forKey: .jmxExporter)
        }
        if let nodeExporter = nodeExporter {
            try encodeContainer.encode(nodeExporter, forKey: .nodeExporter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jmxExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.JmxExporterInfo.self, forKey: .jmxExporter)
        jmxExporter = jmxExporterDecoded
        let nodeExporterDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.NodeExporterInfo.self, forKey: .nodeExporter)
        nodeExporter = nodeExporterDecoded
    }
}

extension KafkaClientTypes.PrometheusInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrometheusInfo(jmxExporter: \(Swift.String(describing: jmxExporter)), nodeExporter: \(Swift.String(describing: nodeExporter)))"}
}

extension KafkaClientTypes {
    /// Prometheus settings.
    public struct PrometheusInfo: Swift.Equatable {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public var jmxExporter: KafkaClientTypes.JmxExporterInfo?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public var nodeExporter: KafkaClientTypes.NodeExporterInfo?

        public init (
            jmxExporter: KafkaClientTypes.JmxExporterInfo? = nil,
            nodeExporter: KafkaClientTypes.NodeExporterInfo? = nil
        )
        {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }
    }

}

extension KafkaClientTypes.Provisioned: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
        case zookeeperConnectString = "zookeeperConnectString"
        case zookeeperConnectStringTls = "zookeeperConnectStringTls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let currentBrokerSoftwareInfo = currentBrokerSoftwareInfo {
            try encodeContainer.encode(currentBrokerSoftwareInfo, forKey: .currentBrokerSoftwareInfo)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
        if let zookeeperConnectString = zookeeperConnectString {
            try encodeContainer.encode(zookeeperConnectString, forKey: .zookeeperConnectString)
        }
        if let zookeeperConnectStringTls = zookeeperConnectStringTls {
            try encodeContainer.encode(zookeeperConnectStringTls, forKey: .zookeeperConnectStringTls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let currentBrokerSoftwareInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerSoftwareInfo.self, forKey: .currentBrokerSoftwareInfo)
        currentBrokerSoftwareInfo = currentBrokerSoftwareInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
        let zookeeperConnectStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectString)
        zookeeperConnectString = zookeeperConnectStringDecoded
        let zookeeperConnectStringTlsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperConnectStringTls)
        zookeeperConnectStringTls = zookeeperConnectStringTlsDecoded
    }
}

extension KafkaClientTypes.Provisioned: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Provisioned(brokerNodeGroupInfo: \(Swift.String(describing: brokerNodeGroupInfo)), clientAuthentication: \(Swift.String(describing: clientAuthentication)), currentBrokerSoftwareInfo: \(Swift.String(describing: currentBrokerSoftwareInfo)), encryptionInfo: \(Swift.String(describing: encryptionInfo)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), loggingInfo: \(Swift.String(describing: loggingInfo)), numberOfBrokerNodes: \(Swift.String(describing: numberOfBrokerNodes)), openMonitoring: \(Swift.String(describing: openMonitoring)), zookeeperConnectString: \(Swift.String(describing: zookeeperConnectString)), zookeeperConnectStringTls: \(Swift.String(describing: zookeeperConnectStringTls)))"}
}

extension KafkaClientTypes {
    /// Provisioned cluster.
    public struct Provisioned: Swift.Equatable {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Information about the Apache Kafka version deployed on the brokers.
        public var currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public var zookeeperConnectString: Swift.String?
        /// The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.
        public var zookeeperConnectStringTls: Swift.String?

        public init (
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            currentBrokerSoftwareInfo: KafkaClientTypes.BrokerSoftwareInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil,
            zookeeperConnectString: Swift.String? = nil,
            zookeeperConnectStringTls: Swift.String? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }
    }

}

extension KafkaClientTypes.ProvisionedRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerNodeGroupInfo = "brokerNodeGroupInfo"
        case clientAuthentication = "clientAuthentication"
        case configurationInfo = "configurationInfo"
        case encryptionInfo = "encryptionInfo"
        case enhancedMonitoring = "enhancedMonitoring"
        case kafkaVersion = "kafkaVersion"
        case loggingInfo = "loggingInfo"
        case numberOfBrokerNodes = "numberOfBrokerNodes"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerNodeGroupInfo = brokerNodeGroupInfo {
            try encodeContainer.encode(brokerNodeGroupInfo, forKey: .brokerNodeGroupInfo)
        }
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let kafkaVersion = kafkaVersion {
            try encodeContainer.encode(kafkaVersion, forKey: .kafkaVersion)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let numberOfBrokerNodes = numberOfBrokerNodes {
            try encodeContainer.encode(numberOfBrokerNodes, forKey: .numberOfBrokerNodes)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerNodeGroupInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.BrokerNodeGroupInfo.self, forKey: .brokerNodeGroupInfo)
        brokerNodeGroupInfo = brokerNodeGroupInfoDecoded
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let kafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kafkaVersion)
        kafkaVersion = kafkaVersionDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let numberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfBrokerNodes)
        numberOfBrokerNodes = numberOfBrokerNodesDecoded
    }
}

extension KafkaClientTypes.ProvisionedRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedRequest(brokerNodeGroupInfo: \(Swift.String(describing: brokerNodeGroupInfo)), clientAuthentication: \(Swift.String(describing: clientAuthentication)), configurationInfo: \(Swift.String(describing: configurationInfo)), encryptionInfo: \(Swift.String(describing: encryptionInfo)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), kafkaVersion: \(Swift.String(describing: kafkaVersion)), loggingInfo: \(Swift.String(describing: loggingInfo)), numberOfBrokerNodes: \(Swift.String(describing: numberOfBrokerNodes)), openMonitoring: \(Swift.String(describing: openMonitoring)))"}
}

extension KafkaClientTypes {
    /// Provisioned cluster request.
    public struct ProvisionedRequest: Swift.Equatable {
        /// Information about the brokers.
        /// This member is required.
        public var brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
        /// Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.
        public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
        /// Includes all encryption-related information.
        public var encryptionInfo: KafkaClientTypes.EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
        /// The Apache Kafka version that you want for the cluster.
        /// This member is required.
        public var kafkaVersion: Swift.String?
        /// Log delivery information for the cluster.
        public var loggingInfo: KafkaClientTypes.LoggingInfo?
        /// The number of broker nodes in the cluster.
        /// This member is required.
        public var numberOfBrokerNodes: Swift.Int?
        /// The settings for open monitoring.
        public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?

        public init (
            brokerNodeGroupInfo: KafkaClientTypes.BrokerNodeGroupInfo? = nil,
            clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
            configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
            encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil,
            enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
            kafkaVersion: Swift.String? = nil,
            loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
            numberOfBrokerNodes: Swift.Int? = nil,
            openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil
        )
        {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
        }
    }

}

extension KafkaClientTypes.PublicAccess: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension KafkaClientTypes.PublicAccess: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicAccess(type: \(Swift.String(describing: type)))"}
}

extension KafkaClientTypes {
    /// Public access control for brokers.
    public struct PublicAccess: Swift.Equatable {
        /// The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

public struct RebootBrokerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

extension RebootBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootBrokerInput(brokerIds: \(Swift.String(describing: brokerIds)), clusterArn: \(Swift.String(describing: clusterArn)))"}
}

extension RebootBrokerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerIds = "brokerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerIds = brokerIds {
            var brokerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .brokerIds)
            for __listof__string0 in brokerIds {
                try brokerIdsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct RebootBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RebootBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RebootBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/reboot-broker"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

/// Reboots a node.
public struct RebootBrokerInput: Swift.Equatable {
    /// The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
    /// This member is required.
    public var brokerIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init (
        brokerIds: [Swift.String]? = nil,
        clusterArn: Swift.String? = nil
    )
    {
        self.brokerIds = brokerIds
        self.clusterArn = clusterArn
    }
}

struct RebootBrokerInputBody: Swift.Equatable {
    public let brokerIds: [Swift.String]?
}

extension RebootBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerIds = "brokerIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .brokerIds)
        var brokerIdsDecoded0:[Swift.String]? = nil
        if let brokerIdsContainer = brokerIdsContainer {
            brokerIdsDecoded0 = [Swift.String]()
            for string0 in brokerIdsContainer {
                if let string0 = string0 {
                    brokerIdsDecoded0?.append(string0)
                }
            }
        }
        brokerIds = brokerIdsDecoded0
    }
}

extension RebootBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootBrokerOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension RebootBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct RebootBrokerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct RebootBrokerOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension RebootBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

extension KafkaClientTypes.S3: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "bucket"
        case enabled = "enabled"
        case prefix = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension KafkaClientTypes.S3: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3(bucket: \(Swift.String(describing: bucket)), enabled: \(Swift.String(describing: enabled)), prefix: \(Swift.String(describing: prefix)))"}
}

extension KafkaClientTypes {
    public struct S3: Swift.Equatable {
        public var bucket: Swift.String?
        /// This member is required.
        public var enabled: Swift.Bool?
        public var prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }
    }

}

extension KafkaClientTypes.Sasl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "iam"
        case scram = "scram"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
        if let scram = scram {
            try encodeContainer.encode(scram, forKey: .scram)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scramDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Scram.self, forKey: .scram)
        scram = scramDecoded
        let iamDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Iam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension KafkaClientTypes.Sasl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Sasl(iam: \(Swift.String(describing: iam)), scram: \(Swift.String(describing: scram)))"}
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct Sasl: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?
        /// Details for SASL/SCRAM client authentication.
        public var scram: KafkaClientTypes.Scram?

        public init (
            iam: KafkaClientTypes.Iam? = nil,
            scram: KafkaClientTypes.Scram? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension KafkaClientTypes.Scram: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes.Scram: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Scram(enabled: \(Swift.String(describing: enabled)))"}
}

extension KafkaClientTypes {
    /// Details for SASL/SCRAM client authentication.
    public struct Scram: Swift.Equatable {
        /// SASL/SCRAM authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension KafkaClientTypes.Serverless: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case vpcConfigs = "vpcConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let vpcConfigs = vpcConfigs {
            var vpcConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigs)
            for __listofvpcconfig0 in vpcConfigs {
                try vpcConfigsContainer.encode(__listofvpcconfig0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.VpcConfig?].self, forKey: .vpcConfigs)
        var vpcConfigsDecoded0:[KafkaClientTypes.VpcConfig]? = nil
        if let vpcConfigsContainer = vpcConfigsContainer {
            vpcConfigsDecoded0 = [KafkaClientTypes.VpcConfig]()
            for structure0 in vpcConfigsContainer {
                if let structure0 = structure0 {
                    vpcConfigsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigs = vpcConfigsDecoded0
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
    }
}

extension KafkaClientTypes.Serverless: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Serverless(clientAuthentication: \(Swift.String(describing: clientAuthentication)), vpcConfigs: \(Swift.String(describing: vpcConfigs)))"}
}

extension KafkaClientTypes {
    /// Serverless cluster.
    public struct Serverless: Swift.Equatable {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init (
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessClientAuthentication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sasl = "sasl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sasl = sasl {
            try encodeContainer.encode(sasl, forKey: .sasl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let saslDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessSasl.self, forKey: .sasl)
        sasl = saslDecoded
    }
}

extension KafkaClientTypes.ServerlessClientAuthentication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerlessClientAuthentication(sasl: \(Swift.String(describing: sasl)))"}
}

extension KafkaClientTypes {
    /// Includes all client authentication information.
    public struct ServerlessClientAuthentication: Swift.Equatable {
        /// Details for ClientAuthentication using SASL.
        public var sasl: KafkaClientTypes.ServerlessSasl?

        public init (
            sasl: KafkaClientTypes.ServerlessSasl? = nil
        )
        {
            self.sasl = sasl
        }
    }

}

extension KafkaClientTypes.ServerlessRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case vpcConfigs = "vpcConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let vpcConfigs = vpcConfigs {
            var vpcConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcConfigs)
            for __listofvpcconfig0 in vpcConfigs {
                try vpcConfigsContainer.encode(__listofvpcconfig0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigsContainer = try containerValues.decodeIfPresent([KafkaClientTypes.VpcConfig?].self, forKey: .vpcConfigs)
        var vpcConfigsDecoded0:[KafkaClientTypes.VpcConfig]? = nil
        if let vpcConfigsContainer = vpcConfigsContainer {
            vpcConfigsDecoded0 = [KafkaClientTypes.VpcConfig]()
            for structure0 in vpcConfigsContainer {
                if let structure0 = structure0 {
                    vpcConfigsDecoded0?.append(structure0)
                }
            }
        }
        vpcConfigs = vpcConfigsDecoded0
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ServerlessClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
    }
}

extension KafkaClientTypes.ServerlessRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerlessRequest(clientAuthentication: \(Swift.String(describing: clientAuthentication)), vpcConfigs: \(Swift.String(describing: vpcConfigs)))"}
}

extension KafkaClientTypes {
    /// Serverless cluster request.
    public struct ServerlessRequest: Swift.Equatable {
        /// Includes all client authentication information.
        public var clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        /// This member is required.
        public var vpcConfigs: [KafkaClientTypes.VpcConfig]?

        public init (
            clientAuthentication: KafkaClientTypes.ServerlessClientAuthentication? = nil,
            vpcConfigs: [KafkaClientTypes.VpcConfig]? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }
    }

}

extension KafkaClientTypes.ServerlessSasl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "iam"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iam = iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.Iam.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension KafkaClientTypes.ServerlessSasl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerlessSasl(iam: \(Swift.String(describing: iam)))"}
}

extension KafkaClientTypes {
    /// Details for client authentication using SASL.
    public struct ServerlessSasl: Swift.Equatable {
        /// Indicates whether IAM access control is enabled.
        public var iam: KafkaClientTypes.Iam?

        public init (
            iam: KafkaClientTypes.Iam? = nil
        )
        {
            self.iam = iam
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.StateInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.StateInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateInfo(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension KafkaClientTypes {
    public struct StateInfo: Swift.Equatable {
        public var code: Swift.String?
        public var message: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension KafkaClientTypes.StorageInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsStorageInfo = "ebsStorageInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsStorageInfo = ebsStorageInfo {
            try encodeContainer.encode(ebsStorageInfo, forKey: .ebsStorageInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsStorageInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EBSStorageInfo.self, forKey: .ebsStorageInfo)
        ebsStorageInfo = ebsStorageInfoDecoded
    }
}

extension KafkaClientTypes.StorageInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageInfo(ebsStorageInfo: \(Swift.String(describing: ebsStorageInfo)))"}
}

extension KafkaClientTypes {
    /// Contains information about storage volumes attached to MSK broker nodes.
    public struct StorageInfo: Swift.Equatable {
        /// EBS volume information.
        public var ebsStorageInfo: KafkaClientTypes.EBSStorageInfo?

        public init (
            ebsStorageInfo: KafkaClientTypes.EBSStorageInfo? = nil
        )
        {
            self.ebsStorageInfo = ebsStorageInfo
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension KafkaClientTypes.Tls: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArnList = "certificateAuthorityArnList"
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArnList = certificateAuthorityArnList {
            var certificateAuthorityArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArnList)
            for __listof__string0 in certificateAuthorityArnList {
                try certificateAuthorityArnListContainer.encode(__listof__string0)
            }
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificateAuthorityArnList)
        var certificateAuthorityArnListDecoded0:[Swift.String]? = nil
        if let certificateAuthorityArnListContainer = certificateAuthorityArnListContainer {
            certificateAuthorityArnListDecoded0 = [Swift.String]()
            for string0 in certificateAuthorityArnListContainer {
                if let string0 = string0 {
                    certificateAuthorityArnListDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArnList = certificateAuthorityArnListDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes.Tls: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tls(certificateAuthorityArnList: \(Swift.String(describing: certificateAuthorityArnList)), enabled: \(Swift.String(describing: enabled)))"}
}

extension KafkaClientTypes {
    /// Details for client authentication using TLS.
    public struct Tls: Swift.Equatable {
        /// List of ACM Certificate Authority ARNs.
        public var certificateAuthorityArnList: [Swift.String]?
        /// Specifies whether you want to turn on or turn off TLS authentication.
        public var enabled: Swift.Bool?

        public init (
            certificateAuthorityArnList: [Swift.String]? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }
    }

}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.Unauthenticated: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension KafkaClientTypes.Unauthenticated: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Unauthenticated(enabled: \(Swift.String(describing: enabled)))"}
}

extension KafkaClientTypes {
    public struct Unauthenticated: Swift.Equatable {
        /// Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(invalidParameter: \(Swift.String(describing: invalidParameter)), message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidParameter = output.invalidParameter
            self.message = output.message
        } else {
            self.invalidParameter = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The parameter that caused the error.
    public var invalidParameter: Swift.String?
    /// The description of the error.
    public var message: Swift.String?

    public init (
        invalidParameter: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidParameter = invalidParameter
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let invalidParameter: Swift.String?
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidParameter = "invalidParameter"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidParameter)
        invalidParameter = invalidParameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KafkaClientTypes.UnprocessedScramSecret: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
        case secretArn = "secretArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension KafkaClientTypes.UnprocessedScramSecret: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnprocessedScramSecret(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), secretArn: \(Swift.String(describing: secretArn)))"}
}

extension KafkaClientTypes {
    /// Error info for scram secret associate/disassociate failure.
    public struct UnprocessedScramSecret: Swift.Equatable {
        /// Error code for associate/disassociate failure.
        public var errorCode: Swift.String?
        /// Error message for associate/disassociate failure.
        public var errorMessage: Swift.String?
        /// AWS Secrets Manager secret ARN.
        public var secretArn: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys must be unique for a given cluster. In addition, the following restrictions apply:
    ///
    /// * Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.
    ///
    /// * You can't start a tag key with aws: because this prefix is reserved for use by AWS. AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.
    ///
    /// * Tag keys must be between 1 and 128 Unicode characters in length.
    ///
    /// * Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateBrokerCountInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerCountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerCountOutputError>
}

extension UpdateBrokerCountInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerCountInput(clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)), targetNumberOfBrokerNodes: \(Swift.String(describing: targetNumberOfBrokerNodes)))"}
}

extension UpdateBrokerCountInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetNumberOfBrokerNodes = targetNumberOfBrokerNodes {
            try encodeContainer.encode(targetNumberOfBrokerNodes, forKey: .targetNumberOfBrokerNodes)
        }
    }
}

public struct UpdateBrokerCountInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerCountInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerCountInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerCountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerCountInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerCountInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerCountInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/count"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerCountInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerCountOutputError>
}

public struct UpdateBrokerCountInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
    /// This member is required.
    public var targetNumberOfBrokerNodes: Swift.Int?

    public init (
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetNumberOfBrokerNodes: Swift.Int? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
    }
}

struct UpdateBrokerCountInputBody: Swift.Equatable {
    public let currentVersion: Swift.String?
    public let targetNumberOfBrokerNodes: Swift.Int?
}

extension UpdateBrokerCountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetNumberOfBrokerNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetNumberOfBrokerNodes)
        targetNumberOfBrokerNodes = targetNumberOfBrokerNodesDecoded
    }
}

extension UpdateBrokerCountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerCountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerCountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerCountOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerCountOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerCountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrokerCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerCountOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerCountOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateBrokerCountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateBrokerStorageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerStorageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerStorageOutputError>
}

extension UpdateBrokerStorageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerStorageInput(clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)), targetBrokerEBSVolumeInfo: \(Swift.String(describing: targetBrokerEBSVolumeInfo)))"}
}

extension UpdateBrokerStorageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo {
            var targetBrokerEBSVolumeInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetBrokerEBSVolumeInfo)
            for __listofbrokerebsvolumeinfo0 in targetBrokerEBSVolumeInfo {
                try targetBrokerEBSVolumeInfoContainer.encode(__listofbrokerebsvolumeinfo0)
            }
        }
    }
}

public struct UpdateBrokerStorageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerStorageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerStorageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerStorageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerStorageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerStorageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerStorageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerStorageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerStorageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/storage"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerStorageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerStorageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerStorageOutputError>
}

public struct UpdateBrokerStorageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of cluster to update from. A successful operation will then generate a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Describes the target volume size and the ID of the broker to apply the update to.
    /// This member is required.
    public var targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?

    public init (
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
    }
}

struct UpdateBrokerStorageInputBody: Swift.Equatable {
    public let currentVersion: Swift.String?
    public let targetBrokerEBSVolumeInfo: [KafkaClientTypes.BrokerEBSVolumeInfo]?
}

extension UpdateBrokerStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetBrokerEBSVolumeInfoContainer = try containerValues.decodeIfPresent([KafkaClientTypes.BrokerEBSVolumeInfo?].self, forKey: .targetBrokerEBSVolumeInfo)
        var targetBrokerEBSVolumeInfoDecoded0:[KafkaClientTypes.BrokerEBSVolumeInfo]? = nil
        if let targetBrokerEBSVolumeInfoContainer = targetBrokerEBSVolumeInfoContainer {
            targetBrokerEBSVolumeInfoDecoded0 = [KafkaClientTypes.BrokerEBSVolumeInfo]()
            for structure0 in targetBrokerEBSVolumeInfoContainer {
                if let structure0 = structure0 {
                    targetBrokerEBSVolumeInfoDecoded0?.append(structure0)
                }
            }
        }
        targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfoDecoded0
    }
}

extension UpdateBrokerStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerStorageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerStorageOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrokerStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerStorageOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerStorageOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateBrokerStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateBrokerTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerTypeOutputError>
}

extension UpdateBrokerTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerTypeInput(clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)), targetInstanceType: \(Swift.String(describing: targetInstanceType)))"}
}

extension UpdateBrokerTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetInstanceType = targetInstanceType {
            try encodeContainer.encode(targetInstanceType, forKey: .targetInstanceType)
        }
    }
}

public struct UpdateBrokerTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerTypeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerTypeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerTypeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/nodes/type"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerTypeInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerTypeOutputError>
}

public struct UpdateBrokerTypeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
    /// This member is required.
    public var targetInstanceType: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        targetInstanceType: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.targetInstanceType = targetInstanceType
    }
}

struct UpdateBrokerTypeInputBody: Swift.Equatable {
    public let currentVersion: Swift.String?
    public let targetInstanceType: Swift.String?
}

extension UpdateBrokerTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case targetInstanceType = "targetInstanceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceType)
        targetInstanceType = targetInstanceTypeDecoded
    }
}

extension UpdateBrokerTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerTypeOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateBrokerTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrokerTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateBrokerTypeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateBrokerTypeOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateBrokerTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateClusterConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterConfigurationOutputError>
}

extension UpdateClusterConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterConfigurationInput(clusterArn: \(Swift.String(describing: clusterArn)), configurationInfo: \(Swift.String(describing: configurationInfo)), currentVersion: \(Swift.String(describing: currentVersion)))"}
}

extension UpdateClusterConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

public struct UpdateClusterConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterConfigurationOutputError>
}

public struct UpdateClusterConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Represents the configuration that you want MSK to use for the brokers in a cluster.
    /// This member is required.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// The version of the cluster that needs to be updated.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
    }
}

struct UpdateClusterConfigurationInputBody: Swift.Equatable {
    public let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    public let currentVersion: Swift.String?
}

extension UpdateClusterConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension UpdateClusterConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterConfigurationOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateClusterConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateClusterConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterConfigurationOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateClusterConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateClusterKafkaVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterKafkaVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterKafkaVersionOutputError>
}

extension UpdateClusterKafkaVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterKafkaVersionInput(clusterArn: \(Swift.String(describing: clusterArn)), configurationInfo: \(Swift.String(describing: configurationInfo)), currentVersion: \(Swift.String(describing: currentVersion)), targetKafkaVersion: \(Swift.String(describing: targetKafkaVersion)))"}
}

extension UpdateClusterKafkaVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationInfo = configurationInfo {
            try encodeContainer.encode(configurationInfo, forKey: .configurationInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let targetKafkaVersion = targetKafkaVersion {
            try encodeContainer.encode(targetKafkaVersion, forKey: .targetKafkaVersion)
        }
    }
}

public struct UpdateClusterKafkaVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterKafkaVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterKafkaVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterKafkaVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterKafkaVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterKafkaVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterKafkaVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterKafkaVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateClusterKafkaVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/version"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateClusterKafkaVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterKafkaVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterKafkaVersionOutputError>
}

public struct UpdateClusterKafkaVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster to be updated.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The custom configuration that should be applied on the new version of cluster.
    public var configurationInfo: KafkaClientTypes.ConfigurationInfo?
    /// Current cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Target Kafka version.
    /// This member is required.
    public var targetKafkaVersion: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        configurationInfo: KafkaClientTypes.ConfigurationInfo? = nil,
        currentVersion: Swift.String? = nil,
        targetKafkaVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.configurationInfo = configurationInfo
        self.currentVersion = currentVersion
        self.targetKafkaVersion = targetKafkaVersion
    }
}

struct UpdateClusterKafkaVersionInputBody: Swift.Equatable {
    public let configurationInfo: KafkaClientTypes.ConfigurationInfo?
    public let currentVersion: Swift.String?
    public let targetKafkaVersion: Swift.String?
}

extension UpdateClusterKafkaVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationInfo = "configurationInfo"
        case currentVersion = "currentVersion"
        case targetKafkaVersion = "targetKafkaVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationInfo.self, forKey: .configurationInfo)
        configurationInfo = configurationInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let targetKafkaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKafkaVersion)
        targetKafkaVersion = targetKafkaVersionDecoded
    }
}

extension UpdateClusterKafkaVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterKafkaVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterKafkaVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterKafkaVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterKafkaVersionOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateClusterKafkaVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateClusterKafkaVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateClusterKafkaVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateClusterKafkaVersionOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateClusterKafkaVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

extension UpdateConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationInput(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), serverProperties: \(Swift.String(describing: serverProperties)))"}
}

extension UpdateConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverProperties = serverProperties {
            try encodeContainer.encode(serverProperties.base64EncodedString(), forKey: .serverProperties)
        }
    }
}

public struct UpdateConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(arn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the configuration revision.
    public var description: Swift.String?
    /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded. When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    /// This member is required.
    public var serverProperties: ClientRuntime.Data?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        serverProperties: ClientRuntime.Data? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.serverProperties = serverProperties
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let serverProperties: ClientRuntime.Data?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case serverProperties = "serverProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverPropertiesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .serverProperties)
        serverProperties = serverPropertiesDecoded
    }
}

extension UpdateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), latestRevision: \(Swift.String(describing: latestRevision)))"}
}

extension UpdateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.latestRevision = output.latestRevision
        } else {
            self.arn = nil
            self.latestRevision = nil
        }
    }
}

public struct UpdateConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Latest revision of the configuration.
    public var latestRevision: KafkaClientTypes.ConfigurationRevision?

    public init (
        arn: Swift.String? = nil,
        latestRevision: KafkaClientTypes.ConfigurationRevision? = nil
    )
    {
        self.arn = arn
        self.latestRevision = latestRevision
    }
}

struct UpdateConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let latestRevision: KafkaClientTypes.ConfigurationRevision?
}

extension UpdateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case latestRevision = "latestRevision"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
    }
}

public struct UpdateConnectivityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectivityOutputError>
}

extension UpdateConnectivityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectivityInput(clusterArn: \(Swift.String(describing: clusterArn)), connectivityInfo: \(Swift.String(describing: connectivityInfo)), currentVersion: \(Swift.String(describing: currentVersion)))"}
}

extension UpdateConnectivityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "connectivityInfo"
        case currentVersion = "currentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = connectivityInfo {
            try encodeContainer.encode(connectivityInfo, forKey: .connectivityInfo)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

public struct UpdateConnectivityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectivityOutputError>
}

public struct UpdateConnectivityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConnectivityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConnectivityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectivityOutputError>
}

public struct UpdateConnectivityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectivityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectivityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectivityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectivityOutputError>
}

public struct UpdateConnectivityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConnectivityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConnectivityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/connectivity"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConnectivityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConnectivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConnectivityOutputError>
}

/// Request body for UpdateConnectivity.
public struct UpdateConnectivityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// Information about the broker access configuration.
    /// This member is required.
    public var connectivityInfo: KafkaClientTypes.ConnectivityInfo?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        connectivityInfo: KafkaClientTypes.ConnectivityInfo? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.connectivityInfo = connectivityInfo
        self.currentVersion = currentVersion
    }
}

struct UpdateConnectivityInputBody: Swift.Equatable {
    public let connectivityInfo: KafkaClientTypes.ConnectivityInfo?
    public let currentVersion: Swift.String?
}

extension UpdateConnectivityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "connectivityInfo"
        case currentVersion = "currentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ConnectivityInfo.self, forKey: .connectivityInfo)
        connectivityInfo = connectivityInfoDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension UpdateConnectivityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectivityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectivityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectivityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConnectivityOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateConnectivityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConnectivityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateConnectivityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateConnectivityOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateConnectivityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateMonitoringInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMonitoringInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMonitoringOutputError>
}

extension UpdateMonitoringInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMonitoringInput(clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)), enhancedMonitoring: \(Swift.String(describing: enhancedMonitoring)), loggingInfo: \(Swift.String(describing: loggingInfo)), openMonitoring: \(Swift.String(describing: openMonitoring)))"}
}

extension UpdateMonitoringInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let enhancedMonitoring = enhancedMonitoring {
            try encodeContainer.encode(enhancedMonitoring.rawValue, forKey: .enhancedMonitoring)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let openMonitoring = openMonitoring {
            try encodeContainer.encode(openMonitoring, forKey: .openMonitoring)
        }
    }
}

public struct UpdateMonitoringInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMonitoringInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMonitoringOutputError>
}

public struct UpdateMonitoringInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMonitoringInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMonitoringInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMonitoringInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMonitoringOutputError>
}

public struct UpdateMonitoringInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMonitoringInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMonitoringInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMonitoringInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMonitoringOutputError>
}

public struct UpdateMonitoringInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMonitoringInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMonitoringInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/monitoring"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMonitoringInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMonitoringOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMonitoringOutputError>
}

/// Request body for UpdateMonitoring.
public struct UpdateMonitoringInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
    public var enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    public var loggingInfo: KafkaClientTypes.LoggingInfo?
    /// The settings for open monitoring.
    public var openMonitoring: KafkaClientTypes.OpenMonitoringInfo?

    public init (
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring? = nil,
        loggingInfo: KafkaClientTypes.LoggingInfo? = nil,
        openMonitoring: KafkaClientTypes.OpenMonitoringInfo? = nil
    )
    {
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.enhancedMonitoring = enhancedMonitoring
        self.loggingInfo = loggingInfo
        self.openMonitoring = openMonitoring
    }
}

struct UpdateMonitoringInputBody: Swift.Equatable {
    public let currentVersion: Swift.String?
    public let enhancedMonitoring: KafkaClientTypes.EnhancedMonitoring?
    public let openMonitoring: KafkaClientTypes.OpenMonitoringInfo?
    public let loggingInfo: KafkaClientTypes.LoggingInfo?
}

extension UpdateMonitoringInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "currentVersion"
        case enhancedMonitoring = "enhancedMonitoring"
        case loggingInfo = "loggingInfo"
        case openMonitoring = "openMonitoring"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let enhancedMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EnhancedMonitoring.self, forKey: .enhancedMonitoring)
        enhancedMonitoring = enhancedMonitoringDecoded
        let openMonitoringDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.OpenMonitoringInfo.self, forKey: .openMonitoring)
        openMonitoring = openMonitoringDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
    }
}

extension UpdateMonitoringOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMonitoringOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMonitoringOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMonitoringOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMonitoringOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateMonitoringOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMonitoringOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateMonitoringOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateMonitoringOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateMonitoringOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

public struct UpdateSecurityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecurityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecurityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecurityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecurityOutputError>
}

extension UpdateSecurityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecurityInput(clientAuthentication: \(Swift.String(describing: clientAuthentication)), clusterArn: \(Swift.String(describing: clusterArn)), currentVersion: \(Swift.String(describing: currentVersion)), encryptionInfo: \(Swift.String(describing: encryptionInfo)))"}
}

extension UpdateSecurityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAuthentication = clientAuthentication {
            try encodeContainer.encode(clientAuthentication, forKey: .clientAuthentication)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let encryptionInfo = encryptionInfo {
            try encodeContainer.encode(encryptionInfo, forKey: .encryptionInfo)
        }
    }
}

public struct UpdateSecurityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecurityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecurityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecurityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecurityOutputError>
}

public struct UpdateSecurityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecurityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateSecurityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateSecurityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecurityOutputError>
}

public struct UpdateSecurityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecurityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateSecurityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSecurityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecurityOutputError>
}

public struct UpdateSecurityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateSecurityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateSecurityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let clusterArn = input.clusterArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("clusterArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/clusters/\(clusterArn.urlPercentEncoding())/security"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateSecurityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateSecurityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateSecurityOutputError>
}

public struct UpdateSecurityInput: Swift.Equatable {
    /// Includes all client authentication related information.
    public var clientAuthentication: KafkaClientTypes.ClientAuthentication?
    /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// Includes all encryption-related information.
    public var encryptionInfo: KafkaClientTypes.EncryptionInfo?

    public init (
        clientAuthentication: KafkaClientTypes.ClientAuthentication? = nil,
        clusterArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        encryptionInfo: KafkaClientTypes.EncryptionInfo? = nil
    )
    {
        self.clientAuthentication = clientAuthentication
        self.clusterArn = clusterArn
        self.currentVersion = currentVersion
        self.encryptionInfo = encryptionInfo
    }
}

struct UpdateSecurityInputBody: Swift.Equatable {
    public let clientAuthentication: KafkaClientTypes.ClientAuthentication?
    public let currentVersion: Swift.String?
    public let encryptionInfo: KafkaClientTypes.EncryptionInfo?
}

extension UpdateSecurityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientAuthentication = "clientAuthentication"
        case currentVersion = "currentVersion"
        case encryptionInfo = "encryptionInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientAuthenticationDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.ClientAuthentication.self, forKey: .clientAuthentication)
        clientAuthentication = clientAuthenticationDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let encryptionInfoDecoded = try containerValues.decodeIfPresent(KafkaClientTypes.EncryptionInfo.self, forKey: .encryptionInfo)
        encryptionInfo = encryptionInfoDecoded
    }
}

extension UpdateSecurityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSecurityOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSecurityOutputResponse(clusterArn: \(Swift.String(describing: clusterArn)), clusterOperationArn: \(Swift.String(describing: clusterOperationArn)))"}
}

extension UpdateSecurityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSecurityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterArn = output.clusterArn
            self.clusterOperationArn = output.clusterOperationArn
        } else {
            self.clusterArn = nil
            self.clusterOperationArn = nil
        }
    }
}

public struct UpdateSecurityOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the cluster.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster operation.
    public var clusterOperationArn: Swift.String?

    public init (
        clusterArn: Swift.String? = nil,
        clusterOperationArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.clusterOperationArn = clusterOperationArn
    }
}

struct UpdateSecurityOutputResponseBody: Swift.Equatable {
    public let clusterArn: Swift.String?
    public let clusterOperationArn: Swift.String?
}

extension UpdateSecurityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "clusterArn"
        case clusterOperationArn = "clusterOperationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterOperationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterOperationArn)
        clusterOperationArn = clusterOperationArnDecoded
    }
}

extension KafkaClientTypes.VpcConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __listof__string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__listof__string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __listof__string0 in subnetIds {
                try subnetIdsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension KafkaClientTypes.VpcConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcConfig(securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension KafkaClientTypes {
    /// The configuration of the Amazon VPCs for the cluster.
    public struct VpcConfig: Swift.Equatable {
        /// The IDs of the security groups associated with the cluster.
        public var securityGroupIds: [Swift.String]?
        /// The IDs of the subnets associated with the cluster.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension KafkaClientTypes.ZookeeperNodeInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedENIId = "attachedENIId"
        case clientVpcIpAddress = "clientVpcIpAddress"
        case endpoints = "endpoints"
        case zookeeperId = "zookeeperId"
        case zookeeperVersion = "zookeeperVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedENIId = attachedENIId {
            try encodeContainer.encode(attachedENIId, forKey: .attachedENIId)
        }
        if let clientVpcIpAddress = clientVpcIpAddress {
            try encodeContainer.encode(clientVpcIpAddress, forKey: .clientVpcIpAddress)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
        if let zookeeperId = zookeeperId {
            try encodeContainer.encode(zookeeperId, forKey: .zookeeperId)
        }
        if let zookeeperVersion = zookeeperVersion {
            try encodeContainer.encode(zookeeperVersion, forKey: .zookeeperVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedENIIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedENIId)
        attachedENIId = attachedENIIdDecoded
        let clientVpcIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientVpcIpAddress)
        clientVpcIpAddress = clientVpcIpAddressDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let zookeeperIdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .zookeeperId)
        zookeeperId = zookeeperIdDecoded
        let zookeeperVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zookeeperVersion)
        zookeeperVersion = zookeeperVersionDecoded
    }
}

extension KafkaClientTypes.ZookeeperNodeInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZookeeperNodeInfo(attachedENIId: \(Swift.String(describing: attachedENIId)), clientVpcIpAddress: \(Swift.String(describing: clientVpcIpAddress)), endpoints: \(Swift.String(describing: endpoints)), zookeeperId: \(Swift.String(describing: zookeeperId)), zookeeperVersion: \(Swift.String(describing: zookeeperVersion)))"}
}

extension KafkaClientTypes {
    /// Zookeeper node information.
    public struct ZookeeperNodeInfo: Swift.Equatable {
        /// The attached elastic network interface of the broker.
        public var attachedENIId: Swift.String?
        /// The virtual private cloud (VPC) IP address of the client.
        public var clientVpcIpAddress: Swift.String?
        /// Endpoints for accessing the ZooKeeper.
        public var endpoints: [Swift.String]?
        /// The role-specific ID for Zookeeper.
        public var zookeeperId: Swift.Double?
        /// The version of Zookeeper.
        public var zookeeperVersion: Swift.String?

        public init (
            attachedENIId: Swift.String? = nil,
            clientVpcIpAddress: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            zookeeperId: Swift.Double? = nil,
            zookeeperVersion: Swift.String? = nil
        )
        {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }
    }

}
