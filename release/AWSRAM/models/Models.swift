// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptResourceShareInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

extension AcceptResourceShareInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptResourceShareInvitationInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension AcceptResourceShareInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct AcceptResourceShareInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AcceptResourceShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptResourceShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AcceptResourceShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/acceptresourceshareinvitation"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptResourceShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the invitation.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct AcceptResourceShareInvitationInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcceptResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyAccepted" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptResourceShareInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptResourceShareInvitationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitation: \(Swift.String(describing: resourceShareInvitation)))"}
}

extension AcceptResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct AcceptResourceShareInvitationOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the invitation.
    public var resourceShareInvitation: RamClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RamClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct AcceptResourceShareInvitationOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?
    public let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

extension AssociateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension AssociateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/associateresourceshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The principals to associate with the resource share. The possible values are:
    ///
    /// * An Amazon Web Services account ID
    ///
    /// * An Amazon Resource Name (ARN) of an organization in Organizations
    ///
    /// * An ARN of an organizational unit (OU) in Organizations
    ///
    /// * An ARN of an IAM role
    ///
    /// * An ARN of an IAM user
    ///
    ///
    /// Not all resource types can be shared with IAM roles and IAM users. For more information, see [Sharing with IAM roles and IAM users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// The Amazon Resource Names (ARNs) of the resources.
    public var resourceArns: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let clientToken: Swift.String?
}

extension AssociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension AssociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct AssociateResourceShareOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the associations.
    public var resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct AssociateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let clientToken: Swift.String?
}

extension AssociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceSharePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

extension AssociateResourceSharePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceSharePermissionInput(clientToken: \(Swift.String(describing: clientToken)), permissionArn: \(Swift.String(describing: permissionArn)), permissionVersion: \(Swift.String(describing: permissionVersion)), replace: \(Swift.String(describing: replace)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension AssociateResourceSharePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let replace = replace {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceSharePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateResourceSharePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateResourceSharePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateResourceSharePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/associateresourcesharepermission"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateResourceSharePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the RAM permission to associate with the resource share.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// The version of the RAM permissions to associate with the resource share.
    public var permissionVersion: Swift.Int?
    /// Indicates whether the permission should replace the permissions that are currently associated with the resource share. Use true to replace the current permissions. Use false to add the permission to the current permission.
    public var replace: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil,
        replace: Swift.Bool? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
        self.replace = replace
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceSharePermissionInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let permissionArn: Swift.String?
    public let replace: Swift.Bool?
    public let clientToken: Swift.String?
    public let permissionVersion: Swift.Int?
}

extension AssociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let replaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension AssociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceSharePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceSharePermissionOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension AssociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct AssociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Indicates whether the request succeeded.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct AssociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension AssociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct CreateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

extension CreateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceShareInput(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), permissionArns: \(Swift.String(describing: permissionArns)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArns = permissionArns {
            var permissionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionArns)
            for permissionarnlist0 in permissionArns {
                try permissionArnsContainer.encode(permissionarnlist0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/createresourceshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInput: Swift.Equatable {
    /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.
    public var allowExternalPrincipals: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the resource share.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the permissions to associate with the resource share. If you do not specify an ARN for the permission, RAM automatically attaches the default version of the permission for each resource type. Only one permission can be associated with each resource type in a resource share.
    public var permissionArns: [Swift.String]?
    /// The principals to associate with the resource share. The possible values are:
    ///
    /// * An Amazon Web Services account ID
    ///
    /// * An Amazon Resource Name (ARN) of an organization in Organizations
    ///
    /// * An ARN of an organizational unit (OU) in Organizations
    ///
    /// * An ARN of an IAM role
    ///
    /// * An ARN of an IAM user
    ///
    ///
    /// Not all resource types can be shared with IAM roles and IAM users. For more information, see [Sharing with IAM roles and IAM users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// The ARNs of the resources to associate with the resource share.
    public var resourceArns: [Swift.String]?
    /// One or more tags.
    public var tags: [RamClientTypes.Tag]?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionArns: [Swift.String]? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        tags: [RamClientTypes.Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.permissionArns = permissionArns
        self.principals = principals
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

struct CreateResourceShareInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let tags: [RamClientTypes.Tag]?
    public let allowExternalPrincipals: Swift.Bool?
    public let clientToken: Swift.String?
    public let permissionArns: [Swift.String]?
}

extension CreateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionArns)
        var permissionArnsDecoded0:[Swift.String]? = nil
        if let permissionArnsContainer = permissionArnsContainer {
            permissionArnsDecoded0 = [Swift.String]()
            for string0 in permissionArnsContainer {
                if let string0 = string0 {
                    permissionArnsDecoded0?.append(string0)
                }
            }
        }
        permissionArns = permissionArnsDecoded0
    }
}

extension CreateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolation" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShare: \(Swift.String(describing: resourceShare)))"}
}

extension CreateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct CreateResourceShareOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the resource share.
    public var resourceShare: RamClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RamClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct CreateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShare: RamClientTypes.ResourceShare?
    public let clientToken: Swift.String?
}

extension CreateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DeleteResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/deleteresourceshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareArn = resourceShareArn
    }
}

struct DeleteResourceShareInputBody: Swift.Equatable {
}

extension DeleteResourceShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension DeleteResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DeleteResourceShareOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Indicates whether the request succeeded.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DeleteResourceShareOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension DeleteResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

extension DisassociateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DisassociateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/disassociateresourceshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The principals.
    public var principals: [Swift.String]?
    /// The Amazon Resource Names (ARNs) of the resources.
    public var resourceArns: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let clientToken: Swift.String?
}

extension DisassociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension DisassociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct DisassociateResourceShareOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the associations.
    public var resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct DisassociateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let clientToken: Swift.String?
}

extension DisassociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceSharePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

extension DisassociateResourceSharePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceSharePermissionInput(clientToken: \(Swift.String(describing: clientToken)), permissionArn: \(Swift.String(describing: permissionArn)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DisassociateResourceSharePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceSharePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateResourceSharePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateResourceSharePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateResourceSharePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/disassociateresourcesharepermission"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateResourceSharePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the permission to disassociate from the resource share.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceSharePermissionInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let permissionArn: Swift.String?
    public let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceSharePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceSharePermissionOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension DisassociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DisassociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Indicates whether the request succeeded.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DisassociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableSharingWithAwsOrganizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSharingWithAwsOrganizationInput()"}
}

extension EnableSharingWithAwsOrganizationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct EnableSharingWithAwsOrganizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: EnableSharingWithAwsOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableSharingWithAwsOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: EnableSharingWithAwsOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/enablesharingwithawsorganization"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableSharingWithAwsOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInput: Swift.Equatable {

    public init() {}
}

struct EnableSharingWithAwsOrganizationInputBody: Swift.Equatable {
}

extension EnableSharingWithAwsOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableSharingWithAwsOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSharingWithAwsOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSharingWithAwsOrganizationOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSharingWithAwsOrganizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSharingWithAwsOrganizationOutputResponse(returnValue: \(Swift.String(describing: returnValue)))"}
}

extension EnableSharingWithAwsOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableSharingWithAwsOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct EnableSharingWithAwsOrganizationOutputResponse: Swift.Equatable {
    /// Indicates whether the request succeeded.
    public var returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
}

extension EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct GetPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

extension GetPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPermissionInput(permissionArn: \(Swift.String(describing: permissionArn)), permissionVersion: \(Swift.String(describing: permissionVersion)))"}
}

extension GetPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

public struct GetPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/getpermission"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the permission.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// The identifier for the version of the permission.
    public var permissionVersion: Swift.Int?

    public init (
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct GetPermissionInputBody: Swift.Equatable {
    public let permissionArn: Swift.String?
    public let permissionVersion: Swift.Int?
}

extension GetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension GetPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPermissionOutputResponse(permission: \(Swift.String(describing: permission)))"}
}

extension GetPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permission = output.permission
        } else {
            self.permission = nil
        }
    }
}

public struct GetPermissionOutputResponse: Swift.Equatable {
    /// Information about the permission.
    public var permission: RamClientTypes.ResourceSharePermissionDetail?

    public init (
        permission: RamClientTypes.ResourceSharePermissionDetail? = nil
    )
    {
        self.permission = permission
    }
}

struct GetPermissionOutputResponseBody: Swift.Equatable {
    public let permission: RamClientTypes.ResourceSharePermissionDetail?
}

extension GetPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
    }
}

public struct GetResourcePoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

extension GetResourcePoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePoliciesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArns: \(Swift.String(describing: resourceArns)))"}
}

extension GetResourcePoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct GetResourcePoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetResourcePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourcePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetResourcePoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/getresourcepolicies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourcePoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The principal.
    public var principal: Swift.String?
    /// The Amazon Resource Names (ARNs) of the resources.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
    }
}

struct GetResourcePoliciesInputBody: Swift.Equatable {
    public let resourceArns: [Swift.String]?
    public let principal: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourcePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArn.NotFound" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePoliciesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), policies: \(Swift.String(describing: policies)))"}
}

extension GetResourcePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A key policy document, in JSON format.
    public var policies: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        policies: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct GetResourcePoliciesOutputResponseBody: Swift.Equatable {
    public let policies: [Swift.String]?
    public let nextToken: Swift.String?
}

extension GetResourcePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policies)
        var policiesDecoded0:[Swift.String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Swift.String]()
            for string0 in policiesContainer {
                if let string0 = string0 {
                    policiesDecoded0?.append(string0)
                }
            }
        }
        policies = policiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

extension GetResourceShareAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareAssociationsInput(associationStatus: \(Swift.String(describing: associationStatus)), associationType: \(Swift.String(describing: associationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArn: \(Swift.String(describing: resourceArn)), resourceShareArns: \(Swift.String(describing: resourceShareArns)))"}
}

extension GetResourceShareAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
    }
}

public struct GetResourceShareAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetResourceShareAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceShareAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetResourceShareAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/getresourceshareassociations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceShareAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInput: Swift.Equatable {
    /// The association status.
    public var associationStatus: RamClientTypes.ResourceShareAssociationStatus?
    /// The association type. Specify PRINCIPAL to list the principals that are associated with the specified resource share. Specify RESOURCE to list the resources that are associated with the specified resource share.
    /// This member is required.
    public var associationType: RamClientTypes.ResourceShareAssociationType?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The principal. You cannot specify this parameter if the association type is RESOURCE.
    public var principal: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. You cannot specify this parameter if the association type is PRINCIPAL.
    public var resourceArn: Swift.String?
    /// The Amazon Resource Names (ARN) of the resource shares.
    public var resourceShareArns: [Swift.String]?

    public init (
        associationStatus: RamClientTypes.ResourceShareAssociationStatus? = nil,
        associationType: RamClientTypes.ResourceShareAssociationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationType = associationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArn = resourceArn
        self.resourceShareArns = resourceShareArns
    }
}

struct GetResourceShareAssociationsInputBody: Swift.Equatable {
    public let associationType: RamClientTypes.ResourceShareAssociationType?
    public let resourceShareArns: [Swift.String]?
    public let resourceArn: Swift.String?
    public let principal: Swift.String?
    public let associationStatus: RamClientTypes.ResourceShareAssociationStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourceShareAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension GetResourceShareAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceShareAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.nextToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct GetResourceShareAssociationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the associations.
    public var resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct GetResourceShareAssociationsOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let nextToken: Swift.String?
}

extension GetResourceShareAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareInvitationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

extension GetResourceShareInvitationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareInvitationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceShareInvitationArns: \(Swift.String(describing: resourceShareInvitationArns)))"}
}

extension GetResourceShareInvitationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareInvitationArns = resourceShareInvitationArns {
            var resourceShareInvitationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareInvitationArns)
            for resourceshareinvitationarnlist0 in resourceShareInvitationArns {
                try resourceShareInvitationArnsContainer.encode(resourceshareinvitationarnlist0)
            }
        }
    }
}

public struct GetResourceShareInvitationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetResourceShareInvitationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceShareInvitationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetResourceShareInvitationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/getresourceshareinvitations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceShareInvitationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARN) of the resource shares.
    public var resourceShareArns: [Swift.String]?
    /// The Amazon Resource Names (ARN) of the invitations.
    public var resourceShareInvitationArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareInvitationArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArns = resourceShareArns
        self.resourceShareInvitationArns = resourceShareInvitationArns
    }
}

struct GetResourceShareInvitationsInputBody: Swift.Equatable {
    public let resourceShareInvitationArns: [Swift.String]?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourceShareInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareInvitationArns)
        var resourceShareInvitationArnsDecoded0:[Swift.String]? = nil
        if let resourceShareInvitationArnsContainer = resourceShareInvitationArnsContainer {
            resourceShareInvitationArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareInvitationArnsContainer {
                if let string0 = string0 {
                    resourceShareInvitationArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareInvitationArns = resourceShareInvitationArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareInvitationsOutputError: Swift.Error, Swift.Equatable {
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareInvitationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareInvitationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShareInvitations: \(Swift.String(describing: resourceShareInvitations)))"}
}

extension GetResourceShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareInvitations = output.resourceShareInvitations
        } else {
            self.nextToken = nil
            self.resourceShareInvitations = nil
        }
    }
}

public struct GetResourceShareInvitationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the invitations.
    public var resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareInvitations = resourceShareInvitations
    }
}

struct GetResourceShareInvitationsOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]?
    public let nextToken: Swift.String?
}

extension GetResourceShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareInvitations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareInvitation?].self, forKey: .resourceShareInvitations)
        var resourceShareInvitationsDecoded0:[RamClientTypes.ResourceShareInvitation]? = nil
        if let resourceShareInvitationsContainer = resourceShareInvitationsContainer {
            resourceShareInvitationsDecoded0 = [RamClientTypes.ResourceShareInvitation]()
            for structure0 in resourceShareInvitationsContainer {
                if let structure0 = structure0 {
                    resourceShareInvitationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareInvitations = resourceShareInvitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

extension GetResourceSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSharesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), permissionArn: \(Swift.String(describing: permissionArn)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceShareStatus: \(Swift.String(describing: resourceShareStatus)), tagFilters: \(Swift.String(describing: tagFilters)))"}
}

extension GetResourceSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareStatus = resourceShareStatus {
            try encodeContainer.encode(resourceShareStatus.rawValue, forKey: .resourceShareStatus)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilters0 in tagFilters {
                try tagFiltersContainer.encode(tagfilters0)
            }
        }
    }
}

public struct GetResourceSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetResourceSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetResourceSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/getresourceshares"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetResourceSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The name of the resource share.
    public var name: Swift.String?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the RAM permission that is associated with the resource share.
    public var permissionArn: Swift.String?
    /// The type of owner.
    /// This member is required.
    public var resourceOwner: RamClientTypes.ResourceOwner?
    /// The Amazon Resource Names (ARNs) of the resource shares.
    public var resourceShareArns: [Swift.String]?
    /// The status of the resource share.
    public var resourceShareStatus: RamClientTypes.ResourceShareStatus?
    /// One or more tag filters.
    public var tagFilters: [RamClientTypes.TagFilter]?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareStatus: RamClientTypes.ResourceShareStatus? = nil,
        tagFilters: [RamClientTypes.TagFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionArn = permissionArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceShareStatus = resourceShareStatus
        self.tagFilters = tagFilters
    }
}

struct GetResourceSharesInputBody: Swift.Equatable {
    public let resourceShareArns: [Swift.String]?
    public let resourceShareStatus: RamClientTypes.ResourceShareStatus?
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let name: Swift.String?
    public let tagFilters: [RamClientTypes.TagFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let permissionArn: Swift.String?
}

extension GetResourceSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceShareStatusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareStatus.self, forKey: .resourceShareStatus)
        resourceShareStatus = resourceShareStatusDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([RamClientTypes.TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[RamClientTypes.TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [RamClientTypes.TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
    }
}

extension GetResourceSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceSharesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSharesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShares: \(Swift.String(describing: resourceShares)))"}
}

extension GetResourceSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShares = output.resourceShares
        } else {
            self.nextToken = nil
            self.resourceShares = nil
        }
    }
}

public struct GetResourceSharesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the resource shares.
    public var resourceShares: [RamClientTypes.ResourceShare]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShares: [RamClientTypes.ResourceShare]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShares = resourceShares
    }
}

struct GetResourceSharesOutputResponseBody: Swift.Equatable {
    public let resourceShares: [RamClientTypes.ResourceShare]?
    public let nextToken: Swift.String?
}

extension GetResourceSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShares
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSharesContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShare?].self, forKey: .resourceShares)
        var resourceSharesDecoded0:[RamClientTypes.ResourceShare]? = nil
        if let resourceSharesContainer = resourceSharesContainer {
            resourceSharesDecoded0 = [RamClientTypes.ResourceShare]()
            for structure0 in resourceSharesContainer {
                if let structure0 = structure0 {
                    resourceSharesDecoded0?.append(structure0)
                }
            }
        }
        resourceShares = resourceSharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdempotentParameterMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatchException(message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A client token input parameter was reused with an operation, but at least one of the other input parameters is different from the previous call to the operation.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClientTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidClientTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A client token is not valid.
public struct InvalidClientTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClientTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidMaxResultsException(message: \(Swift.String(describing: message)))"}
}

extension InvalidMaxResultsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for MaxResults is not valid.
public struct InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for NextToken is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter is not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceTypeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidResourceTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource type is not valid.
public struct InvalidResourceTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceTypeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResourceTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateTransitionException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateTransitionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested state transition is not valid.
public struct InvalidStateTransitionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateTransitionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListPendingInvitationResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

extension ListPendingInvitationResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPendingInvitationResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension ListPendingInvitationResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct ListPendingInvitationResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPendingInvitationResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPendingInvitationResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPendingInvitationResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listpendinginvitationresources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPendingInvitationResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the invitation.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct ListPendingInvitationResourcesInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPendingInvitationResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPendingInvitationResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPendingInvitationResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPendingInvitationResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPendingInvitationResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPendingInvitationResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListPendingInvitationResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPendingInvitationResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListPendingInvitationResourcesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the resources included the resource share.
    public var resources: [RamClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RamClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListPendingInvitationResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [RamClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListPendingInvitationResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RamClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RamClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RamClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listpermissions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the resource type for which to list permissions. For example, to list only permissions that apply to EC2 subnets, specify ec2:Subnet.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    public let resourceType: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the permissions.
    public var permissions: [RamClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RamClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?
    public let nextToken: Swift.String?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RamClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RamClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPrincipalsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

extension ListPrincipalsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principals: \(Swift.String(describing: principals)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListPrincipalsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPrincipalsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPrincipalsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPrincipalsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPrincipalsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listprincipals"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPrincipalsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The principals.
    public var principals: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the resource.
    public var resourceArn: Swift.String?
    /// The type of owner.
    /// This member is required.
    public var resourceOwner: RamClientTypes.ResourceOwner?
    /// The Amazon Resource Names (ARN) of the resource shares.
    public var resourceShareArns: [Swift.String]?
    /// The resource type. Valid values: acm-pca:CertificateAuthority | appmesh:Mesh | codebuild:Project | codebuild:ReportGroup | ec2:CapacityReservation | ec2:DedicatedHost | ec2:LocalGatewayRouteTable | ec2:PrefixList | ec2:Subnet | ec2:TrafficMirrorTarget | ec2:TransitGateway | imagebuilder:Component | imagebuilder:Image | imagebuilder:ImageRecipe | imagebuilder:ContainerRecipe | glue:Catalog | glue:Database | glue:Table | license-manager:LicenseConfiguration I network-firewall:FirewallPolicy | network-firewall:StatefulRuleGroup | network-firewall:StatelessRuleGroup | outposts:Outpost | resource-groups:Group | rds:Cluster | route53resolver:FirewallRuleGroup |route53resolver:ResolverQueryLogConfig | route53resolver:ResolverRule | s3-outposts:Outpost | ssm-contacts:Contact | ssm-incidents:ResponsePlan
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principals = principals
        self.resourceArn = resourceArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListPrincipalsInputBody: Swift.Equatable {
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let resourceArn: Swift.String?
    public let principals: [Swift.String]?
    public let resourceType: Swift.String?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPrincipalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPrincipalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), principals: \(Swift.String(describing: principals)))"}
}

extension ListPrincipalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The principals.
    public var principals: [RamClientTypes.Principal]?

    public init (
        nextToken: Swift.String? = nil,
        principals: [RamClientTypes.Principal]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListPrincipalsOutputResponseBody: Swift.Equatable {
    public let principals: [RamClientTypes.Principal]?
    public let nextToken: Swift.String?
}

extension ListPrincipalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case principals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([RamClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[RamClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [RamClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceSharePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

extension ListResourceSharePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSharePermissionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension ListResourceSharePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct ListResourceSharePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceSharePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceSharePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceSharePermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listresourcesharepermissions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceSharePermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArn = resourceShareArn
    }
}

struct ListResourceSharePermissionsInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourceSharePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceSharePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSharePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceSharePermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSharePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSharePermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListResourceSharePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceSharePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListResourceSharePermissionsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The permissions associated with the resource share.
    public var permissions: [RamClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RamClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListResourceSharePermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?
    public let nextToken: Swift.String?
}

extension ListResourceSharePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RamClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RamClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

extension ListResourceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceTypesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listresourcetypes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceTypesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceTypesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceTypes: \(Swift.String(describing: resourceTypes)))"}
}

extension ListResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTypes = output.resourceTypes
        } else {
            self.nextToken = nil
            self.resourceTypes = nil
        }
    }
}

public struct ListResourceTypesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The shareable resource types supported by RAM.
    public var resourceTypes: [RamClientTypes.ServiceNameAndResourceType]?

    public init (
        nextToken: Swift.String? = nil,
        resourceTypes: [RamClientTypes.ServiceNameAndResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct ListResourceTypesOutputResponseBody: Swift.Equatable {
    public let resourceTypes: [RamClientTypes.ServiceNameAndResourceType]?
    public let nextToken: Swift.String?
}

extension ListResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([RamClientTypes.ServiceNameAndResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[RamClientTypes.ServiceNameAndResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [RamClientTypes.ServiceNameAndResourceType]()
            for structure0 in resourceTypesContainer {
                if let structure0 = structure0 {
                    resourceTypesDecoded0?.append(structure0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArns: \(Swift.String(describing: resourceArns)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/listresources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The principal.
    public var principal: Swift.String?
    /// The Amazon Resource Names (ARNs) of the resources.
    public var resourceArns: [Swift.String]?
    /// The type of owner.
    /// This member is required.
    public var resourceOwner: RamClientTypes.ResourceOwner?
    /// The Amazon Resource Names (ARN) of the resource shares.
    public var resourceShareArns: [Swift.String]?
    /// The resource type. Valid values: acm-pca:CertificateAuthority | appmesh:Mesh | codebuild:Project | codebuild:ReportGroup | ec2:CapacityReservation | ec2:DedicatedHost | ec2:LocalGatewayRouteTable | ec2:PrefixList | ec2:Subnet | ec2:TrafficMirrorTarget | ec2:TransitGateway | imagebuilder:Component | imagebuilder:Image | imagebuilder:ImageRecipe | imagebuilder:ContainerRecipe | glue:Catalog | glue:Database | glue:Table | license-manager:LicenseConfiguration I network-firewall:FirewallPolicy | network-firewall:StatefulRuleGroup | network-firewall:StatelessRuleGroup | outposts:Outpost | resource-groups:Group | rds:Cluster | route53resolver:FirewallRuleGroup |route53resolver:ResolverQueryLogConfig | route53resolver:ResolverRule | s3-outposts:Outpost | ssm-contacts:Contact | ssm-incidents:ResponsePlan
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let principal: Swift.String?
    public let resourceType: Swift.String?
    public let resourceArns: [Swift.String]?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType.Unknown" : self = .invalidResourceTypeException(try InvalidResourceTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceTypeException(InvalidResourceTypeException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the resources.
    public var resources: [RamClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RamClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [RamClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RamClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RamClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RamClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedArnException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedArnException(message: \(Swift.String(describing: message)))"}
}

extension MalformedArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The format of an Amazon Resource Name (ARN) is not valid.
public struct MalformedArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedArnExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MissingRequiredParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingRequiredParameterException(message: \(Swift.String(describing: message)))"}
}

extension MissingRequiredParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A required input parameter is missing.
public struct MissingRequiredParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotPermittedException(message: \(Swift.String(describing: message)))"}
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.Principal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case external
        case id
        case lastUpdatedTime
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RamClientTypes.Principal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Principal(creationTime: \(Swift.String(describing: creationTime)), external: \(Swift.String(describing: external)), id: \(Swift.String(describing: id)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension RamClientTypes {
    /// Describes a principal for use with Resource Access Manager.
    public struct Principal: Swift.Equatable {
        /// The time when the principal was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public var external: Swift.Bool?
        /// The ID of the principal.
        public var id: Swift.String?
        /// The time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource share.
        public var resourceShareArn: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.external = external
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
        }
    }

}

extension PromoteResourceShareCreatedFromPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteResourceShareCreatedFromPolicyInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension PromoteResourceShareCreatedFromPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PromoteResourceShareCreatedFromPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PromoteResourceShareCreatedFromPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PromoteResourceShareCreatedFromPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/promoteresourcesharecreatedfrompolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PromoteResourceShareCreatedFromPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource share to promote.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        resourceShareArn: Swift.String? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
    }
}

struct PromoteResourceShareCreatedFromPolicyInputBody: Swift.Equatable {
}

extension PromoteResourceShareCreatedFromPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteResourceShareCreatedFromPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteResourceShareCreatedFromPolicyOutputResponse(returnValue: \(Swift.String(describing: returnValue)))"}
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteResourceShareCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.Equatable {
    /// Indicates whether the request succeeded.
    public var returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
}

extension PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct RejectResourceShareInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

extension RejectResourceShareInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectResourceShareInvitationInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension RejectResourceShareInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct RejectResourceShareInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RejectResourceShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectResourceShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RejectResourceShareInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/rejectresourceshareinvitation"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectResourceShareInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the invitation.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct RejectResourceShareInvitationInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let clientToken: Swift.String?
}

extension RejectResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RejectResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyAccepted" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectResourceShareInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectResourceShareInvitationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitation: \(Swift.String(describing: resourceShareInvitation)))"}
}

extension RejectResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct RejectResourceShareInvitationOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the invitation.
    public var resourceShareInvitation: RamClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RamClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct RejectResourceShareInvitationOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?
    public let clientToken: Swift.String?
}

extension RejectResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RamClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastUpdatedTime
        case resourceGroupArn
        case resourceShareArn
        case status
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RamClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceGroupArn: \(Swift.String(describing: resourceGroupArn)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), type: \(Swift.String(describing: type)))"}
}

extension RamClientTypes {
    /// Describes a resource associated with a resource share.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time when the resource was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// The time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource group. This value is returned only if the resource is a resource group.
        public var resourceGroupArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource share.
        public var resourceShareArn: Swift.String?
        /// The status of the resource.
        public var status: RamClientTypes.ResourceStatus?
        /// A message about the status of the resource.
        public var statusMessage: Swift.String?
        /// The resource type.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceGroupArn: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RamClientTypes.ResourceStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceGroupArn = resourceGroupArn
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ResourceArnNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceArnNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceArnNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Amazon Resource Name (ARN) was not found.
public struct ResourceArnNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case otherAccounts
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .otherAccounts,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .otherAccounts: return "OTHER-ACCOUNTS"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes.ResourceShare: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case creationTime
        case featureSet
        case lastUpdatedTime
        case name
        case owningAccountId
        case resourceShareArn
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let featureSet = featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningAccountId = owningAccountId {
            try encodeContainer.encode(owningAccountId, forKey: .owningAccountId)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningAccountId)
        owningAccountId = owningAccountIdDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
    }
}

extension RamClientTypes.ResourceShare: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShare(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), creationTime: \(Swift.String(describing: creationTime)), featureSet: \(Swift.String(describing: featureSet)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), owningAccountId: \(Swift.String(describing: owningAccountId)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)))"}
}

extension RamClientTypes {
    /// Describes a resource share.
    public struct ResourceShare: Swift.Equatable {
        /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.
        public var allowExternalPrincipals: Swift.Bool?
        /// The time when the resource share was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates how the resource share was created. Possible values include:
        ///
        /// * CREATED_FROM_POLICY - Indicates that the resource share was created from an Amazon Web Services Identity and Access Management (Amazon Web Services IAM) policy attached to a resource. These resource shares are visible only to the Amazon Web Services account that created it. They cannot be modified in RAM.
        ///
        /// * PROMOTING_TO_STANDARD - The resource share is in the process of being promoted. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * STANDARD - Indicates that the resource share was created in RAM using the console or APIs. These resource shares are visible to all principals. They can be modified in RAM.
        public var featureSet: RamClientTypes.ResourceShareFeatureSet?
        /// The time when the resource share was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the resource share.
        public var name: Swift.String?
        /// The ID of the Amazon Web Services account that owns the resource share.
        public var owningAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource share.
        public var resourceShareArn: Swift.String?
        /// The status of the resource share.
        public var status: RamClientTypes.ResourceShareStatus?
        /// A message about the status of the resource share.
        public var statusMessage: Swift.String?
        /// The tags for the resource share.
        public var tags: [RamClientTypes.Tag]?

        public init (
            allowExternalPrincipals: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            featureSet: RamClientTypes.ResourceShareFeatureSet? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningAccountId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RamClientTypes.ResourceShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [RamClientTypes.Tag]? = nil
        )
        {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.creationTime = creationTime
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owningAccountId = owningAccountId
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension RamClientTypes.ResourceShareAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedEntity
        case associationType
        case creationTime
        case external
        case lastUpdatedTime
        case resourceShareArn
        case resourceShareName
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedEntity = associatedEntity {
            try encodeContainer.encode(associatedEntity, forKey: .associatedEntity)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let associatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedEntity)
        associatedEntity = associatedEntityDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RamClientTypes.ResourceShareAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareAssociation(associatedEntity: \(Swift.String(describing: associatedEntity)), associationType: \(Swift.String(describing: associationType)), creationTime: \(Swift.String(describing: creationTime)), external: \(Swift.String(describing: external)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), resourceShareName: \(Swift.String(describing: resourceShareName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension RamClientTypes {
    /// Describes an association with a resource share.
    public struct ResourceShareAssociation: Swift.Equatable {
        /// The associated entity. For resource associations, this is the Amazon Resource Name (ARN) of the resource. For principal associations, this is one of the following:
        ///
        /// * An Amazon Web Services account ID
        ///
        /// * An ARN of an organization in Organizations
        ///
        /// * An ARN of an organizational unit (OU) in Organizations
        ///
        /// * An ARN of an IAM role
        ///
        /// * An ARN of an IAM user
        public var associatedEntity: Swift.String?
        /// The association type.
        public var associationType: RamClientTypes.ResourceShareAssociationType?
        /// The time when the association was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public var external: Swift.Bool?
        /// The time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the resource share.
        public var resourceShareArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The status of the association.
        public var status: RamClientTypes.ResourceShareAssociationStatus?
        /// A message about the status of the association.
        public var statusMessage: Swift.String?

        public init (
            associatedEntity: Swift.String? = nil,
            associationType: RamClientTypes.ResourceShareAssociationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            status: RamClientTypes.ResourceShareAssociationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.associatedEntity = associatedEntity
            self.associationType = associationType
            self.creationTime = creationTime
            self.external = external
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension RamClientTypes {
    public enum ResourceShareAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationStatus] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationStatus(rawValue: rawValue) ?? ResourceShareAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceShareAssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case principal
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationType] {
            return [
                .principal,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .principal: return "PRINCIPAL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationType(rawValue: rawValue) ?? ResourceShareAssociationType.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceShareFeatureSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdFromPolicy
        case promotingToStandard
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareFeatureSet] {
            return [
                .createdFromPolicy,
                .promotingToStandard,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdFromPolicy: return "CREATED_FROM_POLICY"
            case .promotingToStandard: return "PROMOTING_TO_STANDARD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareFeatureSet(rawValue: rawValue) ?? ResourceShareFeatureSet.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes.ResourceShareInvitation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationTimestamp
        case receiverAccountId
        case receiverArn
        case resourceShareArn
        case resourceShareAssociations
        case resourceShareInvitationArn
        case resourceShareName
        case senderAccountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationTimestamp = invitationTimestamp {
            try encodeContainer.encode(invitationTimestamp.timeIntervalSince1970, forKey: .invitationTimestamp)
        }
        if let receiverAccountId = receiverAccountId {
            try encodeContainer.encode(receiverAccountId, forKey: .receiverAccountId)
        }
        if let receiverArn = receiverArn {
            try encodeContainer.encode(receiverArn, forKey: .receiverArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareAssociations = resourceShareAssociations {
            var resourceShareAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareAssociations)
            for resourceshareassociationlist0 in resourceShareAssociations {
                try resourceShareAssociationsContainer.encode(resourceshareassociationlist0)
            }
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let senderAccountId = senderAccountId {
            try encodeContainer.encode(senderAccountId, forKey: .senderAccountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let senderAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderAccountId)
        senderAccountId = senderAccountIdDecoded
        let receiverAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverAccountId)
        receiverAccountId = receiverAccountIdDecoded
        let invitationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .invitationTimestamp)
        invitationTimestamp = invitationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitationStatus.self, forKey: .status)
        status = statusDecoded
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let receiverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverArn)
        receiverArn = receiverArnDecoded
    }
}

extension RamClientTypes.ResourceShareInvitation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitation(invitationTimestamp: \(Swift.String(describing: invitationTimestamp)), receiverAccountId: \(Swift.String(describing: receiverAccountId)), receiverArn: \(Swift.String(describing: receiverArn)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)), resourceShareName: \(Swift.String(describing: resourceShareName)), senderAccountId: \(Swift.String(describing: senderAccountId)), status: \(Swift.String(describing: status)))"}
}

extension RamClientTypes {
    /// Describes an invitation to join a resource share.
    public struct ResourceShareInvitation: Swift.Equatable {
        /// The date and time when the invitation was sent.
        public var invitationTimestamp: ClientRuntime.Date?
        /// The ID of the Amazon Web Services account that received the invitation.
        public var receiverAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM user or IAM role that received the invitation.
        public var receiverArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource share.
        public var resourceShareArn: Swift.String?
        /// To view the resources associated with a pending resource share invitation, use [ ListPendingInvitationResources](https://docs.aws.amazon.com/ram/latest/APIReference/API_ListPendingInvitationResources.html).
        @available(*, deprecated, message: "This member has been deprecated. Use ListPendingInvitationResources.")
        public var resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
        /// The Amazon Resource Name (ARN) of the invitation.
        public var resourceShareInvitationArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The ID of the Amazon Web Services account that sent the invitation.
        public var senderAccountId: Swift.String?
        /// The status of the invitation.
        public var status: RamClientTypes.ResourceShareInvitationStatus?

        public init (
            invitationTimestamp: ClientRuntime.Date? = nil,
            receiverAccountId: Swift.String? = nil,
            receiverArn: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil,
            resourceShareInvitationArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            senderAccountId: Swift.String? = nil,
            status: RamClientTypes.ResourceShareInvitationStatus? = nil
        )
        {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.receiverArn = receiverArn
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = resourceShareAssociations
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }
    }

}

extension ResourceShareInvitationAlreadyAcceptedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationAlreadyAcceptedException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyAcceptedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationAlreadyAcceptedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The invitation was already accepted.
public struct ResourceShareInvitationAlreadyAcceptedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationAlreadyRejectedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationAlreadyRejectedException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyRejectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationAlreadyRejectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The invitation was already rejected.
public struct ResourceShareInvitationAlreadyRejectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationArnNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationArnNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationArnNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Resource Name (ARN) for an invitation was not found.
public struct ResourceShareInvitationArnNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationArnNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationExpiredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationExpiredException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationExpiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The invitation is expired.
public struct ResourceShareInvitationExpiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationExpiredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes {
    public enum ResourceShareInvitationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareInvitationStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareInvitationStatus(rawValue: rawValue) ?? ResourceShareInvitationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceShareLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource share exceeds the limit for your account.
public struct ResourceShareLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case permission
        case resourceType
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let isResourceTypeDefault = isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permission = permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSharePermissionDetail(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultVersion: \(Swift.String(describing: defaultVersion)), isResourceTypeDefault: \(Swift.String(describing: isResourceTypeDefault)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), permission: \(Swift.String(describing: permission)), resourceType: \(Swift.String(describing: resourceType)), version: \(Swift.String(describing: version)))"}
}

extension RamClientTypes {
    /// Information about an RAM permission.
    public struct ResourceSharePermissionDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the permission.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the permission is set to the default version for this permission.
        public var defaultVersion: Swift.Bool?
        /// Specifies whether the version of the permission is set to the default version for this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the permission.
        public var name: Swift.String?
        /// The permission's effect and actions in JSON format. The effect indicates whether the actions are allowed or denied. The actions list the API actions to which the principal is granted or denied access.
        public var permission: Swift.String?
        /// The resource type to which the permission applies.
        public var resourceType: Swift.String?
        /// The identifier for the version of the permission.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permission: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permission = permission
            self.resourceType = resourceType
            self.version = version
        }
    }

}

extension RamClientTypes.ResourceSharePermissionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case resourceType
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let isResourceTypeDefault = isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSharePermissionSummary(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultVersion: \(Swift.String(describing: defaultVersion)), isResourceTypeDefault: \(Swift.String(describing: isResourceTypeDefault)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), resourceType: \(Swift.String(describing: resourceType)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension RamClientTypes {
    /// Information about a permission that is associated with a resource share.
    public struct ResourceSharePermissionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the permission.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the permission is set to the default version for this permission.
        public var defaultVersion: Swift.Bool?
        /// Specifies whether the version of the permission is set to the default version for this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the permission.
        public var name: Swift.String?
        /// The type of resource to which the permission applies.
        public var resourceType: Swift.String?
        /// The current status of the permission.
        public var status: Swift.String?
        /// The identifier for the version of the permission.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.version = version
        }
    }

}

extension RamClientTypes {
    public enum ResourceShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareStatus(rawValue: rawValue) ?? ResourceShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case limitExceeded
        case pending
        case unavailable
        case zonalResourceInaccessible
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .limitExceeded,
                .pending,
                .unavailable,
                .zonalResourceInaccessible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .pending: return "PENDING"
            case .unavailable: return "UNAVAILABLE"
            case .zonalResourceInaccessible: return "ZONAL_RESOURCE_INACCESSIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServerInternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerInternalException(message: \(Swift.String(describing: message)))"}
}

extension ServerInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service could not respond to the request due to an internal problem.
public struct ServerInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.ServiceNameAndResourceType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension RamClientTypes.ServiceNameAndResourceType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNameAndResourceType(resourceType: \(Swift.String(describing: resourceType)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension RamClientTypes {
    /// Information about the shareable resource types and the Amazon Web Services services to which they belong.
    public struct ServiceNameAndResourceType: Swift.Equatable {
        /// The shareable resource types.
        public var resourceType: Swift.String?
        /// The name of the Amazon Web Services services to which the resources belong.
        public var serviceName: Swift.String?

        public init (
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is not available.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RamClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension RamClientTypes {
    /// Information about a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RamClientTypes.TagFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension RamClientTypes.TagFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagFilter(tagKey: \(Swift.String(describing: tagKey)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension RamClientTypes {
    /// Used to filter information based on tags.
    public struct TagFilter: Swift.Equatable {
        /// The tag key.
        public var tagKey: Swift.String?
        /// The tag values.
        public var tagValues: [Swift.String]?

        public init (
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension TagLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TagLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested tags exceed the limit for your account.
public struct TagLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyViolationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagPolicyViolationException(message: \(Swift.String(describing: message)))"}
}

extension TagPolicyViolationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tagresource"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public var tags: [RamClientTypes.Tag]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tags: [RamClientTypes.Tag]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let tags: [RamClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArn.NotFound" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceeded" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolation" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnknownResourceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnknownResourceException(message: \(Swift.String(describing: message)))"}
}

extension UnknownResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified resource was not found.
public struct UnknownResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/untagresource"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

extension UpdateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceShareInput(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension UpdateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct UpdateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/updateresourceshare"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInput: Swift.Equatable {
    /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.
    public var allowExternalPrincipals: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the resource share.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.resourceShareArn = resourceShareArn
    }
}

struct UpdateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let name: Swift.String?
    public let allowExternalPrincipals: Swift.Bool?
    public let clientToken: Swift.String?
}

extension UpdateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShare: \(Swift.String(describing: resourceShare)))"}
}

extension UpdateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct UpdateResourceShareOutputResponse: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Information about the resource share.
    public var resourceShare: RamClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RamClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct UpdateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShare: RamClientTypes.ResourceShare?
    public let clientToken: Swift.String?
}

extension UpdateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
