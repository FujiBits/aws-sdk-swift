// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSServiceAccessNotEnabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AWSServiceAccessNotEnabledException(message: \(Swift.String(describing: message)))"}
}

extension AWSServiceAccessNotEnabledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSServiceAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action you attempted is not allowed unless Service Access with Service Quotas is
///       enabled in your organization.
public struct AWSServiceAccessNotEnabledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AWSServiceAccessNotEnabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AWSServiceAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateServiceQuotaTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateServiceQuotaTemplateInput()"}
}

extension AssociateServiceQuotaTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateServiceQuotaTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceQuotaTemplateOutputError>
}

public struct AssociateServiceQuotaTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceQuotaTemplateOutputError>
}

public struct AssociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() {}
}

struct AssociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension AssociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceQuotaTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesModeException" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateServiceQuotaTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceQuotaTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateServiceQuotaTemplateOutputResponse()"}
}

extension AssociateServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateServiceQuotaTemplateOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateServiceQuotaTemplateOutputResponseBody: Swift.Equatable {
}

extension AssociateServiceQuotaTemplateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceQuotaIncreaseRequestFromTemplateInput(awsRegion: \(Swift.String(describing: awsRegion)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// The AWS Region.
    /// This member is required.
    public let awsRegion: Swift.String?
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
    public let awsRegion: Swift.String?
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceQuotaIncreaseRequestFromTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse()"}
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Equatable {
}

extension DeleteServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DependencyAccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependencyAccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension DependencyAccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform this action because a dependency does not have access.
public struct DependencyAccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyAccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DependencyAccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DisassociateServiceQuotaTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateServiceQuotaTemplateInput()"}
}

extension DisassociateServiceQuotaTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateServiceQuotaTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceQuotaTemplateOutputError>
}

public struct DisassociateServiceQuotaTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceQuotaTemplateOutputError>
}

public struct DisassociateServiceQuotaTemplateInput: Swift.Equatable {

    public init() {}
}

struct DisassociateServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension DisassociateServiceQuotaTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceQuotaTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaTemplateNotInUseException" : self = .serviceQuotaTemplateNotInUseException(try ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateServiceQuotaTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case serviceQuotaTemplateNotInUseException(ServiceQuotaTemplateNotInUseException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceQuotaTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateServiceQuotaTemplateOutputResponse()"}
}

extension DisassociateServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateServiceQuotaTemplateOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateServiceQuotaTemplateOutputResponseBody: Swift.Equatable {
}

extension DisassociateServiceQuotaTemplateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceQuotasClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyAccessDeniedError
        case dependencyServiceError
        case dependencyThrottlingError
        case serviceQuotaNotAvailableError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .dependencyAccessDeniedError,
                .dependencyServiceError,
                .dependencyThrottlingError,
                .serviceQuotaNotAvailableError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDeniedError: return "DEPENDENCY_ACCESS_DENIED_ERROR"
            case .dependencyServiceError: return "DEPENDENCY_SERVICE_ERROR"
            case .dependencyThrottlingError: return "DEPENDENCY_THROTTLING_ERROR"
            case .serviceQuotaNotAvailableError: return "SERVICE_QUOTA_NOT_AVAILABLE_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.ErrorReason: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceQuotasClientTypes.ErrorReason: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorReason(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension ServiceQuotasClientTypes {
    /// An error that explains why an action did not succeed.
    public struct ErrorReason: Swift.Equatable {
        /// Service Quotas returns the following error values:
        ///
        ///
        ///
        ///                   DEPENDENCY_ACCESS_DENIED_ERROR - The caller does not have the required
        ///           permissions to complete the action. To resolve the error, you must have permission to
        ///           access the service or quota.
        ///
        ///
        ///
        ///                   DEPENDENCY_THROTTLING_ERROR - The service is throttling Service
        ///           Quotas.
        ///
        ///
        ///
        ///                   DEPENDENCY_SERVICE_ERROR - The service is not available.
        ///
        ///
        ///
        ///                   SERVICE_QUOTA_NOT_AVAILABLE_ERROR - There was an error in Service
        ///           Quotas.
        ///
        ///
        public let errorCode: ServiceQuotasClientTypes.ErrorCode?
        /// The error message.
        public let errorMessage: Swift.String?

        public init (
            errorCode: ServiceQuotasClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

public struct GetAWSDefaultServiceQuotaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSDefaultServiceQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSDefaultServiceQuotaOutputError>
}

extension GetAWSDefaultServiceQuotaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAWSDefaultServiceQuotaInput(quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension GetAWSDefaultServiceQuotaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetAWSDefaultServiceQuotaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSDefaultServiceQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSDefaultServiceQuotaOutputError>
}

public struct GetAWSDefaultServiceQuotaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSDefaultServiceQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAWSDefaultServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSDefaultServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSDefaultServiceQuotaOutputError>
}

public struct GetAWSDefaultServiceQuotaInput: Swift.Equatable {
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetAWSDefaultServiceQuotaInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension GetAWSDefaultServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GetAWSDefaultServiceQuotaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAWSDefaultServiceQuotaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAWSDefaultServiceQuotaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAWSDefaultServiceQuotaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAWSDefaultServiceQuotaOutputResponse(quota: \(Swift.String(describing: quota)))"}
}

extension GetAWSDefaultServiceQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAWSDefaultServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetAWSDefaultServiceQuotaOutputResponse: Swift.Equatable {
    /// Information about the quota.
    public let quota: ServiceQuotasClientTypes.ServiceQuota?

    public init (
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetAWSDefaultServiceQuotaOutputResponseBody: Swift.Equatable {
    public let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetAWSDefaultServiceQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension GetAssociationForServiceQuotaTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssociationForServiceQuotaTemplateInput()"}
}

extension GetAssociationForServiceQuotaTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssociationForServiceQuotaTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssociationForServiceQuotaTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssociationForServiceQuotaTemplateOutputError>
}

public struct GetAssociationForServiceQuotaTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssociationForServiceQuotaTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssociationForServiceQuotaTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssociationForServiceQuotaTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssociationForServiceQuotaTemplateOutputError>
}

public struct GetAssociationForServiceQuotaTemplateInput: Swift.Equatable {

    public init() {}
}

struct GetAssociationForServiceQuotaTemplateInputBody: Swift.Equatable {
}

extension GetAssociationForServiceQuotaTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssociationForServiceQuotaTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssociationForServiceQuotaTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaTemplateNotInUseException" : self = .serviceQuotaTemplateNotInUseException(try ServiceQuotaTemplateNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssociationForServiceQuotaTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case serviceQuotaTemplateNotInUseException(ServiceQuotaTemplateNotInUseException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssociationForServiceQuotaTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssociationForServiceQuotaTemplateOutputResponse(serviceQuotaTemplateAssociationStatus: \(Swift.String(describing: serviceQuotaTemplateAssociationStatus)))"}
}

extension GetAssociationForServiceQuotaTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssociationForServiceQuotaTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaTemplateAssociationStatus = output.serviceQuotaTemplateAssociationStatus
        } else {
            self.serviceQuotaTemplateAssociationStatus = nil
        }
    }
}

public struct GetAssociationForServiceQuotaTemplateOutputResponse: Swift.Equatable {
    /// The association status. If the status is ASSOCIATED, the quota increase
    ///       requests in the template are automatically applied to new accounts in your
    ///       organization.
    public let serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?

    public init (
        serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus? = nil
    )
    {
        self.serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatus
    }
}

struct GetAssociationForServiceQuotaTemplateOutputResponseBody: Swift.Equatable {
    public let serviceQuotaTemplateAssociationStatus: ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus?
}

extension GetAssociationForServiceQuotaTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaTemplateAssociationStatus = "ServiceQuotaTemplateAssociationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaTemplateAssociationStatusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaTemplateAssociationStatus.self, forKey: .serviceQuotaTemplateAssociationStatus)
        serviceQuotaTemplateAssociationStatus = serviceQuotaTemplateAssociationStatusDecoded
    }
}

public struct GetRequestedServiceQuotaChangeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRequestedServiceQuotaChangeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRequestedServiceQuotaChangeOutputError>
}

extension GetRequestedServiceQuotaChangeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRequestedServiceQuotaChangeInput(requestId: \(Swift.String(describing: requestId)))"}
}

extension GetRequestedServiceQuotaChangeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }
}

public struct GetRequestedServiceQuotaChangeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRequestedServiceQuotaChangeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRequestedServiceQuotaChangeOutputError>
}

public struct GetRequestedServiceQuotaChangeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRequestedServiceQuotaChangeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRequestedServiceQuotaChangeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRequestedServiceQuotaChangeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRequestedServiceQuotaChangeOutputError>
}

public struct GetRequestedServiceQuotaChangeInput: Swift.Equatable {
    /// The ID of the quota increase request.
    /// This member is required.
    public let requestId: Swift.String?

    public init (
        requestId: Swift.String? = nil
    )
    {
        self.requestId = requestId
    }
}

struct GetRequestedServiceQuotaChangeInputBody: Swift.Equatable {
    public let requestId: Swift.String?
}

extension GetRequestedServiceQuotaChangeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetRequestedServiceQuotaChangeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestedServiceQuotaChangeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestedServiceQuotaChangeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestedServiceQuotaChangeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRequestedServiceQuotaChangeOutputResponse(requestedQuota: \(Swift.String(describing: requestedQuota)))"}
}

extension GetRequestedServiceQuotaChangeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRequestedServiceQuotaChangeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct GetRequestedServiceQuotaChangeOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init (
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct GetRequestedServiceQuotaChangeOutputResponseBody: Swift.Equatable {
    public let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension GetRequestedServiceQuotaChangeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaIncreaseRequestFromTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceQuotaIncreaseRequestFromTemplateInput(awsRegion: \(Swift.String(describing: awsRegion)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaIncreaseRequestFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaIncreaseRequestFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaIncreaseRequestFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaIncreaseRequestFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaIncreaseRequestFromTemplateOutputError>
}

public struct GetServiceQuotaIncreaseRequestFromTemplateInput: Swift.Equatable {
    /// The AWS Region.
    /// This member is required.
    public let awsRegion: Swift.String?
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
    public let awsRegion: Swift.String?
}

extension GetServiceQuotaIncreaseRequestFromTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceQuotaIncreaseRequestFromTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceQuotaIncreaseRequestFromTemplateOutputResponse(serviceQuotaIncreaseRequestInTemplate: \(Swift.String(describing: serviceQuotaIncreaseRequestInTemplate)))"}
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init (
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Equatable {
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension GetServiceQuotaIncreaseRequestFromTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

public struct GetServiceQuotaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaOutputError>
}

extension GetServiceQuotaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceQuotaInput(quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension GetServiceQuotaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct GetServiceQuotaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaOutputError>
}

public struct GetServiceQuotaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetServiceQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetServiceQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetServiceQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetServiceQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetServiceQuotaOutputError>
}

public struct GetServiceQuotaInput: Swift.Equatable {
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct GetServiceQuotaInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension GetServiceQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension GetServiceQuotaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceQuotaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceQuotaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceQuotaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetServiceQuotaOutputResponse(quota: \(Swift.String(describing: quota)))"}
}

extension GetServiceQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetServiceQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.quota = output.quota
        } else {
            self.quota = nil
        }
    }
}

public struct GetServiceQuotaOutputResponse: Swift.Equatable {
    /// Information about the quota.
    public let quota: ServiceQuotasClientTypes.ServiceQuota?

    public init (
        quota: ServiceQuotasClientTypes.ServiceQuota? = nil
    )
    {
        self.quota = quota
    }
}

struct GetServiceQuotaOutputResponseBody: Swift.Equatable {
    public let quota: ServiceQuotasClientTypes.ServiceQuota?
}

extension GetServiceQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quota = "Quota"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuota.self, forKey: .quota)
        quota = quotaDecoded
    }
}

extension IllegalArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalArgumentException(message: \(Swift.String(describing: message)))"}
}

extension IllegalArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IllegalArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid input was provided.
public struct IllegalArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPaginationTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPaginationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Invalid input was provided.
public struct InvalidPaginationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is in an invalid state.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAWSDefaultServiceQuotasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAWSDefaultServiceQuotasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAWSDefaultServiceQuotasOutputError>
}

extension ListAWSDefaultServiceQuotasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAWSDefaultServiceQuotasInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ListAWSDefaultServiceQuotasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListAWSDefaultServiceQuotasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAWSDefaultServiceQuotasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAWSDefaultServiceQuotasOutputError>
}

public struct ListAWSDefaultServiceQuotasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAWSDefaultServiceQuotasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAWSDefaultServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAWSDefaultServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAWSDefaultServiceQuotasOutputError>
}

public struct ListAWSDefaultServiceQuotasInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListAWSDefaultServiceQuotasInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAWSDefaultServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAWSDefaultServiceQuotasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAWSDefaultServiceQuotasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAWSDefaultServiceQuotasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAWSDefaultServiceQuotasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAWSDefaultServiceQuotasOutputResponse(nextToken: \(Swift.String(describing: nextToken)), quotas: \(Swift.String(describing: quotas)))"}
}

extension ListAWSDefaultServiceQuotasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAWSDefaultServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListAWSDefaultServiceQuotasOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the quotas.
    public let quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init (
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListAWSDefaultServiceQuotasOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListAWSDefaultServiceQuotasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRequestedServiceQuotaChangeHistoryByQuotaInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)), status: \(Swift.String(describing: status)))"}
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryByQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryByQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryByQuotaOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?
    /// The status value of the quota increase request.
    public let status: ServiceQuotasClientTypes.RequestStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
    public let status: ServiceQuotasClientTypes.RequestStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRequestedServiceQuotaChangeHistoryByQuotaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse(nextToken: \(Swift.String(describing: nextToken)), requestedQuotas: \(Swift.String(describing: requestedQuotas)))"}
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the quota increase requests.
    public let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init (
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

extension ListRequestedServiceQuotaChangeHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRequestedServiceQuotaChangeHistoryInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)), status: \(Swift.String(describing: status)))"}
}

extension ListRequestedServiceQuotaChangeHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRequestedServiceQuotaChangeHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRequestedServiceQuotaChangeHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRequestedServiceQuotaChangeHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRequestedServiceQuotaChangeHistoryOutputError>
}

public struct ListRequestedServiceQuotaChangeHistoryInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?
    /// The service identifier.
    public let serviceCode: Swift.String?
    /// The status of the quota increase request.
    public let status: ServiceQuotasClientTypes.RequestStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        status: ServiceQuotasClientTypes.RequestStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
        self.status = status
    }
}

struct ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let status: ServiceQuotasClientTypes.RequestStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRequestedServiceQuotaChangeHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRequestedServiceQuotaChangeHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRequestedServiceQuotaChangeHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRequestedServiceQuotaChangeHistoryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), requestedQuotas: \(Swift.String(describing: requestedQuotas)))"}
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRequestedServiceQuotaChangeHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestedQuotas = output.requestedQuotas
        } else {
            self.nextToken = nil
            self.requestedQuotas = nil
        }
    }
}

public struct ListRequestedServiceQuotaChangeHistoryOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the quota increase requests.
    public let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?

    public init (
        nextToken: Swift.String? = nil,
        requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestedQuotas = requestedQuotas
    }
}

struct ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let requestedQuotas: [ServiceQuotasClientTypes.RequestedServiceQuotaChange]?
}

extension ListRequestedServiceQuotaChangeHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestedQuotas = "RequestedQuotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestedQuotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.RequestedServiceQuotaChange?].self, forKey: .requestedQuotas)
        var requestedQuotasDecoded0:[ServiceQuotasClientTypes.RequestedServiceQuotaChange]? = nil
        if let requestedQuotasContainer = requestedQuotasContainer {
            requestedQuotasDecoded0 = [ServiceQuotasClientTypes.RequestedServiceQuotaChange]()
            for structure0 in requestedQuotasContainer {
                if let structure0 = structure0 {
                    requestedQuotasDecoded0?.append(structure0)
                }
            }
        }
        requestedQuotas = requestedQuotasDecoded0
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotaIncreaseRequestsInTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceQuotaIncreaseRequestsInTemplateInput(awsRegion: \(Swift.String(describing: awsRegion)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotaIncreaseRequestsInTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotaIncreaseRequestsInTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotaIncreaseRequestsInTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotaIncreaseRequestsInTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotaIncreaseRequestsInTemplateOutputError>
}

public struct ListServiceQuotaIncreaseRequestsInTemplateInput: Swift.Equatable {
    /// The AWS Region.
    public let awsRegion: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?
    /// The service identifier.
    public let serviceCode: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let awsRegion: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServiceQuotaIncreaseRequestsInTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceQuotaIncreaseRequestsInTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceQuotaIncreaseRequestsInTemplateOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serviceQuotaIncreaseRequestInTemplateList: \(Swift.String(describing: serviceQuotaIncreaseRequestInTemplateList)))"}
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceQuotaIncreaseRequestInTemplateList = output.serviceQuotaIncreaseRequestInTemplateList
        } else {
            self.nextToken = nil
            self.serviceQuotaIncreaseRequestInTemplateList = nil
        }
    }
}

public struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the quota increase requests.
    public let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?

    public init (
        nextToken: Swift.String? = nil,
        serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateList
    }
}

struct ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Swift.Equatable {
    public let serviceQuotaIncreaseRequestInTemplateList: [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]?
    public let nextToken: Swift.String?
}

extension ListServiceQuotaIncreaseRequestsInTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceQuotaIncreaseRequestInTemplateList = "ServiceQuotaIncreaseRequestInTemplateList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateListContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?].self, forKey: .serviceQuotaIncreaseRequestInTemplateList)
        var serviceQuotaIncreaseRequestInTemplateListDecoded0:[ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]? = nil
        if let serviceQuotaIncreaseRequestInTemplateListContainer = serviceQuotaIncreaseRequestInTemplateListContainer {
            serviceQuotaIncreaseRequestInTemplateListDecoded0 = [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]()
            for structure0 in serviceQuotaIncreaseRequestInTemplateListContainer {
                if let structure0 = structure0 {
                    serviceQuotaIncreaseRequestInTemplateListDecoded0?.append(structure0)
                }
            }
        }
        serviceQuotaIncreaseRequestInTemplateList = serviceQuotaIncreaseRequestInTemplateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServiceQuotasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotasOutputError>
}

extension ListServiceQuotasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceQuotasInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ListServiceQuotasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct ListServiceQuotasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotasOutputError>
}

public struct ListServiceQuotasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceQuotasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceQuotasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceQuotasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceQuotasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceQuotasOutputError>
}

public struct ListServiceQuotasInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct ListServiceQuotasInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServiceQuotasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServiceQuotasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceQuotasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceQuotasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceQuotasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceQuotasOutputResponse(nextToken: \(Swift.String(describing: nextToken)), quotas: \(Swift.String(describing: quotas)))"}
}

extension ListServiceQuotasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceQuotasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.quotas = output.quotas
        } else {
            self.nextToken = nil
            self.quotas = nil
        }
    }
}

public struct ListServiceQuotasOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the quotas.
    public let quotas: [ServiceQuotasClientTypes.ServiceQuota]?

    public init (
        nextToken: Swift.String? = nil,
        quotas: [ServiceQuotasClientTypes.ServiceQuota]? = nil
    )
    {
        self.nextToken = nextToken
        self.quotas = quotas
    }
}

struct ListServiceQuotasOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let quotas: [ServiceQuotasClientTypes.ServiceQuota]?
}

extension ListServiceQuotasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case quotas = "Quotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let quotasContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceQuota?].self, forKey: .quotas)
        var quotasDecoded0:[ServiceQuotasClientTypes.ServiceQuota]? = nil
        if let quotasContainer = quotasContainer {
            quotasDecoded0 = [ServiceQuotasClientTypes.ServiceQuota]()
            for structure0 in quotasContainer {
                if let structure0 = structure0 {
                    quotasDecoded0?.append(structure0)
                }
            }
        }
        quotas = quotasDecoded0
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining
    ///       results, if any, make another call with the token returned from this call.
    public let maxResults: Swift.Int?
    /// The token for the next page of results.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), services: \(Swift.String(describing: services)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are
    ///       no more results to return.
    public let nextToken: Swift.String?
    /// Information about the services.
    public let services: [ServiceQuotasClientTypes.ServiceInfo]?

    public init (
        nextToken: Swift.String? = nil,
        services: [ServiceQuotasClientTypes.ServiceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let services: [ServiceQuotasClientTypes.ServiceInfo]?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let servicesContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.ServiceInfo?].self, forKey: .services)
        var servicesDecoded0:[ServiceQuotasClientTypes.ServiceInfo]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceQuotasClientTypes.ServiceInfo]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota for which you want to list tags. You
    ///       can get this information by using the Service Quotas console, or by listing the quotas using the
    ///         <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas AWS API operation.
    /// This member is required.
    public let resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A complex data type that contains zero or more tag elements.
    public let tags: [ServiceQuotasClientTypes.Tag]?

    public init (
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [ServiceQuotasClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ServiceQuotasClientTypes.MetricInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDimensions = "MetricDimensions"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case metricStatisticRecommendation = "MetricStatisticRecommendation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDimensions = metricDimensions {
            var metricDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metricDimensions)
            for (dictKey0, metricdimensionsmapdefinition0) in metricDimensions {
                try metricDimensionsContainer.encode(metricdimensionsmapdefinition0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricStatisticRecommendation = metricStatisticRecommendation {
            try encodeContainer.encode(metricStatisticRecommendation, forKey: .metricStatisticRecommendation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metricDimensions)
        var metricDimensionsDecoded0: [Swift.String:Swift.String]? = nil
        if let metricDimensionsContainer = metricDimensionsContainer {
            metricDimensionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, metricdimensionvalue0) in metricDimensionsContainer {
                if let metricdimensionvalue0 = metricdimensionvalue0 {
                    metricDimensionsDecoded0?[key0] = metricdimensionvalue0
                }
            }
        }
        metricDimensions = metricDimensionsDecoded0
        let metricStatisticRecommendationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricStatisticRecommendation)
        metricStatisticRecommendation = metricStatisticRecommendationDecoded
    }
}

extension ServiceQuotasClientTypes.MetricInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricInfo(metricDimensions: \(Swift.String(describing: metricDimensions)), metricName: \(Swift.String(describing: metricName)), metricNamespace: \(Swift.String(describing: metricNamespace)), metricStatisticRecommendation: \(Swift.String(describing: metricStatisticRecommendation)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about the CloudWatch metric that reflects quota usage.
    public struct MetricInfo: Swift.Equatable {
        /// The metric dimension. This is a name/value pair that is part of the identity of a
        ///       metric.
        public let metricDimensions: [Swift.String:Swift.String]?
        /// The name of the metric.
        public let metricName: Swift.String?
        /// The namespace of the metric.
        public let metricNamespace: Swift.String?
        /// The metric statistic that we recommend you use when determining quota usage.
        public let metricStatisticRecommendation: Swift.String?

        public init (
            metricDimensions: [Swift.String:Swift.String]? = nil,
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricStatisticRecommendation: Swift.String? = nil
        )
        {
            self.metricDimensions = metricDimensions
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricStatisticRecommendation = metricStatisticRecommendation
        }
    }

}

extension NoAvailableOrganizationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoAvailableOrganizationException(message: \(Swift.String(describing: message)))"}
}

extension NoAvailableOrganizationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The account making this call is not a member of an organization.
public struct NoAvailableOrganizationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoAvailableOrganizationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResourceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchResourceException(message: \(Swift.String(describing: message)))"}
}

extension NoSuchResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoSuchResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct NoSuchResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationNotInAllFeaturesModeException(message: \(Swift.String(describing: message)))"}
}

extension OrganizationNotInAllFeaturesModeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The organization that your account belongs to is not in All Features mode.
public struct OrganizationNotInAllFeaturesModeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum PeriodUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case microsecond
        case millisecond
        case minute
        case second
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [PeriodUnit] {
            return [
                .day,
                .hour,
                .microsecond,
                .millisecond,
                .minute,
                .second,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .microsecond: return "MICROSECOND"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PeriodUnit(rawValue: rawValue) ?? PeriodUnit.sdkUnknown(rawValue)
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutServiceQuotaIncreaseRequestIntoTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutServiceQuotaIncreaseRequestIntoTemplateInput(awsRegion: \(Swift.String(describing: awsRegion)), desiredValue: \(Swift.String(describing: desiredValue)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutServiceQuotaIncreaseRequestIntoTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutServiceQuotaIncreaseRequestIntoTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutServiceQuotaIncreaseRequestIntoTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutServiceQuotaIncreaseRequestIntoTemplateOutputError>
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateInput: Swift.Equatable {
    /// The AWS Region.
    /// This member is required.
    public let awsRegion: Swift.String?
    /// The new, increased value for the quota.
    /// This member is required.
    public let desiredValue: Swift.Double?
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Equatable {
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
    public let awsRegion: Swift.String?
    public let desiredValue: Swift.Double?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AWSServiceAccessNotEnabledException" : self = .aWSServiceAccessNotEnabledException(try AWSServiceAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceededException" : self = .quotaExceededException(try QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplatesNotAvailableInRegionException" : self = .templatesNotAvailableInRegionException(try TemplatesNotAvailableInRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutServiceQuotaIncreaseRequestIntoTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case aWSServiceAccessNotEnabledException(AWSServiceAccessNotEnabledException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case noSuchResourceException(NoSuchResourceException)
    case quotaExceededException(QuotaExceededException)
    case serviceException(ServiceException)
    case templatesNotAvailableInRegionException(TemplatesNotAvailableInRegionException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse(serviceQuotaIncreaseRequestInTemplate: \(Swift.String(describing: serviceQuotaIncreaseRequestInTemplate)))"}
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceQuotaIncreaseRequestInTemplate = output.serviceQuotaIncreaseRequestInTemplate
        } else {
            self.serviceQuotaIncreaseRequestInTemplate = nil
        }
    }
}

public struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?

    public init (
        serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate? = nil
    )
    {
        self.serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplate
    }
}

struct PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Swift.Equatable {
    public let serviceQuotaIncreaseRequestInTemplate: ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate?
}

extension PutServiceQuotaIncreaseRequestIntoTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceQuotaIncreaseRequestInTemplate = "ServiceQuotaIncreaseRequestInTemplate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceQuotaIncreaseRequestInTemplateDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate.self, forKey: .serviceQuotaIncreaseRequestInTemplate)
        serviceQuotaIncreaseRequestInTemplate = serviceQuotaIncreaseRequestInTemplateDecoded
    }
}

extension QuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension QuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the
///       relevant resources, or use Service Quotas to request a service quota increase.
public struct QuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension QuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case periodUnit = "PeriodUnit"
        case periodValue = "PeriodValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodUnit = periodUnit {
            try encodeContainer.encode(periodUnit.rawValue, forKey: .periodUnit)
        }
        if let periodValue = periodValue {
            try encodeContainer.encode(periodValue, forKey: .periodValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodValue)
        periodValue = periodValueDecoded
        let periodUnitDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.PeriodUnit.self, forKey: .periodUnit)
        periodUnit = periodUnitDecoded
    }
}

extension ServiceQuotasClientTypes.QuotaPeriod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuotaPeriod(periodUnit: \(Swift.String(describing: periodUnit)), periodValue: \(Swift.String(describing: periodValue)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about the quota period.
    public struct QuotaPeriod: Swift.Equatable {
        /// The time unit.
        public let periodUnit: ServiceQuotasClientTypes.PeriodUnit?
        /// The value.
        public let periodValue: Swift.Int?

        public init (
            periodUnit: ServiceQuotasClientTypes.PeriodUnit? = nil,
            periodValue: Swift.Int? = nil
        )
        {
            self.periodUnit = periodUnit
            self.periodValue = periodValue
        }
    }

}

public struct RequestServiceQuotaIncreaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RequestServiceQuotaIncreaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RequestServiceQuotaIncreaseOutputError>
}

extension RequestServiceQuotaIncreaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestServiceQuotaIncreaseInput(desiredValue: \(Swift.String(describing: desiredValue)), quotaCode: \(Swift.String(describing: quotaCode)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension RequestServiceQuotaIncreaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

public struct RequestServiceQuotaIncreaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RequestServiceQuotaIncreaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RequestServiceQuotaIncreaseOutputError>
}

public struct RequestServiceQuotaIncreaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RequestServiceQuotaIncreaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RequestServiceQuotaIncreaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RequestServiceQuotaIncreaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RequestServiceQuotaIncreaseOutputError>
}

public struct RequestServiceQuotaIncreaseInput: Swift.Equatable {
    /// The new, increased value for the quota.
    /// This member is required.
    public let desiredValue: Swift.Double?
    /// The quota identifier.
    /// This member is required.
    public let quotaCode: Swift.String?
    /// The service identifier.
    /// This member is required.
    public let serviceCode: Swift.String?

    public init (
        desiredValue: Swift.Double? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.desiredValue = desiredValue
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct RequestServiceQuotaIncreaseInputBody: Swift.Equatable {
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
    public let desiredValue: Swift.Double?
}

extension RequestServiceQuotaIncreaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredValue = "DesiredValue"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
    }
}

extension RequestServiceQuotaIncreaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RequestServiceQuotaIncreaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyAccessDeniedException" : self = .dependencyAccessDeniedException(try DependencyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceededException" : self = .quotaExceededException(try QuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RequestServiceQuotaIncreaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dependencyAccessDeniedException(DependencyAccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case invalidResourceStateException(InvalidResourceStateException)
    case noSuchResourceException(NoSuchResourceException)
    case quotaExceededException(QuotaExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RequestServiceQuotaIncreaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestServiceQuotaIncreaseOutputResponse(requestedQuota: \(Swift.String(describing: requestedQuota)))"}
}

extension RequestServiceQuotaIncreaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestServiceQuotaIncreaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestedQuota = output.requestedQuota
        } else {
            self.requestedQuota = nil
        }
    }
}

public struct RequestServiceQuotaIncreaseOutputResponse: Swift.Equatable {
    /// Information about the quota increase request.
    public let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?

    public init (
        requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange? = nil
    )
    {
        self.requestedQuota = requestedQuota
    }
}

struct RequestServiceQuotaIncreaseOutputResponseBody: Swift.Equatable {
    public let requestedQuota: ServiceQuotasClientTypes.RequestedServiceQuotaChange?
}

extension RequestServiceQuotaIncreaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestedQuota = "RequestedQuota"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedQuotaDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestedServiceQuotaChange.self, forKey: .requestedQuota)
        requestedQuota = requestedQuotaDecoded
    }
}

extension ServiceQuotasClientTypes {
    public enum RequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case caseClosed
        case caseOpened
        case denied
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestStatus] {
            return [
                .approved,
                .caseClosed,
                .caseOpened,
                .denied,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .caseClosed: return "CASE_CLOSED"
            case .caseOpened: return "CASE_OPENED"
            case .denied: return "DENIED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestStatus(rawValue: rawValue) ?? RequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId = "CaseId"
        case created = "Created"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case id = "Id"
        case lastUpdated = "LastUpdated"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case requester = "Requester"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case status = "Status"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let quotaArn = quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let requester = requester {
            try encodeContainer.encode(requester, forKey: .requester)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.RequestStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let requesterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requester)
        requester = requesterDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let globalQuotaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ServiceQuotasClientTypes.RequestedServiceQuotaChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestedServiceQuotaChange(caseId: \(Swift.String(describing: caseId)), created: \(Swift.String(describing: created)), desiredValue: \(Swift.String(describing: desiredValue)), globalQuota: \(Swift.String(describing: globalQuota)), id: \(Swift.String(describing: id)), lastUpdated: \(Swift.String(describing: lastUpdated)), quotaArn: \(Swift.String(describing: quotaArn)), quotaCode: \(Swift.String(describing: quotaCode)), quotaName: \(Swift.String(describing: quotaName)), requester: \(Swift.String(describing: requester)), serviceCode: \(Swift.String(describing: serviceCode)), serviceName: \(Swift.String(describing: serviceName)), status: \(Swift.String(describing: status)), unit: \(Swift.String(describing: unit)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct RequestedServiceQuotaChange: Swift.Equatable {
        /// The case ID.
        public let caseId: Swift.String?
        /// The date and time when the quota increase request was received and the case ID was
        ///       created.
        public let created: ClientRuntime.Date?
        /// The new, increased value for the quota.
        public let desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public let globalQuota: Swift.Bool
        /// The unique identifier.
        public let id: Swift.String?
        /// The date and time of the most recent change.
        public let lastUpdated: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the quota.
        public let quotaArn: Swift.String?
        /// The quota identifier.
        public let quotaCode: Swift.String?
        /// The quota name.
        public let quotaName: Swift.String?
        /// The IAM identity of the requester.
        public let requester: Swift.String?
        /// The service identifier.
        public let serviceCode: Swift.String?
        /// The service name.
        public let serviceName: Swift.String?
        /// The state of the quota increase request.
        public let status: ServiceQuotasClientTypes.RequestStatus?
        /// The unit of measurement.
        public let unit: Swift.String?

        public init (
            caseId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            requester: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            status: ServiceQuotasClientTypes.RequestStatus? = nil,
            unit: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.created = created
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.id = id
            self.lastUpdated = lastUpdated
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.requester = requester
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.status = status
            self.unit = unit
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceException(message: \(Swift.String(describing: message)))"}
}

extension ServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Something went wrong.
public struct ServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceInfo(serviceCode: \(Swift.String(describing: serviceCode)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about a service.
    public struct ServiceInfo: Swift.Equatable {
        /// The service identifier.
        public let serviceCode: Swift.String?
        /// The service name.
        public let serviceName: Swift.String?

        public init (
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.serviceCode = serviceCode
            self.serviceName = serviceName
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuota: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustable = "Adjustable"
        case errorReason = "ErrorReason"
        case globalQuota = "GlobalQuota"
        case period = "Period"
        case quotaArn = "QuotaArn"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
        case usageMetric = "UsageMetric"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if adjustable != false {
            try encodeContainer.encode(adjustable, forKey: .adjustable)
        }
        if let errorReason = errorReason {
            try encodeContainer.encode(errorReason, forKey: .errorReason)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let period = period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let quotaArn = quotaArn {
            try encodeContainer.encode(quotaArn, forKey: .quotaArn)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageMetric = usageMetric {
            try encodeContainer.encode(usageMetric, forKey: .usageMetric)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaArn)
        quotaArn = quotaArnDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let adjustableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .adjustable)
        adjustable = adjustableDecoded
        let globalQuotaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
        let usageMetricDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.MetricInfo.self, forKey: .usageMetric)
        usageMetric = usageMetricDecoded
        let periodDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.QuotaPeriod.self, forKey: .period)
        period = periodDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(ServiceQuotasClientTypes.ErrorReason.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceQuota: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuota(adjustable: \(Swift.String(describing: adjustable)), errorReason: \(Swift.String(describing: errorReason)), globalQuota: \(Swift.String(describing: globalQuota)), period: \(Swift.String(describing: period)), quotaArn: \(Swift.String(describing: quotaArn)), quotaCode: \(Swift.String(describing: quotaCode)), quotaName: \(Swift.String(describing: quotaName)), serviceCode: \(Swift.String(describing: serviceCode)), serviceName: \(Swift.String(describing: serviceName)), unit: \(Swift.String(describing: unit)), usageMetric: \(Swift.String(describing: usageMetric)), value: \(Swift.String(describing: value)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about a quota.
    public struct ServiceQuota: Swift.Equatable {
        /// Indicates whether the quota value can be increased.
        public let adjustable: Swift.Bool
        /// The error code and error reason.
        public let errorReason: ServiceQuotasClientTypes.ErrorReason?
        /// Indicates whether the quota is global.
        public let globalQuota: Swift.Bool
        /// The period of time.
        public let period: ServiceQuotasClientTypes.QuotaPeriod?
        /// The Amazon Resource Name (ARN) of the quota.
        public let quotaArn: Swift.String?
        /// The quota identifier.
        public let quotaCode: Swift.String?
        /// The quota name.
        public let quotaName: Swift.String?
        /// The service identifier.
        public let serviceCode: Swift.String?
        /// The service name.
        public let serviceName: Swift.String?
        /// The unit of measurement.
        public let unit: Swift.String?
        /// Information about the measurement.
        public let usageMetric: ServiceQuotasClientTypes.MetricInfo?
        /// The quota value.
        public let value: Swift.Double?

        public init (
            adjustable: Swift.Bool = false,
            errorReason: ServiceQuotasClientTypes.ErrorReason? = nil,
            globalQuota: Swift.Bool = false,
            period: ServiceQuotasClientTypes.QuotaPeriod? = nil,
            quotaArn: Swift.String? = nil,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageMetric: ServiceQuotasClientTypes.MetricInfo? = nil,
            value: Swift.Double? = nil
        )
        {
            self.adjustable = adjustable
            self.errorReason = errorReason
            self.globalQuota = globalQuota
            self.period = period
            self.quotaArn = quotaArn
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
            self.usageMetric = usageMetric
            self.value = value
        }
    }

}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case desiredValue = "DesiredValue"
        case globalQuota = "GlobalQuota"
        case quotaCode = "QuotaCode"
        case quotaName = "QuotaName"
        case serviceCode = "ServiceCode"
        case serviceName = "ServiceName"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let desiredValue = desiredValue {
            try encodeContainer.encode(desiredValue, forKey: .desiredValue)
        }
        if globalQuota != false {
            try encodeContainer.encode(globalQuota, forKey: .globalQuota)
        }
        if let quotaCode = quotaCode {
            try encodeContainer.encode(quotaCode, forKey: .quotaCode)
        }
        if let quotaName = quotaName {
            try encodeContainer.encode(quotaName, forKey: .quotaName)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let desiredValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .desiredValue)
        desiredValue = desiredValueDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let globalQuotaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .globalQuota)
        globalQuota = globalQuotaDecoded
    }
}

extension ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaIncreaseRequestInTemplate(awsRegion: \(Swift.String(describing: awsRegion)), desiredValue: \(Swift.String(describing: desiredValue)), globalQuota: \(Swift.String(describing: globalQuota)), quotaCode: \(Swift.String(describing: quotaCode)), quotaName: \(Swift.String(describing: quotaName)), serviceCode: \(Swift.String(describing: serviceCode)), serviceName: \(Swift.String(describing: serviceName)), unit: \(Swift.String(describing: unit)))"}
}

extension ServiceQuotasClientTypes {
    /// Information about a quota increase request.
    public struct ServiceQuotaIncreaseRequestInTemplate: Swift.Equatable {
        /// The AWS Region.
        public let awsRegion: Swift.String?
        /// The new, increased value of the quota.
        public let desiredValue: Swift.Double?
        /// Indicates whether the quota is global.
        public let globalQuota: Swift.Bool
        /// The quota identifier.
        public let quotaCode: Swift.String?
        /// The quota name.
        public let quotaName: Swift.String?
        /// The service identifier.
        public let serviceCode: Swift.String?
        /// The service name.
        public let serviceName: Swift.String?
        /// The unit of measurement.
        public let unit: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            desiredValue: Swift.Double? = nil,
            globalQuota: Swift.Bool = false,
            quotaCode: Swift.String? = nil,
            quotaName: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.desiredValue = desiredValue
            self.globalQuota = globalQuota
            self.quotaCode = quotaCode
            self.quotaName = quotaName
            self.serviceCode = serviceCode
            self.serviceName = serviceName
            self.unit = unit
        }
    }

}

extension ServiceQuotasClientTypes {
    public enum ServiceQuotaTemplateAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaTemplateAssociationStatus] {
            return [
                .associated,
                .disassociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaTemplateAssociationStatus(rawValue: rawValue) ?? ServiceQuotaTemplateAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaTemplateNotInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaTemplateNotInUseException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaTemplateNotInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaTemplateNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota request template is not associated with your organization.
public struct ServiceQuotaTemplateNotInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaTemplateNotInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaTemplateNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotasClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceQuotasClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceQuotasClientTypes {
    /// A complex data type that contains a tag key and tag value.
    public struct Tag: Swift.Equatable {
        /// A string that contains a tag key. The string length should be between 1 and 128
        ///       characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ - . :
        ///       / = + @.
        /// This member is required.
        public let key: Swift.String?
        /// A string that contains an optional tag value. The string length should be between 0 and
        ///       256 characters. Valid characters include a-z, A-Z, 0-9, space, and the special characters _ -
        ///       . : / = + @.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagPolicyViolationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagPolicyViolationException(message: \(Swift.String(describing: message)))"}
}

extension TagPolicyViolationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified tag is a reserved word and cannot be used.
public struct TagPolicyViolationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for inputtags0 in tags {
                try tagsContainer.encode(inputtags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota. You can get this information by
    ///       using the Service Quotas console, or by listing the quotas using the <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas AWS API operation.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The tags that you want to add to the resource.
    /// This member is required.
    public let tags: [ServiceQuotasClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ServiceQuotasClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [ServiceQuotasClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceQuotasClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceQuotasClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceQuotasClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TemplatesNotAvailableInRegionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TemplatesNotAvailableInRegionException(message: \(Swift.String(describing: message)))"}
}

extension TemplatesNotAvailableInRegionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TemplatesNotAvailableInRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Service Quotas template is not available in this AWS Region.
public struct TemplatesNotAvailableInRegionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TemplatesNotAvailableInRegionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TemplatesNotAvailableInRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Due to throttling, the request was denied. Slow down the rate of request calls, or request
///       an increase for this quota.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. For more information, see
///         <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/sq-tagging.html#sq-tagging-restrictions">Tag
///         restrictions in the Service Quotas User Guide.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for inputtagkeys0 in tagKeys {
                try tagKeysContainer.encode(inputtagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the applied quota that you want to untag. You can get
    ///       this information by using the Service Quotas console, or by listing the quotas using the <a href="https://docs.aws.amazon.com/cli/latest/reference/service-quotas/list-service-quotas.html">list-service-quotas AWS CLI command or the <a href="https://docs.aws.amazon.com/servicequotas/2019-06-24/apireference/API_ListServiceQuotas.html">ListServiceQuotas AWS API operation.
    /// This member is required.
    public let resourceARN: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalArgumentException" : self = .illegalArgumentException(try IllegalArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResourceException" : self = .noSuchResourceException(try NoSuchResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case illegalArgumentException(IllegalArgumentException)
    case noSuchResourceException(NoSuchResourceException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
