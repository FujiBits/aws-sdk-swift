// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppConfigClientTypes.Application: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppConfigClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension AppConfigClientTypes {
    public struct Application: Swift.Equatable {
        /// The description of the application.
        public var description: Swift.String?
        /// The application ID.
        public var id: Swift.String?
        /// The application name.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppConfigClientTypes {
    public enum BytesMeasure: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilobytes
        case sdkUnknown(Swift.String)

        public static var allCases: [BytesMeasure] {
            return [
                .kilobytes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilobytes: return "KILOBYTES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BytesMeasure(rawValue: rawValue) ?? BytesMeasure.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.ConfigurationProfileSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case validatorTypes = "ValidatorTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validatorTypes = validatorTypes {
            var validatorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatorTypes)
            for validatortypelist0 in validatorTypes {
                try validatorTypesContainer.encode(validatortypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let validatorTypesContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ValidatorType?].self, forKey: .validatorTypes)
        var validatorTypesDecoded0:[AppConfigClientTypes.ValidatorType]? = nil
        if let validatorTypesContainer = validatorTypesContainer {
            validatorTypesDecoded0 = [AppConfigClientTypes.ValidatorType]()
            for string0 in validatorTypesContainer {
                if let string0 = string0 {
                    validatorTypesDecoded0?.append(string0)
                }
            }
        }
        validatorTypes = validatorTypesDecoded0
    }
}

extension AppConfigClientTypes.ConfigurationProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationProfileSummary(applicationId: \(Swift.String(describing: applicationId)), id: \(Swift.String(describing: id)), locationUri: \(Swift.String(describing: locationUri)), name: \(Swift.String(describing: name)), validatorTypes: \(Swift.String(describing: validatorTypes)))"}
}

extension AppConfigClientTypes {
    /// A summary of a configuration profile.
    public struct ConfigurationProfileSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The ID of the configuration profile.
        public var id: Swift.String?
        /// The URI location of the configuration.
        public var locationUri: Swift.String?
        /// The name of the configuration profile.
        public var name: Swift.String?
        /// The types of validators in the configuration profile.
        public var validatorTypes: [AppConfigClientTypes.ValidatorType]?

        public init (
            applicationId: Swift.String? = nil,
            id: Swift.String? = nil,
            locationUri: Swift.String? = nil,
            name: Swift.String? = nil,
            validatorTypes: [AppConfigClientTypes.ValidatorType]? = nil
        )
        {
            self.applicationId = applicationId
            self.id = id
            self.locationUri = locationUri
            self.name = name
            self.validatorTypes = validatorTypes
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the
///          resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A description of the application.
    public var description: Swift.String?
    /// A name for the application.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the application. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutputResponse(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct CreateConfigurationProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationProfileOutputError>
}

extension CreateConfigurationProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationProfileInput(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), locationUri: \(Swift.String(describing: locationUri)), name: \(Swift.String(describing: name)), retrievalRoleArn: \(Swift.String(describing: retrievalRoleArn)), tags: \(Swift.String(describing: tags)), validators: \(Swift.String(describing: validators)))"}
}

extension CreateConfigurationProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

public struct CreateConfigurationProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// A URI to locate the configuration. You can specify a Systems Manager (SSM) document, an SSM
    ///          Parameter Store parameter, or an Amazon S3 object. For an SSM document, specify either the
    ///          document name in the format ssm-document://<Document_name> or the Amazon
    ///          Resource Name (ARN). For a parameter, specify either the parameter name in the format
    ///             ssm-parameter://<Parameter_name> or the ARN. For an Amazon S3 object,
    ///          specify the URI in the following format: s3://<bucket>/<objectKey>
    ///          . Here is an example: s3://my-bucket/my-app/us-east-1/my-config.json
    /// This member is required.
    public var locationUri: Swift.String?
    /// A name for the configuration profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// Metadata to assign to the configuration profile. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.tags = tags
        self.validators = validators
    }
}

struct CreateConfigurationProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let locationUri: Swift.String?
    public let retrievalRoleArn: Swift.String?
    public let validators: [AppConfigClientTypes.Validator]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationProfileOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), locationUri: \(Swift.String(describing: locationUri)), name: \(Swift.String(describing: name)), retrievalRoleArn: \(Swift.String(describing: retrievalRoleArn)), validators: \(Swift.String(describing: validators)))"}
}

extension CreateConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct CreateConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct CreateConfigurationProfileOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let locationUri: Swift.String?
    public let retrievalRoleArn: Swift.String?
    public let validators: [AppConfigClientTypes.Validator]?
}

extension CreateConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

public struct CreateDeploymentStrategyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentStrategyOutputError>
}

extension CreateDeploymentStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentStrategyInput(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), name: \(Swift.String(describing: name)), replicateTo: \(Swift.String(describing: replicateTo)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDeploymentStrategyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentStrategyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentStrategyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentStrategyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/deploymentstrategies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    /// This member is required.
    public var deploymentDurationInMinutes: Swift.Int
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitors for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each
    ///          interval.
    /// This member is required.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grows over time. AWS AppConfig supports the
    ///          following growth types:
    ///
    ///             Linear: For this type, AppConfig processes the
    ///          deployment by dividing the total number of targets by the value specified for Step
    ///             percentage. For example, a linear deployment that uses a Step
    ///             percentage of 10 deploys the configuration to 10 percent of the hosts. After
    ///          those deployments are complete, the system deploys the configuration to the next 10
    ///          percent. This continues until 100% of the targets have successfully received the
    ///          configuration.
    ///
    ///
    ///             Exponential: For this type, AppConfig processes the
    ///          deployment exponentially using the following formula: G*(2^N). In this
    ///          formula, G is the growth factor specified by the user and N is
    ///          the number of steps until the configuration is deployed to all targets. For example, if you
    ///          specify a growth factor of 2, then the system rolls out the configuration as
    ///          follows:
    ///
    ///             2*(2^0)
    ///
    ///
    ///             2*(2^1)
    ///
    ///
    ///             2*(2^2)
    ///
    ///          Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the
    ///          targets, 8% of the targets, and continues until the configuration has been deployed to all
    ///          targets.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// A name for the deployment strategy.
    /// This member is required.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    /// This member is required.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?
    /// Metadata to assign to the deployment strategy. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.name = name
        self.replicateTo = replicateTo
        self.tags = tags
    }
}

struct CreateDeploymentStrategyInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let finalBakeTimeInMinutes: Swift.Int
    public let growthFactor: Swift.Float
    public let growthType: AppConfigClientTypes.GrowthType?
    public let replicateTo: AppConfigClientTypes.ReplicateTo?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentStrategyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), replicateTo: \(Swift.String(describing: replicateTo)))"}
}

extension CreateDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct CreateDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct CreateDeploymentStrategyOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension CreateDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

public struct CreateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// A name for the environment.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the environment. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.monitors = monitors
        self.name = name
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let monitors: [AppConfigClientTypes.Monitor]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension CreateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states:
    ///             READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or
    ///             ROLLED_BACK
    ///
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct CreateEnvironmentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let state: AppConfigClientTypes.EnvironmentState?
    public let monitors: [AppConfigClientTypes.Monitor]?
}

extension CreateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

public struct CreateHostedConfigurationVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let content = input.operationInput.content {
            let contentdata = content
            let contentbody = ClientRuntime.HttpBody.data(contentdata)
            input.builder.withBody(contentbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHostedConfigurationVersionOutputError>
}

extension CreateHostedConfigurationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHostedConfigurationVersionInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), latestVersionNumber: \(Swift.String(describing: latestVersionNumber)))"}
}

extension CreateHostedConfigurationVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
    }
}

public struct CreateHostedConfigurationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: Swift.String(contentType))
        }
        if let description = input.operationInput.description {
            input.builder.withHeader(name: "Description", value: Swift.String(description))
        }
        if input.operationInput.latestVersionNumber != 0 {
            input.builder.withHeader(name: "Latest-Version-Number", value: Swift.String(input.operationInput.latestVersionNumber))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    /// This member is required.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type.
    /// This member is required.
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// An optional locking token used to prevent race conditions from overwriting configuration
    ///          updates when creating a new version. To ensure your data is not overwritten when creating
    ///          multiple hosted configuration versions in rapid succession, specify the version of the
    ///          latest hosted configuration version.
    public var latestVersionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.latestVersionNumber = latestVersionNumber
    }
}

struct CreateHostedConfigurationVersionInputBody: Swift.Equatable {
    public let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case payloadTooLargeException(PayloadTooLargeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHostedConfigurationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHostedConfigurationVersionOutputResponse(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension CreateHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct CreateHostedConfigurationVersionOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type.
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct CreateHostedConfigurationVersionOutputResponseBody: Swift.Equatable {
    public let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension DeleteApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationInput(applicationId: \(Swift.String(describing: applicationId)))"}
}

extension DeleteApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application to delete.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Swift.Equatable {
}

extension DeleteApplicationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationProfileInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)))"}
}

extension DeleteConfigurationProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteConfigurationProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConfigurationProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInput: Swift.Equatable {
    /// The application ID that includes the configuration profile you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile you want to delete.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct DeleteConfigurationProfileInputBody: Swift.Equatable {
}

extension DeleteConfigurationProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConfigurationProfileOutputResponse()"}
}

extension DeleteConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteConfigurationProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteConfigurationProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeploymentStrategyInput(deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)))"}
}

extension DeleteDeploymentStrategyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDeploymentStrategyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeploymentStrategyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDeploymentStrategyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let deploymentStrategyId = input.deploymentStrategyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deploymentStrategyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/deployementstrategies/\(deploymentStrategyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy you want to delete.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init (
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct DeleteDeploymentStrategyInputBody: Swift.Equatable {
}

extension DeleteDeploymentStrategyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentStrategyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDeploymentStrategyOutputResponse()"}
}

extension DeleteDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentStrategyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDeploymentStrategyOutputResponseBody: Swift.Equatable {
}

extension DeleteDeploymentStrategyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentInput(applicationId: \(Swift.String(describing: applicationId)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension DeleteEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The application ID that includes the environment you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment you want to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Swift.Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHostedConfigurationVersionInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension DeleteHostedConfigurationVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteHostedConfigurationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHostedConfigurationVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHostedConfigurationVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The versions number to delete.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct DeleteHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension DeleteHostedConfigurationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHostedConfigurationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHostedConfigurationVersionOutputResponse()"}
}

extension DeleteHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHostedConfigurationVersionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteHostedConfigurationVersionOutputResponseBody: Swift.Equatable {
}

extension DeleteHostedConfigurationVersionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppConfigClientTypes.DeploymentEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventType = "EventType"
        case occurredAt = "OccurredAt"
        case triggeredBy = "TriggeredBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let occurredAt = occurredAt {
            try encodeContainer.encode(occurredAt.timeIntervalSince1970, forKey: .occurredAt)
        }
        if let triggeredBy = triggeredBy {
            try encodeContainer.encode(triggeredBy.rawValue, forKey: .triggeredBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let triggeredByDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.TriggeredBy.self, forKey: .triggeredBy)
        triggeredBy = triggeredByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let occurredAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .occurredAt)
        occurredAt = occurredAtDecoded
    }
}

extension AppConfigClientTypes.DeploymentEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentEvent(description: \(Swift.String(describing: description)), eventType: \(Swift.String(describing: eventType)), occurredAt: \(Swift.String(describing: occurredAt)), triggeredBy: \(Swift.String(describing: triggeredBy)))"}
}

extension AppConfigClientTypes {
    /// An object that describes a deployment event.
    public struct DeploymentEvent: Swift.Equatable {
        /// A description of the deployment event. Descriptions include, but are not limited to, the
        ///          user account or the CloudWatch alarm ARN that initiated a rollback, the percentage of hosts
        ///          that received the deployment, or in the case of an internal error, a recommendation to
        ///          attempt a new deployment.
        public var description: Swift.String?
        /// The type of deployment event. Deployment event types include the start, stop, or
        ///          completion of a deployment; a percentage update; the start or stop of a bake period; the
        ///          start or completion of a rollback.
        public var eventType: AppConfigClientTypes.DeploymentEventType?
        /// The date and time the event occurred.
        public var occurredAt: ClientRuntime.Date?
        /// The entity that triggered the deployment event. Events can be triggered by a user, AWS
        ///          AppConfig, an Amazon CloudWatch alarm, or an internal error.
        public var triggeredBy: AppConfigClientTypes.TriggeredBy?

        public init (
            description: Swift.String? = nil,
            eventType: AppConfigClientTypes.DeploymentEventType? = nil,
            occurredAt: ClientRuntime.Date? = nil,
            triggeredBy: AppConfigClientTypes.TriggeredBy? = nil
        )
        {
            self.description = description
            self.eventType = eventType
            self.occurredAt = occurredAt
            self.triggeredBy = triggeredBy
        }
    }

}

extension AppConfigClientTypes {
    public enum DeploymentEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bakeTimeStarted
        case deploymentCompleted
        case deploymentStarted
        case percentageUpdated
        case rollbackCompleted
        case rollbackStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentEventType] {
            return [
                .bakeTimeStarted,
                .deploymentCompleted,
                .deploymentStarted,
                .percentageUpdated,
                .rollbackCompleted,
                .rollbackStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bakeTimeStarted: return "BAKE_TIME_STARTED"
            case .deploymentCompleted: return "DEPLOYMENT_COMPLETED"
            case .deploymentStarted: return "DEPLOYMENT_STARTED"
            case .percentageUpdated: return "PERCENTAGE_UPDATED"
            case .rollbackCompleted: return "ROLLBACK_COMPLETED"
            case .rollbackStarted: return "ROLLBACK_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentEventType(rawValue: rawValue) ?? DeploymentEventType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes {
    public enum DeploymentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case baking
        case complete
        case deploying
        case rolledBack
        case rollingBack
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentState] {
            return [
                .baking,
                .complete,
                .deploying,
                .rolledBack,
                .rollingBack,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .baking: return "BAKING"
            case .complete: return "COMPLETE"
            case .deploying: return "DEPLOYING"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.DeploymentStrategy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension AppConfigClientTypes.DeploymentStrategy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentStrategy(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), replicateTo: \(Swift.String(describing: replicateTo)))"}
}

extension AppConfigClientTypes {
    public struct DeploymentStrategy: Swift.Equatable {
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The description of the deployment strategy.
        public var description: Swift.String?
        /// The amount of time AppConfig monitored for alarms before considering the deployment to be
        ///          complete and no longer eligible for automatic roll back.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets that received a deployed configuration during each
        ///          interval.
        public var growthFactor: Swift.Float
        /// The algorithm used to define how percentage grew over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The deployment strategy ID.
        public var id: Swift.String?
        /// The name of the deployment strategy.
        public var name: Swift.String?
        /// Save the deployment strategy to a Systems Manager (SSM) document.
        public var replicateTo: AppConfigClientTypes.ReplicateTo?

        public init (
            deploymentDurationInMinutes: Swift.Int = 0,
            description: Swift.String? = nil,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float = 0.0,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            replicateTo: AppConfigClientTypes.ReplicateTo? = nil
        )
        {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.id = id
            self.name = name
            self.replicateTo = replicateTo
        }
    }

}

extension AppConfigClientTypes.DeploymentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt = "CompletedAt"
        case configurationName = "ConfigurationName"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let configurationName = configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if deploymentNumber != 0 {
            try encodeContainer.encode(deploymentNumber, forKey: .deploymentNumber)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if percentageComplete != 0.0 {
            try encodeContainer.encode(percentageComplete, forKey: .percentageComplete)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension AppConfigClientTypes.DeploymentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentSummary(completedAt: \(Swift.String(describing: completedAt)), configurationName: \(Swift.String(describing: configurationName)), configurationVersion: \(Swift.String(describing: configurationVersion)), deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), percentageComplete: \(Swift.String(describing: percentageComplete)), startedAt: \(Swift.String(describing: startedAt)), state: \(Swift.String(describing: state)))"}
}

extension AppConfigClientTypes {
    /// Information about the deployment.
    public struct DeploymentSummary: Swift.Equatable {
        /// Time the deployment completed.
        public var completedAt: ClientRuntime.Date?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The version of the configuration.
        public var configurationVersion: Swift.String?
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The sequence number of the deployment.
        public var deploymentNumber: Swift.Int
        /// The amount of time AppConfig monitors for alarms before considering the deployment to be
        ///          complete and no longer eligible for automatic roll back.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets to receive a deployed configuration during each
        ///          interval.
        public var growthFactor: Swift.Float
        /// The algorithm used to define how percentage grows over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The percentage of targets for which the deployment is available.
        public var percentageComplete: Swift.Float
        /// Time the deployment started.
        public var startedAt: ClientRuntime.Date?
        /// The state of the deployment.
        public var state: AppConfigClientTypes.DeploymentState?

        public init (
            completedAt: ClientRuntime.Date? = nil,
            configurationName: Swift.String? = nil,
            configurationVersion: Swift.String? = nil,
            deploymentDurationInMinutes: Swift.Int = 0,
            deploymentNumber: Swift.Int = 0,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float = 0.0,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            percentageComplete: Swift.Float = 0.0,
            startedAt: ClientRuntime.Date? = nil,
            state: AppConfigClientTypes.DeploymentState? = nil
        )
        {
            self.completedAt = completedAt
            self.configurationName = configurationName
            self.configurationVersion = configurationVersion
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentNumber = deploymentNumber
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.percentageComplete = percentageComplete
            self.startedAt = startedAt
            self.state = state
        }
    }

}

extension AppConfigClientTypes.Environment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension AppConfigClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension AppConfigClientTypes {
    public struct Environment: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The environment ID.
        public var id: Swift.String?
        /// Amazon CloudWatch alarms monitored during the deployment.
        public var monitors: [AppConfigClientTypes.Monitor]?
        /// The name of the environment.
        public var name: Swift.String?
        /// The state of the environment. An environment can be in one of the following states:
        ///             READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or
        ///             ROLLED_BACK
        ///
        public var state: AppConfigClientTypes.EnvironmentState?

        public init (
            applicationId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            monitors: [AppConfigClientTypes.Monitor]? = nil,
            name: Swift.String? = nil,
            state: AppConfigClientTypes.EnvironmentState? = nil
        )
        {
            self.applicationId = applicationId
            self.description = description
            self.id = id
            self.monitors = monitors
            self.name = name
            self.state = state
        }
    }

}

extension AppConfigClientTypes {
    public enum EnvironmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploying
        case readyForDeployment
        case rolledBack
        case rollingBack
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .deploying,
                .readyForDeployment,
                .rolledBack,
                .rollingBack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploying: return "DEPLOYING"
            case .readyForDeployment: return "READY_FOR_DEPLOYMENT"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
        }
    }
}

extension GetApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationInput(applicationId: \(Swift.String(describing: applicationId)))"}
}

extension GetApplicationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application you want to get.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApplicationOutputResponse(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationInput(application: \(Swift.String(describing: application)), clientConfigurationVersion: \(Swift.String(describing: clientConfigurationVersion)), clientId: \(Swift.String(describing: clientId)), configuration: \(Swift.String(describing: configuration)), environment: \(Swift.String(describing: environment)))"}
}

extension GetConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientId = input.operationInput.clientId {
            let clientIdQueryItem = ClientRuntime.URLQueryItem(name: "client_id".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
            input.builder.withQueryItem(clientIdQueryItem)
        }
        if let clientConfigurationVersion = input.operationInput.clientConfigurationVersion {
            let clientConfigurationVersionQueryItem = ClientRuntime.URLQueryItem(name: "client_configuration_version".urlPercentEncoding(), value: Swift.String(clientConfigurationVersion).urlPercentEncoding())
            input.builder.withQueryItem(clientConfigurationVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let application = input.application else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("application is nil and needs a value for the path of this operation"))))
        }
        guard let environment = input.environment else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environment is nil and needs a value for the path of this operation"))))
        }
        guard let configuration = input.configuration else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configuration is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(application.urlPercentEncoding())/environments/\(environment.urlPercentEncoding())/configurations/\(configuration.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInput: Swift.Equatable {
    /// The application to get. Specify either the application name or the application
    ///          ID.
    /// This member is required.
    public var application: Swift.String?
    /// The configuration version returned in the most recent GetConfiguration
    ///          response.
    ///
    ///             AWS AppConfig uses the value of the ClientConfigurationVersion parameter
    ///             to identify the configuration version on your clients. If you don’t send
    ///                ClientConfigurationVersion with each call to
    ///                GetConfiguration, your clients receive the current configuration. You
    ///             are charged each time your clients receive a configuration.
    ///             To avoid excess charges, we recommend that you include the
    ///                ClientConfigurationVersion value with every call to
    ///                GetConfiguration. This value must be saved on your client. Subsequent
    ///             calls to GetConfiguration must pass this value by using the
    ///                ClientConfigurationVersion parameter.
    ///
    ///          For more information about working with configurations, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig-retrieving-the-configuration.html">Retrieving the Configuration in the
    ///          AWS AppConfig User Guide.
    public var clientConfigurationVersion: Swift.String?
    /// A unique ID to identify the client for the configuration. This ID enables AppConfig to
    ///          deploy the configuration in intervals, as defined in the deployment strategy.
    /// This member is required.
    public var clientId: Swift.String?
    /// The configuration to get. Specify either the configuration name or the configuration
    ///          ID.
    /// This member is required.
    public var configuration: Swift.String?
    /// The environment to get. Specify either the environment name or the environment
    ///          ID.
    /// This member is required.
    public var environment: Swift.String?

    public init (
        application: Swift.String? = nil,
        clientConfigurationVersion: Swift.String? = nil,
        clientId: Swift.String? = nil,
        configuration: Swift.String? = nil,
        environment: Swift.String? = nil
    )
    {
        self.application = application
        self.clientConfigurationVersion = clientConfigurationVersion
        self.clientId = clientId
        self.configuration = configuration
        self.environment = environment
    }
}

struct GetConfigurationInputBody: Swift.Equatable {
}

extension GetConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationOutputResponse(configurationVersion: \(Swift.String(describing: configurationVersion)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)))"}
}

extension GetConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let configurationVersionHeaderValue = httpResponse.headers.value(for: "Configuration-Version") {
            self.configurationVersion = configurationVersionHeaderValue
        } else {
            self.configurationVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetConfigurationOutputResponse: Swift.Equatable {
    /// The configuration version.
    public var configurationVersion: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type.
    public var contentType: Swift.String?

    public init (
        configurationVersion: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.configurationVersion = configurationVersion
        self.content = content
        self.contentType = contentType
    }
}

struct GetConfigurationOutputResponseBody: Swift.Equatable {
    public let content: ClientRuntime.Data?
}

extension GetConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetConfigurationProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationProfileInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)))"}
}

extension GetConfigurationProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetConfigurationProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigurationProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInput: Swift.Equatable {
    /// The ID of the application that includes the configuration profile you want to
    ///          get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile you want to get.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct GetConfigurationProfileInputBody: Swift.Equatable {
}

extension GetConfigurationProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigurationProfileOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), locationUri: \(Swift.String(describing: locationUri)), name: \(Swift.String(describing: name)), retrievalRoleArn: \(Swift.String(describing: retrievalRoleArn)), validators: \(Swift.String(describing: validators)))"}
}

extension GetConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct GetConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct GetConfigurationProfileOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let locationUri: Swift.String?
    public let retrievalRoleArn: Swift.String?
    public let validators: [AppConfigClientTypes.Validator]?
}

extension GetConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension GetDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentInput(applicationId: \(Swift.String(describing: applicationId)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension GetDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        let deploymentNumber = input.deploymentNumber
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the application that includes the deployment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int
    /// The ID of the environment that includes the deployment you want to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), completedAt: \(Swift.String(describing: completedAt)), configurationLocationUri: \(Swift.String(describing: configurationLocationUri)), configurationName: \(Swift.String(describing: configurationName)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), configurationVersion: \(Swift.String(describing: configurationVersion)), deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), eventLog: \(Swift.String(describing: eventLog)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), percentageComplete: \(Swift.String(describing: percentageComplete)), startedAt: \(Swift.String(describing: startedAt)), state: \(Swift.String(describing: state)))"}
}

extension GetDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are
    ///          displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct GetDeploymentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let environmentId: Swift.String?
    public let deploymentStrategyId: Swift.String?
    public let configurationProfileId: Swift.String?
    public let deploymentNumber: Swift.Int
    public let configurationName: Swift.String?
    public let configurationLocationUri: Swift.String?
    public let configurationVersion: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let state: AppConfigClientTypes.DeploymentState?
    public let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    public let percentageComplete: Swift.Float
    public let startedAt: ClientRuntime.Date?
    public let completedAt: ClientRuntime.Date?
}

extension GetDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension GetDeploymentStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentStrategyInput(deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)))"}
}

extension GetDeploymentStrategyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeploymentStrategyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentStrategyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentStrategyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let deploymentStrategyId = input.deploymentStrategyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deploymentStrategyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy to get.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init (
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct GetDeploymentStrategyInputBody: Swift.Equatable {
}

extension GetDeploymentStrategyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentStrategyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), replicateTo: \(Swift.String(describing: replicateTo)))"}
}

extension GetDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct GetDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct GetDeploymentStrategyOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension GetDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension GetEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentInput(applicationId: \(Swift.String(describing: applicationId)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension GetEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the application that includes the environment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment you wnat to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension GetEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states:
    ///             READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or
    ///             ROLLED_BACK
    ///
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct GetEnvironmentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let state: AppConfigClientTypes.EnvironmentState?
    public let monitors: [AppConfigClientTypes.Monitor]?
}

extension GetEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension GetHostedConfigurationVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHostedConfigurationVersionInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension GetHostedConfigurationVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetHostedConfigurationVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostedConfigurationVersionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetHostedConfigurationVersionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetHostedConfigurationVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        let versionNumber = input.versionNumber
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetHostedConfigurationVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension GetHostedConfigurationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostedConfigurationVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetHostedConfigurationVersionOutputResponse(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension GetHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetHostedConfigurationVersionOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type.
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionOutputResponseBody: Swift.Equatable {
    public let content: ClientRuntime.Data?
}

extension GetHostedConfigurationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension AppConfigClientTypes {
    public enum GrowthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exponential
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [GrowthType] {
            return [
                .exponential,
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exponential: return "EXPONENTIAL"
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrowthType(rawValue: rawValue) ?? GrowthType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.HostedConfigurationVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case configurationProfileId = "ConfigurationProfileId"
        case contentType = "ContentType"
        case description = "Description"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let versionNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension AppConfigClientTypes.HostedConfigurationVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HostedConfigurationVersionSummary(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), versionNumber: \(Swift.String(describing: versionNumber)))"}
}

extension AppConfigClientTypes {
    /// Information about the configuration.
    public struct HostedConfigurationVersionSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The configuration profile ID.
        public var configurationProfileId: Swift.String?
        /// A standard MIME type describing the format of the configuration content. For more
        ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type.
        public var contentType: Swift.String?
        /// A description of the configuration.
        public var description: Swift.String?
        /// The configuration version.
        public var versionNumber: Swift.Int

        public init (
            applicationId: Swift.String? = nil,
            configurationProfileId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.contentType = contentType
            self.description = description
            self.versionNumber = versionNumber
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal failure in the AppConfig service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListApplicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/applications"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Application]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.Application]?
    public let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Application?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationProfilesInput(applicationId: \(Swift.String(describing: applicationId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationProfilesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationProfilesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesInputBody: Swift.Equatable {
}

extension ListConfigurationProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationProfilesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationProfilesOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationProfilesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.ConfigurationProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    public let nextToken: Swift.String?
}

extension ListConfigurationProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ConfigurationProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.ConfigurationProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.ConfigurationProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentStrategiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentStrategiesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentStrategiesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeploymentStrategiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentStrategiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentStrategiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentStrategiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentStrategiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentStrategiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentStrategiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentStrategiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDeploymentStrategiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentStrategiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentStrategiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDeploymentStrategiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/deploymentstrategies"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentStrategiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesInputBody: Swift.Equatable {
}

extension ListDeploymentStrategiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentStrategiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentStrategiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentStrategiesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentStrategiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentStrategiesOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentStrategiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentStrategiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentStrategiesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentStrategy]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.DeploymentStrategy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.DeploymentStrategy]?
    public let nextToken: Swift.String?
}

extension ListDeploymentStrategiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentStrategy?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentStrategy]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentStrategy]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentsInput(applicationId: \(Swift.String(describing: applicationId)), environmentId: \(Swift.String(describing: environmentId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeploymentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDeploymentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDeploymentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.DeploymentSummary]?
    public let nextToken: Swift.String?
}

extension ListDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsInput(applicationId: \(Swift.String(describing: applicationId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Environment]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.Environment]?
    public let nextToken: Swift.String?
}

extension ListEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Environment?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Environment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Environment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHostedConfigurationVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHostedConfigurationVersionsInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHostedConfigurationVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListHostedConfigurationVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHostedConfigurationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHostedConfigurationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHostedConfigurationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHostedConfigurationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHostedConfigurationVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHostedConfigurationVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHostedConfigurationVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListHostedConfigurationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListHostedConfigurationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHostedConfigurationVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListHostedConfigurationVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListHostedConfigurationVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsInputBody: Swift.Equatable {
}

extension ListHostedConfigurationVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHostedConfigurationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHostedConfigurationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHostedConfigurationVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHostedConfigurationVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHostedConfigurationVersionsOutputResponse(items: \(Swift.String(describing: items)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHostedConfigurationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHostedConfigurationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListHostedConfigurationVersionsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of
    ///          results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsOutputResponseBody: Swift.Equatable {
    public let items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListHostedConfigurationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.HostedConfigurationVersionSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.HostedConfigurationVersionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Metadata to assign to AppConfig resources. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppConfigClientTypes.Monitor: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmArn = "AlarmArn"
        case alarmRoleArn = "AlarmRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmArn = alarmArn {
            try encodeContainer.encode(alarmArn, forKey: .alarmArn)
        }
        if let alarmRoleArn = alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
    }
}

extension AppConfigClientTypes.Monitor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Monitor(alarmArn: \(Swift.String(describing: alarmArn)), alarmRoleArn: \(Swift.String(describing: alarmRoleArn)))"}
}

extension AppConfigClientTypes {
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public struct Monitor: Swift.Equatable {
        /// ARN of the Amazon CloudWatch alarm.
        public var alarmArn: Swift.String?
        /// ARN of an IAM role for AppConfig to monitor AlarmArn.
        public var alarmRoleArn: Swift.String?

        public init (
            alarmArn: Swift.String? = nil,
            alarmRoleArn: Swift.String? = nil
        )
        {
            self.alarmArn = alarmArn
            self.alarmRoleArn = alarmRoleArn
        }
    }

}

extension PayloadTooLargeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PayloadTooLargeException(limit: \(Swift.String(describing: limit)), measure: \(Swift.String(describing: measure)), message: \(Swift.String(describing: message)), size: \(Swift.String(describing: size)))"}
}

extension PayloadTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PayloadTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.measure = output.measure
            self.message = output.message
            self.size = output.size
        } else {
            self.limit = 0.0
            self.measure = nil
            self.message = nil
            self.size = 0.0
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration size is too large.
public struct PayloadTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var limit: Swift.Float
    public var measure: AppConfigClientTypes.BytesMeasure?
    public var message: Swift.String?
    public var size: Swift.Float

    public init (
        limit: Swift.Float = 0.0,
        measure: AppConfigClientTypes.BytesMeasure? = nil,
        message: Swift.String? = nil,
        size: Swift.Float = 0.0
    )
    {
        self.limit = limit
        self.measure = measure
        self.message = message
        self.size = size
    }
}

struct PayloadTooLargeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let measure: AppConfigClientTypes.BytesMeasure?
    public let limit: Swift.Float
    public let size: Swift.Float
}

extension PayloadTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case measure = "Measure"
        case message = "Message"
        case size = "Size"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let measureDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BytesMeasure.self, forKey: .measure)
        measure = measureDecoded
        let limitDecoded = try containerValues.decode(Swift.Float.self, forKey: .limit)
        limit = limitDecoded
        let sizeDecoded = try containerValues.decode(Swift.Float.self, forKey: .size)
        size = sizeDecoded
    }
}

extension AppConfigClientTypes {
    public enum ReplicateTo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case ssmDocument
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicateTo] {
            return [
                .none,
                .ssmDocument,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .ssmDocument: return "SSM_DOCUMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicateTo(rawValue: rawValue) ?? ReplicateTo.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of hosted configuration versions exceeds the limit for the AppConfig
///          configuration store. Delete one or more versions and try again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), configurationVersion: \(Swift.String(describing: configurationVersion)), deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), tags: \(Swift.String(describing: tags)))"}
}

extension StartDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if let deploymentStrategyId = deploymentStrategyId {
            try encodeContainer.encode(deploymentStrategyId, forKey: .deploymentStrategyId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The configuration version to deploy.
    /// This member is required.
    public var configurationVersion: Swift.String?
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Metadata to assign to the deployment. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.tags = tags
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    public let deploymentStrategyId: Swift.String?
    public let configurationProfileId: Swift.String?
    public let configurationVersion: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), completedAt: \(Swift.String(describing: completedAt)), configurationLocationUri: \(Swift.String(describing: configurationLocationUri)), configurationName: \(Swift.String(describing: configurationName)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), configurationVersion: \(Swift.String(describing: configurationVersion)), deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), eventLog: \(Swift.String(describing: eventLog)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), percentageComplete: \(Swift.String(describing: percentageComplete)), startedAt: \(Swift.String(describing: startedAt)), state: \(Swift.String(describing: state)))"}
}

extension StartDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are
    ///          displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StartDeploymentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let environmentId: Swift.String?
    public let deploymentStrategyId: Swift.String?
    public let configurationProfileId: Swift.String?
    public let deploymentNumber: Swift.Int
    public let configurationName: Swift.String?
    public let configurationLocationUri: Swift.String?
    public let configurationVersion: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let state: AppConfigClientTypes.DeploymentState?
    public let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    public let percentageComplete: Swift.Float
    public let startedAt: ClientRuntime.Date?
    public let completedAt: ClientRuntime.Date?
}

extension StartDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension StopDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDeploymentInput(applicationId: \(Swift.String(describing: applicationId)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension StopDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        let deploymentNumber = input.deploymentNumber
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct StopDeploymentInputBody: Swift.Equatable {
}

extension StopDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDeploymentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), completedAt: \(Swift.String(describing: completedAt)), configurationLocationUri: \(Swift.String(describing: configurationLocationUri)), configurationName: \(Swift.String(describing: configurationName)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), configurationVersion: \(Swift.String(describing: configurationVersion)), deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), deploymentNumber: \(Swift.String(describing: deploymentNumber)), deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), eventLog: \(Swift.String(describing: eventLog)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), percentageComplete: \(Swift.String(describing: percentageComplete)), startedAt: \(Swift.String(describing: startedAt)), state: \(Swift.String(describing: state)))"}
}

extension StopDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StopDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are
    ///          displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StopDeploymentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let environmentId: Swift.String?
    public let deploymentStrategyId: Swift.String?
    public let configurationProfileId: Swift.String?
    public let deploymentNumber: Swift.Int
    public let configurationName: Swift.String?
    public let configurationLocationUri: Swift.String?
    public let configurationVersion: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let state: AppConfigClientTypes.DeploymentState?
    public let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    public let percentageComplete: Swift.Float
    public let startedAt: ClientRuntime.Date?
    public let completedAt: ClientRuntime.Date?
}

extension StopDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value string map. The valid character set is [a-zA-Z+-=._:/]. The tag key can be
    ///          up to 128 characters and must not start with aws:. The tag value can be up to
    ///          256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppConfigClientTypes {
    public enum TriggeredBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appconfig
        case cloudwatchAlarm
        case internalError
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggeredBy] {
            return [
                .appconfig,
                .cloudwatchAlarm,
                .internalError,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appconfig: return "APPCONFIG"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .internalError: return "INTERNAL_ERROR"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggeredBy(rawValue: rawValue) ?? TriggeredBy.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationInput(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension UpdateApplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateApplicationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateApplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateApplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the application.
    public var description: Swift.String?
    /// The name of the application.
    public var name: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutputResponse(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateConfigurationProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationProfileOutputError>
}

extension UpdateConfigurationProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationProfileInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), retrievalRoleArn: \(Swift.String(describing: retrievalRoleArn)), validators: \(Swift.String(describing: validators)))"}
}

extension UpdateConfigurationProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

public struct UpdateConfigurationProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationProfileInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationProfileInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.description = description
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let retrievalRoleArn: Swift.String?
    public let validators: [AppConfigClientTypes.Validator]?
}

extension UpdateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension UpdateConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationProfileOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), locationUri: \(Swift.String(describing: locationUri)), name: \(Swift.String(describing: name)), retrievalRoleArn: \(Swift.String(describing: retrievalRoleArn)), validators: \(Swift.String(describing: validators)))"}
}

extension UpdateConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct UpdateConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let locationUri: Swift.String?
    public let retrievalRoleArn: Swift.String?
    public let validators: [AppConfigClientTypes.Validator]?
}

extension UpdateConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

public struct UpdateDeploymentStrategyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeploymentStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeploymentStrategyOutputError>
}

extension UpdateDeploymentStrategyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeploymentStrategyInput(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), deploymentStrategyId: \(Swift.String(describing: deploymentStrategyId)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)))"}
}

extension UpdateDeploymentStrategyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
    }
}

public struct UpdateDeploymentStrategyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeploymentStrategyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeploymentStrategyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDeploymentStrategyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let deploymentStrategyId = input.deploymentStrategyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deploymentStrategyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDeploymentStrategyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    public var deploymentDurationInMinutes: Swift.Int
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitors for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grows over time. AWS AppConfig supports the
    ///          following growth types:
    ///
    ///             Linear: For this type, AppConfig processes the
    ///          deployment by increments of the growth factor evenly distributed over the deployment time.
    ///          For example, a linear deployment that uses a growth factor of 20 initially makes the
    ///          configuration available to 20 percent of the targets. After 1/5th of the deployment time
    ///          has passed, the system updates the percentage to 40 percent. This continues until 100% of
    ///          the targets are set to receive the deployed configuration.
    ///
    ///
    ///             Exponential: For this type, AppConfig processes the
    ///          deployment exponentially using the following formula: G*(2^N). In this
    ///          formula, G is the growth factor specified by the user and N is
    ///          the number of steps until the configuration is deployed to all targets. For example, if you
    ///          specify a growth factor of 2, then the system rolls out the configuration as
    ///          follows:
    ///
    ///             2*(2^0)
    ///
    ///
    ///             2*(2^1)
    ///
    ///
    ///             2*(2^2)
    ///
    ///          Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the
    ///          targets, 8% of the targets, and continues until the configuration has been deployed to all
    ///          targets.
    public var growthType: AppConfigClientTypes.GrowthType?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
    }
}

struct UpdateDeploymentStrategyInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let finalBakeTimeInMinutes: Swift.Int
    public let growthFactor: Swift.Float
    public let growthType: AppConfigClientTypes.GrowthType?
}

extension UpdateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
    }
}

extension UpdateDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentStrategyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(Swift.String(describing: deploymentDurationInMinutes)), description: \(Swift.String(describing: description)), finalBakeTimeInMinutes: \(Swift.String(describing: finalBakeTimeInMinutes)), growthFactor: \(Swift.String(describing: growthFactor)), growthType: \(Swift.String(describing: growthType)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), replicateTo: \(Swift.String(describing: replicateTo)))"}
}

extension UpdateDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct UpdateDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each
    ///          interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct UpdateDeploymentStrategyOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let deploymentDurationInMinutes: Swift.Int
    public let growthType: AppConfigClientTypes.GrowthType?
    public let growthFactor: Swift.Float
    public let finalBakeTimeInMinutes: Swift.Int
    public let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension UpdateDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)))"}
}

extension UpdateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.environmentId = environmentId
        self.monitors = monitors
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension UpdateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutputResponse(applicationId: \(Swift.String(describing: applicationId)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), monitors: \(Swift.String(describing: monitors)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension UpdateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states:
    ///             READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or
    ///             ROLLED_BACK
    ///
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct UpdateEnvironmentOutputResponseBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let state: AppConfigClientTypes.EnvironmentState?
    public let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension ValidateConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateConfigurationInput(applicationId: \(Swift.String(describing: applicationId)), configurationProfileId: \(Swift.String(describing: configurationProfileId)), configurationVersion: \(Swift.String(describing: configurationVersion)))"}
}

extension ValidateConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ValidateConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ValidateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let configurationVersion = input.operationInput.configurationVersion {
            let configurationVersionQueryItem = ClientRuntime.URLQueryItem(name: "configuration_version".urlPercentEncoding(), value: Swift.String(configurationVersion).urlPercentEncoding())
            input.builder.withQueryItem(configurationVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ValidateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ValidateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ValidateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ValidateConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ValidateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let applicationId = input.applicationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("applicationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationProfileId = input.configurationProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationProfileId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/validators"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ValidateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version of the configuration to validate.
    /// This member is required.
    public var configurationVersion: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
    }
}

struct ValidateConfigurationInputBody: Swift.Equatable {
}

extension ValidateConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateConfigurationOutputResponse()"}
}

extension ValidateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ValidateConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct ValidateConfigurationOutputResponseBody: Swift.Equatable {
}

extension ValidateConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AppConfigClientTypes.Validator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ValidatorType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension AppConfigClientTypes.Validator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Validator(content: \(Swift.String(describing: content)), type: \(Swift.String(describing: type)))"}
}

extension AppConfigClientTypes {
    /// A validator provides a syntactic or semantic check to ensure the configuration you want
    ///          to deploy functions as intended. To validate your application configuration data, you
    ///          provide a schema or a Lambda function that runs against the configuration. The
    ///          configuration deployment or update can only proceed when the configuration data is
    ///          valid.
    public struct Validator: Swift.Equatable {
        /// Either the JSON Schema content or the Amazon Resource Name (ARN) of an AWS Lambda
        ///          function.
        /// This member is required.
        public var content: Swift.String?
        /// AppConfig supports validators of type JSON_SCHEMA and
        ///          LAMBDA
        ///
        /// This member is required.
        public var type: AppConfigClientTypes.ValidatorType?

        public init (
            content: Swift.String? = nil,
            type: AppConfigClientTypes.ValidatorType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension AppConfigClientTypes {
    public enum ValidatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonSchema
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatorType] {
            return [
                .jsonSchema,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonSchema: return "JSON_SCHEMA"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatorType(rawValue: rawValue) ?? ValidatorType.sdkUnknown(rawValue)
        }
    }
}
